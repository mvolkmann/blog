<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Git</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#ignoring-files">Ignoring files</a></li><li><a href="#tagging">Tagging</a></li><li><a href="#rebase">Rebase</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p>This page documents tips on using Git for version control. At the moment it is very incomplete.</p><h2 id="ignoring-files" tabindex="-1">Ignoring files</h2><p>Each repository can have a <code>.gitignore</code> file that lists the files and directories that should be committed to the repository.</p><p>A global <code>.gitignore</code> file can be added to your home directory to prevent committing common files such as <code>.env</code> and common directories such as <code>node_modules</code>.</p><h2 id="tagging" tabindex="-1">Tagging</h2><p>To list existing tags in a repository, enter <code>git tag</code>.</p><p>To add a new tag, enter <code>git tag -a {tag}</code>. It is common for tag names to use semantic versioning. For example, <code>v{major}.{minor}.{patch}</code>.</p><p>To push a tag to the remote repository, enter <code>git push origin {tag}</code>.</p><p>To see details about a specific tag, enter <code>git show {tag}</code>.</p><h2 id="rebase" tabindex="-1">Rebase</h2><p>Rebasing in git is a scary topic for many, including me. So I decided to document the steps and verify them to remove the fear.</p><p>The main benefit of rebasing over just merging is producing a cleaner git history so the changes made are more clear when reviewing the history.</p><p>The <code>git rebase</code> command can be used to:</p><ul><li>combine multiple commits into one (squash)</li><li>split one commit into multiple commits (scary)</li><li>reorder commits (scary)</li><li>incorporate changes made in one branch into the current one so the changes appear to have been made on the current branch (scary)</li></ul><p>Let's walk through the entire flow from creating a feature branch, to working on it over a period of time, to merging the changes back to the main branch. During the time you work on your feature branch, other developers (or even you) may have merged other feature branches back to main.</p><ul><li><p>Switch to the main branch with <code>git checkout main</code></p></li><li><p>Update your local main branch from the remote with <code>git pull origin</code></p></li><li><p>Create a feature branch with <code>git checkout -b my-feat</code></p></li><li><p>Make changes to files in the feature branch, including adding and deleting files.</p></li><li><p>Periodically commit changes to your feature branch with <code>git add .</code> and <code>git commit -av</code></p></li><li><p>Periodically rebase your feature branch from main with the following:</p><ul><li><code>git checkout main</code></li><li><code>git pull</code></li><li><code>git checkout my-feat</code></li><li><code>git rebase -i main</code></li></ul><p>The <code>-i</code> flag makes it interactive which allows you to squash (combine) commits into a single commit.</p><p>This updates my-feat by setting it to the current state of main and then replaying all the changes made on my-feat onto this copy of main.</p></li><li><p>Merge the feature branch to main with the following:</p><ul><li><code>git checkout main</code></li><li><code>git pull</code></li><li><code>git merge my-feat</code></li></ul></li><li><p>Delete the local feature branch with <code>git branch -d my-feat</code></p></li><li><p>Delete the remote feature branch with <code>git branch -rd origin/my-feat</code></p></li></ul></article>