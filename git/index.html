<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Git</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#viewing-commits">Viewing Commits</a></li><li><a href="#ignoring-files">Ignoring files</a></li><li><a href="#tagging">Tagging</a></li><li><a href="#rebase">Rebase</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p>This page documents tips on using Git for version control. At the moment it is very incomplete.</p><h2 id="viewing-commits" tabindex="-1">Viewing Commits</h2><p>To see all the commits that have been made on the current branch:</p><ul><li><code>git log</code> to output the full commit hash, author, timestamp, and comment for each commit</li><li><code>git log --oneline</code> to see only the first 8 characters of the hash and the comment for each commit</li></ul><h2 id="ignoring-files" tabindex="-1">Ignoring files</h2><p>Each repository can have a <code>.gitignore</code> file that lists the files and directories that should be committed to the repository.</p><p>A global <code>.gitignore</code> file can be added to your home directory to prevent committing common files such as <code>.env</code> and common directories such as <code>node_modules</code>.</p><h2 id="tagging" tabindex="-1">Tagging</h2><p>To list existing tags in a repository, enter <code>git tag</code>.</p><p>To add a new tag, enter <code>git tag -a {tag}</code>. It is common for tag names to use semantic versioning. For example, <code>v{major}.{minor}.{patch}</code>.</p><p>To push a tag to the remote repository, enter <code>git push origin {tag}</code>.</p><p>To see details about a specific tag, enter <code>git show {tag}</code>.</p><h2 id="rebase" tabindex="-1">Rebase</h2><p>Rebasing in git is a scary topic for many.</p><p>The main benefit of rebasing over just merging is producing a cleaner git history so the changes made are more clear when reviewing the history.</p><p>The <code>git rebase</code> command can be used to:</p><ul><li>incorporate changes made in branch A (such as main) into the current branch B (such as a feature branch) by starting with a copy of A and replaying changes made in B on top of it</li><li>combine multiple commits into one (squash)</li><li>split one commit into multiple commits (questionable)</li><li>reorder commits (questionable)</li></ul><p>Rebasing should be avoided for feature branches that are being modified by multiple developers.</p><p>Let's walk through the entire flow from creating a feature branch, to working on it over a period of time, to merging the changes back to the main branch. During the time you work on your feature branch, other developers (or even you) may have merged other feature branches back to main.</p><ul><li><p>Switch to the main branch with <code>git checkout main</code>.</p></li><li><p>Update your local main branch from the remote with <code>git pull origin</code>.</p></li><li><p>Create a feature branch with <code>git checkout -b my-feat</code>.</p></li><li><p>Make changes to files in the feature branch, including adding and deleting files.</p></li><li><p>Periodically commit changes to the feature branch with <code>git add .</code> and <code>git commit -av</code>.</p><p>The <code>a</code> commits all changes and the <code>v</code> flag shows the diffs in the editor where you will compose a commit message, which helps you write a good one.</p></li><li><p>When work on the feature branch is finished, rebase the feature branch onto the <code>main</code> branch with the following:</p><ul><li><code>git checkout main</code></li><li><code>git pull</code></li><li><code>git rebase -i my-feat</code></li></ul><p>The <code>-i</code> flag (for &quot;interacive&quot;) causes git to open a text editor where you can make changes to commits. It uses Vim by default. To configure git to use a different editor such as nano, enter <code>git config --global core.editor &quot;nano&quot;</code>.</p><p>If there are any conflicts, resolve them in each reported file, enter <code>git add {file}</code> for each file, and run <code>git rebase --continue</code>.</p><p>To modify the comment on a commit, change &quot;pick&quot; to &quot;reword&quot; (or &quot;r&quot;) and edit the comment.</p><p>To squash (combine) a set of commits into a single commit, pick the earliest one to retain and change &quot;pick&quot; to &quot;squash&quot; (or &quot;s&quot;) for any number of consecutive commits that follow it. There is no need to edit the commit message of the retained commit because you will be prompted for a new commit message for the squashed commit.</p><p>To delete a commit as if it never happened, change &quot;pick&quot; to &quot;drop&quot; (or just &quot;d&quot;).</p><p>Save the changes and quit the editor to start the rebase process.</p><p>This updates the local <code>main</code> branch with the changes made on <code>my-feat</code> by replaying them onto the local <code>main</code> branch.</p></li><li><p>Test the code on my-feat to verify that everything is still working correctly.</p></li><li><p>On projects that are using pull requests, create one. Otherwise, push your local <code>main</code> branch to the remote with <code>git push</code>.</p></li><li><p>Delete the local feature branch with <code>git branch -d my-feat</code></p></li><li><p>Delete the remote feature branch with <code>git branch -rd origin/my-feat</code></p></li></ul></article>