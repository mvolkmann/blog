<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>TypeScript Effect</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#recent-changes">Recent Changes</a></li><li><a href="#effects">Effects</a></li><li><a href="#pipelines">Pipelines</a></li><li><a href="#error-handling">Error Handling</a></li><li><a href="#logging">Logging</a></li><li><a href="#generators">Generators</a></li></ol></nav></aside><article><style>img {
    border: 1px solid gray;
  }</style><figure style="width: 30%"><img alt="TypeScript Effect logo" style="border: 0" src="/blog/assets/ts-effect-logo.jpg?v=1.1.1"></figure><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://effect.website/" target="_blank">Effect</a> is a TypeScript library with a large set of features that:</p><ul><li>maximizes type safety</li><li>improves error handling</li><li>makes code more composable, reusable, and testable</li></ul><h2 id="recent-changes" tabindex="-1">Recent Changes</h2><p>Several significant changes where made to the Effect library in early 2024 which make most tutorial videos somewhat wrong.</p><ul><li>The order of the type parameters for the generic type <code>Effect</code> changed from <code>&lt;Requirements, ErrorType, SuccessType&gt;</code> to <code>&lt;SuccessType, ErrorType, Requirements&gt;</code>.</li><li>The schema types had changes.</li><li>The operation of the <code>pipe</code> function changed.</li><li>The generator no longer requires wrapper functions.</li></ul><h2 id="effects" tabindex="-1">Effects</h2><p>An <code>Effect</code> is an immutable value that describes an operation (a.k.a a program) to be run later. It is a type that is generic over three values:</p><ol><li>A success type (<code>void</code> if there is no result)</li><li>An error type (<code>never</code> if no errors can occur)</li><li>An optional set of requirements that must be fulfilled in order for the code to run (<code>never</code> if there are none, <code>Error</code> type is the most general).</li></ol><p>The result of an <code>Effect</code> is only computed when it is run.</p><p>To create an <code>Effect</code> from a value, use the <code>Effect.succeed(value)</code> or <code>Effect.fail(error-object)</code> functions.</p><p>There are four ways to create an <code>Effect</code>.</p><p>If the function to be run never throws ...</p><ul><li>If the function is synchronous, use <code>Effect.sync(fn)</code>.</li><li>If the function is asynchronous and never throws, use <code>Effect.promise(fn)</code>.</li></ul><p>In both cases, <code>fn</code> is the function to be run.</p><p>If the function can throw ...</p><ul><li>If the function is synchronous, use <code>Effect.try(obj)</code>.</li><li>If the function is asynchronous, use <code>Effect.tryPromise(obj)</code>.</li></ul><p>In both cases, <code>obj</code> is an object with <code>try</code> and <code>catch</code> properties. The <code>try</code> property value is a function that can throw. A <code>Promise</code> is returned.</p><p>When an <code>Effect</code> is run, it produces a value or an error. It is similar to the <code>Result</code> type in languages like OCaml.</p><p>To run an <code>Effect</code>:</p><ul><li>If it never throws, use <code>effect.runSync</code>.</li><li>If it can throw, use <code>Effect.runPromise</code>.</li></ul><h2 id="pipelines" tabindex="-1">Pipelines</h2><p>Pipelines pass values through a series of functions. Each function take one value from the previous function, and produces one result that is passed to the next function in the pipeline.</p><p>A pipeline is defined by calling the <code>Effect.pipe</code> function or the <code>effect.pipe</code> method. The <code>Effect.pipe</code> function takes an initial value and a series of functions, and passes the initial value to the first function. The <code>effect.pipe</code> method takes a series of functions, and passes the value of the <code>Effect</code> on which it is called to the first function.</p><p>The value returned by a function can be transformed with the <code>Effect.map</code> and <code>Effect.flatMap</code> functions.</p><p>Side effects can be triggered wtih the <code>Effect.tap</code> function.</p><p>The values from multiple effects can be combined with the <code>Effect.all</code> function.</p><h2 id="error-handling" tabindex="-1">Error Handling</h2><p>TODO: Discuss creating objects with a <code>_tag</code> property that is used to identify an error type.</p><p>To handle all kinds of errors, use the <code>Effect.catchAll</code> function.</p><p>To handle a specific kind of error, use the <code>Effect.catchTag</code> function.</p><p>To handle multiple specific kinds of errors, use the <code>Effect.catchTags</code> function.</p><p>TODO: Is there also an <code>Effect.catch</code> function?</p><p>TODO: What does <code>Effect.provideService</code> do?</p><h2 id="logging" tabindex="-1">Logging</h2><p>The Effect library provides a set of functions for logging.</p><ul><li><code>Effect.logDebug</code></li><li><code>Effect.logInfo</code></li><li><code>Effect.logWarning</code></li><li><code>Effect.logError</code></li><li><code>Effect.logFatal</code></li></ul><p>By default, output from all of these is disabled. To specify a logging level where all logging at that level and above is output, call the <code>Effect.withMinimumLogLevel(level)</code> function.</p><p>To include timing information in log output, call the <code>Effect.withLogSpan</code> function.</p><h2 id="generators" tabindex="-1">Generators</h2><p>Generators can simplify Effect code in a way that is similar to using the JavaScript <code>async</code> and <code>await</code> keywords. This utilizes the JavaScript <code>yield*</code> keyword.</p></article>