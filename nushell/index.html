<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Nushell</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#installing">Installing</a></li><li><a href="#getting-started">Getting Started</a></li><li><a href="#subcommands">Subcommands</a></li><li><a href="#configuration">Configuration</a><ol><li><a href="#startup-setting">startup Setting</a></li><li><a href="#table_mode-setting">table_mode Setting</a></li><li><a href="#color_config-section">color_config Section</a></li><li><a href="#line_editor-section">line_editor Section</a></li><li><a href="#path-setting">path setting</a></li><li><a href="#env-section">env Section</a></li><li><a href="#textview-section">textview Section</a></li></ol></li><li><a href="#data-types">Data Types</a><ol><li><a href="#type-conversions">Type Conversions</a></li><li><a href="#strings">Strings</a></li><li><a href="#ranges">Ranges</a></li><li><a href="#types-with-units">Types With Units</a></li><li><a href="#lists">Lists</a></li><li><a href="#tables">Tables</a></li></ol></li><li><a href="#operators">Operators</a></li><li><a href="#working-with-numbers">Working with numbers</a></li><li><a href="#working-with-urls">Working with URLs</a></li><li><a href="#common-unix-commands">Common UNIX Commands</a></li><li><a href="#aliases">Aliases</a></li><li><a href="#custom-commands">Custom Commands</a></li><li><a href="#variables">Variables</a></li><li><a href="#environment-variables">Environment Variables</a></li><li><a href="#open-command">open Command</a></li><li><a href="#table-commands">Table Commands</a></li><li><a href="#plugins">Plugins</a><ol><li><a href="#nu_plugin_start">nu_plugin_start</a></li><li><a href="#nu_plugin_chart">nu_plugin_chart</a></li></ol></li><li><a href="#default-shell">Default Shell</a></li><li><a href="#scripts">Scripts</a></li><li><a href="#vs-code">VS Code</a></li><li><a href="#comparison-to-bash">Comparison to Bash</a></li><li><a href="#per-directory-environment-variables">Per Directory Environment Variables</a></li><li><a href="#additional-shells">Additional Shells</a></li><li><a href="#issues">Issues</a></li></ol></nav></aside><article><h2 id="overview">Overview</h2><p><a href="https://www.nushell.sh?v=1.0.12" rel="noopener" target="_blank">Nushell</a> is &quot;a new type of shell&quot;. &quot;The goal of this project is to take the Unix philosophy of shells, where pipes connect simple commands together, and bring it to the modern style of development.&quot; Nushell was created by Jonathan Turner, Yehuda Katz, and Andres Robalino. It runs in Linux, macOS, and Windows.</p><p>Nushell is implemented in Rust. And like Rust, Nushell produces helpful, nicely formatted error messages.</p><p>Nushell includes the Nu language which excels at &quot;processing streams of structured data&quot;. This provides features that are somewhat like SQL for databases. It also has similarities to the Python-based <a href="https://pandas.pydata.org?v=1.0.12" rel="noopener" target="_blank">Pandas</a> data analysis library. These are features not typically seen in shell environments. It is far from a toy project and uses recursive descent parser that is driven by its many supported data types.</p><p>Nushell continues the UNIX tradition of commands whose input can be piped in from a previous command and whose output can be piped to a subsequent command. A series of commands separated by the pipe character <code>|</code> is referred to as a &quot;pipeline&quot;. Commands stream their output to the next command in the pipeline. A command does not have to run to completion before the next command in the pipeline can begin receiving that output as its input.</p><p>Some commands such as <code>echo</code> and <code>ls</code> are lazy. This means they do not produce output unless something is requesting data from their output stream. One way to do this it to pipe their output to the <code>autoview</code> command which determines how to render the data based on its type. Piping to <code>autoview</code> occurs implicitly in the shell after the last command in a pipeline. So the command <code>ls</code> is processed as if <code>ls | autoview</code> was entered. When semicolons are used to separate multiple pipelines on the same line, <code>autoview</code> is only applied to the last pipeline. For example, <code>let a = 2; let b = 3; = $a + $b</code> outputs <code>5</code>.</p><p>Color coding is applied to commands as they are typed. If a command becomes invalid, all the text changes to red.</p><p>Because Rust is a great source for compiling to WebAssembly, it was possible to implement a web-based environment for experimenting with Nushell. This can be found at <a href="https://www.nushell.sh/demo/?v=1.0.12" rel="noopener" target="_blank">Nushell demo</a>.</p><p>The Nu language can be used outside Nushell, such as in Jupyter Notebooks.</p><p>It costs nothing but some disk space to try Nushell (about 50 MB). You don't have to commit to making it your default shell. Just pop in periodically to try it and exit to return to your current shell. Over time you may decide you like it enough to make it your default shell.</p><h2 id="terminology">Terminology</h2><p>The term &quot;pipeline&quot; was described earlier. Command pipelines entered in the shell must be on a single line, but inside scripts lines that end with <code>|</code> continue on the next line. Nushell does not support using <code>\</code> as a line continuation character like in other shells such as Bash.</p><p>Commands that take no input and produce output are referred to as &quot;inputs&quot; or &quot;sources&quot;. An example is the <code>open</code> command which loads a file.</p><p>Commands that take input and transform it are referred to as &quot;filters&quot;. Examples include the <code>where</code> and <code>sort-by</code> commands.</p><p>Commands that take input and display it or write it somewhere such as file are referred to as &quot;outputs&quot; or &quot;sinks&quot;. Examples include the <code>autoview</code> and <code>save</code> commands.</p><h2 id="installing">Installing</h2><p>There are many options for installing the Nushell.</p><p>If you have Rust installed, enter <code>cargo install nu</code>. This takes several minutes to complete.</p><p>If you are on macOS and have Homebrew installed, enter <code>brew install nushell</code>. Note that Homebrew may install a version that is several versions behind the latest.</p><p>Prebuilt binaries for Linux, macOS, and Windows can also be downloaded.</p><p>For more information on installation options, click the Nushell link above.</p><h2 id="getting-started">Getting Started</h2><p>After installing Nushell, enter <code>nu</code> in a terminal to start a shell.</p><p>For help, enter <code>help</code>. For a list of Nushell commands and custom commands, enter <code>help commands</code>. In version 0.28.0 there are 105 Nushell commands. For help on a specific command, enter <code>help {command-name}</code> or {command-name} -h`. For more detail on supported commands, see the <a href="https://www.nushell.sh/book/command_reference.html?v=1.0.12" rel="noopener" target="_blank">Command Reference</a>.</p><aside>To search for commands whose name or help text contains given text, define the following custom command and pass the text to it. Later we will see how to define custom commands so they are automatically available in new Nushell sessions.<pre class="language-bash"><code class="language-bash">def help-text <span class="token punctuation">[</span>s: string<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">help</span> commands <span class="token operator">|</span><br>    <span class="token keyword">select</span> name description <span class="token operator">|</span><br>    append <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">help</span> commands <span class="token operator">|</span> get subcommands <span class="token variable">)</span></span> <span class="token operator">|</span><br>    flatten <span class="token operator">|</span><br>    where description <span class="token operator">=</span>~ <span class="token variable">$s</span> <span class="token operator">||</span> name <span class="token operator">=</span>~ <span class="token variable">$s</span><br><span class="token punctuation">}</span></code></pre></aside><p>Like in all shells, commands are executed by typing them and pressing the enter key. Multi-line commands can be entered by pressing enter before a block, delimited by square brackets or curly braces, is complete.</p><p>Nushell has great command recall and completion like the Fish and Zsh shells. Command recall even supports multi-line command editing.</p><p>When a command not defined by Nushell is encountered, the directories listed in the <code>path</code> configuration setting are searched to find a matching executable. To run a command in the <code>path</code> that happens to have the same name as a Nushell command, prefix the command name with <code>^</code>. For example, <code>^ls *.html</code> uses the <code>ls</code> command defined in root shell rather than the version defined by Nushell.</p><p>For detailed documentation on Nushell commands, see the <a href="https://www.nushell.sh/book/?v=1.0.12" rel="noopener" target="_blank">Book</a> link in the top nav of the Nushell website.</p><p>For more help, join the <a href="https://discord.gg/NtAbbGn?v=1.0.12" rel="noopener" target="_blank">nushell Discord channel</a>.</p><h2 id="subcommands">Subcommands</h2><p>Subcommands provide a way of grouping commands under a common &quot;namespace&quot;. Examples of such built-in namespaces include <code>date</code>, <code>from</code>, <code>to</code>, <code>math</code>, <code>str</code>, <code>url</code>.</p><p>The <code>date</code> subcommands are <code>format</code>, <code>list-timezone</code>, <code>now</code>, <code>to-table</code>, and <code>to-timezone</code>.</p><p>The <code>from</code> subcommands convert data from a given format to a table. They are <code>csv</code>, <code>eml</code>, <code>ics</code>, <code>ini</code>, <code>json</code>, <code>ods</code>, <code>ssv</code>, <code>toml</code>, <code>tsv</code>, <code>url</code>, <code>vcf</code>, <code>xlsx</code>, <code>xml</code>, <code>yaml</code>, and <code>yml</code>.</p><p>The <code>to</code> subcommands convert a table into a given output format and are commonly piped to the <code>save</code> command to write the result to a file. They are <code>csv</code>, <code>html</code>, <code>json</code>, <code>md</code>, <code>toml</code>, <code>tsv</code>, <code>url</code>, <code>xml</code>, and <code>yaml</code>.</p><p>The <code>math</code> subcommands perform math calculations. They are <code>abs</code>, <code>avg</code>, <code>ceil</code>, <code>eval</code>, <code>floor</code>, <code>max</code>, <code>median</code>, <code>min</code>, <code>mode</code>, <code>product</code>, <code>round</code>, <code>sqrt</code>, <code>stddev</code>, <code>sum</code>, and <code>variance</code>. Also see the commands <code>inc</code>, <code>into-int</code>, <code>random</code>, and <code>seq</code>.</p><p>The <code>str</code> subcommands perform string operations. They are <code>camel-case</code>, <code>capitalize</code>, <code>collect</code>, <code>contains</code>, <code>downcase</code>, <code>ends-with</code>, <code>find-replace</code>, <code>from</code>, <code>index-of</code>, <code>kebab-case</code>, <code>length</code>, <code>lpad</code>, <code>ltrim</code>, <code>pascal-case</code>, <code>reverse</code>, <code>rpad</code>, <code>rtrim</code>, <code>screaming-snake-case</code>, <code>snake-case</code>, <code>starts-with</code>, <code>substring</code>, <code>to-datetime</code>, <code>to-decimal</code>, <code>to-int</code>, <code>trim</code>, and <code>upcase</code>. Also see the commands <code>build-string</code>, <code>char</code>, <code>format</code>, and <code>size</code>.</p><p>The <code>url</code> subcommands get information from a URL. They are <code>host</code>, <code>path</code>, <code>query</code>, and <code>scheme</code> (ex. http).</p><h2 id="configuration">Configuration</h2><p>The configuration for Nushell is stored in a <a href="https://github.com/toml-lang/toml?v=1.0.12" rel="noopener" target="_blank">TOML</a> (Tom's Obvious, Minimal Language) file whose path can be obtained by entering <code>config path</code>. Configuration settings can be changed by editing this file or using the <code>config</code> subcommands described below. Changes to the config file only affect new shell sessions, not the current one.</p><p>To edit the config file with Vim, enter <code>vim $(config path)</code>. To edit the config file with VS Code, enter <code>code $(config path)</code>. When editing the config file using VS Code, consider installing the &quot;TOML Language Support&quot; extension which profiles syntax highlighting and formatting.</p><aside>The syntax <code>$(pipeline)</code> is referred to as an "invocation". This can be used to pass the result of a command pipeline as a argument to a command.</aside><p>Some Nushell configuration settings are top-level and do not appear in a specific TOML section. Notable top-level options include:</p><table><thead><tr><th>Setting</th><th>Description</th></tr></thead><tbody><tr><td><code>disable_table_indexes</code></td><td>when <code>true</code>, omits index column from table output</td></tr><tr><td><code>path</code></td><td>list of directories in quotes to search for executables</td></tr><tr><td><code>prompt</code></td><td>command whose output is used for the prompt</td></tr><tr><td><code>skip_welcome_message</code></td><td>when <code>true</code>, starting a shell doesn't output a<br>welcome message including the Nushell version</td></tr><tr><td><code>startup</code></td><td>list of commands to execute when a shell starts;<br>typically defines aliases and custom commands</td></tr><tr><td><code>table_mode</code></td><td>controls the border lines drawn when tables are rendered<br>(more detail below)</td></tr></tbody></table><p>For details on configuration options, see <a href="https://www.nushell.sh/book/configuration.html?v=1.0.12" rel="noopener" target="_blank">Configuration</a>.</p><p>The <code>config</code> command supports many subcommands that operate on the config file. These are summarized in the table below.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>config</code></td><td>outputs all the settings</td></tr><tr><td><code>config path</code></td><td>outputs the file path to the configuration file</td></tr><tr><td><code>config set {name} {value}</code></td><td>sets or updates a specific setting</td></tr><tr><td><code>{pipeline} | config set_into {name}</code></td><td>sets a specific setting to a piped-in value</td></tr><tr><td><code>config get {name}</code></td><td>gets a specific setting</td></tr><tr><td><code>config remove {name}</code></td><td>removes a specific setting</td></tr></tbody></table><p>For example, to change the prompt enter the following:</p><pre class="language-bash"><code class="language-bash">config <span class="token builtin class-name">set</span> prompt <span class="token string">"echo <span class="token variable"><span class="token variable">$(</span>ansi yellow<span class="token variable">)</span></span> '🦀ν> '"</span></code></pre><p>This adds the line <code>prompt = &quot;echo $(ansi yellow) '🦀ν&gt; '&quot;</code> to the configuration file. 🦀 is for the Rust mascot Ferris and ν is the Greek letter nu.</p><p>For a fancier prompt setting that includes the current working directory in yellow, and a green, right-pointing triangle at the end, add the following line in the config file:</p><pre class="language-bash"><code class="language-bash">prompt <span class="token operator">=</span><br>  <span class="token string">"echo <span class="token variable"><span class="token variable">`</span>🦀ν <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">$(</span>ansi yellow<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">$(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">$(</span>ansi green<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">$(</span>char prompt<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token variable">`</span></span>"</span></code></pre><p>Another option for customizing the prompt is to enable the use of <a href="/blog/starship">Starship</a>, which has many more options. It also has the advantage that it can be used with nearly any shell, which is great for users that sometimes switch between shells.</p><h3 id="startup-setting"><code>startup</code> Setting</h3><p>The <code>startup</code> setting specifies a list of commands to run each time a new Nushell session is started. Typically the commands define aliases and custom commands (using <code>def</code>). For example:</p><pre class="language-toml"><code class="language-toml"><span class="token key property">startup</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><br>  <span class="token string">"alias cls = clear"</span><span class="token punctuation">,</span><br>  <span class="token string">"def cdjs [] { cd $nu.env.JS_DIR }"</span><span class="token punctuation">,</span><br>  <span class="token string">"def cdrust [] { cd $nu.env.RUST_DIR }"</span><br><span class="token punctuation">]</span></code></pre><p>Some code formatters reformat TOML arrays to be on a single line which makes reading these definitions difficult. VS Code and the &quot;TOML Language Support&quot; extension does not do this.</p><p>Aliases that use the &quot;cd&quot; command currently causes Nushell to crash. See <a href="https://github.com/nushell/nushell/issues/3138?v=1.0.12" rel="noopener" target="_blank">issue 3138</a>.</p><h3 id="table_mode-setting"><code>table_mode</code> Setting</h3><p>Table borders can be customized with the <code>table_mode</code> setting. Supported values include:</p><ul><li>basic: uses +, -, and | characters for borders</li><li>compact: omits outer left and right borders</li><li>compact_double: like compact, but uses double lines for borders</li><li>heavy: thicker border on every cell</li><li>light: horizontal line below header and no other borders</li><li>none: no borders</li><li>reinforced: border on every cell with thick table corners</li><li>rounded: border on every cell and rounded table corners (my favorite)</li><li>thin: border on every cell</li><li>with_love: heart characters for borders</li></ul><h3 id="color_config-section"><code>color_config</code> Section</h3><p>The colors used to output data of each table element and data type can be customized by adding a <code>[color_config]</code> section in the config file. Supported colors include red, yellow, green, cyan, blue, purple, white, and black. Supported modifiers include bold, underline, italic, dimmed, and reverse. Colors and modifiers can be specified with their full names, separated by an underscore. For example, <code>yellow_bold</code>. They can also be abbreviated using only their first letters. For example, <code>yb</code>. The only exception is blue which uses the letter &quot;u&quot; because &quot;b&quot; is used for black.</p><p>The header elements and styles that can be configured include <code>header_align</code>, <code>header_bold</code>, <code>header_color</code>, <code>index_color</code>, <code>leading_trailing_space_bg</code>, and <code>separator_color</code> (used for table lines). The data types that can be configured include <code>primitive_binary</code>, <code>primitive_boolean</code>, <code>primitive_columnpath</code>, <code>primitive_date</code>, <code>primitive_decimal</code>, <code>primitive_duration</code>, <code>primitive_filesize</code>, <code>primitive_int</code>, <code>primitive_line</code>, <code>primitive_path</code>, <code>primitive_pattern</code>, <code>primitive_range</code>, and <code>primitive_string</code>.</p><p>For example:</p><pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">color_config</span><span class="token punctuation">]</span><br><span class="token key property">header_align</span> <span class="token punctuation">=</span> <span class="token string">"l"</span> <span class="token comment"># use left or l, right or r, and center or c</span><br><span class="token key property">header_bold</span> <span class="token punctuation">=</span> <span class="token boolean">true</span><br><span class="token key property">header_color</span> <span class="token punctuation">=</span> <span class="token string">"r"</span><br><span class="token key property">index_color</span> <span class="token punctuation">=</span> <span class="token string">"wd"</span> <span class="token comment"># white dimmed</span><br><span class="token key property">separator_color</span> <span class="token punctuation">=</span> <span class="token string">"wd"</span> <span class="token comment"># white dimmed; for table lines</span><br><br><span class="token key property">primitive_binary</span> <span class="token punctuation">=</span> <span class="token string">"c"</span><br><span class="token key property">primitive_boolean</span> <span class="token punctuation">=</span> <span class="token string">"p"</span><br><span class="token key property">primitive_date</span> <span class="token punctuation">=</span> <span class="token string">"u"</span><br><span class="token key property">primitive_decimal</span> <span class="token punctuation">=</span> <span class="token string">"g"</span><br><span class="token key property">primitive_filesize</span> <span class="token punctuation">=</span> <span class="token string">"g"</span><br><span class="token key property">primitive_int</span> <span class="token punctuation">=</span> <span class="token string">"g"</span><br><span class="token key property">primitive_path</span> <span class="token punctuation">=</span> <span class="token string">"y"</span><br><span class="token key property">primitive_string</span> <span class="token punctuation">=</span> <span class="token string">"w"</span></code></pre><h3 id="line_editor-section"><code>line_editor</code> Section</h3><p>Nushell line editing is provided by <a href="https://crates.io/crates/rustyline?v=1.0.12" rel="noopener" target="_blank">rustyline</a>. It can be configured with the &quot;[line_editor]&quot; section. Notable settings include:</p><table><thead><tr><th>Setting</th><th>Description</th></tr></thead><tbody><tr><td><code>edit_mode</code></td><td><code>&quot;emacs&quot;</code> or <code>&quot;vi&quot;</code><br>default is to use <a href="https://github.com/kkawakam/rustyline#actions?v=1.0.12" rel="noopener" target="_blank">rustyline key bindings</a></td></tr><tr><td><code>history_duplicates</code></td><td><code>&quot;alwaysadd&quot;</code> or <code>&quot;ignoreconsecutive&quot;</code> (default)</td></tr><tr><td><code>history_ignore_space</code></td><td><code>true</code> (default) or <code>false</code>;<br>when true, commands with leading whitespace are not added to history</td></tr></tbody></table><p>For example:</p><pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">line_editor</span><span class="token punctuation">]</span><br><span class="token key property">edit_mode</span> <span class="token punctuation">=</span> <span class="token string">"vi"</span> <span class="token comment"># omit for default keystrokes (see rustyline link above)</span><br><span class="token key property">history_ignore_space</span> <span class="token punctuation">=</span> <span class="token boolean">true</span></code></pre><h3 id="path-setting"><code>path</code> setting</h3><p>The <code>path</code> setting lists directories to be searched for executables.</p><p>To see a nicely formatted list of directories in your path, enter <code>echo $nu.path</code> or <code>config | get path</code>.</p><p>The command <code>config set path $nu.path</code> sets the <code>path</code> setting to the value of <code>$nu.path</code>, which is the value of the <code>PATH</code> environment variable in the parent shell. Once set, this can be customized to be specific to Nushell. Note that if Nushell is your login shell then there is no parent shell from which to inherit a path.</p><h3 id="env-section"><code>env</code> Section</h3><p>The command <code>config set env $nu.env</code> adds all the current environment variables in the <code>env</code> section of the config file. This section can also define environment variables that are specific to Nushell. Note that if Nushell is your login shell then there is no parent shell from which to inherit environment variables.</p><p>For example:</p><pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">env</span><span class="token punctuation">]</span><br><span class="token key property">GITHUB_USER</span> <span class="token punctuation">=</span> <span class="token string">"mvolkmann"</span></code></pre><h3 id="textview-section"><code>textview</code> Section</h3><p>These settings affect operation of the <code>bat</code> crate which is used by the <code>open</code> command to view text files.</p><table><thead><tr><th>Setting</th><th>Description</th></tr></thead><tbody><tr><td>grid</td><td><code>true</code> (default) or <code>false</code></td></tr><tr><td>header</td><td><code>true</code> (default) or <code>false</code></td></tr><tr><td>line_numbers</td><td><code>true</code> (default) or <code>false</code></td></tr><tr><td>theme</td><td>ex. &quot;Coldark-Dark&quot;</td></tr><tr><td>true_color</td><td><code>true</code> or <code>false</code></td></tr><tr><td>vcs_modification_markers</td><td><code>true</code> or <code>false</code> (seems to have no effect)</td></tr></tbody></table><p>TODO: Setting vcs_modification_markers to true has no effect. See <a href="https://github.com/nushell/nushell/issues/3254?v=1.0.12" rel="noopener" target="_blank">issue 3254</a>.</p><p>To see the supported themes, install <code>bat</code> by entering <code>cargo install bat</code> and enter <code>bat --list-themes</code>. There are over 20.</p><h2 id="data-types">Data Types</h2><p>Unlike most shells where only strings are used for command input and output, Nushell supports many primitive and structured data types. Some types described in the Nushell documentation are purely conceptual, meaning that they cannot be used as the type of a custom command parameter. The following tables list all the real types and conceptual types.</p><p>Real Types:</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>any</code></td><td>any type below (default for variables and custom command parameters)</td></tr><tr><td><code>block</code></td><td>block of nu script code (can be executed on each row of a table)</td></tr><tr><td><code>int</code></td><td>whole number with infinite precision</td></tr><tr><td><code>number</code></td><td><code>int</code> or <code>decimal</code>, both with infinite precision</td></tr><tr><td><code>path</code></td><td>platform-independent path to a file or directory</td></tr><tr><td><code>pattern</code></td><td>glob pattern that can include <code>*</code> wildcard and <code>**</code> for traversing directories</td></tr><tr><td><code>range</code></td><td><code>{start}..{end}</code> (inclusive) or <code>{start}..&lt;{end}</code> (end is exclusive); use 2 dots, not 3</td></tr><tr><td><code>string</code></td><td>single words need no delimiter; multiple words need single quotes, double quotes, or backticks</td></tr><tr><td><code>table</code></td><td>list of rows; returned by many Nushell commands</td></tr><tr><td><code>unit</code></td><td>any value with a unit; includes <code>duration</code> and <code>filesize</code> types</td></tr></tbody></table><p>The ability to specify single-word literal strings with no delimiters is one of my favorite features in Nushell! It makes defining lists and tables that contain single-word strings much more compact. For example, the following line creates a list of color names.</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span>red orange yellow green blue purple<span class="token punctuation">]</span></code></pre><p>Conceptual Types:</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>binary</td><td>sequence of raw bytes</td></tr><tr><td>boolean</td><td>literal values are <code>$true</code> and <code>$false</code></td></tr><tr><td>column path</td><td>dot-separated list of nested column names</td></tr><tr><td>date</td><td>timezone-aware; defaults to UTC</td></tr><tr><td>decimal</td><td>number with a fractional part and infinite precision</td></tr><tr><td>duration</td><td>number followed by a unit which can be <code>ms</code>, <code>sec</code>, <code>min</code>, <code>hr</code>, <code>day</code>, <code>wk</code>, <code>mon</code>, or <code>yr</code></td></tr><tr><td>filesize</td><td>number followed by a unit which can be <code>b</code>, <code>kb</code>, <code>mb</code>, <code>gb</code>, <code>tb</code>, or <code>pb</code></td></tr><tr><td>group</td><td>semicolon-separated list of pipelines where only output from the last is output</td></tr><tr><td>line</td><td>string with an OS-dependent line ending</td></tr><tr><td>list</td><td>sequence of values of any type</td></tr><tr><td>row</td><td>list where each value represents a column with an associated name</td></tr></tbody></table><p>To see a description of the value of an expression, pipe it to the <code>describe</code> command. This is not its real type. Values of type of <code>int</code> are reported as <code>integer</code>. This is likely a bug. See <a href="https://github.com/nushell/nushell/issues/3206?v=1.0.12" rel="noopener" target="_blank">issue 3206</a>. For example, <code>date now | describe</code> outputs <code>date</code>.</p><aside>It seems like many of the conceptual types should become real types long-term. I would think at least these could become real types: boolean, date, decimal (remove number?), duration, filesize, and list.<p>Related to this is the fact that the <code>describe</code> command doesn't strictly return real type names. One of the oddities is that if you pipe an <code>int</code> value to <code>describe</code>, it outputs &quot;integer&quot;. See <a href="https://github.com/nushell/nushell/issues/3206?v=1.0.12" rel="noopener" target="_blank">issue 3206</a>. Maybe it would be good to add a <code>type</code> command that returns the real type of a value.</p></aside><p>Details about Nushell data types can be found at <a href="https://www.nushell.sh/book/types_of_data.html?v=1.0.12" rel="noopener" target="_blank">Types of data</a>.</p><h3 id="type-conversions">Type Conversions</h3><p>The following type conversions are supported:</p><p>TODO: Fill in the ??? in this table. TODO: How can you create values with these types? TODO: binary, line, path, pattern, row</p><table><thead><tr><th>From</th><th>To</th><th>Command</th></tr></thead><tbody><tr><td><code>any</code></td><td><code>string</code></td><td>pipe to <code>describe</code></td></tr><tr><td>boolean</td><td><code>string</code></td><td>pipe to <code>str from</code></td></tr><tr><td>date</td><td><code>string</code></td><td>pipe to <code>str from</code></td></tr><tr><td><code>int</code></td><td><code>string</code></td><td>pipe to <code>str from</code></td></tr><tr><td>list</td><td><code>string</code></td><td>pipe to <code>str collect</code> if the list contains strings</td></tr><tr><td><code>number</code></td><td><code>string</code></td><td>pipe to <code>str from</code></td></tr><tr><td><code>path</code></td><td><code>string</code></td><td>pipe to <code>???</code></td></tr><tr><td><code>pattern</code></td><td><code>string</code></td><td>pipe to <code>???</code></td></tr><tr><td><code>range</code></td><td><code>string</code></td><td>pipe to <code>???</code></td></tr><tr><td><code>table</code></td><td><code>string</code></td><td>pipe to <code>???</code></td></tr><tr><td><code>unit</code></td><td><code>string</code></td><td>pipe to <code>str from</code> *</td></tr><tr><td><code>string</code></td><td>boolean</td><td>pipe to <code>???</code></td></tr><tr><td><code>string</code></td><td>date</td><td>pipe to <code>str to-datetime</code></td></tr><tr><td><code>string</code></td><td><code>int</code></td><td>pipe to <code>str to-int</code></td></tr><tr><td><code>string</code></td><td>list</td><td>pipe to <code>split row</code></td></tr><tr><td><code>string</code></td><td><code>number</code></td><td>pipe to <code>str to-decimal</code></td></tr><tr><td><code>string</code></td><td><code>path</code></td><td>pipe to <code>???</code></td></tr><tr><td><code>string</code></td><td><code>range</code></td><td>pipe to <code>???</code></td></tr><tr><td><code>string</code></td><td><code>table</code></td><td>pipe to <code>???</code></td></tr><tr><td><code>string</code></td><td><code>unit</code></td><td>pipe to <code>???</code></td></tr></tbody></table><p>* TODO: This gives an error. Why?</p><p>The <code>echo</code> command is often used to feed the initial value into a command pipeline. This can be a literal value or an expression such as a variable reference. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"2021-3-21 14:30"</span> <span class="token operator">|</span> str to-datetime <span class="token operator">|</span> <span class="token function">date</span> <span class="token function">format</span> -t <span class="token string">'%B %-d, %Y'</span> <span class="token operator">|</span><br>  get formatted<br><span class="token comment"># This outputs the string "March 21, 2021".</span><br><span class="token comment"># Supported control characters are described &lt;a href="https://man7.org/linux/man-pages/man1/date.1.html?v=1.0.12" rel="noopener" target="_blank">here&lt;/a>.</span></code></pre><p>This handy custom command produces a string from the items in a list where the value of each item is followed by a newline character. It is used in several examples that follow. Consider adding this to the startup array in your Nushell config file.</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># The `each` command iterates over list items that are piped to this command.</span><br><span class="token comment"># During the iteration, the special variable $it (for item)</span><br><span class="token comment"># is set to the current item.</span><br>def as-lines <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  each <span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>build-string $it <span class="token punctuation">$(</span>char newline<span class="token punctuation">)</span><span class="token variable">)</span></span> <span class="token punctuation">}</span> <span class="token operator">|</span> str collect<br><span class="token punctuation">}</span></code></pre><h3 id="strings">Strings</h3><p>Strings delimited by backticks support templating (a.k.a interpolation) with expressions in pairs of double curly brackets. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> x <span class="token operator">=</span> <span class="token number">19</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span>x is <span class="token punctuation">{</span><span class="token punctuation">{</span>$x<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">`</span></span><br><br><span class="token builtin class-name">let</span> x <span class="token operator">=</span> <span class="token number">3</span><br><span class="token builtin class-name">let</span> y <span class="token operator">=</span> <span class="token number">5</span><br><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span>product of <span class="token punctuation">{</span><span class="token punctuation">{</span>$x<span class="token punctuation">}</span><span class="token punctuation">}</span> and <span class="token punctuation">{</span><span class="token punctuation">{</span>$y<span class="token punctuation">}</span><span class="token punctuation">}</span> is <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">$(</span><span class="token operator">=</span> $x * $y<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">`</span></span><br><span class="token comment"># As discussed in the "Operators" section later,</span><br><span class="token comment"># operators can only be used in "math mode".</span><br><span class="token comment"># An expression is in math mode if it begins with `=`.</span></code></pre><p>The operators <code>=~</code> and <code>!~</code> test whether one string contains or does not contain another.</p><p>For example:</p><pre class="language-bash"><code class="language-bash"><span class="token operator">=</span> <span class="token string">"foobarbaz"</span> <span class="token operator">=</span>~ <span class="token string">"bar"</span> <span class="token comment"># true</span><br><span class="token operator">=</span> <span class="token string">"foobarbaz"</span> <span class="token operator">!</span>~ <span class="token string">"bar"</span> <span class="token comment"># false</span></code></pre><h3 id="ranges">Ranges</h3><p>Values of the <code>range</code> type can use default values for their start or end. If the start value of a range is omitted, it defaults to zero. For example, <code>..10</code> is the same as <code>0..10</code>. If the end value of a range is omitted, the range has no upper bound.</p><p>The get the starting and ending values of a <code>range</code>, pipe it to the <code>first</code> and <code>last</code> commands.</p><p>For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token number">3</span><span class="token punctuation">..</span><span class="token number">7</span> <span class="token operator">|</span> first <span class="token comment"># 3</span><br><span class="token builtin class-name">echo</span> <span class="token number">3</span><span class="token punctuation">..</span><span class="token operator">&lt;</span><span class="token number">7</span> <span class="token operator">|</span> last <span class="token comment"># 6</span><br><span class="token builtin class-name">echo</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span> <span class="token operator">|</span> as-lines <span class="token comment"># outputs 1, 2, and 3 on separate lines</span></code></pre><h3 id="types-with-units">Types With Units</h3><p>Duration values with different units can be added. For example, <code>2hr + 57min + 11sec</code> (my best marathon time).</p><p>Values of the <code>filesize</code> type with different units can be added. For example, <code>2mb + 57kb + 11b</code>.</p><p>When values of different types are combined in a coercion error occurs. For example, <code>3hr + 2mb</code> gives this error and clearly identifies that the first value is a <code>duration</code> and the 2nd is a <code>filesize</code>.</p><h3 id="lists">Lists</h3><p>The literal syntax for creating a <code>list</code> is to include expressions in square brackets separated by spaces or commas (for readability). For example, <code>[&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</code> or <code>[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</code>.</p><p>To iterate over the elements in a list, use the <code>each</code> command. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span>Mark Tami Amanda Jeremy<span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$names</span> <span class="token operator">|</span> as-lines <span class="token comment"># outputs each name on a separate line</span></code></pre><p>The <code>$it</code> special variable holds the output of the previous command. When used in a block passed to the <code>each</code> command, it holds the current iteration value.</p><p>To access a list element at a given index, use <code>$name.index</code> where <code>$name</code> is a variable that holds a list. For example, the second element in the list above which is &quot;Tami&quot; can be accessed with <code>$names.1</code>.</p><p>The <code>in</code> and <code>not in</code> operators are used to test whether a value is in a list. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span>red green blue<span class="token punctuation">]</span><br><span class="token comment"># As discussed in the "Operators" section later,</span><br><span class="token comment"># operators can only be used in "math mode".</span><br><span class="token comment"># An expression is in math mode if it begins with `=`.</span><br><span class="token operator">=</span> blue <span class="token keyword">in</span> <span class="token variable">$colors</span> <span class="token comment"># true</span><br><span class="token operator">=</span> yellow <span class="token keyword">in</span> <span class="token variable">$colors</span> <span class="token comment"># false</span></code></pre><p>The <code>where</code> command can be used to create a subset of a list. The following example gets all the colors whose names end in &quot;e&quot;.</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span>red orange yellow green blue purple<span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$colors</span> <span class="token operator">|</span> where <span class="token punctuation">{</span><span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $it <span class="token operator">|</span> str ends-with <span class="token string">'e'</span><span class="token variable">)</span></span><span class="token punctuation">}</span><br><span class="token comment"># The block passed to where must evaluate to a boolean.</span><br><span class="token comment"># This outputs the list [orange blue purple].</span></code></pre><p>The <code>empty?</code> command is used to test whether a string, list, or table is empty. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># Strings</span><br><span class="token builtin class-name">let</span> name <span class="token operator">=</span> <span class="token string">"Mark"</span><br><span class="token operator">=</span> <span class="token variable">$name</span> <span class="token operator">|</span> empty? <span class="token comment"># false</span><br><span class="token builtin class-name">let</span> name <span class="token operator">=</span> <span class="token string">""</span><br><span class="token operator">=</span> <span class="token variable">$name</span> <span class="token operator">|</span> empty? <span class="token comment"># true</span><br><br><span class="token comment"># Lists</span><br><span class="token operator">=</span> <span class="token variable">$colors</span> <span class="token operator">|</span> empty? <span class="token comment"># false</span><br><span class="token builtin class-name">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><br><span class="token operator">=</span> <span class="token variable">$colors</span> <span class="token operator">|</span> empty? <span class="token comment"># true</span><br><br><span class="token comment"># Tables</span><br><span class="token builtin class-name">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Name Score<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>Mark <span class="token number">19</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>Tami <span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">]</span><br><span class="token operator">=</span> <span class="token variable">$scores</span> <span class="token operator">|</span> empty? <span class="token comment"># false</span><br><span class="token builtin class-name">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><br><span class="token operator">=</span> <span class="token variable">$scores</span> <span class="token operator">|</span> empty? <span class="token comment"># true; not empty if only header row is present</span></code></pre><p>The <code>flatten</code> command creates a new list from an existing list by adding items in nested lists to the top-level list. This can be called multiple times to flatten lists nested at any depth. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">4</span> <span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">|</span> flatten <span class="token comment"># [1 2 3 4 5 6]</span><br><br><span class="token builtin class-name">echo</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">4</span> <span class="token number">5</span> <span class="token punctuation">[</span><span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">|</span> flatten <span class="token operator">|</span> flatten <span class="token operator">|</span> flatten <span class="token comment"># [1 2 3 4 5 6 7 8]</span></code></pre><p>The <code>reduce</code> command computes a single value from a list. It takes a block which can use the special variables <code>$acc</code> (for accumulator) and <code>$it</code> (for item). To specify an initial value for <code>$acc</code>, use the <code>--fold</code> flag. To change <code>$it</code> to have <code>$it.index</code> and <code>$it.item</code> values, add the <code>--numbered</code> flag. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">8</span> <span class="token number">4</span><span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token string">"total ="</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $scores <span class="token operator">|</span> reduce <span class="token punctuation">{</span> <span class="token operator">=</span> $acc + $it <span class="token punctuation">}</span><span class="token variable">)</span></span> <span class="token comment"># 15</span><br><span class="token builtin class-name">echo</span> <span class="token string">"total ="</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $scores <span class="token operator">|</span> math <span class="token function">sum</span><span class="token variable">)</span></span> <span class="token comment"># easier approach, same result</span><br><span class="token builtin class-name">echo</span> <span class="token string">"product ="</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $scores <span class="token operator">|</span> reduce --fold <span class="token number">1</span> <span class="token punctuation">{</span> <span class="token operator">=</span> $acc * $it <span class="token punctuation">}</span><span class="token variable">)</span></span> <span class="token comment"># 96</span></code></pre><h3 id="tables">Tables</h3><p>The literal syntax for creating a table defines each row with a list, starting with the header row which is followed by a semicolon. For example, <code>echo [[Name Score]; [Mark 19] [Tami 21]]</code> outputs the following table:</p><pre class="language-text"><code class="language-text">╭───┬──────┬───────╮<br>│ # │ Name │ Score │<br>├───┼──────┼───────┤<br>│ 0 │ Mark │    19 │<br>│ 1 │ Tami │    21 │<br>╰───┴──────┴───────╯</code></pre><p>SQL-like syntax can be used to retrieve data from a table. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Name Score<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>Mark <span class="token number">19</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>Tami <span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$scores</span> <span class="token operator">|</span> where Name <span class="token operator">==</span> <span class="token string">'Tami'</span> <span class="token operator">|</span> get Score <span class="token comment"># 21</span></code></pre><p>The use of the <code>where</code> command above is shorthand for the expanded syntax. This uses the special variable <code>$it</code> which holds the result of the previous command or the current iteration value. The previous pipeline can be written as shown below using this syntax. The curly braces after the <code>where</code> command define a block on which it operates. As we have seen, the leading <code>=</code> enters &quot;math mode&quot; which enables use of operators.</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$scores</span> <span class="token operator">|</span> where <span class="token punctuation">{</span> <span class="token operator">=</span> <span class="token variable">$it</span>.Name <span class="token operator">==</span> <span class="token string">'Tami'</span><span class="token punctuation">}</span> <span class="token operator">|</span> get Score <span class="token comment"># 21</span></code></pre><p>Single-row tables can be used like objects in other languages. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>color flavor<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>yellow vanilla<span class="token punctuation">]</span><span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$data</span>.color <span class="token comment"># outputs yellow</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$data</span>.flavor <span class="token comment"># outputs vanilla</span></code></pre><p>Nushell is currently very picky about splitting table data over multiple lines. The newlines in the table definition below break it! See <a href="https://github.com/nushell/nushell/issues/3204?v=1.0.12" rel="noopener" target="_blank">issue 3204</a>.</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># This way of adding newlines in a table definition is not parsed correctly.</span><br><span class="token builtin class-name">let</span> sports <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token punctuation">[</span>name players<span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span>baseball <span class="token number">9</span><span class="token punctuation">]</span><br>  <span class="token punctuation">[</span>basketball <span class="token number">5</span><span class="token punctuation">]</span><br>  <span class="token punctuation">[</span>football <span class="token number">11</span><span class="token punctuation">]</span><br>  <span class="token punctuation">[</span>hockey <span class="token number">6</span><span class="token punctuation">]</span><br><span class="token punctuation">]</span><br><span class="token comment"># This way is parsed correctly.</span><br><span class="token builtin class-name">let</span> sports <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token punctuation">[</span>name players<br>  <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>baseball <span class="token number">9</span><br>  <span class="token punctuation">]</span> <span class="token punctuation">[</span>basketball <span class="token number">5</span><br>  <span class="token punctuation">]</span> <span class="token punctuation">[</span>football <span class="token number">11</span><br>  <span class="token punctuation">]</span> <span class="token punctuation">[</span>hockey <span class="token number">6</span><span class="token punctuation">]</span><br><span class="token punctuation">]</span><br><span class="token builtin class-name">let</span> sport <span class="token operator">=</span> basketball<br><span class="token builtin class-name">let</span> players <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $sports <span class="token operator">|</span> where name <span class="token operator">==</span> $sport <span class="token operator">|</span> get players<span class="token variable">)</span></span><br><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span>The number of active players <span class="token keyword">in</span>  is <span class="token builtin class-name">.</span><span class="token variable">`</span></span></code></pre><p>Tables can contain nested tables. Note the placement of newlines in the example below which avoids the parsing issue described above. The <code>to json</code> command is used to generate JSON from a table.</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> person <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token punctuation">[</span>name address<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span><br>    <span class="token string">"Mark Volkmann"</span>, <span class="token punctuation">[</span><br>      <span class="token punctuation">[</span>street city state zip<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span><br>        <span class="token string">"123 Some Street"</span> <span class="token string">"Somewhere"</span> <span class="token string">"MO"</span> <span class="token number">12345</span><br>      <span class="token punctuation">]</span><br>    <span class="token punctuation">]</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">]</span><br><br><span class="token builtin class-name">echo</span> <span class="token variable">$person</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$person</span> <span class="token operator">|</span> get address<br><span class="token builtin class-name">echo</span> <span class="token variable">$person</span> <span class="token operator">|</span> to json --pretty <span class="token number">2</span></code></pre><p>Running the code above produces the following result:</p><pre class="language-text"><code class="language-text">╭───┬───────────────┬────────────────╮<br>│ # │ name          │ address        │<br>├───┼───────────────┼────────────────┤<br>│ 0 │ Mark Volkmann │ [table 1 rows] │<br>╰───┴───────────────┴────────────────╯<br><br>╭───┬─────────────────┬───────────┬───────┬───────╮<br>│ # │ street          │ city      │ state │ zip   │<br>├───┼─────────────────┼───────────┼───────┼───────┤<br>│ 0 │ 123 Some Street │ Somewhere │ MO    │ 12345 │<br>╰───┴─────────────────┴───────────┴───────┴───────╯<br><br>{<br>  "address": [<br>    {<br>      "city": "Somewhere",<br>      "state": "MO",<br>      "street": "123 Some Street",<br>      "zip": 12345<br>    }<br>  ],<br>  "name": "Mark Volkmann"<br>}</code></pre><h2 id="operators">Operators</h2><p>Nushell supports the following operators:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>+</code></td><td>add</td></tr><tr><td><code>-</code></td><td>subtract</td></tr><tr><td><code>*</code></td><td>multiply</td></tr><tr><td><code>/</code></td><td>divide</td></tr><tr><td><code>**</code></td><td>exponentiation (power)</td></tr><tr><td><code>mod</code></td><td>modulo</td></tr><tr><td><code>==</code></td><td>equal</td></tr><tr><td><code>!=</code></td><td>not equal</td></tr><tr><td><code>&lt;</code></td><td>less than</td></tr><tr><td><code>&lt;=</code></td><td>less than or equal</td></tr><tr><td><code>&gt;</code></td><td>greater than</td></tr><tr><td><code>&gt;=</code></td><td>greater than or equal</td></tr><tr><td><code>=~</code></td><td>string contains another</td></tr><tr><td><code>!~</code></td><td>string does not contain another</td></tr><tr><td><code>in</code></td><td>value in list</td></tr><tr><td><code>not in</code></td><td>value not in list</td></tr><tr><td><code>&amp;&amp;</code></td><td>and two Boolean values</td></tr><tr><td><code>||</code></td><td>or two Boolean values</td></tr></tbody></table><p>Parentheses can be used for grouping to specify evaluation order. Operators can only be used in &quot;math mode&quot;. An expression is in math mode if it begins with <code>=</code>. Commands that take a boolean expression, such as <code>where</code>, <code>keep while</code>, <code>keep until</code>, <code>skip while</code>, and <code>skip util</code>, are automatically evaluated in math mode.</p><p>For example, <code>let a = 2; let b = 3; = $a * $b</code> outputs <code>6</code>.</p><h2 id="working-with-numbers">Working with numbers</h2><p>Many of the operators listed in the previous section operate on numbers.</p><p>The <code>inc</code> command has three uses.</p><p>The first use of <code>inc</code> is to return a value that is one higher that the piped in value. For example, <code>echo 2 | inc</code> gives <code>3</code>. Since variables are immutable, this cannot be used to increment the value in a variable.</p><p>The second use of <code>inc</code> is to increment all the <code>int</code> values in a given table column if all the values are of type <code>int</code>. For example, <code>echo [[Name Size]; [Mark 33] [Tami 28]] | inc Size</code> results in a table where the values in the &quot;Size&quot; column are 34 and 29.</p><p>The third use of <code>inc</code> is to increment a specify part of a semantic version number that includes major, minor, and patch parts. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token number">1.2</span>.3 <span class="token operator">|</span> inc -M <span class="token comment"># increments major resulting in 2.0.0</span><br><span class="token builtin class-name">echo</span> <span class="token number">1.2</span>.3 <span class="token operator">|</span> inc -m <span class="token comment"># increments minor resulting in 1.3.0</span><br><span class="token builtin class-name">echo</span> <span class="token number">1.2</span>.3 <span class="token operator">|</span> inc -p <span class="token comment"># increments patch resulting in 1.2.4</span></code></pre><p>There is no <code>dec</code> command for decrementing values.</p><h2 id="working-with-urls">Working with URLs</h2><p>The <code>fetch</code> command can be used to get data from a URL.</p><p>The website <a href="https://jsonplaceholder.typicode.com?v=1.0.12" rel="noopener" target="_blank">JSONPlaceholder</a> provides access to free sample JSON data. The following example gets data about TODOs from this site.</p><pre class="language-bash"><code class="language-bash">fetch https://jsonplaceholder.typicode.com/todos <span class="token operator">|</span><br>  where userId <span class="token operator">==</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> completed <span class="token operator">==</span> <span class="token variable">$false</span> <span class="token operator">|</span><br>  sort-by title <span class="token operator">|</span> keep <span class="token number">3</span></code></pre><p>This produces output like the following:</p><pre class="language-text"><code class="language-text">╭───┬────────┬─────┬─────────────────────────────────────────────────┬───────────╮<br>│ # │ userId │ id  │ title                                           │ completed │<br>├───┼────────┼─────┼─────────────────────────────────────────────────┼───────────┤<br>│ 0 │      5 │  97 │ dolorum laboriosam eos qui iure aliquam         │ false     │<br>│ 1 │      5 │ 100 │ excepturi a et neque qui expedita vel voluptate │ false     │<br>│ 2 │      5 │  94 │ facilis modi saepe mollitia                     │ false     │<br>╰───┴────────┴─────┴─────────────────────────────────────────────────┴───────────╯</code></pre><p>The <code>post</code> command sends an HTTP POST requests to a server and returns the response as a table. The following example simulates creating a TODO using the JSONPlaceholder site and returns the id of the newly created TODO.</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> json <span class="token operator">=</span> <span class="token string">'{"title": "get milk", "userId": 5}"'</span><br>post https://jsonplaceholder.typicode.com/todos <span class="token variable">$json</span></code></pre><p>Nushell does not currently provide commands to send <code>PUT</code>, <code>PATCH</code>, or <code>DELETE</code> requests.</p><h2 id="common-unix-commands">Common UNIX Commands</h2><p>Many common UNIX commands are supported by Nushell. These are implemented in Rust and are very fast. They include:</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>cal</code></td><td>displays a calendar for the current month or an entire specified year</td></tr><tr><td><code>cd</code></td><td>changes the current working directory</td></tr><tr><td><code>clear</code></td><td>clears the terminal</td></tr><tr><td><code>cp</code></td><td>copies a file or directory</td></tr><tr><td><code>date now</code></td><td>gets the current date (see the other <code>date</code> subcommands)</td></tr><tr><td><code>du</code></td><td>gets information about disk usage</td></tr><tr><td><code>echo</code></td><td>outputs the values of expressions</td></tr><tr><td><code>exit</code></td><td>exits the current shell; can specify a status code</td></tr><tr><td><code>help</code></td><td>outputs help information</td></tr><tr><td><code>history</code></td><td>outputs command history (last 100 commands)</td></tr><tr><td><code>kill</code></td><td>kills a process</td></tr><tr><td><code>ls</code></td><td>lists the contents of the current directory or specified path</td></tr><tr><td><code>mkdir</code></td><td>makes (creates) a directory</td></tr><tr><td><code>mv</code></td><td>moves a file or directory</td></tr><tr><td><code>open</code></td><td>opens a file</td></tr><tr><td><code>ps</code></td><td>outputs process information</td></tr><tr><td><code>pwd</code></td><td>outputs the present (current) working directory</td></tr><tr><td><code>rm</code></td><td>removes (deletes) a file or directory</td></tr><tr><td><code>source</code></td><td>executes a script file in the current context</td></tr><tr><td><code>which</code></td><td>outputs the path of an executable OR<br>information about aliases and custom commands</td></tr></tbody></table><p>The change to a subdirectory named &quot;sub&quot;, enter <code>cd sub</code> or just <code>sub</code>.</p><p>The <code>cp</code>, <code>mv</code>, and <code>rm</code> commands do not currently support the <code>-i</code> flag to prompt for confirmation. However, aliases for these can be defined to use the corresponding commands from the parent shell. For example, <code>alias rm = ^rm -i</code>.</p><p>Commands such as <code>ls</code>, <code>ps</code>, and <code>sys</code> output data as a table. When a cell displays <code>[table n rows]</code>, that indicates that it contains a nested table. Use the <code>get</code> filter to display them (see examples below).</p><p>SQL-like filters such as <code>where</code>, <code>sort-by</code>, and <code>reverse</code> can be used to modify the output.</p><p>Let's walk through some examples.</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># List all the package.json files in and below the current directory</span><br><span class="token comment"># using a glob pattern.</span><br><span class="token function">ls</span> **/package.json<br><br><span class="token comment"># List Rust files in and below the current directory</span><br><span class="token comment"># using a glob pattern.</span><br><span class="token function">ls</span> **/*.rs<br><br><span class="token comment"># List files in a tree layout.</span><br><span class="token function">ls</span> <span class="token operator">|</span> tree<br><br><span class="token comment"># List files in the current directory with a size of 2kb or more,</span><br><span class="token comment"># sorted on size from largest to smallest.</span><br><span class="token function">ls</span> <span class="token operator">|</span> where <span class="token builtin class-name">type</span> <span class="token operator">==</span> File <span class="token operator">&amp;&amp;</span> size <span class="token operator">></span><span class="token operator">=</span> 2kb <span class="token operator">|</span> sort-by size <span class="token operator">|</span> reverse<br><span class="token function">ls</span> <span class="token operator">|</span> where <span class="token builtin class-name">type</span> <span class="token operator">==</span> File <span class="token operator">&amp;&amp;</span> size <span class="token operator">></span><span class="token operator">=</span> 2kb <span class="token operator">|</span> sort-by -r size <span class="token comment"># same</span><br><br><span class="token comment"># List directories in the current directory,</span><br><span class="token comment"># sorted on size from largest to smallest,</span><br><span class="token comment"># excluding the type column since all will be "Dir".</span><br><span class="token function">ls</span> <span class="token operator">|</span> where <span class="token builtin class-name">type</span> <span class="token operator">==</span> Dir <span class="token operator">|</span> sort-by -r size <span class="token operator">|</span> reject <span class="token builtin class-name">type</span><br><br><span class="token comment"># Output processes using more than 5% of a CPU</span><br><span class="token comment"># sorted on CPU usage in reverse order.</span><br><span class="token function">ps</span> <span class="token operator">|</span> where cpu <span class="token operator">></span> <span class="token number">5</span> <span class="token operator">|</span> sort-by -r cpu<br><br><span class="token comment"># Output information about the current machine</span><br><span class="token comment"># including OS version, host name, and uptime.</span><br>sys <span class="token operator">|</span> get <span class="token function">host</span><br><br><span class="token comment"># Output the temperature of the CPUs, GPU, and battery (tested on macOS).</span><br>sys <span class="token operator">|</span> get temp<br><br><span class="token comment"># Output the parts of the current date and time in a table.</span><br><span class="token function">date</span> now <span class="token operator">|</span> <span class="token function">date</span> to-table</code></pre><p>To convert a table to a specific text format, use the <code>to</code> command. Supported formats include csv (comma-separated), html, json, md (Markdown), toml, tsv (tab-separated), url (url-encoded text), xml, and yaml. For example, to generate JSON from the <code>ls</code> command output, enter <code>ls | to json</code>.</p><p>The <code>save</code> command writes the string output of a command to a file. This is alternative to the <code>&gt;</code> redirect operator used in the Bash shell. The <code>to</code> command can be used to convert non-string data to a string.</p><p>For example:</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># Create an HTML file describing the directories</span><br><span class="token comment"># in the current directory that are larger than 1 KB.</span><br><span class="token function">ls</span> <span class="token operator">|</span> where <span class="token builtin class-name">type</span> <span class="token operator">==</span> Dir <span class="token operator">&amp;&amp;</span> size <span class="token operator">></span> <span class="token number">1024</span> <span class="token operator">|</span> sort-by -r size <span class="token operator">|</span> to html <span class="token operator">|</span><br>  save big-dirs.html<br><br><span class="token comment"># The text format defaults to CSV if the file extension is .csv.</span><br><span class="token comment"># It does not do this for any other file extensions.</span><br><span class="token function">ls</span> <span class="token operator">|</span> where <span class="token builtin class-name">type</span> <span class="token operator">==</span> Dir <span class="token operator">&amp;&amp;</span> size <span class="token operator">></span> <span class="token number">1024</span> <span class="token operator">|</span> sort-by -r size <span class="token operator">|</span> save big-dirs.csv</code></pre><h2 id="aliases">Aliases</h2><p>To create an alias for a command, enter <code>alias {name} = {command}</code>. For example, <code>alias cls = clear</code>.</p><p>The command can be a built-in command or a custom command, and literal arguments can be specified. When aliases are used, additional arguments can be specified. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token function">df</span> <span class="token operator">=</span> <span class="token function">date</span> <span class="token function">format</span><br><span class="token function">date</span> now <span class="token operator">|</span> <span class="token function">df</span> <span class="token string">"%B %-d, %Y"</span> <span class="token comment"># April 3, 2021</span></code></pre><p>To make aliases available in each new Nushell session, add them to the <code>startup</code> list in the config file as shown in the &quot;Configuration&quot; section.</p><p>Aliases cannot use pipelines. Custom commands must be used instead. For example, the following does not work:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token function">top</span> <span class="token operator">=</span> <span class="token function">ps</span> <span class="token operator">|</span> sort-by -r cpu <span class="token operator">|</span> first <span class="token number">10</span></code></pre><p>But defining it as as custom command as follows does work:</p><pre class="language-bash"><code class="language-bash">def <span class="token function">top</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">ps</span> <span class="token operator">|</span> sort-by cpu -r <span class="token operator">|</span> first <span class="token number">10</span> <span class="token punctuation">}</span></code></pre><h2 id="custom-commands">Custom Commands</h2><p>To define a custom command, enter <code>def {name} [params] { commands }</code>. Names can be in kebab-case, including hyphens for readability. They can end with <code>?</code> to indicate that they return a Boolean value. Square brackets are used to surround the parameters because they are treated as a list and that syntax is used for lists. If no parameters are required, <code>[]</code> must still be included.</p><p>The result of a custom command is the result of the last command pipeline or a string formed by the accumulation of everything it echoes.</p><p>The following custom command has no parameters and outputs a table showing the processes that have CPU usage of 5% or more sorted from highest to lowest.</p><pre class="language-bash"><code class="language-bash">def <span class="token function">top</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">ps</span> <span class="token operator">|</span> where cpu <span class="token operator">></span><span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">|</span> sort-by -r cpu <span class="token punctuation">}</span></code></pre><p>To run this, enter <code>top</code>.</p><p>Here is a version that has a CPU percentage parameter. Parameter values are accessed by adding <code>$</code> before their names.</p><pre class="language-bash"><code class="language-bash">def topn <span class="token punctuation">[</span>pct<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">ps</span> <span class="token operator">|</span> where cpu <span class="token operator">></span><span class="token operator">=</span> <span class="token variable">$pct</span> <span class="token operator">|</span> sort-by -r cpu <span class="token punctuation">}</span></code></pre><p>To run this enter <code>top</code> followed by a number. For example, <code>top 5</code>.</p><p>To make custom commands available in each new Nushell session, add them to the <code>startup</code> list in the config file as shown in the &quot;Configuration&quot; section.</p><p>The type of each parameter can optionally be specified after a colon to provide better documentation and better error messages when used incorrectly. See the list of &quot;real types&quot; described in the &quot;Data Types&quot; section. For example:</p><pre class="language-bash"><code class="language-bash">def <span class="token function">sum</span> <span class="token punctuation">[</span>n1: number, n2: number<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token operator">=</span> <span class="token variable">$n1</span> + <span class="token variable">$n2</span> <span class="token punctuation">}</span><br><br>def topn <span class="token punctuation">[</span>pct: number<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">ps</span> <span class="token operator">|</span> where cpu <span class="token operator">></span><span class="token operator">=</span> <span class="token variable">$pct</span> <span class="token operator">|</span> sort-by -r cpu <span class="token punctuation">}</span></code></pre><p>When invoking a command, multiple arguments are separated by spaces. For example, entering <code>sum 1 2</code> which outputs <code>3</code>.</p><p>Here are examples of custom commands whose result is defined by what they echo rather than the result of a command pipeline.</p><pre class="language-bash"><code class="language-bash">def evaluate <span class="token punctuation">[</span>n: int<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>build-string <span class="token string">"The number "</span> $n <span class="token string">" is "</span><span class="token variable">)</span></span><br>  <span class="token keyword">if</span> <span class="token variable">$n</span> <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> big <span class="token punctuation">}</span> <span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> small <span class="token punctuation">}</span><br>  <span class="token builtin class-name">echo</span> <span class="token string">"."</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>char newline<span class="token variable">)</span></span><br><span class="token punctuation">}</span><br><br><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>evaluate <span class="token number">1</span><span class="token variable">)</span></span> <span class="token comment"># The number 1 is small.</span><br><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>evaluate <span class="token number">9</span><span class="token variable">)</span></span> <span class="token comment"># The number 9 is big.</span><br><br>def evaluate2 <span class="token punctuation">[</span>n: int<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">let</span> word <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token keyword">if</span> $n <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> big <span class="token punctuation">}</span> <span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> small <span class="token punctuation">}</span><span class="token variable">)</span></span><br>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>build-string <span class="token string">"The number "</span> $n <span class="token string">" is "</span> $word <span class="token string">"."</span> <span class="token punctuation">$(</span>char newline<span class="token punctuation">)</span><span class="token variable">)</span></span><br><span class="token punctuation">}</span><br><br><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>evaluate2 <span class="token number">1</span><span class="token variable">)</span></span> <span class="token comment"># The number 1 is small.</span><br><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>evaluate2 <span class="token number">9</span><span class="token variable">)</span></span> <span class="token comment"># The number 9 is big.</span></code></pre><p>Input from other commands can be piped into a custom command and accessed with the <code>$it</code> special variable. Output from custom commands can be piped into other commands.</p><p>The parameters in the examples above are positional. Named parameters (a.k.a. flags) can also be specified by adding <code>--</code> before their names. These are long-form names. To also specify short-form names, follow the long name with <code>(-short-name)</code>. Like positional parameters, types can be specified for flags. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># Prints a value followed by a newline.</span><br>def logv <span class="token punctuation">[</span>value: any<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>build-string $value <span class="token punctuation">$(</span>char newline<span class="token punctuation">)</span><span class="token variable">)</span></span><br>  <span class="token comment"># Another way to write the line above is:</span><br>  <span class="token comment"># echo [`{{$value}}` $(char newline)] | str collect</span><br><span class="token punctuation">}</span><br><br><span class="token comment"># Prints "name = value" followed by a newline.</span><br>def lognv <span class="token punctuation">[</span>name: string, value: any<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  logv <span class="token variable"><span class="token variable">$(</span>build-string $name <span class="token string">" = "</span> $value<span class="token variable">)</span></span><br><span class="token punctuation">}</span><br><br>def logv-color <span class="token punctuation">[</span><br>  text: string,<br>  --color <span class="token punctuation">(</span>-c<span class="token punctuation">)</span>: string <span class="token comment"># a flag</span><br><span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token comment">#if $(echo $color | empty?) { # same as next line</span><br>  <span class="token keyword">if</span> <span class="token variable"><span class="token variable">$(</span><span class="token operator">=</span> $color <span class="token operator">|</span> empty?<span class="token variable">)</span></span> <span class="token punctuation">{</span><br>    logv <span class="token variable">$text</span><br>  <span class="token punctuation">}</span> <span class="token punctuation">{</span><br>    logv <span class="token variable"><span class="token variable">$(</span>build-string <span class="token punctuation">$(</span>ansi $color<span class="token punctuation">)</span> $text <span class="token punctuation">$(</span>ansi reset<span class="token punctuation">)</span><span class="token variable">)</span></span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br>logv-color <span class="token string">"Giraffes are cool!"</span> -c <span class="token string">"yellow"</span></code></pre><p>Custom commands can take arguments with a type of <code>block</code>. The <code>do</code> command can be used to execute the block. For example, this can be used to implement a <code>map</code> command which takes a list and a block.</p><pre class="language-bash"><code class="language-bash">def map <span class="token punctuation">[</span>values: any, code: block<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable">$values</span> <span class="token operator">|</span> each <span class="token variable">$code</span><br><span class="token punctuation">}</span><br><br><span class="token builtin class-name">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span>Mark Tami Amanda Jeremy<span class="token punctuation">]</span><br><br>map <span class="token variable">$names</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>build-string <span class="token string">"Hello, "</span> $it <span class="token punctuation">$(</span>char newline<span class="token punctuation">)</span><span class="token variable">)</span></span><br><span class="token punctuation">}</span> <span class="token operator">|</span> str collect<br><br><span class="token comment"># Same result using built-in "each" command instead of custom "map" command.</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$names</span> <span class="token operator">|</span> each <span class="token punctuation">{</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>build-string <span class="token string">"Hello, "</span> $it <span class="token punctuation">(</span><span class="token punctuation">$(</span>char newline<span class="token punctuation">)</span><span class="token variable">)</span></span><br><span class="token punctuation">}</span> <span class="token operator">|</span> str collect</code></pre><p>Custom commands can take a variable number of arguments using the parameter syntax <code>...rest</code>. The parameter name must be &quot;rest&quot; and it must be the last parameter. Its value is a list. For example:</p><pre class="language-bash"><code class="language-bash">def labelled-sum <span class="token punctuation">[</span>label: string, <span class="token punctuation">..</span>.rest: int<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>build-string $label <span class="token string">" = "</span> <span class="token punctuation">$(</span>echo $rest <span class="token operator">|</span> math <span class="token function">sum</span><span class="token punctuation">)</span> <span class="token punctuation">$(</span>char newline<span class="token punctuation">)</span><span class="token variable">)</span></span><br><span class="token punctuation">}</span><br><br>labelled-sum <span class="token string">"sum of scores"</span> <span class="token number">3</span> <span class="token number">7</span> <span class="token number">19</span> <span class="token comment"># sum of scores = 29</span></code></pre><p>Help for custom commands is obtained in the same way it is for built-in commands, using <code>help {command-name}</code> or <code>{command-name} -h</code>.</p><p>To add documentation to custom commands, add a comment before the definition and after each parameter. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># Computes the sum of two numbers.</span><br>def <span class="token function">sum</span> <span class="token punctuation">[</span><br>  n1: number, <span class="token comment"># first number</span><br>  n2: number <span class="token comment"># second number</span><br><span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token operator">=</span> <span class="token variable">$n1</span> + <span class="token variable">$n2</span><br><span class="token punctuation">}</span></code></pre><p>Defining a custom subcommand is similar to defining a custom command, but the name is specified as the parent command name and the subcommand name separated by a space and inside quotes. In the following custom commands, the parent command <code>rmv</code> is my initials:</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># Parent command.</span><br>def rmv <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><br><span class="token comment"># Increments a number by 1.</span><br>def <span class="token string">"rmv increment"</span> <span class="token punctuation">[</span>n: number<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token operator">=</span> <span class="token variable">$n</span> + <span class="token number">1</span> <span class="token punctuation">}</span><br><br><span class="token comment"># Doubles a number.</span><br>def <span class="token string">"rmv double"</span> <span class="token punctuation">[</span>n: number<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token operator">=</span> <span class="token variable">$n</span> * <span class="token number">2</span> <span class="token punctuation">}</span><br><br><span class="token builtin class-name">let</span> score <span class="token operator">=</span> <span class="token number">3</span><br><span class="token comment"># The "lognv" command is defined above.</span><br>lognv <span class="token string">'score'</span> <span class="token variable"><span class="token variable">$(</span>rmv double <span class="token punctuation">$(</span>rmv increment $score<span class="token punctuation">)</span><span class="token variable">)</span></span> <span class="token comment"># 8</span></code></pre><h2 id="variables">Variables</h2><p>Variables in Nushell are distinct from environment variables. They are immutable, so they must be set when they are declared. However, they can be shadowed to have different values in different scopes.</p><p>To set a variable, enter <code>let name = value</code>. The scope of a variable is the context or block in which it is defined.</p><p>To set a variable to the result of a command pipeline, which can be comprised of one or more commands, enter <code>let name = $(pipeline)</code>.</p><p>To use a variable in an expression, precede its name with <code>$</code>. For example, <code>$total</code>.</p><p>The <code>build-str</code> command concatenates the values of multiple expressions into a single string. For example, the following sets a variable to the result of concatenating two variable values as strings:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> v3 <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>build-str $v1 $v2<span class="token variable">)</span></span></code></pre><h2 id="environment-variables">Environment Variables</h2><p>Environment variables are distinct from regular variables. Unlike regular variables, environment variables can be accessed by executables that are run from Nushell.</p><p>To set the value of an environment variable only in the current scope, not permanently, enter <code>let-env NAME = value</code>. This adds <code>NAME</code> to <code>$nu.env</code> which holds a map of environment variables.</p><p>To set the value of an environment variable so it is available in subsequent Nushell sessions, add it to the <code>env</code> section of the Nushell configuration file as shown in the &quot;Configuration&quot; section.</p><p>To get the value of an environment variable, use <code>$nu.env.NAME</code>. To print the value, enter <code>echo $nu.env.NAME</code> or <code>config | get env.{name}</code>.</p><p>To see a nicely formatted list of environment variables, enter <code>echo $nu.env | pivot</code> or <code>config | get env | pivot</code>.</p><h2 id="open-command">open Command</h2><p>The <code>open</code> command renders certain file types as tables. These file types include csv, ini, json, toml, xml, and yaml.</p><p>Consider the file <code>scores.csv</code> containing the follow:</p><pre class="language-text"><code class="language-text">Name,Score<br>Mark,19<br>Tami,21<br>Amanda,17<br>Jeremy,15</code></pre><p>The command <code>open scores.csv</code> renders this as follows:</p><pre class="language-text"><code class="language-text">╭───┬────────┬───────╮<br>│ # │ Name   │ Score │<br>├───┼────────┼───────┤<br>│ 0 │ Mark   │    19 │<br>│ 1 │ Tami   │    21 │<br>│ 2 │ Amanda │    17 │<br>│ 3 │ Jeremy │    15 │<br>╰───┴────────┴───────╯</code></pre><p>When run on a JSON file, the <code>open</code> command produces a table from which specific data can be extracted. For example, the following outputs a table of scripts in a <code>package.json</code> file.</p><pre class="language-bash"><code class="language-bash"><span class="token function">open</span> package.json <span class="token operator">|</span> get scripts <span class="token operator">|</span> pivot</code></pre><p>The output will be similar to the following:</p><pre class="language-text"><code class="language-text">╭───┬─────────┬────────────────────────────────╮<br>│ # │ Column0 │ Column1                        │<br>├───┼─────────┼────────────────────────────────┤<br>│ 0 │ dev     │ svelte-kit dev                 │<br>│ 1 │ build   │ svelte-kit build               │<br>│ 2 │ start   │ svelte-kit start               │<br>│ 3 │ lint    │ prettier --check . && eslint . │<br>│ 4 │ format  │ prettier --write .             │<br>│ 5 │ open    │ svelte-kit dev --open          │<br>╰───┴─────────┴────────────────────────────────╯</code></pre><p>There is no way to output a table without the heading row. The &quot;#&quot; column can be suppressed from all table output by setting the <code>disable_table_indexes</code> configuration option to <code>true</code>, but there is no way to do this for the output of a specific command.</p><p>To see the commands in the Nushell configuration file <code>startup</code> section, enter <code>open $(config path) | get startup</code>.</p><p>The <code>lines</code> and <code>split</code> commands can be used to render delimited data as a table. For example, consider the following file content:</p><pre class="language-text"><code class="language-text">Go|2012|Rob Pike<br>Java|1995|James Gosling<br>JavaScript|1995|Brendan Eich<br>Python|1991|Guido van Rossum<br>Ruby|1995|Yukihiro Matsumoto<br>Rust|2010|Graydon Hoare<br>TypeScript|2012|Anders Hejlsberg</code></pre><p>The following command renders a table where each row describes a programming language, the columns have proper names, and the rows are sorted on ascending year of creation:</p><pre class="language-bash"><code class="language-bash"><span class="token function">open</span> languages.txt <span class="token operator">|</span> lines <span class="token operator">|</span> <span class="token function">split</span> <span class="token function">column</span> <span class="token string">'|'</span> Language Year Creator <span class="token operator">|</span><br>  sort-by Year</code></pre><p>The <code>lines</code> command converts input text into a list of separate lines from the text. The command above produces the following output.</p><pre class="language-text"><code class="language-text">╭───┬────────────┬──────┬────────────────────╮<br>│ # │ Language   │ Year │ Creator            │<br>├───┼────────────┼──────┼────────────────────┤<br>│ 0 │ Python     │ 1991 │ Guido van Rossum   │<br>│ 1 │ Java       │ 1995 │ James Gosling      │<br>│ 2 │ JavaScript │ 1995 │ Brendan Eich       │<br>│ 3 │ Ruby       │ 1995 │ Yukihiro Matsumoto │<br>│ 4 │ Rust       │ 2010 │ Graydon Hoare      │<br>│ 5 │ Go         │ 2012 │ Rob Pike           │<br>│ 6 │ TypeScript │ 2012 │ Anders Hejlsberg   │<br>╰───┴────────────┴──────┴────────────────────╯</code></pre><p>The <code>open</code> command treats other types of files as a list of lines and produces a table where the first column contains line numbers. For known programming language file extensions, the <code>open</code> command uses the <code>bat</code> crate which provides syntax highlighting. Compare this to using the <code>cat</code> command where this does not happen.</p><p>If the file extension on a file does not match its content type, use the <code>from</code> command to specify the actual content type. For example, <code>open really-json.txt | from json</code>.</p><p>To prevent the <code>open</code> command from processing a file, add the <code>--raw</code> flag. For example, <code>open scores.csv --raw</code> outputs the following:</p><pre class="language-text"><code class="language-text">───────┬────────────<br>       │ scores.csv<br>───────┼────────────<br>   1   │ Name,Score<br>   2   │ Mark,19<br>   3   │ Tami,21<br>   4   │ Amanda,17<br>   5   │ Jeremy,15<br>───────┴───────────</code></pre><p>To process data from a URL instead of a local file, use the <code>fetch</code> command. For example, the <a href="https://jsonplaceholder.typicode.com?v=1.0.12" rel="noopener" target="_blank">{JSON} Placeholder</a> site provides free data for testing and prototyping. Todo data from this site can be rendered as a table with the following commands:</p><pre class="language-bash"><code class="language-bash">fetch https://jsonplaceholder.typicode.com/todos <span class="token operator">|</span> first <span class="token number">10</span><br><br>fetch https://jsonplaceholder.typicode.com/todos <span class="token operator">|</span><br>  where userId <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> completed <span class="token operator">==</span> <span class="token variable">$true</span> <span class="token operator">|</span> sort-by title</code></pre><h2 id="table-commands">Table Commands</h2><p>TODO: Continue reviewing from the <code>lines</code> command.</p><p>Many Nushell commands operate on tables.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>append</code></td><td>creates a new table by appending a single row to an existing table</td></tr><tr><td><code>autoview</code></td><td>renders data as a table or list</td></tr><tr><td><code>compact</code></td><td>removes empty rows</td></tr><tr><td><code>drop n</code></td><td>removes the last <code>n</code> rows (<code>n</code> defaults to 1)</td></tr><tr><td><code>drop column n</code></td><td>removes the last <code>n</code> columns (<code>n</code> defaults to 1)</td></tr><tr><td><code>each</code></td><td>runs a block of code on each row</td></tr><tr><td><code>every n</code></td><td>shows (default) or skips (with <code>-s</code> option) every <code>n</code>th row</td></tr><tr><td><code>first n</code></td><td>shows only the first <code>n</code> rows (<code>n</code> defaults to 1); alternative to <code>keep</code></td></tr><tr><td><code>flatten</code></td><td>flattens a table or list, turning nested values into top-level values</td></tr><tr><td><code>format</code></td><td>formats specified columns into a single string using a pattern</td></tr><tr><td><code>from {format}</code></td><td>parses a given file format into a table</td></tr><tr><td><code>get {column-name}</code></td><td>gets the content of a given column</td></tr><tr><td><code>group-by</code></td><td>creates multiple tables from one based on some grouping</td></tr><tr><td><code>headers</code></td><td>creates a table from an existing one where the first row replaces the current column headers</td></tr><tr><td><code>histogram</code></td><td>creates a table with &quot;value&quot;, &quot;count&quot;, &quot;percentage&quot;, and &quot;frequency&quot;<br>columns based on a given column in an input table</td></tr><tr><td><code>insert</code></td><td>inserts a column</td></tr><tr><td><code>keep n</code></td><td>keeps the first <code>n</code> rows (<code>n</code> defaults to 1); alternative to <code>first</code></td></tr><tr><td><code>keep until {condition}</code></td><td>keeps rows until the condition is met</td></tr><tr><td><code>keep while {condition}</code></td><td>keeps rows while the condition is met</td></tr><tr><td><code>last n</code></td><td>shows only the last <code>n</code> rows (<code>n</code> defaults to 1)</td></tr><tr><td><code>length</code></td><td>counts rows or list items</td></tr><tr><td><code>lines</code></td><td>splits a string of lines into rows</td></tr><tr><td><code>match</code></td><td>filters rows by matching the values in given column against a regular expression</td></tr><tr><td><code>merge</code></td><td>merges tables by adding columns</td></tr><tr><td><code>move</code></td><td>moves columns to another position</td></tr><tr><td><code>nth</code></td><td>keep or skip specified rows</td></tr><tr><td><code>parse</code></td><td>parses columns from a string using a pattern</td></tr><tr><td><code>pivot</code></td><td>swaps the rows and columns</td></tr><tr><td><code>prepend</code></td><td>prepends a row</td></tr><tr><td><code>range</code></td><td>gets a subset of rows</td></tr><tr><td><code>reduce</code></td><td>computes a single value from a list table</td></tr><tr><td><code>reject</code></td><td>removes columns by name</td></tr><tr><td><code>rename</code></td><td>renames columns</td></tr><tr><td><code>reverse</code></td><td>reverses the order of the rows</td></tr><tr><td><code>roll n</code></td><td>rolls the bottom <code>n</code> rows to the top (<code>n</code> defaults to 1)</td></tr><tr><td><code>rotate</code></td><td>rotates the table 90 degrees clockwise; can apply multiple times</td></tr><tr><td><code>rotate counter-clockwise</code></td><td>rotates the table 90 degrees counter-clockwise</td></tr><tr><td><code>select {column-names}</code></td><td>specifies columns to be retained by name and their order</td></tr><tr><td><code>shuffle</code></td><td>shuffles the rows randomly</td></tr><tr><td><code>skip n</code></td><td>skips the first <code>n</code> rows (<code>n</code> defaults to 1)</td></tr><tr><td><code>skip until {condition}</code></td><td>skips rows until the condition is met</td></tr><tr><td><code>skip while {condition}</code></td><td>skips rows while the condition is met</td></tr><tr><td><code>sort-by</code></td><td>sorts rows on given columns</td></tr><tr><td><code>split row</code></td><td>converts a string into a list of strings</td></tr><tr><td><code>split column</code></td><td>converts a list of strings into a table with generic &quot;Column{n}&quot; headers</td></tr><tr><td><code>split-by</code></td><td>creates a new table from one with nested tables where column headings are values of a given nested table heading</td></tr><tr><td><code>table</code></td><td>views pipeline output as a table</td></tr><tr><td><code>to {format}</code></td><td>converts a table to a given format such as json</td></tr><tr><td><code>uniq</code></td><td>gets unique rows</td></tr><tr><td><code>update</code></td><td>updates data in a given column</td></tr><tr><td><code>where</code></td><td>specifies a condition rows must meet to render</td></tr><tr><td><code>wrap</code></td><td>creates a table column from its data and a name</td></tr></tbody></table><p>The <code>sort-by</code> command accepts the <code>--insensitive</code> flag to make the sort case-insensitive and the <code>--reverse</code> flag to reverse the sort order.</p><p>Let's look at some examples using the <code>ls</code> command. This produces a table with the columns &quot;name&quot;, &quot;type&quot;, &quot;size&quot;, and &quot;modified&quot;. Here is a command that lists the files with a <code>.ts</code> file extension, only includes the &quot;name&quot; and &quot;size&quot; columns, sorts the files from largest to smallest, and only outputs the three largest files:</p><pre class="language-bash"><code class="language-bash"><span class="token function">ls</span> *.ts <span class="token operator">|</span> <span class="token keyword">select</span> name size <span class="token operator">|</span> sort-by -r size <span class="token operator">|</span> first <span class="token number">3</span></code></pre><p>This produces output similar to the following:</p><pre class="language-text"><code class="language-text">───┬────────────────────────┬──────────<br> # │          name          │   size<br>───┼────────────────────────┼──────────<br> 0 │ lib.deno.unstable.d.ts │ 194.4 KB<br> 1 │ lib.deno.d.ts          │ 145.8 KB<br> 2 │ my_server.ts           │   2.7 KB<br>───┴────────────────────────┴──────────</code></pre><p>The row indexes in the first column can be used to retrieve only a specific row using the <code>nth</code> command. For example, we can add <code>| nth 1</code> to the end of the command to only output the row for the file <code>lib.deno.d.ts</code>.</p><p>The <code>get</code> command can be used to output only the values in a single column. It returns a list rather than a table. For example, the following outputs the names of the three largest TypeScript files:</p><pre class="language-bash"><code class="language-bash"><span class="token function">ls</span> *.ts <span class="token operator">|</span> sort-by size <span class="token operator">|</span> reverse <span class="token operator">|</span> first <span class="token number">3</span> <span class="token operator">|</span> get name</code></pre><p>The <code>get</code> command is especially useful when the type of a field is &quot;table&quot;. The key can be arbitrarily deep with sub-keys separated by periods. For example, <code>sys | get host.sessions | where name == 'root' | get groups</code>.</p><p>The following example demonstrates getting all the headings from a table.</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$myTable</span> <span class="token operator">|</span> get</code></pre><p>Table columns can be accessed by their header name using the <code>get</code> and <code>select</code> commands, but there is no command to get a table column by its index. However, this can be done with the following pipeline:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$myTable</span> <span class="token operator">|</span> <span class="token keyword">select</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $myTable <span class="token operator">|</span> get <span class="token operator">|</span> nth $columnIndex<span class="token variable">)</span></span></code></pre><p>A new table can be created by appending a new row. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> primaryColors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>name red green blue<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span><br>  red <span class="token number">255</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  green <span class="token number">0</span> <span class="token number">255</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  blue <span class="token number">0</span> <span class="token number">0</span> <span class="token number">255</span><span class="token punctuation">]</span><br><span class="token punctuation">]</span><br><span class="token builtin class-name">let</span> purple <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>name red green blue<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>purple <span class="token number">255</span> <span class="token number">0</span> <span class="token number">255</span><span class="token punctuation">]</span><span class="token punctuation">]</span><br><span class="token builtin class-name">let</span> colors <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $primaryColors <span class="token operator">|</span> append $purple<span class="token variable">)</span></span><br><span class="token builtin class-name">echo</span> <span class="token variable">$colors</span></code></pre><p>This produces the following output:</p><pre class="language-text"><code class="language-text">╭───┬────────┬─────┬───────┬──────╮<br>│ # │ name   │ red │ green │ blue │<br>├───┼────────┼─────┼───────┼──────┤<br>│ 0 │ red    │ 255 │     0 │    0 │<br>│ 1 │ green  │   0 │   255 │    0 │<br>│ 2 │ blue   │   0 │     0 │  255 │<br>│ 3 │ purple │ 255 │     0 │  255 │<br>╰───┴────────┴─────┴───────┴──────╯</code></pre><p>The table in the previous example can be created from a string using the <code>split</code> and <code>headers</code> commands.</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> data <span class="token operator">=</span><br>  <span class="token string">"name red green blue|red 255 0 0|green 0 255 0|blue 0 0 255|purple 255 0 255"</span><br><span class="token builtin class-name">let</span> colors <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $data <span class="token operator">|</span> <span class="token function">split</span> row <span class="token string">"|"</span> <span class="token operator">|</span> <span class="token function">split</span> <span class="token function">column</span> <span class="token string">" "</span> <span class="token operator">|</span> headers<span class="token variable">)</span></span><br><span class="token builtin class-name">echo</span> <span class="token variable">$colors</span></code></pre><p>The <code>split-by</code> command doesn't seem very useful. TODO: See <code>split-by-demo.nu</code>.</p><p>The <code>flatten</code> can create a new table from an existing table, replacing columns that whose values are nested tables with the columns in those tables. For example, the <code>sys</code> command creates a table with the columns &quot;host&quot;, &quot;cpu&quot;, &quot;disks&quot;, &quot;mem&quot; (for memory), &quot;temp&quot; (for temperature), and &quot;net&quot; (for network activity). Piping this output to the <code>flatten</code> command replaces the &quot;host&quot; and &quot;mem&quot; columns with the columns in their nested tables.</p><p>The <code>format</code> command formats specified columns into a single string using a pattern. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">format</span> <span class="token string">'{name} is a {size} {type} and was modified {modified}.'</span> <span class="token operator">|</span><br>  str downcase<br><span class="token comment"># downcase is used to change the type to lowercase.</span></code></pre><p>This outputs lines like the following:</p><pre class="language-text"><code class="language-text">histogram.nu is a 233 b file and was modified 1 week ago.</code></pre><p>The <code>from</code> command parses a given file format into a table. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> data <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">open</span> --raw scores.csv<span class="token variable">)</span></span><br><span class="token builtin class-name">let</span> table <span class="token operator">=</span> <span class="token builtin class-name">echo</span> <span class="token variable">$data</span> <span class="token operator">|</span> from csv</code></pre><p>This can be done in a single line with <code>let table = $(open scores.csv)</code>.</p><p>The <code>match</code> command filters rows by matching the values in given column against a regular expression. For example, <code>ls | where type == File | match name &quot;^c.*\.nu$&quot;</code> lists files in the current directory whose name begin with &quot;c&quot; and have a file extension of &quot;.nu&quot;.</p><p>TODO: How could you iterate over the rows of a table TODO: and add each one to another table? Use reduce and append? TODO: See <code>append-demo.nu</code>.</p><p>The rows of a table can be segregated into multiple tables using the <code>group-by</code> command. For example, the output of <code>ls</code> can be split into two tables where one contains rows with a type of &quot;File&quot; and the other contains rows with a type of &quot;Dir&quot;. The following command produces a table with the columns &quot;File&quot; and &quot;Dir&quot; that contains a single row whose cells are themselves tables.</p><pre class="language-bash"><code class="language-bash"><span class="token function">ls</span> <span class="token operator">|</span> group-by <span class="token builtin class-name">type</span></code></pre><p>The following code outputs the nested tables:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> temp <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> <span class="token operator">|</span> group-by <span class="token builtin class-name">type</span><span class="token variable">)</span></span><br><span class="token builtin class-name">echo</span> <span class="token variable">$temp</span> <span class="token operator">|</span> get File<br><span class="token builtin class-name">echo</span> <span class="token variable">$temp</span> <span class="token operator">|</span> get Dir</code></pre><p>The <code>group-by</code> command can be passed a block that computes the value used to group the rows. The following example groups files based on their file extension:</p><pre class="language-bash"><code class="language-bash"><span class="token function">ls</span> <span class="token operator">|</span> group-by <span class="token punctuation">{</span> get name <span class="token operator">|</span> path extension <span class="token punctuation">}</span></code></pre><p>To see the contents of one of the nested tables, pipe this to <code>get ext-name</code>.</p><p>Another way to see only the files whose name ends with certain characters is:</p><pre class="language-bash"><code class="language-bash"><span class="token function">ls</span> <span class="token operator">|</span> where <span class="token punctuation">{</span><span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $it.name <span class="token operator">|</span> str ends-with <span class="token string">".rs"</span><span class="token variable">)</span></span> <span class="token punctuation">}</span> <span class="token operator">|</span> get name</code></pre><p>Table columns can be moved after or before another column. For example, by default the <code>ls</code> command outputs a type with the columns &quot;name&quot;, &quot;type&quot;, &quot;size&quot;, and &quot;modified&quot;. The following command moves the &quot;type&quot; and &quot;size&quot; columns to be after the &quot;modified&quot; column. It also reorders the &quot;size&quot; and &quot;type&quot; columns to the specified order.</p><pre class="language-bash"><code class="language-bash"><span class="token function">ls</span> <span class="token operator">|</span> move size <span class="token builtin class-name">type</span> --after modified</code></pre><p>The columns of one table can be added to another to produce a new table using the <code>merge</code> command. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> t1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>name score<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>Mark <span class="token number">19</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>Tami <span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$t1</span><br><br><span class="token comment"># Add a single column.</span><br><span class="token builtin class-name">let</span> <span class="token function">column</span> <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token punctuation">[</span>yellow blue<span class="token punctuation">]</span> <span class="token operator">|</span> wrap color<span class="token variable">)</span></span><br><span class="token builtin class-name">echo</span> <span class="token variable">$t1</span> <span class="token operator">|</span> merge <span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> <span class="token variable">$column</span> <span class="token punctuation">}</span><br><br><span class="token comment"># Add all the columns from another table.</span><br><span class="token builtin class-name">let</span> t2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>color flavor<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>yellow vanilla<span class="token punctuation">]</span> <span class="token punctuation">[</span>blue chocolate<span class="token punctuation">]</span><span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$t1</span> <span class="token operator">|</span> merge <span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> <span class="token variable">$t2</span> <span class="token punctuation">}</span></code></pre><p>The output produced by this example is:</p><pre class="language-text"><code class="language-text">╭───┬──────┬───────╮<br>│ # │ name │ score │<br>├───┼──────┼───────┤<br>│ 0 │ Mark │    19 │<br>│ 1 │ Tami │    21 │<br>╰───┴──────┴───────╯<br><br>╭───┬──────┬───────┬────────╮<br>│ # │ name │ score │ color  │<br>├───┼──────┼───────┼────────┤<br>│ 0 │ Mark │    19 │ yellow │<br>│ 1 │ Tami │    21 │ blue   │<br>╰───┴──────┴───────┴────────╯<br><br>╭───┬──────┬───────┬────────┬───────────╮<br>│ # │ name │ score │ color  │ flavor    │<br>├───┼──────┼───────┼────────┼───────────┤<br>│ 0 │ Mark │    19 │ yellow │ vanilla   │<br>│ 1 │ Tami │    21 │ blue   │ chocolate │<br>╰───┴──────┴───────┴────────┴───────────╯</code></pre><p>The <code>histogram</code> command generates a histogram from the data in a given table row. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token comment"># The newlines need to be placed like this</span><br><span class="token comment"># due to a parser bug.</span><br><span class="token builtin class-name">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token punctuation">[</span>name color<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span><br>  Mark yellow<span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  Tami blue<span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  Amanda green<span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  Jeremy yellow<span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  Sally blue<span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  Sam yellow<span class="token punctuation">]</span><br><span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$data</span> <span class="token operator">|</span> get color <span class="token operator">|</span> histogram</code></pre><p>This produces the following table:</p><pre class="language-text"><code class="language-text">╭───┬────────┬───────┬────────────┬──────────────────────────────────────────────╮<br>│ # │ value  │ count │ percentage │ frequency                                    │<br>├───┼────────┼───────┼────────────┼──────────────────────────────────────────────┤<br>│ 0 │ blue   │     2 │ 66.67%     │ *****************************                │<br>│ 1 │ green  │     1 │ 33.33%     │ ***************                              │<br>│ 2 │ yellow │     3 │ 100.00%    │ ******************************************** │<br>╰───┴────────┴───────┴────────────┴──────────────────────────────────────────────╯</code></pre><p>The percentage values are double what they should be. See <a href="https://github.com/nushell/nushell/issues/3215?v=1.0.12" rel="noopener" target="_blank">issue 3215</a>.</p><h2 id="plugins">Plugins</h2><p>Nushell plugins add new commands. They can be installed using the Rust <code>cargo</code> utility. After installing, open a new shell to gain access to commands that they add.</p><h3 id="nu_plugin_start">nu_plugin_start</h3><p>This plugin adds the <code>start</code> command that opens a given file using its default application. To install this, enter <code>cargo install nu_plugin_start</code>. Then open a new shell and enter <code>start file-path</code>.</p><h3 id="nu_plugin_chart">nu_plugin_chart</h3><p>This plugin adds the <code>chart</code> command with the subcommands <code>bar</code> and <code>line</code>. To install this, enter <code>cargo install nu_plugin_chart</code>.</p><p>Here is an example of creating both kinds of charts.</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>name score<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span><br>  Mark <span class="token number">19</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  Tami <span class="token number">21</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  Amanda <span class="token number">17</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><br>  Jeremy <span class="token number">15</span><span class="token punctuation">]</span><br><span class="token punctuation">]</span><br><br><span class="token builtin class-name">echo</span> <span class="token variable">$data</span> <span class="token operator">|</span> chart bar <span class="token punctuation">[</span>name score<span class="token punctuation">]</span><br><span class="token builtin class-name">echo</span> <span class="token variable">$data</span> <span class="token operator">|</span> chart line <span class="token punctuation">[</span>name score<span class="token punctuation">]</span></code></pre><p>After each chart is rendered, press enter to go to the next chart or exit if the last chart has been rendered.</p><p>Unfortunately these plot the frequencies of the values and not values themselves. So the bar chart shows four bars at 100% because the values 19, 21, 17, and 15 each occur once. See <a href="https://github.com/nushell/nushell/issues/3096?v=1.0.12" rel="noopener" target="_blank">issue 3096</a>.</p><h2 id="default-shell">Default Shell</h2><p>To make Nushell your default shell in Linux or macOS, first add a line containing the file path to the <code>nu</code> executable in <code>/etc/shells</code>. For example, for me using macOS I entered <code>su vim /etc/shells</code> and added the line <code>/Users/mark/.cargo/bin/nu</code>. Then enter <code>chsh -s nu</code>. If using tmux, also change the value of <code>default-shell</code> in <code>~/.tmux.conf</code>.</p><h2 id="scripts">Scripts</h2><p>Nushell scripts are written in files with a <code>.nu</code> extension. To execute a script, enter <code>nu {name}.nu</code>. To &quot;source&quot; a script so its definitions become available in the current shell, enter <code>source {name}.nu</code>.</p><p>For examples of Nushell scripts, see <a href="https://github.com/nushell/nu_scripts/tree/main/nu_101?v=1.0.12" rel="noopener" target="_blank">Nu_101 Scripts</a>.</p><p>To add comments or &quot;comment-out&quot; a line of code, preceded the comment with a <code>#</code> character.</p><p>Commands commonly used in Nushell scripts include <code>def</code>, <code>if</code>, <code>each</code>, and <code>seq</code>.</p><p>The <code>def</code> command defines a custom command which can be used like a function in many programming languages.</p><p>Conditional processing is implemented with the <code>if</code> command. Its syntax is <code>if condition { then-block } { else-block }</code>. Note that the condition is not surrounded by parentheses and curly braces are required around the then and else blocks. There are no <code>then</code> or <code>else</code> keywords. Nested ifs must be placed inside a then or else block. An <code>if</code> command can be split over multiple lines. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">let</span> temperature <span class="token operator">=</span> <span class="token number">80</span><br><span class="token keyword">if</span> <span class="token variable">$temperature</span> <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">32</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">echo</span> cold<br><span class="token punctuation">}</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token variable">$temperature</span> <span class="token operator">></span><span class="token operator">=</span> <span class="token number">80</span> <span class="token punctuation">{</span><br>    <span class="token builtin class-name">echo</span> hot<br>  <span class="token punctuation">}</span> <span class="token punctuation">{</span><br>    <span class="token builtin class-name">echo</span> warm<br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>To iterate over a range of integers, use the <code>seq</code> command and pipe the result to the <code>each</code> command. The special variable <code>$it</code> holds each iteration value. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token operator">|</span> each <span class="token punctuation">{</span> build-string <span class="token variable">$it</span> <span class="token variable"><span class="token variable">$(</span>char newline<span class="token variable">)</span></span> <span class="token punctuation">}</span> <span class="token operator">|</span> str collect</code></pre><p>Let's break this down.</p><ul><li><p><code>seq 1 4</code> returns the list <code>[1 2 3 4]</code>.</p></li><li><p><code>each { build-string $it $(char newline) }</code> returns the list <code>[&quot;1\n&quot; &quot;2\n&quot; &quot;3\n&quot; &quot;4\n&quot;]</code></p></li><li><p><code>str collect</code> returns a string created by concatenating the list values.</p></li><li><p>The output is:</p><pre class="language-text"><code class="language-text">1<br>2<br>3<br>4</code></pre></li></ul><p>The <code>seq</code> command creates a list of strings, not integers. An alternative is to use the <code>echo</code> command with a range specified with <code>start..end</code> which creates a list of integers. The previous example can be written as follows:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">4</span> <span class="token operator">|</span> each <span class="token punctuation">{</span> build-string <span class="token variable">$it</span> <span class="token variable"><span class="token variable">$(</span>char newline<span class="token variable">)</span></span> <span class="token punctuation">}</span> <span class="token operator">|</span> str collect</code></pre><p>Iteration over the elements of a list is implemented with the <code>each</code> command. Its syntax is <code>echo some-list | each { block }</code>. The block can use the special variable <code>$it</code> to access the current element in the iteration. For example:</p><pre class="language-bash"><code class="language-bash">def log-value <span class="token punctuation">[</span>label, value<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span>build-string $label <span class="token string">" = "</span> $value <span class="token punctuation">$(</span>char newline<span class="token punctuation">)</span><span class="token variable">)</span></span><br><span class="token punctuation">}</span><br><br>def report <span class="token punctuation">[</span>list<span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token comment"># Without the --numbered flag, $it is set to each list value.</span><br>  <span class="token comment"># With it, $it is an object with the properties index and item.</span><br>  <span class="token builtin class-name">echo</span> <span class="token variable">$list</span> <span class="token operator">|</span> each --numbered <span class="token punctuation">{</span><br>    build-string <span class="token variable"><span class="token variable">$(</span><span class="token operator">=</span> $it.index + <span class="token number">1</span><span class="token variable">)</span></span> <span class="token string">") "</span> <span class="token variable">$it</span>.item <span class="token variable"><span class="token variable">$(</span>char newline<span class="token variable">)</span></span><br>  <span class="token punctuation">}</span> <span class="token operator">|</span> str collect <span class="token comment"># with this the result is a table instead of a string</span><br><span class="token punctuation">}</span><br><br><span class="token builtin class-name">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span>Mark Tami Amanda Jeremy<span class="token punctuation">]</span><br><br>log-value <span class="token string">"name at index 2"</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $names <span class="token operator">|</span> nth <span class="token number">2</span><span class="token variable">)</span></span> <span class="token comment"># Amanda</span><br><br>report <span class="token variable">$names</span><br><span class="token comment"># 1) Mark</span><br><span class="token comment"># 2) Tami</span><br><span class="token comment"># 3) Amanda</span><br><span class="token comment"># 4) Jeremy</span></code></pre><p>To calculate the combined size of the <code>nu</code> executable and installed plugins, enter <code>ls $(build-string $(which nu | get path) '*') | get size | math sum</code>.</p><h2 id="vs-code">VS Code</h2><p>There is a VS Code extension for Nushell that provides syntax highlighting for Nushell scripts. See <a href="https://marketplace.visualstudio.com/items?itemName=TheNuProjectContributors.vscode-nushell-lang?v=1.0.12" rel="noopener" target="_blank">vscode-nushell-lang</a>.</p><h2 id="comparison-to-bash">Comparison to Bash</h2><p>The following table shows the Nushell equivalent of some common Bash commands.</p><table><thead><tr><th>Bash</th><th>Nushell</th><th>Description</th></tr></thead><tbody><tr><td><code>man command</code></td><td><code>help command</code></td><td><code>help commands</code> lists Nushell commands and custom commands</td></tr><tr><td><code>$PATH</code></td><td><code>$nu.path</code></td><td>list of directories search for executables</td></tr><tr><td><code>cat file-path</code></td><td><code>open --raw file-path</code></td><td>print the contents of a file; omit <code>--raw</code> to output structured data</td></tr><tr><td><code>command &gt; file-path</code></td><td><code>command | save --raw file-path</code></td><td>saves command output to a file<br>without converting based on file extension</td></tr><tr><td><code>mkdir -p foo/bar/baz</code></td><td><code>mkdir foo/bar/baz</code></td><td>creates directory structure, including any missing directories</td></tr><tr><td>cmd1 &amp;&amp; cmd2</td><td>cmd1; cmd2</td><td>run cmd1 and then only run cmd2 if cmd1 was successful</td></tr></tbody></table><p>The command whose output is piped in the <code>save</code> command must produce a string. For example, <code>date now | save --raw timestamp.txt</code> does not work, but <code>date now | str from | save --raw timestamp.txt</code> does.</p><h2 id="per-directory-environment-variables">Per Directory Environment Variables</h2><p>Nushell supports defining things to happen when changing to given directories. To configure this, create a <code>.nu-env</code> file in each directory. These are TOML files with the following sections:</p><table><thead><tr><th>TOML Section</th><th>Description</th></tr></thead><tbody><tr><td><code>[env]</code></td><td>sets environment variables to literal values; lines have syntax<br><code>name = &quot;value&quot;</code></td></tr><tr><td><code>[scriptvars]</code></td><td>sets environment variables to command output; lines have syntax<br><code>name = &quot;command-pipeline&quot;</code></td></tr><tr><td><code>[scripts]</code></td><td>specifies commands to run when entering and exiting the directory<br>with <code>entryscripts</code> and <code>exitscripts</code> commands</td></tr></tbody></table><p>After creating the <code>.nu-env</code> file in each directory, enter <code>autoenv trust</code> to give Nushell permission to read the file.</p><p>For example, suppose we want to set the environment variable <code>NODE_ENV</code> to <code>development</code> or <code>production</code> based on the current directory. Add the following setting in the Nushell configuration file:</p><pre class="language-toml"><code class="language-toml"><span class="token key property">nu_env_dirs</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><br>  <span class="token string">"~/projects/airline-reservations"</span><span class="token punctuation">,</span><br>  <span class="token string">"~/projects/bank-accounts"</span><br><span class="token punctuation">]</span></code></pre><p>In the <code>~/projects/airline-reservations</code> directory, create the file <code>.nu-env</code> containing the following and then enter <code>autoenv trust</code>:</p><pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">env</span><span class="token punctuation">]</span><br><span class="token key property">NODE_ENV</span> <span class="token punctuation">=</span> <span class="token string">"development"</span></code></pre><p>Currently the <code>echo</code> command does not write to stdout when run from <code>entryscripts</code> or <code>exitscripts</code>.</p><p>In the <code>~/projects/bank-accounts</code> directory, create the file <code>.nu-env</code> containing the following and then enter <code>autoenv trust</code>:</p><pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">env</span><span class="token punctuation">]</span><br><span class="token key property">NODE_ENV</span> <span class="token punctuation">=</span> <span class="token string">"production"</span></code></pre><p>Now <code>cd</code> to each of these directories and verify that the <code>NODE_ENV</code> environment variable is set to the expected value.</p><p>For more details on this feature, enter <code>help autoenv</code>.</p><h2 id="additional-shells">Additional Shells</h2><p>New shells can be created from the current shell. This enables retaining the working directory of the current shell and switching back to it using the <code>n</code> (for next) and <code>p</code> (for previous) commands.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>enter dir-path</code></td><td>similar to <code>cd</code>, but creates a new shell starting in the given directory</td></tr><tr><td><code>enter file-path</code></td><td>creates a new shell whose context is the content of the given file; odd</td></tr><tr><td><code>shells</code></td><td>lists the existing shells and indicates which one is active</td></tr><tr><td><code>n</code></td><td>makes the next shell in the list active;<br>wrapping to first if on last</td></tr><tr><td><code>p</code></td><td>makes the previous shell in the list active;<br>wrapping to last if on first</td></tr><tr><td><code>exit</code></td><td>exits the current shell, removing it from the list</td></tr><tr><td><code>exit --now</code></td><td>exits all the shells;<br>depending on configuration the terminal window may close</td></tr></tbody></table><h2 id="issues">Issues</h2><ul><li>Fuzzy completion is not yet supported. For example, entering <code>cd foo</code> and pressing the tab key doesn’t auto complete to a directory that contains <code>foo</code>.</li><li>The literal syntax for tables is currently very picky about the location of newline characters due to a parser bug. See <a href="https://github.com/nushell/nushell/issues/3204?v=1.0.12" rel="noopener" target="_blank">issue 3204</a></li><li>There is no built-in <code>grep</code> command. Consider using <a href="https://github.com/BurntSushi/ripgrep?v=1.0.12" rel="noopener" target="_blank">ripgrep</a>.</li></ul></article>