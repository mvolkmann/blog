<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Basic Data Types</h2><aside><nav class="toc"><ol><li><a href="#undefinedobject">UndefinedObject</a></li><li><a href="#boolean">Boolean</a></li><li><a href="#number">Number</a><ol><li><a href="#float">Float</a></li><li><a href="#integer">Integer</a></li><li><a href="#fraction">Fraction</a></li></ol></li><li><a href="#character">Character</a></li><li><a href="#strings">Strings</a><ol><li><a href="#charactersequence">CharacterSequence</a></li><li><a href="#string">String</a></li><li><a href="#symbol">Symbol</a></li></ol></li><li><a href="#uuid">UUID</a></li></ol></nav></aside><article><p>The following subsections provide a review of commonly used Smalltalk classes that represent data types.</p><h2 id="undefinedobject" tabindex="-1">UndefinedObject</h2><p>The pseudo-variable <code>nil</code> represents not having a value. It refers to the singleton instance of the <code>UndefinedObject</code> class. Creation of additional instances is prevented by overriding the class method <code>new</code> in the <code>UndefinedObject</code> class.</p><p>The following table describes some of the instance methods defined in the <code>UndefinedObject</code> class. These can be invoked on the pseudo-variable <code>nil</code>.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>ifNil:</code></td><td>always evaluates its argument</td></tr><tr><td><code>ifNil:ifNotNil:</code></td><td>always evaluates its first argument and never its second</td></tr><tr><td><code>ifNotNil:</code></td><td>never evaluates its argument</td></tr><tr><td><code>ifNotNil:ifNil:</code></td><td>always evaluates its second argument and never its first</td></tr><tr><td><code>isEmptyOrNil:</code></td><td>always answers <code>true</code></td></tr><tr><td><code>isLiteral</code></td><td>always answers <code>true</code></td></tr><tr><td><code>isNil</code></td><td>always answers <code>true</code></td></tr><tr><td><code>notNil</code></td><td>always answers <code>false</code></td></tr></tbody></table><h2 id="boolean" tabindex="-1">Boolean</h2><p>The pseudo-variables <code>true</code> and <code>false</code> refer to singleton instances of the classes <code>True</code> and <code>False</code> which are subclasses of the class <code>Boolean</code>.</p><p><code>True</code> and <code>False</code> are singleton classes. Creating of additional instances is prevented by overriding the class method <code>new</code> in the <code>Boolean</code> class.</p><p>Representing the values <code>true</code> and <code>false</code> by distinct classes simplifies the implementation of many of their methods. For example, here are the implementations of the <code>&amp;</code> and <code>ifTrue:</code> instance methods in the <code>True</code> class.</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token comment">"This is simplified because it can assume<br> the receiver (left-hand side) is true."</span><br><span class="token operator">&amp;</span> alternativeObject<br>    <span class="token operator">^</span>alternativeObject<br><br><span class="token comment">"This is simplified by not needing to test whether the receiver is true."</span><br>ifTrue<span class="token punctuation">:</span> alternativeBlock<br>    <span class="token operator">^</span>alternativeBlock value</code></pre><p>The following table describes most of the instance methods defined in the <code>Boolean</code> class. Since <code>True</code> and <code>False</code> are subclasses, they also have these methods.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>&quot;and&quot; without short-circuiting</td></tr><tr><td><code>|</code></td><td>&quot;or&quot; without short-circuiting</td></tr><tr><td><code>and:</code></td><td>&quot;and&quot; with short-circuiting</td></tr><tr><td><code>and:and:</code></td><td>like <code>and:</code> but for three values</td></tr><tr><td><code>and:and:and:</code></td><td>like <code>and:</code> but for four values</td></tr><tr><td><code>and:and:and:and:</code></td><td>like <code>and:</code> but for five values</td></tr><tr><td><code>eqv:</code></td><td>answers whether two <code>Boolean</code> values are equivalent</td></tr><tr><td><code>ifFalse:</code></td><td>evaluates argument (typically a block) if receiver is <code>false</code></td></tr><tr><td><code>ifFalse:ifTrue:</code></td><td>conditionally evaluates arguments (typically blocks)</td></tr><tr><td><code>ifTrue:</code></td><td>evaluates argument (typically a block) if receiver is <code>true</code></td></tr><tr><td><code>ifTrue:ifFalse:</code></td><td>conditionally evaluates arguments (typically blocks)</td></tr><tr><td><code>isLiteral</code></td><td>always answers <code>true</code></td></tr><tr><td><code>not</code></td><td>answers opposite Boolean value</td></tr><tr><td><code>or:</code></td><td>&quot;or&quot; with short-circuiting</td></tr><tr><td><code>or:or:</code></td><td>like <code>or:</code> but for three values</td></tr><tr><td><code>or:or:or:</code></td><td>like <code>or:</code> but for four values</td></tr><tr><td><code>or:or:or:or:</code></td><td>like <code>or:</code> but for five values</td></tr><tr><td><code>xor:</code></td><td>exclusive &quot;or&quot; of two <code>Boolean</code> values</td></tr></tbody></table><p>The <code>True</code> and <code>False</code> classes implement some of the methods described above, but they do not add any methods.</p><h2 id="number" tabindex="-1">Number</h2><p>The following list depicts the class hierarchy for various kinds of numbers:</p><ul><li><code>Number</code><ul><li><code>Float</code><ul><li><code>BoxedFloat64</code></li><li><code>SmallFloat64</code></li></ul></li><li><code>Fraction</code><ul><li><code>Integer</code><ul><li><code>LargePositiveInteger</code><ul><li><code>LargeNegativeInteger</code></li></ul></li><li><code>SmallInteger</code></li></ul></li></ul></li></ul></li></ul><p>Literal numbers without a decimal point automatically become objects of one of the <code>Integer</code> subclasses.</p><p>Literal numbers with a decimal point automatically become objects of one of the <code>Float</code> subclasses.</p><p>The assignment operator <code>:=</code> can be used to assign a literal number to a variable. For example:</p><pre class="language-smalltalk"><code class="language-smalltalk">n <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">.</span><br>n <span class="token operator">:=</span> n <span class="token operator">+</span> <span class="token number">1</span></code></pre><p>A series of assignment operators can be used to assign the same value to multiple variables. For example:</p><pre class="language-smalltalk"><code class="language-smalltalk">foregroundColor <span class="token operator">:=</span> backgroundColor <span class="token operator">:=</span> Color blue<span class="token punctuation">.</span></code></pre><p>There are no shorthand assignment operators like <code>+=</code> for numbers.</p><p>Numbers are automatically converted to objects of the appropriate type. This includes changing size to accomodate larger and smaller values. For example:</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token temporary-variables"><span class="token punctuation">|</span> <span class="token variable">a</span> <span class="token variable">b</span> <span class="token variable">c</span> <span class="token punctuation">|</span></span><br>a <span class="token operator">:=</span> <span class="token number">1000000000000000000</span><span class="token punctuation">.</span><br>b <span class="token operator">:=</span> a <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">.</span><br>c <span class="token operator">:=</span> b <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">.</span><br>a class print<span class="token punctuation">.</span> <span class="token comment">"SmallInteger"</span><br>b class print<span class="token punctuation">.</span> <span class="token comment">"LargePositiveInteger"</span><br>c class print<span class="token punctuation">.</span> <span class="token comment">"SmallInteger"</span></code></pre><p>The following table describes most of the instance methods defined in the <code>Number</code> class. These can be invoked on instances of all <code>Number</code> subclasses.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>*</code></td><td>answers product of two numbers</td></tr><tr><td><code>+</code></td><td>answers sum of two numbers</td></tr><tr><td><code>-</code></td><td>answers difference of two numbers</td></tr><tr><td><code>/</code></td><td>answers quotient of two numbers</td></tr><tr><td><code>//</code></td><td>answers integer quotient of two numbers truncating toward negative infinity</td></tr><tr><td><code>=</code></td><td>answers if two numbers are equivalent</td></tr><tr><td><code>@</code></td><td>answers a <code>Point</code> object where receiver is x and argument is y</td></tr><tr><td><code>\\</code></td><td>answers same as <code>mod:</code></td></tr><tr><td><code>^</code></td><td>answers same as <code>raisedTo:</code></td></tr><tr><td><code>abs</code></td><td>answers absolute value of receiver</td></tr><tr><td><code>arcCos</code></td><td>answers arccosine of receiver</td></tr><tr><td><code>arcSin</code></td><td>answers arcsine of receiver</td></tr><tr><td><code>arcTan</code></td><td>answers arctangent of receiver</td></tr><tr><td><code>asFloat</code></td><td>answers equivalent <code>Float</code> value</td></tr><tr><td><code>asInteger</code></td><td>answers equivalent <code>Integer</code> value</td></tr><tr><td><code>ceiling</code></td><td>answers nearest integer rounding toward infinity</td></tr><tr><td><code>cos</code></td><td>answers cosine of receiver in radians</td></tr><tr><td><code>degreeCos</code></td><td>answers cosine of receiver in degrees</td></tr><tr><td><code>degreeSin</code></td><td>answers sine of receiver in degrees</td></tr><tr><td><code>degreeTan</code></td><td>answers tangent of receiver in degrees</td></tr><tr><td><code>cubed</code></td><td>answers receiver raised to 3rd power</td></tr><tr><td><code>degreesToRadians</code></td><td>answers result of converting receiver in degees to radians</td></tr><tr><td><code>div:</code></td><td>answers integer division rounding toward negative infinity</td></tr><tr><td><code>even</code></td><td>answers <code>Boolean</code> value indicating if receiver is equivalent to an even integer</td></tr><tr><td><code>floor</code></td><td>answers nearest integer rounding toward negative infinity</td></tr><tr><td><code>fractionPart</code></td><td>answers fractional part (ex. <code>3.25 fractionPart</code> gives 0.25)</td></tr><tr><td><code>ifNotZero:</code></td><td>evaluates argument (typically a block) if receiver is not zero</td></tr><tr><td><code>integerPart</code></td><td>answers integer part (ex. <code>3.25 integerPart</code> gives 3.0)</td></tr><tr><td><code>isDivisibleBy:</code></td><td>answers <code>Boolean</code> value indicating if receiver is divisible by argument</td></tr><tr><td><code>isNaN</code></td><td>always answers <code>false</code></td></tr><tr><td><code>isNumber</code></td><td>always answers <code>true</code></td></tr><tr><td><code>isZero</code></td><td>answers <code>Boolean</code> value indicating if receiver is zero</td></tr><tr><td><code>lg</code></td><td>answers same as <code>log2</code></td></tr><tr><td><code>ln</code></td><td>answers natural log of receiver</td></tr><tr><td><code>log</code></td><td>answers base 10 log of receiver</td></tr><tr><td><code>log2</code></td><td>answers base 2 log of receiver</td></tr><tr><td><code>log:</code></td><td>answers log of receiver where argument is the base</td></tr><tr><td><code>magnitude</code></td><td>same as <code>abs</code></td></tr><tr><td><code>mod:</code></td><td>answers receiver modulo argument</td></tr><tr><td><code>moduloTwoPiAsFloat:</code></td><td>answers receiver modulo 2 * pi as a <code>Float</code></td></tr><tr><td><code>negated</code></td><td>answers receiver with opposite sign</td></tr><tr><td><code>negative</code></td><td>answers <code>Boolean</code> value indicating if receiver is negative</td></tr><tr><td><code>nthRoot:</code></td><td>answers argument root of receiver</td></tr><tr><td><code>odd</code></td><td>answers <code>Boolean</code> value indicating if receiver is equivalent to an odd integer</td></tr><tr><td><code>positive</code></td><td>answers <code>Boolean</code> value indicating if receiver is positive or zero</td></tr><tr><td><code>radiansToDegrees</code></td><td>answers result of converting receiver in radians to degrees</td></tr><tr><td><code>raisedTo:</code></td><td>answers receiver raised to argument exponent</td></tr><tr><td><code>reciprocal</code></td><td>answers reciprocoal of receiver (<code>1 / self</code>)</td></tr><tr><td><code>rem:</code></td><td>answers remainder of integer division of receiver by argument</td></tr><tr><td><code>roundTo:</code></td><td>answers nearest value or receiver rounded to a multiple of argument</td></tr><tr><td><code>rounded</code></td><td>answers nearest integer to receiver</td></tr><tr><td><code>sign</code></td><td>answers <code>1</code>, <code>0</code>, or <code>-1</code> based on sign of receiver</td></tr><tr><td><code>sin</code></td><td>answers sine of receiver in radians</td></tr><tr><td><code>sqrt</code></td><td>answers square root of receiver</td></tr><tr><td><code>squared</code></td><td>answers square of receiver</td></tr><tr><td><code>strictlyPositive</code></td><td>answers <code>Boolean</code> value indicating if receiver is positive and not zero</td></tr><tr><td><code>tan</code></td><td>answers tangent of receiver in radians</td></tr><tr><td><code>to:</code></td><td>answers an <code>Interval</code> from receiver to argument</td></tr><tr><td><code>to:by:</code></td><td>answers an <code>Interval</code> from receiver to <code>to:</code> in steps of <code>by:</code></td></tr><tr><td><code>to:by:do:</code></td><td>evaluates &quot;do&quot; block with every value from receiver to <code>to:</code> in steps of <code>by:</code></td></tr><tr><td><code>to:do:</code></td><td>evaluates &quot;do&quot; block with every value from receiver to <code>to:</code></td></tr><tr><td><code>toSelfPlus:</code></td><td>answers an <code>Interval</code> from receiver to receiver plus argument</td></tr><tr><td><code>truncated</code></td><td>answers closes integer rounding toward zero</td></tr></tbody></table><p>For example, <code>3.14159 roundTo: 0.0001</code> gives <code>3.1416</code>.</p><p>All subclasses of <code>Number</code> except <code>Fraction</code> implement the <code>isLiteral</code> method to always return <code>true</code>. The <code>Fraction</code> class implements the <code>isLiteral</code> method to return <code>true</code> if the denominator is a multiple of 2 or 5, and <code>false</code> otherwise. TODO: Why?</p><h3 id="float" tabindex="-1">Float</h3><p>The subclasses <code>Float</code>, <code>BoxedFloat64</code>, and <code>SmallFloat64</code> do not implement any particularly interesting methods that were not already described for the <code>Number</code> class.</p><p>The following table describes some of the instance methods defined in the <code>BoxedFloat64</code> and <code>SmallFloat64</code> classes (both subclasses of <code>Integer</code>) that are not defined in the <code>Number</code> class.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>answers <code>Boolean</code> value indicating if receiver is less than argument</td></tr><tr><td><code>&lt;=</code></td><td>answers <code>Boolean</code> value indicating if receiver is less than or equal to argument</td></tr><tr><td><code>=</code></td><td>answers <code>Boolean</code> value indicating if receiver is equal to argument</td></tr><tr><td><code>&gt;</code></td><td>answers <code>Boolean</code> value indicating if receiver is greater than argument</td></tr><tr><td><code>&gt;=</code></td><td>answers <code>Boolean</code> value indicating if receiver is greater than or equal to argument</td></tr><tr><td><code>~=</code></td><td>answers <code>Boolean</code> value indicating if receiver is not equal to argument</td></tr></tbody></table><h3 id="integer" tabindex="-1">Integer</h3><p>The following table describes some of the instance methods defined in the <code>Integer</code> class that are not defined in the <code>Number</code> class.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>/</code></td><td>answers result of dividing receiver by argument (<code>Integer</code> if divides evenly; <code>Fraction</code> otherwise to retain accuracy)</td></tr><tr><td><code>&lt;</code></td><td>answers <code>Boolean</code> value indicating if receiver is less than argument</td></tr><tr><td><code>&lt;=</code></td><td>answers <code>Boolean</code> value indicating if receiver is less than or equal to argument</td></tr><tr><td><code>=</code></td><td>answers <code>Boolean</code> value indicating if receiver is equal to argument</td></tr><tr><td><code>&gt;</code></td><td>answers <code>Boolean</code> value indicating if receiver is greater than argument</td></tr><tr><td><code>&gt;=</code></td><td>answers <code>Boolean</code> value indicating if receiver is greater than or equal to argument</td></tr><tr><td><code>~=</code></td><td>answers <code>Boolean</code> value indicating if receiver is not equal to the argument</td></tr><tr><td><code>&lt;&lt;</code></td><td>answers new <code>Integer</code> obtained by shifting argument bits left</td></tr><tr><td><code>&gt;&gt;</code></td><td>answers new <code>Integer</code> obtained by shifting argument bits right</td></tr><tr><td><code>asFloat</code></td><td>answers the equivalent value as a <code>Float</code></td></tr><tr><td><code>atRandom</code></td><td>answers a random integer from 1 to receiver</td></tr><tr><td><code>atRandom:</code></td><td>answers a random integer from 1 to receiver using argument as a generator</td></tr><tr><td><code>bitAnd:</code></td><td>answers new <code>Integer</code> obtained by anding the bits in receiver and argument</td></tr><tr><td><code>bitAt:</code></td><td>answers the bit (0 or 1) in receiver at argument position</td></tr><tr><td><code>bitAt:put:</code></td><td>answers new <code>Integer</code> obtained by changing the bit at <code>bitAt:</code> to <code>put:</code></td></tr><tr><td><code>bitOr:</code></td><td>answers new <code>Integer</code> obtained by oring the bits in receiver and argument</td></tr><tr><td><code>bitXor:</code></td><td>answers new <code>Integer</code> obtained by exclusive oring the bits in receiver and argument</td></tr><tr><td><code>factorial</code></td><td>answers factorial of receiver</td></tr><tr><td><code>gcd</code></td><td>answers greatest common divisor of receiver and argument</td></tr><tr><td><code>hex</code></td><td>answers equivalent hexadecimal string</td></tr><tr><td><code>isPrime</code></td><td>answers <code>Boolean</code> value indicating if receiver is a prime number</td></tr><tr><td><code>lcm</code></td><td>answers least common multiple of receiver and argument</td></tr><tr><td><code>printStringRoman</code></td><td>answers <code>String</code> that is the equivalent Roman numeral</td></tr><tr><td><code>printStringWords</code></td><td>answers <code>String</code> that is the equivalent in English words</td></tr><tr><td><code>timesRepeat:</code></td><td>evaluate argument block receiver times</td></tr></tbody></table><p>In the following code, the <code>Integer</code> instance method <code>/</code> is used to set the variable <code>result</code> to the <code>Fraction</code> <code>4/3</code> rather than the <code>Float</code> <code>1.333333...</code>.</p><pre class="language-smalltalk"><code class="language-smalltalk">result <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span></code></pre><p>To cause the result of the expression above to be a <code>Float</code> value rather than a <code>Fraction</code>, change one or more of the literal <code>Integer</code> values to a <code>Float</code> by adding <code>.0</code> after the value. Alternatively, send the <code>#asFloat</code> message to any of the <code>Integer</code> values.</p><p>The result of <code>1961 printStringRoman</code> is <code>'MCMLXI'</code>.<br>The result of <code>1961 printStringWords</code> is <code>'one thousand, nine hundred sixty-one'</code>.</p><h3 id="fraction" tabindex="-1">Fraction</h3><p><code>Fraction</code> objects represent rational values that have the instance variables <code>numerator</code> and <code>denominator</code>.</p><p>Operations of fractions always return a new <code>Fraction</code> object rather than a <code>Float</code> object in order to maintain accuracy.</p><p>It is recommended to use <code>Fraction</code> values rather that <code>Float</code> values whenever possible for better calculation accuracy.</p><p>The following table describes some of the instance methods defined in the <code>Fraction</code> class that are not defined in the <code>Number</code> class.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>asFloat</code></td><td>answers the nearest equivalent <code>Float</code> value</td></tr><tr><td><code>denominator</code></td><td>answers the denominator of the fraction</td></tr><tr><td><code>numerator</code></td><td>answers the numerator of the fraction</td></tr><tr><td><code>reduced</code></td><td>answers a new <code>Fraction</code> that is a reduced equivalent of the receiver</td></tr></tbody></table><p>For example, <code>(4/6) reduced</code> returns <code>2/3</code>. Parentheses are needed here because otherwise the message <code>#reduced</code> is sent to the <code>Integer</code> <code>6</code> which does not have a corresponding method.</p><h2 id="character" tabindex="-1">Character</h2><p>Characters are represented by the <code>Character</code> class. They are restricted to single-byte Latin-1 (ISO 8859-1) characters.</p><p>Printable literal characters are preceded by a dollar sign. For example, <code>$a</code>. Non-printable characters can be obtained from unary class methods in the <code>Character</code> class such as <code>cr</code>, <code>space</code>, and <code>tab</code>.</p><p>The following table describes some of the class methods defined in the <code>Character</code> class.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>codePoint:</code></td><td>answers <code>Character</code> instance that corresponds to argument code</td></tr><tr><td><code>cr</code></td><td>answers carriage return instance</td></tr><tr><td><code>digitValue:</code></td><td>answers <code>Character</code> instance that corresponds to argument digit (0-9)</td></tr><tr><td><code>escape</code></td><td>answers <code>Character</code> instance that corresponds to escape character</td></tr><tr><td><code>lf</code></td><td>answers <code>Character</code> instance that corresponds to line feed character</td></tr><tr><td><code>newLineCharacter</code></td><td>answers same as <code>lf</code></td></tr><tr><td><code>separators</code></td><td>answers array of whitespace characters</td></tr><tr><td><code>space</code></td><td>answers <code>Character</code> instance that corresponds to space character</td></tr><tr><td><code>tab</code></td><td>answers <code>Character</code> instance that corresponds to tab character</td></tr></tbody></table><p>The following table describes some of the instance methods defined in the <code>Character</code> class.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>answers <code>Boolean</code> value indicating if receiver is less than argument</td></tr><tr><td><code>&lt;=</code></td><td>answers <code>Boolean</code> value indicating if receiver is less than or equal to argument</td></tr><tr><td><code>=</code></td><td>answers <code>Boolean</code> value indicating if receiver is equal to argument</td></tr><tr><td><code>&gt;</code></td><td>answers <code>Boolean</code> value indicating if receiver is greater than argument</td></tr><tr><td><code>&gt;=</code></td><td>answers <code>Boolean</code> value indicating if receiver is greater than or equal to argument</td></tr><tr><td><code>asLowercase</code></td><td>answers lowercase version of receiver</td></tr><tr><td><code>asString</code></td><td>answers <code>String</code> or <code>UnicodeString</code> representation of receiver</td></tr><tr><td><code>asSymbol</code></td><td>answers <code>Symbol</code> of receiver</td></tr><tr><td><code>asUppercase</code></td><td>answers uppercase version of receiver</td></tr><tr><td><code>asciiValue</code></td><td>answers decimal ASCII value of receiver</td></tr><tr><td><code>codePoint</code></td><td>answers decimal Unicode value of receiver</td></tr><tr><td><code>digitValue</code></td><td>answers <code>Integer</code> value of digit <code>Character</code>; opposite of class method <code>digitValue:</code></td></tr><tr><td><code>hex</code></td><td>answers hexadecimal ASCII value of receiver</td></tr><tr><td><code>isAlphaNumeric</code></td><td>answers <code>Boolean</code> value indicating if receiver is a letter or digit</td></tr><tr><td><code>isDigit</code></td><td>answers <code>Boolean</code> value indicating if receiver is a digit</td></tr><tr><td><code>isLetter</code></td><td>answers <code>Boolean</code> value indicating if receiver is a letter</td></tr><tr><td><code>isLiteral</code></td><td>always answers <code>true</code></td></tr><tr><td><code>isLowercase</code></td><td>answers <code>Boolean</code> value indicating if receiver is lowercase</td></tr><tr><td><code>isSeparator</code></td><td>answers <code>Boolean</code> value indicating if receiver is whitespace</td></tr><tr><td><code>isUppercase</code></td><td>answers <code>Boolean</code> value indicating if receiver is uppercase</td></tr><tr><td><code>isValidInBinarySelectors</code></td><td>answers <code>Boolean</code> value indicating if receiver can appear in a binary selector name</td></tr><tr><td><code>isValidInFilenames</code></td><td>answers <code>Boolean</code> value indicating if receiver can appear in a file name</td></tr><tr><td><code>isValidInIdentifier</code></td><td>answers <code>Boolean</code> value indicating if receiver can appear in a variable name or unary/keyword selector</td></tr><tr><td><code>isValidStartOfIdentifier</code></td><td>answers <code>Boolean</code> value indicating if receiver can appear as first character in a variable name or unary/keyword selector</td></tr><tr><td><code>isVowel</code></td><td>answers <code>Boolean</code> value indicating if receiver is a vowel</td></tr><tr><td><code>to:</code></td><td>answers <code>Array</code> of <code>Character</code> instances from receiver to argument</td></tr><tr><td><code>tokenish</code></td><td>answers <code>Boolean</code> value indicating if receiver can appear in a token (letter, digit, or colon)</td></tr></tbody></table><h2 id="strings" tabindex="-1">Strings</h2><p>The following list depicts the class hierarchy for character data:</p><ul><li><code>Collection</code><ul><li><code>SequenceableCollection</code><ul><li><code>CharacterSequence</code><ul><li><code>String</code><ul><li><code>Symbol</code></li></ul></li><li><code>UnicodeString</code><ul><li><code>UnicodeSymbol</code></li></ul></li></ul></li></ul></li></ul></li></ul><p>Instances of <code>String</code> and <code>UnicodeString</code> are mutable collections of characters. But instances of <code>CharacterSequence</code>, <code>Symbol</code>, and <code>UnicodeSymbol</code> are immutable.</p><p>Literal strings are delimited by single quotes, not double quotes which are used to delimit comments. The type of object created, <code>String</code> or <code>UnicodeString</code>, is automatically selected based on whether any of the characters require more than one byte. <code>String</code> objects can only hold Latin-1 (ISO 8859-1) characters which are represented by a single byte. <code>UnicodeString</code> objects can, as the name implies, hold Unicode characters whose representation can require multiple bytes.</p><p>Once a <code>String</code> object is created, the <code>#at:put:</code> message cannot be used to set its characters to ones that require multiple bytes. For example, the following code results in the error &quot;String only store Latin-1 Characters&quot;.</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token temporary-variables"><span class="token punctuation">|</span> <span class="token variable">s</span> <span class="token variable">smile</span> <span class="token punctuation">|</span></span><br>s <span class="token operator">:=</span> <span class="token string">'abc'</span><span class="token punctuation">.</span><br>smile <span class="token operator">:=</span> Character codePoint<span class="token punctuation">:</span> <span class="token number">9786</span><span class="token punctuation">.</span><br>s at<span class="token punctuation">:</span> <span class="token number">1</span> put<span class="token punctuation">:</span> smile<span class="token punctuation">.</span></code></pre><p>To fix this, change the line that assigns to <code>s</code> to <code>s := 'abc' asUnicodeString</code>.</p><h3 id="charactersequence" tabindex="-1">CharacterSequence</h3><p>The <code>CharacterSequence</code> class method <code>readFrom:</code> answers an instance created by reading text from a stream.</p><p>The following table describes some of the instance methods defined in the <code>CharacterSequence</code> class.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>append:</code></td><td>answers new <code>CharacterSequence</code> containing argument characters appended to receiver characters; same as <code>,</code> in <code>String</code> class</td></tr><tr><td><code>asCamelCase</code></td><td>answers copy created by camelCasing white-space separated words (first letter lower)</td></tr><tr><td><code>asDate</code></td><td>answers <code>Date</code> parsed from receiver</td></tr><tr><td><code>asLowercase</code></td><td>answers copy that is all lowercase</td></tr><tr><td><code>asNumber</code></td><td>answers number parsed from receiver</td></tr><tr><td><code>asPlural</code></td><td>answers plural of an English word</td></tr><tr><td><code>asUnicodeString</code></td><td>answers receiver converted to a <code>UnicodeString</code></td></tr><tr><td><code>asUppercase</code></td><td>answers copy that is all uppercase</td></tr><tr><td><code>beginsWith:</code></td><td>answers <code>Boolean</code> indicating if receiver begins with given substring</td></tr><tr><td><code>capitalized</code></td><td>answers copy where first letter is changed to uppercase</td></tr><tr><td><code>collect:</code></td><td>answers result of applying block argument to each character</td></tr><tr><td><code>endsWith:</code></td><td>answers <code>Boolean</code> indicating if receiver ends with given substring</td></tr><tr><td><code>findString:</code></td><td>answers index where argument substring begins</td></tr><tr><td><code>findString:startingAt:caseSensitive:</code></td><td>answers index after <code>startingAt:</code> where a substring begins, optionally case sensitive</td></tr><tr><td><code>findTokens:</code></td><td>answers <code>Array</code> of instances created by splitting receiver on delimiters in argument</td></tr><tr><td><code>format:</code></td><td>answers instance created using interpolation</td></tr><tr><td><code>includesSubString:</code></td><td>answers <code>Boolean</code> indicating if receiver contains substring</td></tr><tr><td><code>includesSubstring:caseSensitive:</code></td><td>answers <code>Boolean</code> indicating if receiver contains substring</td></tr><tr><td><code>indexOf:</code></td><td>answers index of a character</td></tr><tr><td><code>isEmpty</code></td><td>answers <code>Boolean</code> indicating if receiver size is zero</td></tr><tr><td><code>isLiteral</code></td><td>always answers <code>true</code></td></tr><tr><td><code>join:</code></td><td>answers instance formed by joining <code>Array</code> elements of any type with receiver delimiter</td></tr><tr><td><code>match:</code></td><td>answers <code>Boolean</code> indicating whether receiver matches a pattern</td></tr><tr><td><code>padded:to:width:</code></td><td>answers copy formed by padding receiver on left or right with a given <code>Character</code></td></tr><tr><td><code>prefixAndSuffix:</code></td><td>answers <code>Array</code> of instances formed by splitting receiver on last occurrence of a <code>Character</code></td></tr><tr><td><code>size</code></td><td>answers largest legal index</td></tr><tr><td><code>squeezedTo:</code></td><td>answers instance that optimizes readability of receiver in given number of characters</td></tr><tr><td><code>subStrings:</code></td><td>answers <code>Array</code> of instances formed by splitting receiver on delimiters</td></tr><tr><td><code>substrings</code></td><td>answers <code>Array</code> of instances created by splitting receiver on whitespace</td></tr><tr><td><code>substringsSeparatedBy:</code></td><td>answers <code>Array</code> of instances formed by splitting receiver on a single delimiter <code>Character</code></td></tr><tr><td><code>truncateWithElipsisTo:</code></td><td>answers instance formed by truncating receiver to given length with elipsis in last 3 of length</td></tr><tr><td><code>uncapitalized</code></td><td>answers copy where first letter is changed to lowercase</td></tr><tr><td><code>withBlanksCondensed</code></td><td>answers instance created by removing leading and trailing spaces and replacing consecutive spaces with one</td></tr><tr><td><code>withBlanksTrimmed</code></td><td>answers instance created by removing leading and trailing spaces</td></tr><tr><td><code>withoutEnclosing:</code></td><td>answers instance created by removing first and last characters if they match a given <code>Character</code></td></tr><tr><td><code>withoutLeadingBlanks</code></td><td>answers instance created by removing leading blanks</td></tr><tr><td><code>withoutPrefix</code></td><td>answers instance created by removing given substring prefix</td></tr><tr><td><code>withoutSuffix</code></td><td>answers instance created by removing given substring suffix</td></tr><tr><td><code>withoutTrailingBlanks</code></td><td>answers instance created by removing trailing blanks</td></tr></tbody></table><h3 id="string" tabindex="-1">String</h3><p>The <code>String</code> class inherits many instance methods from the <code>CharacterSequence</code> class and overrides the behavior some of them. A notable addition is the binary method comma (<code>,</code>) which answers a new <code>String</code> containing the argument characters appended to the receiver characters. For example, <code>'Hello', ' ', 'World'</code> yields the <code>String</code> <code>'Hello World'</code>.</p><p>The following table describes some of the class methods defined in the <code>String</code> class.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>compare:with:</code></td><td>answer 1 if <code>compare:</code> is less than <code>with:</code>, 2 if equal, and 3 if greater than</td></tr><tr><td><code>compareIgnoringCase:with:</code></td><td>same as <code>compare:with:</code>, but case is ignored</td></tr><tr><td><code>crString</code></td><td>answers instance containing the carriage return character</td></tr><tr><td><code>crlfString</code></td><td>answers instance containing the carriage return and line feed characters</td></tr><tr><td><code>findString:in:startingAt:</code></td><td>answers index of <code>findString:</code> in <code>in:</code> starting at index <code>startingAt:</code></td></tr><tr><td><code>findStringIgnoringCase:in:startingAt:</code></td><td>same as <code>findString:in:startingAt:</code>, but case is ignored</td></tr><tr><td><code>is:equalTo:</code></td><td>answers <code>Boolean</code> indicating if <code>is:</code> is equal to <code>equalTo:</code></td></tr><tr><td><code>isAscii:</code></td><td>answers <code>Boolean</code> indicating if all the characters are ASCII</td></tr><tr><td><code>isEmpy:</code></td><td>answers <code>Boolean</code> indicating if size is zero</td></tr><tr><td><code>lfString</code></td><td>answers instance containing only a line feed character</td></tr><tr><td><code>new:withAll:</code></td><td>answers instance with length <code>new:</code> where all characters are <code>withAll:</code></td></tr><tr><td><code>newLineString</code></td><td>answers instance containing only a newline character</td></tr><tr><td><code>percentEscapingNonAscii</code></td><td>answers URL encoded instance where non-ASCII characters are percent encoded</td></tr><tr><td><code>string:lineIndicesDo:</code></td><td>evalautes block <code>lineIndicesDo:</code> for each substring of <code>string:</code> delimited by CR, LF, or CRLF</td></tr><tr><td><code>substringsIn:</code></td><td>answers an <code>Array</code> of substrings delimited by whitespace characters</td></tr><tr><td><code>tab</code></td><td>answers instance containing the tab character</td></tr></tbody></table><p>To get a substring of a <code>String</code>, use the <code>copyFrom:to:</code> method defined in <code>SequenceableCollection</code>. For example:</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token string">'foobarbaz'</span> copyFrom<span class="token punctuation">:</span> <span class="token number">4</span> to<span class="token punctuation">:</span> <span class="token number">6</span> <span class="token comment">"bar"</span></code></pre><p>The following code demonstrates processing lines in a <code>String</code>:</p><pre class="language-smalltalk"><code class="language-smalltalk">cr <span class="token operator">:=</span> String crString<span class="token punctuation">.</span><br>s <span class="token operator">:=</span> <span class="token string">'foo'</span><span class="token operator">,</span> cr<span class="token operator">,</span> <span class="token string">'bar'</span><span class="token operator">,</span> cr<span class="token operator">,</span> <span class="token string">'baz'</span><span class="token punctuation">.</span><br><span class="token comment">"Alternate way to embed newline characters in a String"</span><br>s <span class="token operator">:=</span> <span class="token string">'foo<br>bar<br>baz'</span><span class="token punctuation">.</span><br><br><span class="token comment">"Print each line."</span><br>String string<span class="token punctuation">:</span> s lineIndicesDo<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token block-arguments"><span class="token variable">:start</span> <span class="token variable">:end</span> <span class="token variable">:endWith</span> <span class="token punctuation">|</span></span><br>    <span class="token punctuation">(</span>s copyFrom<span class="token punctuation">:</span> start to<span class="token punctuation">:</span> end<span class="token punctuation">)</span> print<br><span class="token punctuation">]</span><span class="token punctuation">.</span><br><span class="token comment">"Alternate way to iterate over the lines in a String"</span><br>s substrings do<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token block-arguments"><span class="token variable">:sub</span> <span class="token punctuation">|</span></span> sub print<span class="token punctuation">]</span><span class="token punctuation">.</span></code></pre><p>The following table describes some of the instance methods defined in the <code>String</code> class that are not also defined in its superclass <code>CharacterSequence</code>.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>,</code></td><td>answers new string that results from appending argument</td></tr><tr><td><code>&lt;</code></td><td>answers <code>Boolean</code> value indicating if receiver is less than argument</td></tr><tr><td><code>&lt;=</code></td><td>answers <code>Boolean</code> value indicating if receiver is less than or equal to argument</td></tr><tr><td><code>=</code></td><td>answers <code>Boolean</code> value indicating if receiver is equal to argument</td></tr><tr><td><code>&gt;</code></td><td>answers <code>Boolean</code> value indicating if receiver is greater than argument</td></tr><tr><td><code>&gt;=</code></td><td>answers <code>Boolean</code> value indicating if receiver is greater than or equal to argument</td></tr><tr><td><code>at:</code></td><td>answers <code>Character</code> at given index</td></tr><tr><td><code>at:put:</code></td><td>replaces <code>Character</code> at given index</td></tr><tr><td><code>byteSize</code></td><td>answers size in bytes</td></tr><tr><td><code>findString:startingAt:</code></td><td>answers index after <code>startingAt:</code> where a substring begins, case sensitive</td></tr><tr><td><code>findStringCaseInsenstive:startingAt::</code></td><td>answers index after <code>startingAt:</code> where a substring begins, case insensitive</td></tr><tr><td><code>lineIndicesDo:</code></td><td>evalautes block <code>lineIndicesDo:</code> for each substring of <code>string:</code> delimited by CR, LF, or CRLF</td></tr><tr><td><code>percentEscapeUrl</code></td><td>answers URL encoded instance where non-ASCII characters are percent encoded</td></tr><tr><td><code>percentEscapeUrlField</code></td><td>answers URL encoded instance where non-ASCII characters in fields are percent encoded</td></tr><tr><td><code>size</code></td><td>answers largest index</td></tr><tr><td><code>substrings</code></td><td>answers <code>Array</code> of substrings delimited by whitespace characters</td></tr><tr><td><code>unescapePercents</code></td><td>answers reverse of <code>percentEscapeUrl</code></td></tr></tbody></table><p>The <code>format:</code> method returns a <code>String</code> created from a template using interpolation where input comes from an <code>Array</code>. For example, both of the following produce the string <code>'Player Gretzky is number 99.'</code>:</p><pre class="language-smalltalk"><code class="language-smalltalk">s <span class="token operator">:=</span> <span class="token string">'Player {1} is number {2}.'</span> format<span class="token punctuation">:</span> <span class="token symbol">#</span><span class="token punctuation">(</span><span class="token string">'Gretzky'</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">.</span><br><br>name <span class="token operator">:=</span> <span class="token string">'Gretzky'</span><span class="token punctuation">.</span><br>number <span class="token operator">:=</span> <span class="token number">99</span><span class="token punctuation">.</span><br>s <span class="token operator">:=</span> <span class="token string">'Player {1} is number {2}.'</span> format<span class="token punctuation">:</span> <span class="token punctuation">{</span>name<span class="token punctuation">.</span> number<span class="token punctuation">}</span><span class="token punctuation">.</span></code></pre><p>The <code>String</code> <code>format:</code> method is useful for print-style debugging. For example, the following is the equivalent of a <code>console.log</code> call in JavaScript.</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token punctuation">(</span><span class="token string">'myVariable = {1}'</span> format<span class="token punctuation">:</span> <span class="token punctuation">{</span>myVariable<span class="token punctuation">}</span><span class="token punctuation">)</span> print</code></pre><p>An even better approach is to defined the <code>logAs:</code> method in the <code>Object</code> class. This is described in the earlier &quot;Transcript Windows&quot; section.</p><p>The <code>padded:to:with:</code> method answers a copy formed by padding receiver on the left or right with a given <code>Character</code>. For example, the following code answers a <code>String</code> containing three spaces followed by <code>'19'</code>:</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token number">19</span> asString padded<span class="token punctuation">:</span> <span class="token symbol">#left</span> to<span class="token punctuation">:</span> <span class="token number">5</span> with<span class="token punctuation">:</span> Character space</code></pre><p>The <code>prefixAndSuffix:</code> method answers an <code>Array</code> of instances formed by splitting receiver on last occurrence of a <code>Character</code>. For exsample, the following code answers an <code>Array</code> containing <code>'/foo/bar'</code> and <code>'baz.txt')</code>.</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token string">'/foo/bar/baz.txt'</span> prefixAndSuffix<span class="token punctuation">:</span> <span class="token char">$/</span></code></pre><p>Since the <code>String</code> class is a subclass of <code>Collection</code>, the <code>select:</code> method can be used to iterate over and select a subset of its characters. For example, the following code returns a <code>String</code> containing all the digits found in another <code>String</code>:</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token string">'Buy 14 bananas.'</span> select<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token block-arguments"><span class="token variable">:c</span> <span class="token punctuation">|</span></span> c isDigit<span class="token punctuation">]</span> <span class="token comment">"14"</span></code></pre><h3 id="symbol" tabindex="-1">Symbol</h3><p>There are no particularly interesting class methods in the <code>Symbol</code> class.</p><p>The following table describes some of the instance methods defined in the <code>Symbol</code> class that are not also defined in superclasses.</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>asString</code></td><td>answers a <code>String</code> containing the same characters as receiver</td></tr><tr><td><code>isLiteral</code></td><td>always answers <code>true</code></td></tr><tr><td><code>numArgs</code></td><td>answers number of arguments in a keyword message or 0 if not</td></tr><tr><td><code>precedence</code></td><td>answers 0 if not a valid selector, 1 if unary, 2 if binary, and 3 if keyword</td></tr><tr><td><code>separateKeywords</code></td><td>answers space-separated <code>String</code> containing keywords</td></tr><tr><td><code>value:</code></td><td>answers result of sending receiver as a unary message to argument</td></tr></tbody></table><p>Many of the <code>Symbol</code> instance methods are useful for run-time evaluation of instances as keyword messages.</p><p>The <code>UnicodeSymbol</code> class is similar to the <code>Symbol</code> class, but can hold Unicode characters.</p><h2 id="uuid" tabindex="-1">UUID</h2><p>The package &quot;Identities-UUID&quot; generates UUID values. To install it, enter <code>Feature require: 'Identities-UUID'</code> in a Workspace and &quot;Do it&quot;. To generate a UUID value, use <code>UUID new</code>.</p></article>