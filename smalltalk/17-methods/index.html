<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Methods</h2><aside><nav class="toc"><ol><li><a href="#unknown-variables">Unknown Variables</a></li><li><a href="#accessor-methods">Accessor Methods</a></li><li><a href="#overriding-methods">Overriding Methods</a></li><li><a href="#primitive-methods">Primitive Methods</a></li></ol></nav></aside><article><p>Methods are associated with a specific class. Class methods handle messages sent to the class. Instance methods handle messages sent to objects instantiated from the class.</p><p>Method definitions take the following form:</p><pre class="language-smalltalk"><code class="language-smalltalk">messageSelectorAndArgumentNames<br>    <span class="token comment">"comment stating purpose of message"</span><br><br>    <span class="token temporary-variables"><span class="token punctuation">|</span> <span class="token variable">temporary</span> <span class="token variable">variable</span> <span class="token variable">names</span> <span class="token punctuation">|</span></span><br>    statements</code></pre><p>Other programming languages use a keyword like <code>function</code>, <code>func</code>, <code>fun</code>, or <code>fn</code> to identify the start of a function or method definition. Smalltalk does not require a keyword because it is always clear from context when a method is being defined. For example, System Browser windows provide a separate text editing area for viewing and editing each method definition.</p><p>In binary and keyword methods, parameter variable names typically indicate the expected object type and begin with &quot;a&quot; or &quot;an&quot;. For example, <code>aNumber</code>, <code>aString</code>, or <code>anArray</code>. This works well because the keyword that precedes the parameter variable indicates its meaning. For example, <code>name: aString score: aNumber</code>.</p><p>When multiple parameters have the same data type, a good way to name them is to include their meaning and type in the name. For example, <code>latitude: latNumber longitude: lngNumber</code>.</p><p>Methods always &quot;answer&quot; (return) an object, either explicitly with the <code>^</code> return operator or implicitly returning the receiver (<code>self</code>). For example, the instance method <code>asUppercase</code> in the <code>String</code> class contains the comment &quot;Answer a String made up from the receiver whose characters are all uppercase.&quot; Returning the receiver enables message chaining in which multiple messages are sent to the same object.</p><p>All methods are public. By convention, methods that should only be used by other methods in the same class are placed in the &quot;private&quot; message category.</p><p>To find a method when its class is not known:</p><ul><li><p>Open the World menu and select Open ... Message Names. This opens a &quot;Message Names&quot; window.</p></li><li><p>Enter any part of a message name and press the return key. For example, entering &quot;nj&quot; will find several methods including the &quot;inject:into:&quot; message that is implemented by the <code>Collection</code> class.</p><p>A list of matching message names will be displayed in the top left pane with the first one selected. A list of classes that implement the selected method will be displayed in the top right pane with the first one selected. The implementation of the selected method will be displayed in the bottom pane.</p></li><li><p>Click another message name to see the classes that implement it.</p></li><li><p>Click another class name to see its implementation of the method.</p></li><li><p>Click the &quot;Browse&quot; button to open a System Browser focused on that method.</p></li></ul><p>The buttons in the &quot;Message Names&quot; window are the same as the buttons &quot;System Browser&quot; windows.</p><p>Squeak Smalltalk supports finding methods by part of their name OR by providing example input and output. To find a method in Squeak Smalltalk:</p><ul><li>Click the &quot;Tools&quot; menu and select &quot;Method Finder&quot;. This opens a &quot;Selector Browser&quot;.</li><li>Enter part of the method name OR an example input, followed by a period, and the expected output.</li><li>Press the return key.</li><li>A list of all matching methods will be displayed.</li><li>Click one of the methods to open a System Browser that shows the method implementation.</li></ul><p>See <a href="https://www.youtube.com/watch?v=cI_yBWdmoeI&list=PLu8vLCSA-4hklsvT9W6ruintbdx_K0DYW&index=11&t=28s" target="_blank">The amazing Squeak Method Finder</a>.</p><p>To add a method to a class:</p><ul><li>Open a System Browser.</li><li>Select the class category of the class to which the method will be added in the top, first pane.</li><li>Select the class in the top, second pane.</li><li>Select the method category in which the method will be added. If no suitable category appears in the list, press cmd-n (new category...) to create a new one. Alternatively, select &quot;-- all --&quot; and assign the method to a category later. In that case the method will be assigned to the &quot;as yet unclassified&quot; category.</li><li>A starting template for a new method definition will appear in the bottom pane.</li><li>Change &quot;messageSelectorAndArgumentNames&quot; to the name of the new method, including any parameter names it uses.</li><li>Modify the comment describing the method.</li><li>Update the list of temporary (local) variable names or delete that line.</li><li>Replace &quot;statements&quot; with the method implementation.</li><li>To associate the method with a different method category, drag its name from the top, fourth pane to the desired method category in the top, third pane.</li></ul><p>For example, try adding the following methods to the <code>Integer</code> class which is in the class category &quot;Kernel-Numbers&quot;.</p><pre class="language-smalltalk"><code class="language-smalltalk">predecessor<br>    <span class="token comment">"Answer the predecessor of this integer."</span><br>    <span class="token operator">^</span><span class="token keyword">self</span> <span class="token operator">-</span> <span class="token number">1</span><br><br>successor<br>    <span class="token comment">"Answer the successor of this integer."</span><br>    <span class="token operator">^</span><span class="token keyword">self</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre><p>Superclasses can define methods that subclasses must implement and each subclass can implement them differently. For example, a class named <code>VShape</code> can define the following method:</p><pre class="language-smalltalk"><code class="language-smalltalk">area<br>    <span class="token comment">"Answer the area of the shape."</span><br>    <span class="token keyword">self</span> subclassResponsibility</code></pre><p>This does not prevent instances of the class from being created, but calling such methods will result in an Error window with the title &quot;My subclass should have overridden {method-name}&quot; will appear.</p><p>The classes <code>VCircle</code> and <code>VRectangle</code> can be defined as subclasses of <code>VShape</code>. If they do not define the <code>area</code> method and that message is sent to an instance, an Error window with the title &quot;My subclass should have overridden #area&quot; will appear.</p><p>To add the missing method from the Error window:</p><ul><li>Click the &quot;Create&quot; button.</li><li>Select a message category for the method.</li><li>Enter its implemenation.</li><li>Press cmd-s to save.</li><li>Press the &quot;Proceed&quot; button to continue running the code at the point of the failed message send.</li></ul><p>The example classes above adds the prefix &quot;V&quot; (first letter of my last name) to their names because the class name `Rectangle is already defined.</p><p>The <code>VCircle</code> class can add the following class method for creating instances:</p><pre class="language-smalltalk"><code class="language-smalltalk">radius<span class="token punctuation">:</span> aNumber<br>    <span class="token operator">^</span><span class="token keyword">self</span> <span class="token keyword">new</span> setRadius<span class="token punctuation">:</span> aNumber</code></pre><p>The <code>VCircle</code> class can add the following instance methods:</p><pre class="language-smalltalk"><code class="language-smalltalk">setRadius<span class="token punctuation">:</span> aNumber<br>    radius <span class="token operator">:=</span> aNumber<br><br>area<br>    <span class="token operator">^</span>Float pi <span class="token operator">*</span> radius <span class="token operator">*</span> radius</code></pre><p>A common way to provide a constant value is to define a class method that returns it. For example, <code>pi</code> is a class method in the <code>Float</code> class.</p><p>The <code>VRectangle</code> class can add the following class method for creating instances:</p><pre class="language-smalltalk"><code class="language-smalltalk">height<span class="token punctuation">:</span> aHeight width<span class="token punctuation">:</span> aWidth<br>    <span class="token operator">^</span><span class="token keyword">self</span> <span class="token keyword">new</span> setHeight<span class="token punctuation">:</span> aHeight width<span class="token punctuation">:</span> aWidth</code></pre><p>The <code>VRectangle</code> class can add the following instance methods. In method bodies that contain more than one expression, the expressions are separated by the period character (<code>.</code>).</p><pre class="language-smalltalk"><code class="language-smalltalk">setHeight<span class="token punctuation">:</span> aHeight width<span class="token punctuation">:</span> aWidth<br>    height <span class="token operator">:=</span> aHeight<span class="token punctuation">.</span><br>    width <span class="token operator">:=</span> aWidth<br><br>area<br>    <span class="token operator">^</span>height <span class="token operator">*</span> width</code></pre><p>To view the bytecode for a method, select it in a System Browser, click the &quot;show...&quot; button, and select &quot;byteCodes&quot;.</p><p>To delete a method, select its name in the top, fourth pane and press cmd-x (remove method).</p><p>To delete a method category and all the methods in it, select its name in the top, third pane and press cmd-x (remove).</p><p>Both class and instance methods can call themselves recursively.</p><p>Here is an example of a class method from a class I created named <code>Math</code> that calls itself recursively:</p><pre class="language-smalltalk"><code class="language-smalltalk">factorial<span class="token punctuation">:</span> n<br>    <span class="token comment">"Answer the factorial of a given integer."</span><br>    <span class="token operator">^</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">1</span><br>        ifTrue<span class="token punctuation">:</span> <span class="token number">1</span><br>        ifFalse<span class="token punctuation">:</span> <span class="token punctuation">[</span>n <span class="token operator">*</span> <span class="token punctuation">(</span>Math factorial<span class="token punctuation">:</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Here is an example of an instance method I added to the <code>Integer</code> class that calls itself recursively. The method <code>factorial</code> already exists in that class and is more efficient than the version below.</p><pre class="language-smalltalk"><code class="language-smalltalk">factorial2<br>    <span class="token comment">"Answer the factorial of this integer."</span><br>    <span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">self</span> <span class="token operator">=</span> <span class="token number">1</span><br>        ifTrue<span class="token punctuation">:</span> <span class="token number">1</span><br>        ifFalse<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">self</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">self</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> factorial2<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>If you edit the name of a method in code editing pane of a System Browser, it will create a copy of the method with the new name. The method with the previous name will still exist and can be deleted. An alternative is to right-click the method in the 4th pane and select &quot;refactorings...rename...&quot;.</p><p>While it is not commonly done, a method can check the types of its arguments and alter its functionality based on those. For example, this class method returns a number that is double what is passed to it. If it is given a <code>String</code> instead of a <code>Number</code>, it converts it to a <code>Number</code> and doubles it. If it is given any other kind of object, it just returns <code>0</code>.</p><pre class="language-smalltalk"><code class="language-smalltalk">double<span class="token punctuation">:</span> obj<br>    <span class="token comment">"Answer double the value of the argument."</span><br>    <span class="token punctuation">(</span>obj isKindOf<span class="token punctuation">:</span> Number<span class="token punctuation">)</span> ifTrue<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token operator">^</span> obj <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">]</span><span class="token punctuation">.</span><br>    <span class="token punctuation">(</span>obj isKindOf<span class="token punctuation">:</span> String<span class="token punctuation">)</span> ifTrue<span class="token punctuation">:</span> <span class="token punctuation">[</span><br>        <span class="token punctuation">[</span> <span class="token operator">^</span> obj asNumber <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">]</span><br>            on<span class="token punctuation">:</span> Error <span class="token comment">"error converting string to number"</span><br>            do<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token operator">^</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><br>    <span class="token operator">^</span> <span class="token number">0</span><span class="token punctuation">.</span></code></pre><p>Instance and class methods can dynamically added to a class by sending the message <code>#compile:</code> to a class or its metaclass. The argument is a string of Smalltalk code. For example, the following code adds the class method <code>legs</code> and the instance method <code>speak</code> to the <code>Dog</code> class.</p><pre class="language-smalltalk"><code class="language-smalltalk">Dog class compile<span class="token punctuation">:</span> <span class="token string">'legs ^4'</span><span class="token punctuation">.</span><br>Dog compile<span class="token punctuation">:</span> <span class="token string">'speak ''Woof!'' print'</span></code></pre><p>The expression <code>Dog class</code> returns the metaclass of the <code>Dog</code> class and adding a method there makes it a class method.</p><p>The single quotes inside the <code>speak</code> method string are doubled to escape them.</p><p>The new methods will appear in System Browsers.</p><h2 id="unknown-variables" tabindex="-1">Unknown Variables</h2><p>When a method is saved, if it assigns a value to an unknown variable then the following dialog will appear:</p><p><img alt="Unknown Variable" src="/blog/assets/cuis-unknown-variable.png?v=1.1.1" style="width: 65%"></p><p>Choose &quot;declare instance&quot; to add the variable to the <code>instanceVariableNames:</code> list where the class is defined.</p><p>Choose &quot;declare method temp&quot; to add a declaration at the top of the current method.</p><p>Choose &quot;declare block-local temp&quot; to add a declaration inside the block where it is used. This will be at the top of the current method if not inside a block.</p><p>Choose &quot;cancel&quot; to skip adding a variable declaration.</p><h2 id="accessor-methods" tabindex="-1">Accessor Methods</h2><p>&quot;Getter methods&quot; allow instance or class variable values to be accessed from outside the class that defines them.</p><p>&quot;Setter methods&quot; allow instance or class variables to be modified from outside the class the defines them.</p><p>Suppose a class <code>Dog</code> has the instance variable <code>breed</code>. The following accessor methods can be implemented:</p><pre class="language-smalltalk"><code class="language-smalltalk">breed<br>    <span class="token operator">^</span>breed<br><br>breed<span class="token punctuation">:</span> aString<br>    breed <span class="token operator">:=</span> aString</code></pre><p>Accessor methods for all instance variables in a class can be generated by right-clicking the class name in a System Browser and selecting &quot;more...create inst var accessors&quot;.</p><h2 id="overriding-methods" tabindex="-1">Overriding Methods</h2><p>A class can override methods defined in a superclass. In some cases this is required because the superclass method sends the message <code>#subclassResponsibility</code> to self. For example, the <code>Number</code> class defines the instance method <code>+</code> as follows:</p><pre class="language-smalltalk"><code class="language-smalltalk"><span class="token operator">+</span> aNumber<br>    <span class="token comment">"Answer the sum of the receiver and aNumber."</span><br>    <span class="token keyword">self</span> subclassResponsibility</code></pre><p>The subclasses <code>BoxedFloat64</code>, <code>SmallFloat64</code>, <code>Fraction</code>, <code>Integer</code>, and others all override this method to add specific number types in a unique way. The need for this is especially evident when considering how to add two <code>Fraction</code> values.</p><p>In some cases it is desirable for an overriding method in a subclass to call the corresponding method its superclass. This is done by sending the same message to the <code>super</code> keyword. This is always done in the <code>initialize</code> method because otherwise instance variables in the superclass will not be properly initialized.</p><h2 id="primitive-methods" tabindex="-1">Primitive Methods</h2><p>Primitive methods are implemented in the VM, often in a way that is more efficient than what could be achieved in Smalltalk code.</p><p>From the book &quot;Smalltalk-80: The Language and its Implementation&quot;, referred to as the &quot;Blue Book&quot;:</p><blockquote><p>All behavior in the system is invoked by messages, however, all messages are not responded to by executing Smalltalk-80 methods. There are about one hundred primitive methods that the Smalltalk-80 virtual machine knows how to perform. Examples of messages that invoke primitives are the <code>+</code> message to small integers, the <code>at:</code> message to objects with indexed instance variables, and the <code>new</code> and <code>new:</code> messages to classes. When <code>3</code> gets the message <code>+ 4</code>, it does not execute a Smalltalk-80 method. A primitive method returns <code>7</code> as the value of the message. The complete set of primitive methods is included in the fourth part of this book, which degcribes the virtual machine. Methods that are implemented as primitive methods begin with an expression of the form <code>&lt;primitive #&gt;</code> where <code>#</code> is an integer indicating which primitive method will be followed. If the primitive fails to perform correctly, execution continues in the Smalltalk-80 method. The expression <code>&lt;primitive #&gt;</code> is followed by Smalltalk-80 expressions that handle failure situations.</p></blockquote><p>In Cuis Smalltalk, the comment at the beginning of the class method <code>whatIsAPrimitive</code> in the <code>Object</code> class contains the following:</p><blockquote><p>When the Smalltalk interpreter begins to execute a method which specifies a primitive response, it tries to perform the primitive action and to return a result. If the routine in the interpreter for this primitive is successful, it will return a value and the expressions in the method will not be evaluated. If the primitive routine is not successful, the primitive 'fails', and the Smalltalk expressions in the method are executed instead. These expressions are evaluated as though the primitive routine had not been called.</p></blockquote><p>Historically the Squeak VM could support a maximum of 256 primitive operations. Newer versions of the Squeak VM do not have that limitation.</p><p>From Vanessa Freudenberg, &quot;The VM is mostly written in a subset of Smalltalk called Slang, transpiled to C, then compiled and linked with platform-specific code to create the VM executable.&quot;</p><p>The functionality of specific numbered primitives can differ between VM implementations. To get a sense of typical mappings, see the ones used by SqueakJS in the file <a href="https://github.com/codefrau/SqueakJS/blob/2b9ce0cd94b9ab3cb0aae28052c809b0bd3c14ea/vm.primitives.js#L80" target="_blank">vm.primitives.js</a>. For the OpenSmalltalk version, see the file <a href="https://github.com/OpenSmalltalk/opensmalltalk-vm/blob/Cog/src/spur32.cog/cointerp.c" target="_blank">cointerp.c</a>.</p></article>