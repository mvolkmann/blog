<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Authentication</h2><aside><nav class="toc"><ol><li><a href="#terminology">Terminology</a></li><li><a href="#strategies">Strategies</a></li><li><a href="#local-ssl-setup">Local SSL Setup</a></li></ol></nav></aside><article><p>This page describes an approach for implementing web-based authentication from scratch, not using libraries. This is useful for understanding all the underlying steps or implementing a custom authentication approach.</p><h2 id="terminology">Terminology</h2><p><em>Encryption</em> typically encodes data using a key and an algorithm. The data can be decoded if the key and algorithm are known.</p><p><em>Hashing</em> is a one-way encoding of data. While it is possibly given sufficient computing power to recover the original data, doing so is very difficult. This is often used to store passwords in a database. Commonly used hashing algorithms include MD4, MD5, and SHA (Security Hashing Algorithm).</p><p><em>Salting</em> makes data more secure by adding &quot;salt&quot; to the data to be encrypted or hashed. Often a fixed string is added to the beginning, end, or both ends of the data.</p><p>Passing user names, passwords, and email addresses from browsers to servers in plain text can be made safe by using HTTPS.</p><p><code>npm install bcryptjs</code> <code>npm install fastify</code> <code>npm install fastify-cookie</code> <code>npm install fastify-cors</code> <code>npm install jsonwebtoken</code> <code>npm install nodemailer</code></p><p>HTTP-only cookies can only be created by a server and can only be retrieved by the server that created them. They can be made secure and can expire after a given amount of time. Like other cookies, DevTools can see that they exists, but their values are not available. In addition, browser extensions cannot access them.</p><p>A JSON Web Token (JWT) encapsulates encoded information in a token that can be passed to and from servers. The data is not encrypted, so it should not contain sensitive data. It is comprised of three parts, a header, payload, and a signature. The header specifies the algorithm used to encode the data. The payload holds the data as a JSON string. Often this includes a user id and session id. The signature provides information required to decode the data.</p><p>Logging in can create a session that maintains data until the end of the session.</p><p>&quot;Access tokens&quot; are JWTs that are used to indicate that a given user has been authenticated. They often contain a user id, session id, and role information. They are only valid for the current session and typically has a short lifetime.</p><p>&quot;Refresh tokens&quot; are JWTs that typically only contains a session id. They have a longer lifetime than access tokens. When an access token expires, a web application can use a refresh token to request a new access token. This only works if the session is still valid. Site administrators can revoke sessions to prevent this.</p><h2 id="strategies">Strategies</h2><p>This section describes a number of strategies to securely store user passwords in order from least to most secure.</p><ol><li>Store in plain text in an &quot;inaccessible&quot; location.</li></ol><p>This approach is strongly discouraged because hackers often find a way to access data stores that were thought to be inaccessible.</p><ol><li>Store encrypted versions of passwords.</li></ol><p>If a hacker gains access to the data store AND determines the encryption algorithm that was used, they can decrypt any of the passwords.</p><ol><li>Store hashed versions of passwords.</li></ol><p>Encryption and hashing algorithms always produce the same output for a given input. But encryption is two-way and hashing is one-way. Encrypted values can be decrypted. Hashed values cannot be used to recovered the original value. This is analogous to the distinction between loss-less and lossy image compression.</p><p>A hacker can use a rainbow table to discover commonly used passwords. From <a href="https://en.wikipedia.org/wiki/Rainbow_table?v=1.0.14" rel="noopener" target="_blank">Wikipedia</a>, &quot;A rainbow table is a precomputed table for caching the output of cryptographic hash functions, usually for cracking password hashes.&quot;</p><ol><li>Store passwords that add a common salted and are hashed.</li></ol><p>Salting adds a fixed number of bytes to the passwords before they are hashed. This prevents rainbow tables from being used to discover the use of common passwords. However, if a hacker learned the salt value that was added to all of the passwords, they could generate a new rainbow table that is useful.</p><ol><li>Store passwords that add a different salt to each password before hashing.</li></ol><p>With this approach the salt used for each user will also need to be stored. A common approach is to add it to the beginning of hashed password. The steps to hash the password for a single user would be:</p><ul><li>Generate a new salt for the user.</li><li>Hash the password using the new salt and the plain text password.</li><li>Concatenate the new salt and the hashed value.</li><li>Store this value.</li></ul><p>If a hacker gains accessed to these hashed values and they know the length of the salt values and where there are added to the hashed value (ex. beginning or end), they can generate a rainbow table in order to determine if the password is one from a list of commonly used passwords. However, a new rainbow table would be needed for each user since each user uses a different salt value.</p><p>The bcrypt hashing algorithm is purposely slower than other hashing algorithms in order to make creation of rainbow tables time consuming, while still being fast enough for single hashing operations required for uses like authentication.</p><h2 id="local-ssl-setup">Local SSL Setup</h2><p>In macOS, edit the &quot;hosts&quot; file by entering <code>sudo vim /etc/hosts</code>. Then add the following lines:</p><pre class="language-text"><code class="language-text">127.0.0.1 nodeauth.dev<br>127.0.0.1 api.nodeauth.dev</code></pre><p>Caddy is a local server that is implemented in Go and supports HTTPS. Browse <a href="https://caddyserver.com?v=1.0.14" rel="noopener" target="_blank">caddyserver.com</a> for installation instructions. In macOS this can be installed by installing Homebrew and entering <code>brew install caddy</code> and <code>brew install nss</code>. Create the file <code>Caddyfile</code> in the project root directory containing the following:</p><pre class="language-text"><code class="language-text">{<br>  http_port 81<br>  local_certs<br>}<br><br># This is for the UI server.<br>nodeauth.dev {<br>  reverse_proxy 127.0.0.1:5000<br>}<br><br># This is for the API server.<br># Why is it important for this to be a subdomain of the UI server?<br>api.nodeauth.dev {<br>  reverse_proxy 127.0.0.1:1919<br>}</code></pre><p>To start the Caddy server, cd to the project root directory and enter <code>caddy run</code>.</p><p>To stop the Caddy server, press ctrl-c or enter <code>caddy stop</code> in another terminal window.</p><p>To reload changes to <code>Caddyfile</code> in a running server, enter <code>caddy reload</code> in another terminal window.</p></article>