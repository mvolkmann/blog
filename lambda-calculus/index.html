<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Lambda Calculus</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#function-syntax">Function Syntax</a></li><li><a href="#some-rules">Some Rules</a></li><li><a href="#church-encoding-of-numbers">Church Encoding of Numbers</a></li><li><a href="#addition">Addition</a></li><li><a href="#multiplication">Multiplication</a></li><li><a href="#exponentiation">Exponentiation</a></li><li><a href="#boolean-logic">Boolean Logic</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank">Lambda calculus</a> (sometimes written as λ-calculus) was defined by <a href="https://en.wikipedia.org/wiki/Alonzo_Church" target="_blank">Alonzo Church</a> (1903-1985) in the 1930s. It describes concepts that are fundamental to functional programming. It's purpose is to study how functions can interact with each other not to calculate results in a useful way.</p><p>Despite lacking many features found in programming languages, λ-calculus is Turing complete. It only defines three concepts, referred to as lambda terms:</p><ul><li>variable: gives a single-letter name to a value</li><li>lambda extraction: defines an anonymous function</li><li>application: calls a function with arguments</li></ul><p>It does not define values such as booleans, numbers, or strings. It also does not define operators on these types or any built-in functions. However, these can be defined using only the concepts listed above.</p><p>There are two kinds of variables, bound and free. Bound variables appear as function parameters and represent in input value. Free variables appear in function definitions and can represent any value.</p><p>Throughout this post examples are shown in both λ-calculus and the closest equivalent in JavaScript.</p><h2 id="function-syntax" tabindex="-1">Function Syntax</h2><p>Here is an identity function that just returns the value passed in.</p><table><thead><tr><th>λ-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td>λx.x</td><td>x =&gt; x</td></tr></tbody></table><p>Function defintions begin with the λ character, followed by a single parameter name, a period, and the lambsda term to which the function evaluates.</p><p>Here is an example of calling the identity function which results in the value <code>y</code>. Parentheses are used to surround function defintions and enable them to be applied. They are also used to define the order of operations.</p><table><thead><tr><th>λ-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td>(λx.x) y</td><td>(x =&gt; x)(y)</td></tr></tbody></table><p>Functions in λ-calculus can only have a single parameter. To support the concept of multi-parameter functions, a function can be passed to another function. This is commonly used in programming languages for callback functions.</p><p>To demonstrate this we will write a function that adds two numbers. Recall that λ-calculus does not define numbers or operators. But for demonstration purposes, assume that it does define the <code>+</code> operator which adds two numbers held in variables.</p><table><thead><tr><th>λ-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td>λx. (λy.x + y)</td><td>(x, y) =&gt; x + y</td></tr></tbody></table><p>Shorthand ways of writing the λ-calculus function above are <code>λx.λy.x + y</code> (parentheses not necessary) and <code>λxy.x + y</code>.</p><p>This is referred to as &quot;currying&quot; which is a nod to the mathematician <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank">Haskell Curry</a> (1900-1982) who used the concept extensively in his research. However, the concept was initially defined by Gottlob Frege in 1893 before Haskell Curry was born.</p><p>The JavaScript function above could be defined and called as follows to support currying. This uses a function that returns another function.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token parameter">y</span> <span class="token operator">=></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 5 */</span></code></pre><p>In many functional programming languages including Haskell and OCaml, all functions automatically support currying. Passing fewer arguments to a function than it has parameters results in a new function that expects the remaining parameters.</p><h2 id="some-rules" tabindex="-1">Some Rules</h2><p>The names of function parameters are irrelevant. For example, the function <code>λx.x</code> is equivalent to the function <code>λy.y</code>.</p><p>The result of a function application is determined by substituting the argument value for all occurrences of the function parmameter. For example, <code>(λx.x + 3) 2</code> evaluates to <code>2 + 3</code> which evaluates to <code>5</code>.</p><h2 id="church-encoding-of-numbers" tabindex="-1">Church Encoding of Numbers</h2><p>While λ-calculus does not define numbers, we can select λ terms to represent each natural number. We can define functions that take another function <code>f</code> and a number <code>x</code> whose result is that of <code>f</code> being applied <code>x</code> times. Is is not the result of these functions that represent numbers, but rather the functions themselves.</p><p>In the table below, note the number of times the function <code>f</code> is applied on the right side of the period.</p><table><thead><tr><th>Number</th><th>λ term</th></tr></thead><tbody><tr><td>0</td><td><code>λfx.x</code></td></tr><tr><td>1</td><td><code>λfx.f x</code></td></tr><tr><td>2</td><td><code>λfx.f (f x)</code></td></tr><tr><td>3</td><td><code>λfx.f (f (f x))</code></td></tr></tbody></table><h2 id="addition" tabindex="-1">Addition</h2><p>Let's see how we can add 2 and 3 to get 5. See the representations for 2 and 3 in the table above.</p><p>Apply the arguments <code>f</code> and <code>x</code> to the λ term for 3, to get the result of the function application.</p><pre class="language-text"><code class="language-text">(λfx.f (f (f x))) f x<br>f (f (f x))</code></pre><p>Substitute the term above for <code>x</code> on the right side of the λ term for 2.</p><pre class="language-text"><code class="language-text">(λfx.f (f x            )) -- term for 2<br>(λfx.f (f (f (f (f x))))) -- term for 5</code></pre><p>An add function can be written as <code>λfxmn. (m f) (n f x)</code> where <code>m</code> and <code>n</code> are the two numbers to be added.</p><p>For example, here are the steps to use this function to add 2 and 3.</p><pre class="language-text"><code class="language-text">(λfxmn. (m f) (n f x)) 2 3<br>-- Substitute 2 for m and 3 for n.<br>λfx. (2           f) (3               f x)<br>-- Substiture the λ terms for 2 and 3.<br>λfx. (λfx.f (f x) f) (λfx.f (f (f x)) f x)<br>-- Apply the arguments f and x in the last term.<br>λfx. (λfx.f (f x) f) (f (f (f x)))<br>-- Apply the argument f in the last term.<br>λfx. (λx.f (f x)) (f (f (f x)))<br>-- Apply the argument `(f (f (f x)))` to the function on its left.<br>λfx. f (f (f (f (f x))))<br>-- This is the definition of the number 5.</code></pre><h2 id="multiplication" tabindex="-1">Multiplication</h2><p>Let's see how we can multiply 2 and 3 to get 6. See the representations for 2 and 3 in the table above.</p><p>The λ term for 3, <code>λfx.f (f (f x))</code>, is a function that has two parameters. Apply <code>f</code> to this to get the single parameter function <code>λx.f (f (f x))</code>.</p><p>The λ term for 2, <code>λfx.f (f x)</code>, is also a function that has two parameters. Apply the previous result as the value of the <code>f</code> parameter in this. Two substitutions are required, resulting in:</p><pre class="language-text"><code class="language-text">λx.(λx.f (f (f x))) (λx.f (f (f x)) x)</code></pre><p>Simplify the expression on the right to get:</p><pre class="language-text"><code class="language-text">λx.f (f (f x)) (f (f (f x)))</code></pre><p>Substitute the term on the right as value for <code>x</code> in the term on the left to get</p><pre class="language-text"><code class="language-text">λx.f (f (f (f (f (f x))))) -- term for 6</code></pre><p>A multiply function can be written as <code>λfxmn. m (n f) x</code> where <code>m</code> and <code>n</code> are the two numbers to be multiplied.</p><p>For example, here are the steps to use this function to multiply 2 and 3.</p><pre class="language-text"><code class="language-text">(λfxmn. m (n f) x) 2 3<br>-- Substitute 2 for m and 3 for n.<br>λfx. 2 (3 f) x<br>-- Apply the argument x.<br>λf. 2 (3 f)<br>-- Substiture the λ terms for 2 and 3.<br>λf. λfx.f (fx) (λfx.f (f (f x)) f)<br>- Apply the argument f in the last term to get a function that only takes x.<br>- It seems either argument can be supplied, not just the last.<br>λf. λfx.f(f x) (λx.f (f (f x)))<br>- Apply the new last term as the value of the parameter f in the first term<br>- to get a function that only takes x.<br>λf. λx.(λx.f (f (f x))) ((λx.f (f (f x))) x)<br><br><br>-- Apply the last term as the argument x in the first term.<br>λf. λf.f(f(λfx.f(f(fx)) f))<br>-- HOW DO I GET TO THIS?<br>λf. f(f(f(f(f(fx)))))<br><br>-- This is the definition of the number 6.</code></pre><h2 id="exponentiation" tabindex="-1">Exponentiation</h2><h2 id="boolean-logic" tabindex="-1">Boolean Logic</h2></article>