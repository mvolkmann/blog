<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Lambda Calculus</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#resources">Resources</a></li><li><a href="#history">History</a></li><li><a href="#concepts">Concepts</a></li><li><a href="#variables">Variables</a></li><li><a href="#function-syntax">Function Syntax</a></li><li><a href="#evaluation-rules">Evaluation Rules</a></li><li><a href="#testing">Testing</a></li><li><a href="#boolean-logic">Boolean Logic</a><ol><li><a href="#true-and-false">True and False</a></li><li><a href="#not-function">Not Function</a></li><li><a href="#and-function">And Function</a></li><li><a href="#or-function">Or Function</a></li><li><a href="#if-expressions">If Expressions</a></li></ol></li><li><a href="#arithmetic">Arithmetic</a><ol><li><a href="#church-numerals">Church Numerals</a></li><li><a href="#successor">Successor</a></li><li><a href="#predecessor">Predecessor</a></li><li><a href="#is-zero">Is Zero</a></li><li><a href="#addition">Addition</a></li><li><a href="#subtraction">Subtraction</a></li><li><a href="#multiplication">Multiplication</a></li><li><a href="#division">Division</a></li><li><a href="#exponentiation">Exponentiation</a></li></ol></li><li><a href="#equality">Equality</a></li><li><a href="#function-composition">Function Composition</a></li><li><a href="#recursion">Recursion</a><ol><li><a href="#y-combinator">Y Combinator</a></li><li><a href="#z-combinator">Z Combinator</a></li></ol></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank">Lambda calculus</a> (sometimes written as 位-calculus) describes concepts that are fundamental to functional programming such as first-class functions and currying. A first-class function can take other functions as arguments and can return a function. Currying represents a function with multiple parameters as a sequence of functions that each have a single parameter.</p><p>The purpose of 位-calculus is to study how functions can interact with each other, not to calculate results in a useful way.</p><p>The word &quot;calculus&quot; has four meanings, the last of which applies here.</p><ol><li>In mathematics it is a method of calculation known as differential or integral calculus.</li><li>In pathology it is a stone or concretion often formed in the gallbladder or kidneys.</li><li>In dentistry it is a hard, yellowish or brownish deposit on teeth, also known as tartar.</li><li>A method of calculating, judging, or deciding something in a complicated situation.</li></ol><p>Despite lacking many features found in programming languages, 位-calculus is Turing complete.</p><p>Throughout this post examples are shown in both 位-calculus and the closest equivalent in JavaScript. JavaScript implementations of all the functions described here can be found in this <a href="https://github.com/mvolkmann/lambda-calculus/blob/main/lambda-calculus.test.ts" target="_blank">GitHub repository</a>.</p><h2 id="resources" tabindex="-1">Resources</h2><ul><li><a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank">Lambda calculus</a> page on Wikipedia</li><li><a href="https://learnxinyminutes.com/docs/lambda-calculus/" target="_blank">Learn X in Y minutes Where X=Lambda Calculus</a></li><li><a href="https://www.lesswrong.com/posts/D4PYwNtYNwsgoixGa/intro-to-hacking-with-the-lambda-calculus" target="_blank">Intro to hacking with the lambda calculus</a> blog post by L Rudolf L</li><li><a href="https://www.youtube.com/watch?v=3VQ382QG-y4" target="_blank">Fundamentals of Lambda Calculus &amp; Functional Programming in JavaScript</a> YouTube talk by Gabriel Lebec</li></ul><h2 id="history" tabindex="-1">History</h2><p><a href="https://en.wikipedia.org/wiki/Gottlob_Frege" target="_blank">Gottlob Frege</a> (1848-1925) studied the use of functions in logic in 1893.</p><p><a href="https://en.wikipedia.org/wiki/Moses_Sch枚nfinkel" target="_blank">Moses Sch枚nfinkel</a> (1888-1942) studied how combinators can be applied to formal logic in the 1920s. The term &quot;combinator&quot; has two meanings, both of which describe a kind of function. The first describes functions that have no free variables. It combines only its arguments to produce a result. The second describes functions that take other functions and combine them to create a new function.</p><p><a href="https://en.wikipedia.org/wiki/Alonzo_Church" target="_blank">Alonzo Church</a> (1903-1985) invented Lambda Calculus in the 1930s. He was the PhD advisor of <a href="https://en.wikipedia.org/wiki/Alan_Turing" target="_blank">Alan Turing</a> (1912-1954).</p><h2 id="concepts" tabindex="-1">Concepts</h2><p>位-calculus only defines three concepts, referred to as lambda terms:</p><ul><li><p>variable: placeholder for a term represented by a single-letter name</p><p>There are two kinds of variables, bound and free, that are discussed later.</p></li><li><p>lambda abstraction: defines an anonymous function that has exactly one parameter</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位&lt;parameter&gt;.&lt;body&gt;</code></td><td><code>parameter =&gt; body</code></td></tr></tbody></table><p><code>&lt;parameter&gt;</code> is a single variable that is also referred to as a meta-variable.</p><p>The body of a function extends as far right as possible.<br>So <code>位x.a b c x</code> is evaluated as <code>位x.(((a b) c) x)</code><br>which is different from <code>((位x.a b) c) x</code>.<br>The expression <code>位x.位y.位z.a b c</code> is evaluated as <code>位x.(位y.(位z.a b c))</code>.</p><p>Expressions like <code>位x.位y.位z.a b c</code> are sometimes written in the shorthand form <code>位xyz.a b c</code> despite the fact that 位-calculus functions only have a single parameter.</p></li><li><p>application: calls a function with arguments</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>(位&lt;parameter&gt;.&lt;body&gt;) &lt;argument&gt;</code></td><td><code>(parameter =&gt; body)(argument)</code></td></tr><tr><td><code>(位xyz.&lt;body&gt;) a b c</code></td><td><code>(x =&gt; y =&gt; z =&gt; body)(a)(b)(c)</code></td></tr></tbody></table><p><code>&lt;arguments&gt;</code> is a whitespace-separated list of expressions. Function application is left associative. So <code>a b c d</code> is evaluated as <code>((a b) c) d</code>.</p></li></ul><p>位-calculus does not define a syntax for values such as booleans, numbers, and strings. It also does not define operators on these types or any built-in functions. However, these can be defined using only the concepts listed above.</p><h2 id="variables" tabindex="-1">Variables</h2><p>There are two kinds of variables, bound and free. Bound variables are bound by a specific abstraction (function). They appear as function parameters and represent an input value. Free variables appear in function definitions, are not parameters, and can represent any value. The following tables contains examples.</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th><th>Bound Variables</th><th>Free Variables</th></tr></thead><tbody><tr><td><code>位x.(+ x 1)</code></td><td><code>x =&gt; x + 1</code></td><td><code>x</code></td><td>none</td></tr><tr><td><code>位x.(+ y 1)</code></td><td><code>x =&gt; y + 1</code></td><td>none</td><td><code>y</code></td></tr><tr><td><code>位x.x 位x.(+ x 1)</code></td><td><code>x =&gt; x((x =&gt; x + 1))</code></td><td>rename 2nd <code>x</code> as shown below</td><td></td></tr><tr><td><code>位x.x 位y.(+ y 1)</code></td><td><code>x =&gt; x((y =&gt; y + 1))</code></td><td><code>x</code> and <code>y</code></td><td>none</td></tr></tbody></table><p>The last two examples above assume that <code>x</code> is a function that does not necessarily correspond to a number.</p><h2 id="function-syntax" tabindex="-1">Function Syntax</h2><p>An identity function that just returns the value passed in can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位x.x</code></td><td><code>x =&gt; x</code></td></tr></tbody></table><p>Function defintions begin with the 位 character, followed by a single parameter name, a period, and the lambsda term to which the function evaluates.</p><p>Here is an example of calling the identity function which results in the value <code>y</code>. Parentheses are used to surround function defintions and enable them to be applied. They are also used to define the order of operations.</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>(位x.x) y</code></td><td><code>(x =&gt; x)(y)</code></td></tr></tbody></table><p>Functions in 位-calculus can only have a single parameter. To support the concept of multi-parameter functions, a function can be passed to another function. This is commonly used in programming languages for callback functions.</p><p>To demonstrate this we will write a function that adds two numbers. Recall that 位-calculus does not define numbers or operators. But for demonstration purposes, we can pretend that it does define numbers, basic math operators such as <code>+</code>, and the Boolean values <code>true</code> and <code>false</code>.</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位x. 位y.x + y</code></td><td><code>(x, y) =&gt; x + y</code></td></tr></tbody></table><p>A shorthand way of writing the 位-calculus function above is <code>位xy.x + y</code>. This is also sometimes written with a prefix operator as <code>位xy.(+ x y)</code>.</p><p>Chaining functions that each take a single argument is referred to as &quot;currying&quot;. This is a nod to the mathematician <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank">Haskell Curry</a> (1900-1982) who used the concept extensively in his research. However, the concept was initially defined by Gottlob Frege in 1893 before Haskell Curry was born.</p><p>The 位-calculus function above can be defined in JavaScript to support currying. This uses a function that returns another function.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token parameter">y</span> <span class="token operator">=></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token comment">// OR more compactly as:</span><br><span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token operator">=></span> <span class="token parameter">y</span> <span class="token operator">=></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><br><span class="token comment">// It can be called as follows:</span><br><span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 5 */</span></code></pre><p>In many functional programming languages including Haskell and OCaml, all functions automatically support currying. Passing fewer arguments to a function than it has parameters results in a new function that expects the remaining parameters.</p><h2 id="evaluation-rules" tabindex="-1">Evaluation Rules</h2><ul><li><p>-conversion (alpha)</p><p>This changes the names of bound variables (which match function parameters), resulting in equivalent functions. For example, the function <code>位x.x</code> is equivalent to the function <code>位y.y</code> and <code>(位fx.f (+ x 1))</code> is equivalent to <code>(位gy.g (+ y 1))</code>.</p></li><li><p>尾-reduction (beta)</p><p>This is used to apply arguments to a function. The result of a function application is determined by substituting the argument value for all occurrences of the function parmameter. For example, <code>(位x.x + 3) 2</code> evaluates to <code>2 + 3</code> which evaluates to <code>5</code>. Consider the function <code>(位fx.f (+ x 1))</code> which takes two arguments, a function and a number. We can apply two arguments with <code>(位fx.f (+ x 1)) (位x.(* x 2)) 3</code>. The result is <code>(位x.(* x 2)) (+ 3 1)</code>. The second term becomes just <code>4</code> using the 未-rule. We can apply a 尾-reduction again to obtain <code>(* 4 2)</code>. One more use of the 未-rule, gives <code>8</code>.</p></li><li><p>未-rule (delta)</p><p>This is used to evaluate functions that are assumed to be built-in. For example, <code>(+ 1 2)</code> can be evaluated to <code>3</code>.</p></li><li><p>畏-conversion (eta)</p><p>This replaces a function that has an explicit parameter with one that takes an implicit parameter, creating a point-free version of the function. For example, <code>位x.(+ x 1)</code> is equivalent to <code>(+ x)</code> because <code>+</code> is a a function that takes two arguments, but only one is supplied.</p></li></ul><h2 id="testing" tabindex="-1">Testing</h2><p>When implementing 位-calculus functions in programming languages, it is useful to be able to convert 位-calculus representations to actual boolean values and numbers.</p><p>In JavaScript this can be accomplished with the following functions where <code>b</code> is a 位-calculus function that represents true or false and <code>n</code> is a 位-calculus function that represents a natural number:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">jsbool</span> <span class="token operator">=</span> <span class="token parameter">b</span> <span class="token operator">=></span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token function-variable function">jsnum</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=></span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="boolean-logic" tabindex="-1">Boolean Logic</h2><h3 id="true-and-false" tabindex="-1">True and False</h3><p>The Boolean value true is represented by:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位t. 位f. t</code></td><td><code>t =&gt; f =&gt; t</code></td></tr></tbody></table><p>This takes two arguments and returns the first.</p><p>In the examples that follow, the JavaScript function above is represented by <code>true_</code> to avoid conflicting with the JavaScript keyword <code>true</code>.</p><p>The Boolean value false is represented by:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位t. 位f. f</code></td><td><code>t =&gt; f =&gt; f</code></td></tr></tbody></table><p>This takes two arguments and returns the second. It is the same as the function that represents the number zero (below).</p><p>In the examples that follow, the JavaScript function above is represented by <code>false_</code> to avoid conflicting with the JavaScript keyword <code>false</code>.</p><h3 id="not-function" tabindex="-1">Not Function</h3><p>A function to return &quot;not&quot; of a Boolean value, where <code>b</code> is either the true or false function, can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位b.b false true</code></td><td><code>b =&gt; b(false_)(true_)</code></td></tr></tbody></table><p>For example, <code>(位b.b false true) (位t. 位f. t)</code> evaluates to false. <code>(位b.b false true) (位t. 位f. f)</code> evaluates to true.</p><h3 id="and-function" tabindex="-1">And Function</h3><p>A function to return the result of and'ing two Boolean values can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位x. 位y. x y false</code></td><td><code>x =&gt; y =&gt; x(y)(false_)</code></td></tr></tbody></table><p>If the first argument is <code>false</code>, that is the result. Otherwise the second argument is the result. Replacing <code>false</code> with <code>x</code> results in an equivalent definition because the that is only returned when <code>x</code> evaluates to <code>false</code>.</p><p>In a lazily evaluated programmming language like Haskell, the second argument is only evaluated if the first argument evaluates to true. In a strictly evaluated programming language like JavaScript, both arguments are always evaluated.</p><pre class="language-text"><code class="language-text">(位x.  位y. x y false) true true<br>true true false<br>(位t. 位f. t) true false<br>true<br><br>(位x. 位y. x y false) true false<br>true false false<br>(位t. 位f. t) false false<br>false<br><br>(位x. 位y. x y false) false true<br>false true false<br>(位t. 位f. f) true false<br>false<br><br>(位x. 位y. x y false) false false<br>false false false<br>(位t. 位f. f) false false<br>false</code></pre><h3 id="or-function" tabindex="-1">Or Function</h3><p>A function to return the result of or'ing two Boolean values can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位x. 位y. x true y</code></td><td><code>x =&gt; y =&gt; x(true_)(y)</code></td></tr></tbody></table><p>If the first argument is <code>true</code>, that is the result. Otherwise the second argument is the result. Replacing <code>true</code> with <code>x</code> results in an equivalent definition because the that is only returned when <code>x</code> evaluates to <code>true</code>.</p><p>In a lazily evaluated programmming language like Haskell, the second argument is only evaluated if the first argument evaluates to false. In a strictly evaluated programming language like JavaScript, both arguments are always evaluated.</p><pre class="language-text"><code class="language-text">(位x. 位y. x true y) true true<br>true true true<br>(位t. 位f. t) true true<br>true<br><br>(位x. 位y. x true y) true false<br>true true false<br>(位t. 位f. t) true false<br>true<br><br>(位x. 位y. x true y) false true<br>false true true<br>(位t. 位f. f) true true<br>true<br><br>(位x. 位y. x true y) false false<br>false true false<br>(位t. 位f. f) true false<br>false</code></pre><h3 id="if-expressions" tabindex="-1">If Expressions</h3><p>A function that models an &quot;if expression&quot; can be defined as follows where <code>c</code> is the condition to be tested, <code>x</code> is the result if <code>c</code> evaluates to true, and <code>y</code> is the result if <code>c</code> evaluates to false:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位x. 位y. x true y</code></td><td><code>x =&gt; y =&gt; x(true_)(y)</code></td></tr></tbody></table><p>This works because the function that represents <code>true</code> returns its first argument and the function that represents <code>false</code> returns its second argument.</p><p>In strictly-evaluated languages like JavaScript, this definition assumes it is acceptable to evaluate both the <code>x</code> and <code>y</code> expressions. This can be problematic when the evaluations are expensive or when recursion is involved. To solve this, the <code>if</code> function can be implemented as follows where <code>b</code> is a Boolean value, <code>t</code> is a function that can be called to get the true value, and <code>f</code> is a function that can be called to get the false value.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">if_</span> <span class="token operator">=</span> <span class="token parameter">b</span> <span class="token operator">=></span> <span class="token parameter">t</span> <span class="token operator">=></span> <span class="token parameter">f</span> <span class="token operator">=></span> <span class="token function">b</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 位btf.(b t f)(_)</span></code></pre><h2 id="arithmetic" tabindex="-1">Arithmetic</h2><h3 id="church-numerals" tabindex="-1">Church Numerals</h3><p>While 位-calculus does not define numbers, we can select 位 terms to represent each natural number (non-negative integers). We can define functions that take another function <code>f</code> and a number <code>x</code> whose result is that of <code>f</code> being applied <code>x</code> times. It is not the result of these functions that represent numbers, but rather the functions themselves.</p><p>In the table below, note the number of times the function <code>f</code> is applied on the right side of the period.</p><table><thead><tr><th>Number</th><th>位 term</th><th>JavaScript</th></tr></thead><tbody><tr><td>0</td><td><code>位fx.x</code></td><td><code>f =&gt; x =&gt; x</code></td></tr><tr><td>1</td><td><code>位fx.f x</code></td><td><code>f =&gt; x =&gt; f(x)</code></td></tr><tr><td>2</td><td><code>位fx.f (f x)</code></td><td><code>f =&gt; x =&gt; f(f(x))</code></td></tr><tr><td>3</td><td><code>位fx.f (f (f x))</code></td><td><code>f =&gt; x =&gt; f(f(f(x)))</code></td></tr></tbody></table><p>The function that represents zero is the same as the function that represents false (above).</p><p>These functions that represent numbers take another function and a value. They call the given function some number of times, initiallly passing it the value and subsequently passing it what the function returns. For example, the following JavaScript outputs the five numbers 3, 6, 12, 24, and 48.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">demo</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> x <span class="token operator">+</span> x<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token function">five</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="successor" tabindex="-1">Successor</h3><p>The successor function (succ) returns the number that follows a given number. It can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位n (位f. 位x. f (n f x))</code></td><td><code>x =&gt; y =&gt; x(true_)(y)</code></td></tr></tbody></table><p>For example, the successor of 1 is 2.</p><pre class="language-text"><code class="language-text">(位n (位f. 位x. f (n f x))) 1<br>(位n (位f. 位x. f (n f x))) (位fx.f x)<br>位f. 位x. f ((位fx.f x) f x)<br>位f. 位x. f (f x)<br>位fx.f (f x)<br>2</code></pre><h3 id="predecessor" tabindex="-1">Predecessor</h3><p>The predecessor function (pred) returns the number that precedes a given number. It is one of the most compilicated functions in 位-calculus.</p><p>Alonzo Church was unable to discover a definition for the predecessor function. A student of his, Stephen Kleene (1909-1994), arrived at a solution while in a dentist chair for wisdom teeth removal. Kleene is most known for his research into recursion theory.</p><p>Suppose the goal is to find the predecessor of 3 which is 2.<br>Start with the pair (0, 0).<br>Apply a function to the pair three times whose result is a new pair composed of the second number and the successor of the second number. This yields (0, 1), (1, 2), and (2, 3). Take the first number of the final pair.</p><p>A function to represent a pair can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位x.位y.位f.f x y</code></td><td><code>x =&gt; y =&gt; f =&gt; f(x)(y)</code></td></tr></tbody></table><p>A function to get the first element of a pair <code>p</code> can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位p.p TRUE</code></td><td><code>p =&gt; p(true_)</code></td></tr></tbody></table><p>A function to get the second element of a pair <code>p</code> can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位p.p FALSE</code></td><td><code>p =&gt; p(false_)</code></td></tr></tbody></table><p>Let's use the name &quot;phi&quot; to refer to a function that takes a pair and returns a new pair composed of the second element and the successor of the second element. This can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位p.pair (snd p) (succ (snd p))</code></td><td><code>p =&gt; pair(snd(p))(succ(snd(p)))</code></td></tr></tbody></table><p>The term &quot;<code>n phi</code>&quot; represents n applications of the phi function.</p><p>We can now define the predecessor function as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位n.fst (n phi (pair zero zero))</code></td><td><code>n =&gt; fst(n(phi)(pair(zero)(zero)))</code></td></tr></tbody></table><p>The Wikipedia page for &quot;Lambda Calculus&quot; defines the predecessor function as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位n (位f. 位x. n (位g.位h. h (g f)) (位u.x) (位u.u))</code></td><td><code>n =&gt; f =&gt; x =&gt; n(g =&gt; h =&gt; h(g(f)))(u =&gt; x)(u =&gt; u)</code></td></tr></tbody></table><h3 id="is-zero" tabindex="-1">Is Zero</h3><p>A function to determine whether its argument is the zero function can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位n.n (位x.FALSE) TRUE</code></td><td><code>n =&gt; n(x =&gt; false_)(true_)</code></td></tr></tbody></table><p>Let's verify that this works for 0 and 1.</p><pre class="language-text"><code class="language-text">(位n.n (位x.FALSE) TRUE) 位fx.x<br>位fx.x (位x.FALSE) TRUE -- f is not used in the body<br>(位x.x) TRUE<br>TRUE<br><br>(位n.n (位x.FALSE) TRUE) (位fx.f x)<br>位fx.f x (位x.FALSE) TRUE -- f is used in the body<br>(位x.FALSE) TRUE<br>FALSE</code></pre><h3 id="addition" tabindex="-1">Addition</h3><p>Addition can be seen as iterated successions. An add function can be defined as;</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位mn. (m succ) n</code></td><td><code>m =&gt; n =&gt; m(succ)(n)</code></td></tr></tbody></table><p>For example, here are the steps to use this function to add 2 and 3. See the representations for 2 and 3 in the table above.</p><pre class="language-text"><code class="language-text">(位mn. (m succ) n) 2 3<br>(2 succ) 3<br>((位fx.f (f x)) succ) 3<br>(位x.succ (succ x)) 3<br>succ (succ 3)<br>succ (succ (位fx.f (f (f x))))<br>succ (位fx.f (f (f (f x))))<br>位fx.f (f (f (f (f x))))<br>5</code></pre><h3 id="subtraction" tabindex="-1">Subtraction</h3><p>Substraction can be seen as iterated predecessors. A subtraction function can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位mn. (n pred) m</code></td><td><code>m =&gt; n =&gt; n(pred)(m)</code></td></tr></tbody></table><p>This returns <code>zero</code> if <code>m</code> is less than <code>n</code> because we don't have a way to represent negative numbers.</p><h3 id="multiplication" tabindex="-1">Multiplication</h3><p>Multiplication can be seen as iterated addition. A multiply function (mul) can be written as the following where <code>m</code> and <code>n</code> are the two numbers to be multiplied:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位mn. m (add n) 0</code></td><td><code>m =&gt; n =&gt; m(add(n))(zero)</code></td></tr></tbody></table><p>The functions above are correct, but multiplication is also the same as the composition of two numbers. See the &quot;Function Composition&quot; section below.</p><p>For example, here are the steps to use this function to multiply 2 and 3. See the representations for 2 and 3 in the table above.</p><pre class="language-text"><code class="language-text">(位mn. m (add n) 0) 2 3<br>2 (add 3) 0<br>(位fx.f (f x)) (add 3) 0<br>(add 3) ((add 3) 0)<br>add 3 3<br>-- We can assume the add function works and skip to the result of 6.<br>(位mn. (m succ) n) 3 3<br>(3 succ) 3<br>(位fx.f (f (f x))) succ 3<br>succ (succ (succ 3))<br>succ (succ 4)<br>succ 5<br>6 which is represented by 位fx.f (f (f (f (f (f x)))))</code></pre><h3 id="division" tabindex="-1">Division</h3><p>Division of integer numbers usually results in a floating point result and there isn't an easy way to represent floating point numbers in 位-calculus. We could define division as iterated subtraction and make the result be the number of times that one integers goes into another.</p><p>TODO: Add this.</p><h3 id="exponentiation" tabindex="-1">Exponentiation</h3><p>Exponentiation can be seen as iterated multiplicaation. An exponentiation function (exp) can be defined as the following where <code>m</code> is the base and <code>n</code> is the exponent:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位mn. n (mul m) 1</code></td><td><code>m =&gt; n =&gt; n(mul(m))(one)</code></td></tr></tbody></table><p>For example, here are the steps to raise 2 to the 3rd power. See the representations for 2 and 3 in the table above.</p><pre class="language-text"><code class="language-text">(位mn. n (mul m) 1) 2 3<br>3 (mul 2) 1<br>(位fx.f (f (f x))) (mul 2) 1<br>-- We can assume the mul function works.<br>(mul 2) ((mul 2) ((mul 2) 1))<br>(mul 2) ((mul 2) 2)<br>(mul 2) 4<br>8</code></pre><p>An exponentiation function can be defined even more simply as reverse function composition.</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位mn. n m</code></td><td><code>m =&gt; n =&gt; n(m)</code></td></tr></tbody></table><pre class="language-text"><code class="language-text">(位mn. n m) 2 3<br>3 2<br>(位fx.f (f (f x))) 2<br>位x.2 (2 (2 x))<br>which is 2 times 2 times 2 which is 8.</code></pre><h2 id="equality" tabindex="-1">Equality</h2><p>A function to determine if two Boolean values are equal can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位ab. (or (and a b) (and (not a) (not b)))</code></td><td><code>a =&gt; b =&gt; or(and(a)(b))(and(not(a))(not(b)))</code></td></tr></tbody></table><p>A function to determine if two numbers are equal can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位mn.and (iszero (sub m n)) (iszero (sub n m))</code></td><td><code>m =&gt; n =&gt; and(iszero(sub(m)(n)))(iszero(sub(n)(m)))</code></td></tr></tbody></table><p>We have to test both argument orders because our <code>sub</code> function returns zero when the first number is less than the last number.</p><h2 id="function-composition" tabindex="-1">Function Composition</h2><p>A function to compose two functions can be defined as:</p><table><thead><tr><th>位-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>位fgx.f (g x)</code></td><td><code>f =&gt; g =&gt; x =&gt; f(g(x))</code></td></tr></tbody></table><h2 id="recursion" tabindex="-1">Recursion</h2><p>Functions in 位-calculus do not have names. This leaves no way for a function to refer to itself which makes implementing recursion difficult.</p><p>Consider the expression <code>(位x.x x) (位x.x x)</code> which is called the omega (惟) combinator. Substituting the second term for <code>x</code> in the first term yields the exact same pair of expressions. This repeats forever, creating an infinite loop.</p><h3 id="y-combinator" tabindex="-1">Y Combinator</h3><p>The Y combinator, invented by Haskell Curry, is a function that implements recursion and provides a way of implementing loops. It adds use of the function parameter <code>f</code> to the previous definition, which represents the computation to be performed in each iteration. It is defined as <code>位f.(位x.f (x x)) (位x.f (x x))</code>. Note that the body contains two identical terms.</p><p>The Y combinator is intended to be used in lazily evaluated languages like Haskell. When used in a strictly evaluated language like JavaScript, it will loop endless until the heap space is exhausted and the program crashes.</p><p>We can attempt to define a factorial function as:</p><pre class="language-text"><code class="language-text">fact = 位n.if (iszero n) 1 (mult n (fact (pred n)))</code></pre><p>This assumes that functions have names that can be used to call themselves, but they do not.</p><p>Instead we can use the Y combinator to define a factorial function. Note how this differs slightly from the defintion above in order to work in a strictly evaluated language. TODO: Is the modified version equivalent to the Z combinator?</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">Y</span> <span class="token operator">=</span> <span class="token parameter">f</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">y</span> <span class="token operator">=></span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 位f.(位x.x x) (位x.f (x x))</span></code></pre><p>Next, we need a function to compute a single result in a factorial sequence. This function is not recursive because 位-calculus doesn't support named functions. The function <code>f</code> is a parameter of this function and is used to simulate recursion.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">facgen</span> <span class="token operator">=</span> <span class="token parameter">f</span> <span class="token operator">=></span> <span class="token parameter">n</span> <span class="token operator">=></span> <span class="token function">iszero</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> one<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">mul</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token function">sub</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Breaking this down, <code>iszero(n)</code> selects one of the following functions:</p><ul><li>If true then <code>(() =&gt; one)</code> is selected.</li><li>if false then <code>(() =&gt; mul(n)(f(sub(n)(one))))</code> is selected.</li></ul><p>The selected function is then invoked with <code>()</code>.</p><p>Finally, we can define a function that combines the Y combinator and the <code>facgen</code> function.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> factorial <span class="token operator">=</span> <span class="token constant">Y</span><span class="token punctuation">(</span>facgen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>factorial(zero)</code> returns the function for <code>one</code>.<br><code>factorial(one)</code> returns the function for <code>one</code>.<br><code>factorial(two)</code> returns the function for <code>two</code>.<br><code>factorial(three)</code> returns the function for <code>six</code>.<br>and so on.</p><h3 id="z-combinator" tabindex="-1">Z Combinator</h3><p>The Z combinator is similar to the Y combinator, but it provides lazy evaluation, defering function applications until their results are needed. It is an eta-expansion of the Y combinator which can be defined as:</p><pre class="language-text"><code class="language-text">Z = 位f.(位x.f(位v.x x v))(位x.f (位v.x x v))</code></pre><p>It can also be defined as the following where <code>M</code> is the Mockingbird function:</p><pre class="language-text"><code class="language-text">位f.M (位x.f (位v.M x v))</code></pre><p>A JavaScript implementation can be defined as:</p><pre class="language-js"><code class="language-js"><span class="token comment">// Note that the two terms at the end are identical.</span><br><span class="token keyword">const</span> <span class="token function-variable function">Z</span> <span class="token operator">=</span> <span class="token parameter">f</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">y</span> <span class="token operator">=></span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">y</span> <span class="token operator">=></span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This can be used in place of the <code>Y</code> function above to define a factorial function.</p></article>