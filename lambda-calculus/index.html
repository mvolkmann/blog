<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Lambda Calculus</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#history">History</a></li><li><a href="#concepts">Concepts</a></li><li><a href="#function-syntax">Function Syntax</a></li><li><a href="#evaluation-rules">Evaluation Rules</a></li><li><a href="#church-numberals">Church Numberals</a></li><li><a href="#addition">Addition</a></li><li><a href="#multiplication">Multiplication</a></li><li><a href="#exponentiation">Exponentiation</a></li><li><a href="#boolean-logic">Boolean Logic</a></li><li><a href="#recursion">Recursion</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank">Lambda calculus</a> (sometimes written as λ-calculus) describes concepts that are fundamental to functional programming. It's purpose is to study how functions can interact with each other, not to calculate results in a useful way.</p><p>Despite lacking many features found in programming languages, λ-calculus is Turing complete.</p><p>Throughout this post examples are shown in both λ-calculus and the closest equivalent in JavaScript.</p><h2 id="history" tabindex="-1">History</h2><p><a href="https://en.wikipedia.org/wiki/Gottlob_Frege" target="_blank">Gottlob Frege</a> (1848-1925) studied the use of functions in logic in 1893.</p><p><a href="https://en.wikipedia.org/wiki/Moses_Schönfinkel" target="_blank">Moses Schönfinkel</a> (1888-1942) studied how combinators can be applied to formal logic in the 1920s. The term &quot;combinator&quot; has two meanings, both which describe a kind of function. The first describes functions that have no free variables. The second describes functions that take other functions and combine them to create new functions.</p><p><a href="https://en.wikipedia.org/wiki/Alonzo_Church" target="_blank">Alonzo Church</a> (1903-1985) invented Lambda Calculus in the 1930s. He was the PhD advisor of <a href="https://en.wikipedia.org/wiki/Alan_Turing" target="_blank">Alan Turing</a> (1912-1954).</p><h2 id="concepts" tabindex="-1">Concepts</h2><p>λ-calculus only defines three concepts, referred to as lambda terms:</p><ul><li><p>variable: gives a single-letter name to a value</p></li><li><p>lambda abstraction: defines an anonymous function that has exactly one parameter</p><p>This uses the syntax <code>λ&lt;parameter&gt;.&lt;body&gt;</code> where <code>&lt;parameter&gt;</code> is a single variable.</p><p>The body of a function extends as far right as possible. So <code>λx.a b c x</code> is evaluated as <code>λx.(((a b) c) x)</code> which is different from <code>((λx.a b) c) x</code>. The expression <code>λx.λy.λz.a b c</code> is evaluated as <code>λx.(λy.(λz.a b c))</code>.</p><p>Expressions like <code>λx.λy.λz.a b c</code> are sometimes written in the shorter form <code>λxyz.a b c</code> despite the fact that λ-calculus functions only have a single parameter.</p></li><li><p>application: calls a function with arguments</p><p>This uses the syntax <code>(λ&lt;parameter&gt;.&lt;expression&gt;) &lt;arguments&gt;</code> where <code>&lt;arguments&gt;</code> is a whitespace-separated list of expressions. Function application is left associative. So <code>a b c d</code> is evaluated as <code>((a b) c) d</code>.</p></li></ul><p>λ-calculus does not define a syntax for values such as booleans, numbers, and strings. It also does not define operators on these types or any built-in functions. However, these can be defined using only the concepts listed above.</p><p>There are two kinds of variables, bound and free. Bound variables are bound by a specific abstraction (function). They appear as function parameters and represent an input value. Free variables appear in function definitions, are not parameters, and can represent any value. The following tables contains examples.</p><table><thead><tr><th>Expression</th><th>Bound Variables</th><th>Free Variables</th></tr></thead><tbody><tr><td><code>λx.(+ x 1)</code></td><td><code>x</code></td><td>none</td></tr><tr><td><code>λx.(+ y 1)</code></td><td>none</td><td><code>y</code></td></tr><tr><td><code>λx.x λx.(+ x 1)</code></td><td>rename 2nd <code>x</code> as shown below</td><td></td></tr><tr><td><code>λx.x λy.(+ y 1)</code></td><td><code>x</code> and <code>y</code></td><td>none</td></tr></tbody></table><h2 id="function-syntax" tabindex="-1">Function Syntax</h2><p>Here is an identity function that just returns the value passed in.</p><table><thead><tr><th>λ-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td>λx.x</td><td>x =&gt; x</td></tr></tbody></table><p>Function defintions begin with the λ character, followed by a single parameter name, a period, and the lambsda term to which the function evaluates.</p><p>Here is an example of calling the identity function which results in the value <code>y</code>. Parentheses are used to surround function defintions and enable them to be applied. They are also used to define the order of operations.</p><table><thead><tr><th>λ-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td>(λx.x) y</td><td>(x =&gt; x)(y)</td></tr></tbody></table><p>Functions in λ-calculus can only have a single parameter. To support the concept of multi-parameter functions, a function can be passed to another function. This is commonly used in programming languages for callback functions.</p><p>To demonstrate this we will write a function that adds two numbers. Recall that λ-calculus does not define numbers or operators. But for demonstration purposes, we can pretend that it does define numbers, basic math operators such as <code>+</code>, and the Boolean values <code>true</code> and <code>false</code>.</p><table><thead><tr><th>λ-calculus</th><th>JavaScript</th></tr></thead><tbody><tr><td>λx. (λy.x + y)</td><td>(x, y) =&gt; x + y</td></tr></tbody></table><p>Shorthand ways of writing the λ-calculus function above are <code>λx.λy.x + y</code> (parentheses not necessary) and <code>λxy.x + y</code>. This is also sometimes written with a prefix operator as <code>λxy.(+ x y)</code>.</p><p>This is referred to as &quot;currying&quot; which is a nod to the mathematician <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank">Haskell Curry</a> (1900-1982) who used the concept extensively in his research. However, the concept was initially defined by Gottlob Frege in 1893 before Haskell Curry was born.</p><p>The JavaScript function above could be defined and called as follows to support currying. This uses a function that returns another function.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token parameter">y</span> <span class="token operator">=></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 5 */</span></code></pre><p>In many functional programming languages including Haskell and OCaml, all functions automatically support currying. Passing fewer arguments to a function than it has parameters results in a new function that expects the remaining parameters.</p><h2 id="evaluation-rules" tabindex="-1">Evaluation Rules</h2><ul><li><p>δ-rule (delta)</p><p>This is used to evaluate functions that are assumed to be built-in. For example, <code>(+ 1 2)</code> can be evaluated to <code>3</code>.</p></li><li><p>β-reduction (beta)</p><p>This is used to apply arguments to a function. The result of a function application is determined by substituting the argument value for all occurrences of the function parmameter. For example, <code>(λx.x + 3) 2</code> evaluates to <code>2 + 3</code> which evaluates to <code>5</code>. Consider the function <code>(λfx.f (+ x 1))</code> which takes two arguments, a function and a number. We can apply two arguments with <code>(λfx.f (+ x 1)) (λx.(* x 2)) 3</code>. The result is <code>(λx.(* x 2)) (+ 3 1)</code>. The second term becomes just <code>4</code> using the δ-rule. We can apply a β-reduction again to obtain <code>(* 4 2)</code>. One more use of the δ-rule, gives <code>8</code>.</p></li><li><p>𝛼-conversion (alpha)</p><p>This changes the names of a function parameters, resulting in equivalent functions. For example, the function <code>λx.x</code> is equivalent to the function <code>λy.y</code> and <code>(λfx.f (+ x 1))</code> is equivalent to <code>(λgy.g (+ y 1))</code>.</p></li><li><p>η-conversion (eta)</p><p>This replaces a function that has an explicit parameter with one that takes an implicit parameter, creating a point-free version of the function. For example, <code>λx.(+ x 1)</code> is equivalent to <code>(+ x)</code> because <code>+</code> is a a function that takes two arguments, but only one is supplied.</p></li></ul><h2 id="church-numberals" tabindex="-1">Church Numberals</h2><p>While λ-calculus does not define numbers, we can select λ terms to represent each natural number. We can define functions that take another function <code>f</code> and a number <code>x</code> whose result is that of <code>f</code> being applied <code>x</code> times. Is is not the result of these functions that represent numbers, but rather the functions themselves.</p><p>In the table below, note the number of times the function <code>f</code> is applied on the right side of the period.</p><table><thead><tr><th>Number</th><th>λ term</th></tr></thead><tbody><tr><td>0</td><td><code>λfx.x</code></td></tr><tr><td>1</td><td><code>λfx.f x</code></td></tr><tr><td>2</td><td><code>λfx.f (f x)</code></td></tr><tr><td>3</td><td><code>λfx.f (f (f x))</code></td></tr></tbody></table><p>The successor function <code>λn (λf. λx. f (n f x))</code> returns the number that follows a given number. For example, the successo of 1 is 2.</p><pre class="language-text"><code class="language-text">(λn (λf. λx. f (n f x))) 1<br>(λn (λf. λx. f (n f x))) (λfx.f x)<br>λf. λx. f ((λfx.f x) f x)<br>λf. λx. f (f x)<br>λfx.f (f x)<br>2</code></pre><h2 id="addition" tabindex="-1">Addition</h2><p>Addition can be seen as interated succession. An add function can be written as <code>λmn. (m successor) n</code>. For example, here are the steps to use this function to add 2 and 3. See the representations for 2 and 3 in the table above.</p><pre class="language-text"><code class="language-text">(λmn. (m successor) n) 2 3<br>(2 successor) 3<br>((λfx.f (f x)) successor) 3<br>(λx.successor (successor x)) 3<br>successor (successor 3)<br>successor (successor (λfx.f (f (f x))))<br>successor (λfx.f (f (f (f x))))<br>λfx.f (f (f (f (f x))))<br>5</code></pre><h2 id="multiplication" tabindex="-1">Multiplication</h2><p>Multiplication can be seen as interated addition. A multiply function (mul) can be written as <code>λmn. m (add n) 0</code> where <code>m</code> and <code>n</code> are the two numbers to be multiplied. For example, here are the steps to use this function to multiply 2 and 3. See the representations for 2 and 3 in the table above.</p><pre class="language-text"><code class="language-text">(λmn. m (add n) 0) 2 3<br>2 (add 3) 0<br>(λfx.f (f x)) (add 3) 0<br>(add 3) ((add 3) 0)<br>add 3 3<br>-- We can assume the add function works and skip to the result of 6.<br>(λmn. (m successor) n) 3 3<br>(3 successor) 3<br>(λfx.f (f (f x))) successor 3<br>successor (successor (successor 3))<br>successor (successor 4)<br>successor 5<br>6 which is represented by λfx.f (f (f (f (f (f x)))))</code></pre><h2 id="exponentiation" tabindex="-1">Exponentiation</h2><p>Exponentiation can be seen as interated multiplicaation. An exponentiation function (exp) can be written as <code>λmn. n (mul m) 1</code> where <code>m</code> is the base and <code>n</code> is the exponent. For example, here are the steps to raise 2 to the 3rd power. See the representations for 2 and 3 in the table above.</p><pre class="language-text"><code class="language-text">(λmn. n (mul m) 1) 2 3<br>3 (mul 2) 1<br>(λfx.f (f (f x))) (mul 2) 1<br>-- We can assume the mull function works.<br>(mul 2) ((mul 2) ((mul 2) 1))<br>(mul 2) ((mul 2) 2)<br>(mul 2) 4<br>8</code></pre><p>Does this defintion also work? <code>λmn. n m</code></p><pre class="language-text"><code class="language-text">(λmn. n m) 2 3<br>3 2<br>(λfx.f (f (f x))) (λfx.f (f x))<br>-- Apply the right term as the value of the "x" parameter in the left term.<br>(λf.f (f (f (λfx.f (f x)))))<br>TODO: What can be done from here to arrive at 8?</code></pre><h2 id="boolean-logic" tabindex="-1">Boolean Logic</h2><p>The Boolean value true is represented by the function <code>(λt. λf. t)</code>. This takes two arguments and returns the first.</p><p>The Boolean value false is represented by the function <code>(λt. λf. f)</code>. This takes two arguments and returns the second. This is the same as the function that represents the number zero.</p><p>A function to return &quot;not&quot; of a Boolean value is <code>λb. b false true</code>. where <code>b</code> is either the true or false function. For example, <code>(λb. b false true) (λt. λf. t)</code> evaluates to false. <code>(λb. b false true) (λt. λf. f)</code> evaluates to true.</p><p>A function to return the result of and'ing two Boolean values is <code>λx. (λy. x y false)</code>.</p><pre class="language-text"><code class="language-text">(λx. (λy. x y false)) true true<br>true true false<br>(λt. λf. t) true false<br>true<br><br>(λx. (λy. x y false)) true false<br>true false false<br>(λt. λf. t) false false<br>false<br><br>(λx. (λy. x y false)) false true<br>false true false<br>(λt. λf. f) true false<br>false<br><br>(λx. (λy. x y false)) false false<br>false false false<br>(λt. λf. f) false false<br>false</code></pre><p>A function to return the result of or'ing two Boolean values is <code>λx. (λy. x true y)</code>.</p><pre class="language-text"><code class="language-text">(λx. (λy. x true y)) true true<br>true true true<br>(λt. λf. t) true true<br>true<br><br>(λx. (λy. x true y)) true false<br>true true false<br>(λt. λf. t) true false<br>true<br><br>(λx. (λy. x true y)) false true<br>false true true<br>(λt. λf. f) true true<br>true<br><br>(λx. (λy. x true y)) false false<br>false true false<br>(λt. λf. f) true false<br>false</code></pre><h2 id="recursion" tabindex="-1">Recursion</h2><p>TODO: Cover the y-combinator function.</p></article>