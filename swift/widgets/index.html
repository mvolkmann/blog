<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Widgets</h2><aside><nav class="toc"><ol><li><a href="#setup-steps">Setup Steps</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#configuration">Configuration</a></li><li><a href="#adding-files">Adding Files</a></li><li><a href="#data">Data</a></li><li><a href="#widget-sizes">Widget Sizes</a></li><li><a href="#reload-budget">Reload Budget</a></li><li><a href="#widget-title">Widget Title</a></li><li><a href="#updating-widgets">Updating Widgets</a></li></ol></nav></aside><article><h2 id="setup-steps">Setup Steps</h2><ul><li>Create a new iOS app in Xcode. The project name will be the name of the widget displayed to the user, so choose a name that will be meaningful to users.</li><li>To enable users to configure the widget, check the checkbox for &quot;Include Configuration Intent&quot;</li><li>Select File ... New ... Target...</li><li>Select &quot;Widget Extension&quot;.</li><li>Click the &quot;Next&quot; button.</li><li>In &quot;Product Name&quot;, enter a widget name typically ending in &quot;Widget&quot;.</li><li>Click the &quot;Finish&quot; button.</li><li>Click the &quot;Activate&quot; button.</li></ul><p>This creates a new folder in the Navigator whose name matches the widget name. This folder will contain a <code>.swift</code> file whose name also matches the widget name. The file contains starting code that only renders the current time.</p><h2 id="terminology">Terminology</h2><p>Timeline - an array of <code>TimelineEntry</code> objects that describe when the widget display should be updated</p><p>Entry - struct that holds data used by the widget</p><p>The provided sample code defines the struct <code>SimpleEntry</code>. Rename this to be relevant to your widget.</p><p>Reload Policy - determines when the widget requests a new timeline; options include:</p><ul><li><code>atEnd</code> to get a new timeline after the last date in the current line passes</li><li><code>after</code> to get a new timeline after a specified date/time</li><li><code>never</code> to only get a new timeline when the app makes one available</li></ul><h2 id="configuration">Configuration</h2><p>Widgets can have static configuration that users cannot customize or an <code>IntentConfiguration</code> which allows users to long press the widget to reveal customization options.</p><h2 id="adding-files">Adding Files</h2><p>When adding source files within the widget folder of the Navigator, add them to the widget extension target. To do this, click a file in the Navigator, open the Inspector on the right, and click the checkbox for the target under &quot;Target Membership&quot;.</p><h2 id="data">Data</h2><p>Widgets can get data from network calls.</p><h2 id="widget-sizes">Widget Sizes</h2><p>Four sizes can be supported. These are represented by the</p><p>To specify the sizes a widget supports, call <code>.supportedFamilies(sizes)</code> on the <code>IntentConfiguration</code> object returned by the <code>body</code> computed property of the struct that inherits from <code>Widget</code>. The value passed to this (<code>sizes</code>) is an array of <code>WidgetFamily</code> enum values that include <code>.systemSmall</code>, <code>.systemMedium</code>, <code>.systemLarge</code>, and <code>systemExtraLarge</code>.</p><p>When users install the widget they can select one of the supported sizes. The selected size can be determined from the following environment value:</p><pre class="language-swift"><code class="language-swift"><span class="token attribute atrule">@Environment</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">.</span>widgetFamily<span class="token punctuation">)</span> <span class="token keyword">var</span> family</code></pre><p>This value can be used in the <code>body</code> computed property of the struct that inherits from <code>View</code> to decide what to render.</p><h2 id="reload-budget">Reload Budget</h2><p>In order to conserve system resources and battery, iOS limits the number of times a widget can be reloaded each day. A typical number of daily refreshes is between 40 and 70 which is approximately every 15 to 60 minutes.</p><p>For more detail, see <a href="https://developer.apple.com/documentation/widgetkit/keeping-a-widget-up-to-date?v=1.0.20" rel="noopener" target="_blank">Keeping a Widget Up To Date</a>.</p><h2 id="widget-title">Widget Title</h2><p>The title displayed under the widget is the display name of the associated app. To configure this, clicking the top entry in the Navigator, select the app target, click the &quot;General&quot; tab, and enter a title in the &quot;Display Name&quot; input in the &quot;Identity&quot; section. The widget target also has a &quot;Display Name&quot; value but it's unclear how that is used.</p><h2 id="updating-widgets">Updating Widgets</h2><p>iOS limits the frequency of widget updates as described in the &quot;Reload Budget&quot; section above.</p><p>Each widget defines a <code>Provider</code> struct that includes a <code>getTimeline</code> method. This method creates an array of objects that inherit from <code>TimelineEntry</code>. These provide data to the widget. The array must contain at least one entry object.</p><p>The next step is to create a <code>Timeline</code> object that holds the array of entry objects and specifies an update policy. Finally, the completion handler function passed to the <code>getTimeline</code> method must be called, passing it the <code>Timeline</code> object.</p><p>Here is an example using the <code>after</code> policy:</p><pre class="language-swift"><code class="language-swift"><span class="token comment">// A request to update the widget sooner than 15 minutes from now will</span><br><span class="token comment">// likely not be honored and will instead occur in 15 minutes or later.</span><br><span class="token keyword">let</span> later <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">addingTimeInterval</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token comment">// seconds</span><br><span class="token keyword">let</span> timeline <span class="token operator">=</span> <span class="token class-name">Timeline</span><span class="token punctuation">(</span>entries<span class="token punctuation">:</span> entries<span class="token punctuation">,</span> policy<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>later<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token function">completion</span><span class="token punctuation">(</span>timeline<span class="token punctuation">)</span></code></pre><p>There are three update policies to choose from: <code>atEnd</code>, <code>after</code>, and <code>never</code>. Each of these determine when the <code>getTimeline</code> method should be called again which creates a new array of entry objects and triggers a new round of widget updates.</p><p>The <code>.atEnd</code> policy triggers a new round of updates after the widget is updated using the final entry in the array.</p><p>The <code>.after(someDate)</code> policy triggers a new round of updates after a given date/time is passed.</p><p>The <code>.never</code> policy indicates that the associated application will take responsibility for indicating when the widget will be update. The app can do this by importing <code>WidgetKit</code> and running code like the following:</p><pre class="language-swift"><code class="language-swift"><span class="token class-name">WidgetCenter</span><span class="token punctuation">.</span>shared<span class="token punctuation">.</span>getCurrentConfigurations <span class="token punctuation">{</span> result <span class="token keyword">in</span><br>    <span class="token keyword">guard</span> <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">let</span> widgets<span class="token punctuation">)</span> <span class="token operator">=</span> result <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span><br>    <span class="token keyword">for</span> widget <span class="token keyword">in</span> widgets <span class="token punctuation">{</span><br>        <span class="token class-name">WidgetCenter</span><span class="token punctuation">.</span>shared<span class="token punctuation">.</span><span class="token function">reloadTimelines</span><span class="token punctuation">(</span>ofKind<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>kind<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></article>