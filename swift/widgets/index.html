<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Widgets</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#managing-home-screen-widgets">Managing Home Screen Widgets</a></li><li><a href="#managing-lock-screen-widgets">Managing Lock Screen Widgets</a></li><li><a href="#setup-steps">Setup Steps</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#adding-files">Adding Files</a></li><li><a href="#static-widgets">Static Widgets</a></li><li><a href="#configurable-widgets">Configurable Widgets</a></li><li><a href="#data">Data</a></li><li><a href="#widget-sizes">Widget Sizes</a></li><li><a href="#reload-budget">Reload Budget</a></li><li><a href="#widget-title">Widget Title</a></li><li><a href="#updating-widgets">Updating Widgets</a></li><li><a href="#touch-targets-in-widgets">Touch Targets in Widgets</a></li><li><a href="#debugging-output">Debugging Output</a></li><li><a href="#full-example">Full Example</a></li><li><a href="#running-widget-code">Running Widget Code</a></li><li><a href="#making-a-widget-configurable">Making a Widget Configurable</a></li><li><a href="#customizing-%22add-widget%22-button-color">Customizing "Add Widget" Button Color</a></li><li><a href="#multiple-tap-targets">Multiple Tap Targets</a></li><li><a href="#supporting-multiple-widgets">Supporting Multiple Widgets</a></li><li><a href="#sharing-data-between-app-and-widgets">Sharing Data Between App and Widgets</a></li><li><a href="#lock-screen-widgets">Lock Screen Widgets</a></li><li><a href="#%22live-activities%22-widgets">"Live Activities" Widgets</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p>Widgets provide a view of data associated with an app. Tapping a widget launches the associated app. A widget can define multiple touch targets that each launch the app starting on a different screen.</p><p>Widgets are read-only and cannot use input views like <code>Button</code> and <code>TextField</code>. If such views are included, the widget will compile and the views will render. However, tapping input views will launch the associated app rather than allow the user to interact with them.</p><p>As of iOS 16 there are three kinds of widgets: home screen widgets, lock screen widgets, and live activity widgets.</p><h2 id="managing-home-screen-widgets" tabindex="-1">Managing Home Screen Widgets</h2><p>To add a home screen widget:</p><ul><li>Install the app.</li><li>Long press any home screen.</li><li>Tap the &quot;+&quot; in the upper-left.</li><li>Scroll down to find the app name and tap it.</li><li>Scroll horizontally until the desired size preview is displayed.</li><li>Tap the &quot;Add Widget&quot; button.</li></ul><p>To rearrange widgets:</p><ul><li>Long press any home screen.</li><li>Drag widgets to their desired location.</li><li>Press the &quot;Done&quot; button in the upper-right.</li></ul><p>To remove a widget:</p><ul><li>Long press the widget.</li><li>Select &quot;Remove Widget&quot;.</li></ul><p>To configure a widget:</p><ul><li>Long press the widget.</li><li>Select &quot;Edit Widget&quot; (only appears for widgets that support editing).</li><li>Make choices from the presented options.</li><li>Tap outside the widget to save the changes and close it.</li></ul><h2 id="managing-lock-screen-widgets" tabindex="-1">Managing Lock Screen Widgets</h2><p>Lock screen widgets are only supported in iOS 16 and above.</p><p>Lock screens display a selected wallpaper. It seems that wallpapers created before iOS 16 do not support lock screen widgets. Apparently lock screen widgets can only be added to wallpapers created in iOS 16.</p><p>To select a lock screen wallpaper to customize:</p><ul><li>Long press on the current lock screen.</li><li>Authenticate with Face ID if requested.</li><li>Scroll horizontally to select the wallpaper to customize.</li><li>Tap the &quot;Customize&quot; button below a wallpaper or tap the &quot;+&quot; button on the &quot;ADD NEW&quot; wallpaper to create a new one. If the &quot;Customize&quot; button below a pre-iOS 16 wallpaper is tapped, the only option is &quot;ADD NEW&quot;.</li></ul><p>An alternative way to select a wallpaper to customize is to:</p><ul><li>Open the Settings app.</li><li>Select &quot;Wallpaper&quot;.</li><li>Tap the &quot;Customize&quot; button below an existing wallpaper or tap &quot;Add New Wallpaper&quot;.</li><li>Tap &quot;Add New&quot;.</li></ul><p>To customize the widgets on a wallpaper:</p><ul><li>Tap the outlined area below the time to display a sheet of widgets that can be added.</li><li>Select any number widgets to add, but only as many as will fit in the area.</li><li>Close the sheet by tapping the &quot;X&quot; button or tapping outside the sheet.</li></ul><p>To delete a lock screen widget from the wallpaper being customized, tap it and then tap the &quot;-&quot; button that appears.</p><h2 id="setup-steps" tabindex="-1">Setup Steps</h2><ul><li>Create a new iOS app in Xcode. The project name will be the name of the widget displayed to the user, so choose a name that will be meaningful to users.</li><li>Select File ... New ... Target...</li><li>Select &quot;Widget Extension&quot;.</li><li>Click the &quot;Next&quot; button.</li><li>In &quot;Product Name&quot;, enter a name such as simply &quot;Widget&quot; when the app with have only one associated widget or &quot;Widgets&quot; when the app with have multiple associated widget.</li><li>To enable users to configure the widget, check the checkbox for &quot;Include Configuration Intent&quot;.</li><li>Click the &quot;Finish&quot; button.</li><li>Click the &quot;Activate&quot; button.</li></ul><p>This creates a new folder in the Navigator whose name matches the new target name. This folder will contain a <code>.swift</code> file whose name also matches the target name. This file contains starting code that only renders the current time.</p><h2 id="terminology" tabindex="-1">Terminology</h2><p>Timeline - an array of <code>TimelineEntry</code> objects that describe when the widget display should be updated</p><p>Entry - struct that holds data used by the widget</p><p>The provided sample code defines the struct <code>SimpleEntry</code>. Rename this to be relevant to your widget.</p><p>Reload Policy - determines when the widget requests a new timeline; options include:</p><ul><li><code>atEnd</code> to get a new timeline after the last date in the current line passes</li><li><code>after</code> to get a new timeline after a specified date/time</li><li><code>never</code> to only get a new timeline when the app makes one available</li></ul><h2 id="adding-files" tabindex="-1">Adding Files</h2><p>After adding source files within the widget group in the Navigator, add them to the widget extension target. To do this, click a file in the Navigator, open the Inspector on the right, and click the checkbox for the widget target under &quot;Target Membership&quot;.</p><h2 id="static-widgets" tabindex="-1">Static Widgets</h2><p>Static widgets cannot be configured by the user and have a somewhat simpler implementation.</p><h2 id="configurable-widgets" tabindex="-1">Configurable Widgets</h2><h2 id="data" tabindex="-1">Data</h2><p>Widgets can get data from network calls.</p><h2 id="widget-sizes" tabindex="-1">Widget Sizes</h2><p>Four sizes can be supported. These are represented by the</p><p>To specify the sizes a widget supports, call <code>.supportedFamilies(sizes)</code> on the <code>IntentConfiguration</code> object returned by the <code>body</code> computed property of the struct that inherits from <code>Widget</code>. The value passed to this (<code>sizes</code>) is an array of <code>WidgetFamily</code> enum values that include <code>.systemSmall</code>, <code>.systemMedium</code>, <code>.systemLarge</code>, and <code>systemExtraLarge</code>.</p><p>When users install the widget they can select one of the supported sizes. The selected size can be determined from the following environment value:</p><pre class="language-swift"><code class="language-swift"><span class="token attribute atrule">@Environment</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">.</span>widgetFamily<span class="token punctuation">)</span> <span class="token keyword">var</span> family</code></pre><p>This value can be used in the <code>body</code> computed property of the struct that inherits from <code>View</code> to decide what to render.</p><p>To determine the selected widget size in the <code>getTimeline</code> method in order to provide different entry data based on this, use <code>context.family</code> which has an enum value of type <code>WidgetFamily</code>.</p><h2 id="reload-budget" tabindex="-1">Reload Budget</h2><p>In order to conserve system resources and battery, iOS limits the number of times a widget can be reloaded each day. A typical number of daily refreshes is between 40 and 70 which is approximately every 15 to 60 minutes.</p><p>For more detail, see <a href="https://developer.apple.com/documentation/widgetkit/keeping-a-widget-up-to-date?v=1.0.21" rel="noopener" target="_blank">Keeping a Widget Up To Date</a>.</p><h2 id="widget-title" tabindex="-1">Widget Title</h2><p>The title displayed under the widget is the display name of the associated app. To configure this, clicking the top entry in the Navigator, select the app target, click the &quot;General&quot; tab, and enter a title in the &quot;Display Name&quot; input in the &quot;Identity&quot; section. The widget target also has a &quot;Display Name&quot; value but it's unclear how that is used.</p><h2 id="updating-widgets" tabindex="-1">Updating Widgets</h2><p>iOS limits the frequency of widget updates as described in the &quot;Reload Budget&quot; section above.</p><p>Each widget defines a <code>Provider</code> struct that includes a <code>getTimeline</code> method. This method creates an array of objects that inherit from <code>TimelineEntry</code>. These provide data to the widget. They must contain a <code>date</code> property of type <code>Date</code>, but can include additional properties. They can define methods, but none are required. The array must contain at least one entry object.</p><p>The next step is to create a <code>Timeline</code> object that holds the array of entry objects and specifies an update policy. Finally, the completion handler function passed to the <code>getTimeline</code> method must be called, passing it the <code>Timeline</code> object.</p><p>Here is an example using the <code>after</code> policy:</p><pre class="language-swift"><code class="language-swift"><span class="token comment">// A request to update the widget sooner than 15 minutes from now will</span><br><span class="token comment">// likely not be honored and will instead occur in 15 minutes or later.</span><br><span class="token keyword">let</span> later <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">addingTimeInterval</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token comment">// seconds</span><br><span class="token keyword">let</span> timeline <span class="token operator">=</span> <span class="token class-name">Timeline</span><span class="token punctuation">(</span>entries<span class="token punctuation">:</span> entries<span class="token punctuation">,</span> policy<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>later<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token function">completion</span><span class="token punctuation">(</span>timeline<span class="token punctuation">)</span></code></pre><p>There are three update policies to choose from: <code>atEnd</code>, <code>after</code>, and <code>never</code>. Each of these determine when the <code>getTimeline</code> method should be called again which creates a new array of entry objects and triggers a new round of widget updates.</p><p>The <code>.atEnd</code> policy triggers a new round of updates after the widget is updated using the final entry in the array.</p><p>The <code>.after(someDate)</code> policy triggers a new round of updates after a given date/time is passed.</p><p>The <code>.never</code> policy indicates that the associated application will take responsibility for indicating when the widget will be update. The app can do this by importing <code>WidgetKit</code> and running code like the following:</p><pre class="language-swift"><code class="language-swift"><span class="token comment">// This reloads the timeline of all widgets associated with the app.</span><br><span class="token class-name">WidgetCenter</span><span class="token punctuation">.</span>shared<span class="token punctuation">.</span><span class="token function">reloadAllTimelines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><br><span class="token comment">// This approach can be used to only reload the timeline of some of the widgets.</span><br><span class="token class-name">WidgetCenter</span><span class="token punctuation">.</span>shared<span class="token punctuation">.</span>getCurrentConfigurations <span class="token punctuation">{</span> result <span class="token keyword">in</span><br>    <span class="token keyword">guard</span> <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">let</span> widgets<span class="token punctuation">)</span> <span class="token operator">=</span> result <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span><br>    <span class="token keyword">for</span> widget <span class="token keyword">in</span> widgets <span class="token punctuation">{</span><br>        <span class="token comment">// Could just call this with a hardcoded widget kind value.</span><br>        <span class="token class-name">WidgetCenter</span><span class="token punctuation">.</span>shared<span class="token punctuation">.</span><span class="token function">reloadTimelines</span><span class="token punctuation">(</span>ofKind<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>kind<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="touch-targets-in-widgets" tabindex="-1">Touch Targets in Widgets</h2><p>All widget sizes except small can define multiple touch targets that when tapped open the associated app and navigate to a specific screen.</p><p>When a small-sized widget is tapped, it can navigate to a single specific screen in the app by calling <code>.widgetURL(&quot;some-screen-identifier&quot;)</code> on the outermost view rendered by the widget.</p><p>To define touch targets, wrap parts of the widget view in <code>Link</code> views that specify a <code>destination</code> URL. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token class-name">Link</span><span class="token punctuation">(</span>destination<span class="token punctuation">:</span> <span class="token function">URL</span><span class="token punctuation">(</span>string<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"screen-id-1"</span></span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// A section of the widget view goes here.</span><br><span class="token punctuation">}</span></code></pre><p>Suppose the app uses a <code>TabView</code> for displaying the main screens. In the source file that defines the <code>App</code> sub-struct add code like the following:</p><pre class="language-swift"><code class="language-swift"><span class="token attribute atrule">@State</span> <span class="token keyword">private</span> <span class="token keyword">var</span> selectedTag <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"screen-id-1"</span></span><br><br><span class="token keyword">var</span> body<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">Scene</span> <span class="token punctuation">{</span><br>    <span class="token class-name">WindowGroup</span> <span class="token punctuation">{</span><br>        <span class="token class-name">TabView</span><span class="token punctuation">(</span>selection<span class="token punctuation">:</span> $selectedTab<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token class-name">FirstScreen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span>tabItem <span class="token punctuation">{</span><br>                    <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Screen 1"</span></span><span class="token punctuation">,</span> systemImage<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"some-icon"</span></span><span class="token punctuation">)</span><br>                <span class="token punctuation">}</span><br>                <span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"screen-id-1"</span></span><span class="token punctuation">)</span><br>            <span class="token class-name">SecondScreen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span>tabItem <span class="token punctuation">{</span><br>                    <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Screen 2"</span></span><span class="token punctuation">,</span> systemImage<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"another-icon"</span></span><span class="token punctuation">)</span><br>                <span class="token punctuation">}</span><br>                <span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"screen-id-2"</span></span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>        <span class="token punctuation">.</span>onOpenURL <span class="token punctuation">{</span> url <span class="token keyword">in</span><br>            selectedTag <span class="token operator">=</span> url<span class="token punctuation">.</span>absoluteString<br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="debugging-output" tabindex="-1">Debugging Output</h2><p>To see output from <code>print</code> calls in widget code inside the Xcode console, run the widget target instead of the app target.</p><h2 id="full-example" tabindex="-1">Full Example</h2><p>For a full example of a widget, see the file <a href="https://github.com/mvolkmann/SwiftChartsDemo/blob/main/Widgets/HelloWidget.swift?v=1.0.21" rel="noopener" target="_blank">HelloWidget.swift</a> in the SwiftChartsDemo project.</p><h2 id="running-widget-code" tabindex="-1">Running Widget Code</h2><p>To run widget code instead of app code from Xcode, select the widget target from the target dropdown at the top.</p><h2 id="making-a-widget-configurable" tabindex="-1">Making a Widget Configurable</h2><p>Widgets can have static configuration that users cannot customize or an <code>IntentConfiguration</code> which allows users to long press the widget to reveal customization options.</p><p>The steps to make a widget configurable are:</p><ol><li><p>Verify that the widget target contains a <code>.intentdefinition</code> file. If not, add a new file to the target, select the &quot;SiriKit Intent Definition File&quot; template, click the &quot;+&quot; in the lower left, select select &quot;New Intent&quot;, check the checkbox for &quot;Intent is eligible for widgets&quot;, and uncheck the two checkboxes related to Siri.</p></li><li><p>If not already present, add an intent named &quot;Configuration&quot;.</p></li><li><p>Check the &quot;Intent is eligible for widgets&quot; checkbox.</p></li><li><p>Associate the <code>.intentdefinition</code> file with the app and widget target by checking the appropriate checkboxes in the file Inspector.</p></li><li><p>Create an <code>Info.plist</code> file in the widget directory.</p></li><li><p>Do not associate the <code>Info.plist</code> file with the widget target.</p></li><li><p>Add an array property named &quot;NSUserActivityTypes&quot;.</p></li><li><p>Add an element to the array with the value &quot;ConfigurationIntent&quot;.</p></li><li><p>Add and define parameters.</p></li></ol><p>The screenshot below shows defining a parameter called &quot;Name&quot; that allows the user to enter a name.</p><p><img alt="Widget Intent Configuration" style="width: 80%" src="/blog/assets/SwiftUI-widget-intent-configuration.png?v=1.0.21" title="Widget Intent Configuration"></p><p>Note that a &quot;Type&quot; (set to &quot;String&quot;), a &quot;Default Value&quot;, and a &quot;Siri Dialog Prompt&quot; are provided.</p><p>The parameter values entered by user, or their default values, can be accessed in the <code>getTimeline</code> method of the widgets `IntentTimelineProvider. This is where entry objects that provide data to the widget are created. For example, to access the value of the &quot;Name&quot; parameter in the screenshot above:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">let</span> name <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>forKey<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"Name"</span></span><span class="token punctuation">)</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token class-name">String</span> <span class="token operator">??</span> <span class="token string-literal"><span class="token string">"unknown"</span></span></code></pre><h2 id="customizing-%22add-widget%22-button-color" tabindex="-1">Customizing &quot;Add Widget&quot; Button Color</h2><p>When users go through the process of adding a widget, the &quot;Add Widget&quot; button has a default blue color. To customize this for a given widget:</p><ul><li>select the <code>Assets.xcassets</code> file of the widget in the Navigator</li><li>select &quot;AccentColor&quot;</li><li>select a color</li></ul><h2 id="multiple-tap-targets" tabindex="-1">Multiple Tap Targets</h2><p>A widget can include multiple tap targets that each open the associated app on a different screen.</p><p>TODO: Show how to implement this.</p><h2 id="supporting-multiple-widgets" tabindex="-1">Supporting Multiple Widgets</h2><p>To support more than one widget in an app, implement each widget as describe above and then define a <code>WidgetBundle</code> struct in the target of the widgets. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token class-name">SwiftUI</span><br><span class="token keyword">import</span> <span class="token class-name">WidgetKit</span><br><br><span class="token attribute atrule">@main</span><br><span class="token keyword">struct</span> <span class="token class-name">AppNameWidgets</span><span class="token punctuation">:</span> <span class="token class-name">WidgetBundle</span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> body<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><br>        <span class="token class-name">MyFirstWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token class-name">MySecondWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Remove the <code>@main</code> annotation from each of the widgets?</p><h2 id="sharing-data-between-app-and-widgets" tabindex="-1">Sharing Data Between App and Widgets</h2><ol><li>Select the top entry in the navigator.</li><li>Click the app target.</li><li>Click the &quot;Signing &amp; Capabilities&quot; tab.</li><li>Click the &quot;+&quot; in the upper left.</li><li>Double-click &quot;App Groups&quot;.</li><li>Click the &quot;+&quot; in the &quot;App Groups&quot; section.</li><li>Enter &quot;group.&quot; and the bundle identifier.</li><li>Click the widget target.</li><li>Repeat the previous steps to add the same app group.</li></ol><p><code>@AppStorage</code> provides an easier way to access data in UserDefaults. But supposedly widgets cannot use that. To access UserDefaults data in a widget <code>Provider</code> struct,</p><ol><li><p>Add the following at the top of the struct definition:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">let</span> userDefaults <span class="token operator">=</span> <span class="token class-name">UserDefaults</span><span class="token punctuation">(</span>suiteName<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"group.some.group.id"</span></span><span class="token punctuation">)</span><span class="token operator">!</span></code></pre></li><li><p>In the <code>getTimeline</code> method, get a value with the following:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">let</span> someValue <span class="token operator">=</span> userDefaults<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>forKey<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"someKey"</span></span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string-literal"><span class="token string">"someDefault"</span></span></code></pre></li></ol><h2 id="lock-screen-widgets" tabindex="-1">Lock Screen Widgets</h2><p>See <a href="https://swiftwithmajid.com/2022/08/30/lock-screen-widgets-in-swiftui/?v=1.0.21" rel="noopener" target="_blank">Lock screen widgets with SwiftUI</a>.</p><h2 id="%22live-activities%22-widgets" tabindex="-1">&quot;Live Activities&quot; Widgets</h2><p>iOS 16 beta 4 adds support for live activities widgets on the lock screen. These are supported by the new ActivityKit framework.</p><p>From <a href="https://developer.apple.com/news/?id=hi37aek8?v=1.0.21" rel="noopener" target="_blank">Apple News and Updates</a>, &quot;Live Activities and ActivityKit won’t be included in the initial public release of iOS 16. Later this year, they'll be publicly available in an update.&quot;</p><p>From <a href="https://developer.apple.com/documentation/activitykit/displaying-live-data-on-the-lock-screen-with-live-activities?v=1.0.21" rel="noopener" target="_blank">Displaying live data on the Lock Screen with Live Activities</a>, &quot;A Live Activity can be active for up to eight hours unless your app or the user explicitly ends it. After this limit, the system automatically ends a Live Activity if the user or your app hasn’t ended it. In this ended state, the Live Activity remains on the Lock Screen for up to four additional hours before the system removes it. The user can also choose to remove it. As a result, a Live Activity remains on the Lock Screen for a maximum of twelve hours.&quot;</p><p>&quot;Although Live Activities leverage WidgetKit’s functionality, they aren’t widgets. In contrast to the timeline mechanism you use to update the user interface of your widgets, you update a Live Activity from your app with ActivityKit or with remote push notifications.&quot;</p><p>&quot;To add support for Live Activities to your app:&quot;</p><ul><li>Create a widget extension if you haven’t already added one to your app.</li><li>Open your app’s <code>Info.plist</code> file and add an entry with the key <code>NSSupportsLiveActivities</code> of type Boolean with the value <code>YES</code>.</li><li>In your code, define a set of <code>ActivityAttributes</code> and the <code>Activity.ContentState</code> for your Live Activities. You’ll use them to start, update, and end a Live Activity.</li><li>Add code to create a widget and return an <code>ActivityConfiguration</code> in your widget implementation as shown in the example below.</li><li>If your app already contains a widget, add your Live Activity to your <code>WidgetBundle</code> or create one as described in Creating a Widget Extension. Skip this step if you only add a widget extension to support Live Activities.</li><li>Add code to start, update, and end the Live Activity and to create its user interface as described below.</li></ul><p>How can you enable live activities in the Settings app of the phone?</p><p>How can you use <code>areActivitiesEnabled</code> and <code>activityStateUpdates</code> to detect whether live activities are enabled on the phone?</p></article>