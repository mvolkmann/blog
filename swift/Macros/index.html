<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Macros</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#provided-macros">Provided Macros</a></li><li><a href="#third-party-macros">Third Party Macros</a></li><li><a href="#defining-macros">Defining Macros</a></li><li><a href="#macro-types">Macro Types</a></li><li><a href="#freestanding-macros">Freestanding Macros</a></li><li><a href="#attached-macros">Attached Macros</a></li><li><a href="#generics-in-macros">Generics in Macros</a></li><li><a href="#debugging-macros">Debugging Macros</a></li><li><a href="#using-custom-macros">Using Custom Macros</a></li><li><a href="#invoking-macros">Invoking Macros</a></li><li><a href="#unit-tests">Unit Tests</a></li><li><a href="#examples">Examples</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p>Swift macros &quot;allow you to generate repetitive code at compile-time&quot;.</p><p>Swift macros are:</p><ul><li>type-checked by the compiler before they are applied, unlike C macros which are applied before compile-time</li><li>additive, never modifying or deleting existing code</li><li>implemented in Swift</li><li>defined in compiler plugins</li></ul><p>For more detail, watch the WWDC 2023 videos:</p><ul><li><a href="https://developer.apple.com/wwdc23/10166?v=1.0.21" rel="noopener" target="_blank">Write Swift macros</a></li><li><a href="https://developer.apple.com/wwdc23/10167?v=1.0.21" rel="noopener" target="_blank">Expand on Swift macros</a>.</li></ul><h2 id="provided-macros" tabindex="-1">Provided Macros</h2><p>The following macros are provided by Swift and SwiftUI:</p><ul><li><p><a href="https://developer.apple.com/documentation/swift/optionset-swift.macro?v=1.0.21" rel="noopener" target="_blank">@OptionSet</a> creates an option set from a <code>struct</code> that contains a nested <code>Options</code> <code>enum</code>.</p></li><li><p><a href="https://developer.apple.com/documentation/widgetkit/preview-macros?v=1.0.21" rel="noopener" target="_blank">#Preview</a> generates code to display a preview of a SwiftUI widget in Xcode.</p></li><li><p>TODO: Find more of these.</p></li></ul><h2 id="third-party-macros" tabindex="-1">Third Party Macros</h2><p>The following macros are not provided by Apple:</p><ul><li><a href="https://github.com/ailtonvivaz/swift-request?v=1.0.21" rel="noopener" target="_blank">SwiftRequest</a> provides macros for sending all kinds of HTTP requests.</li></ul><h2 id="defining-macros" tabindex="-1">Defining Macros</h2><p>The steps to define a new macro are:</p><ol><li>Open Xcode.</li><li>Select New ... File ... Package</li><li>Select the &quot;Swift Macro&quot; template.</li><li>Click the &quot;Next&quot; button.</li><li>Enter a package name.</li><li>Select the directory where it will be saved.</li><li>Click the &quot;Create&quot; button.</li></ol><p>The generated file structure will contain the following:</p><ul><li><p><code>{package-name}</code> directory</p><ul><li><p><code>Package.swift</code></p><p>This describes the platforms on which the macro can run, its dependencies, and the targets it can create (definining library, client example, and unit tests).</p></li><li><p><code>Sources</code> directory</p><ul><li><p><code>{package-name}</code> directory</p><ul><li><p><code>{package-name}.swift</code></p><p>This file contains the declaration of the <code>stringify</code> macro which serves as an example macro This defines the macro signature. Add new macro declarations in this file and optionally delete the definition for the <code>stringify</code> macro.</p><pre class="language-swift"><code class="language-swift"><span class="token attribute atrule">@freestanding</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><br><span class="token keyword">public</span> macro stringify<span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>    <span class="token other-directive property">#externalMacro</span><span class="token punctuation">(</span><br>        <span class="token comment">// This refers to a Swift file below.</span><br>        module<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"MyFirstMacroMacros"</span></span><span class="token punctuation">,</span><br>        <span class="token comment">// This refers to the name of an ExpressionMacro subtype</span><br>        <span class="token comment">// define in the Swift file.</span><br>        type<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"StringifyMacro"</span></span><br>    <span class="token punctuation">)</span></code></pre></li></ul></li><li><p><code>{package-name}Client</code></p><ul><li><p><code>main.swift</code></p><p>This file contains an example of using the <code>stringify</code> macro. To see the definition (not implementation) of a given macro invocation, right-click it and select &quot;Jump to Definition&quot;. To run this, ???</p></li></ul></li><li><p><code>{package-name}Macros</code></p><ul><li><p><code>{package-name}Macro.swift</code></p><p>This file contains the implementation of the <code>stringify</code> macro. Add new macro implementations in this file and optionally delete the implementation for the <code>stringify</code> macro.</p><p>The following code is the stringify macro implementation with comments added:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">StringifyMacro</span><span class="token punctuation">:</span> <span class="token class-name">ExpressionMacro</span> <span class="token punctuation">{</span><br>    <span class="token comment">// This method is required by the ExpressionMacro protocol.</span><br>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function-definition function">expansion</span><span class="token punctuation">(</span><br>        <span class="token comment">// This argument is the AST of the passed expression.</span><br>        of node<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">FreestandingMacroExpansionSyntax</span><span class="token punctuation">,</span><br>        <span class="token comment">// This argument provides access to surrounding data.</span><br>        <span class="token keyword">in</span> context<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">MacroExpansionContext</span><br>    <span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">ExprSyntax</span> <span class="token punctuation">{</span><br>        <span class="token comment">// This evaluates the expression passed in</span><br>        <span class="token comment">// which was defined to be an Int.</span><br>        <span class="token keyword">guard</span> <span class="token keyword">let</span> argument <span class="token operator">=</span> node<span class="token punctuation">.</span>argumentList<span class="token punctuation">.</span>first<span class="token operator">?</span><span class="token punctuation">.</span>expression <span class="token keyword">else</span> <span class="token punctuation">{</span><br>            <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"compiler bug: the macro does not have any arguments"</span></span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// The string expression returned here</span><br>        <span class="token comment">// is automatically parsed into an AST.</span><br>        <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"(</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">argument</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">literal<span class="token punctuation">:</span> argument<span class="token punctuation">.</span>description</span><span class="token interpolation-punctuation punctuation">)</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></li></ul></li></ul></li><li><p><code>Tests</code> directory</p><ul><li><p><code>{package-name}Tests</code> directory</p><ul><li><p><code>{package-name}Tests.swift</code></p><p>This file contains unit tests for the macros. Each test function calls <code>assertMacroExpansion</code>, passing it a string that invokes a macro, the expected result, and a <code>macros</code> argument whose value is a <code>Dictionary</code> where the keys are macro names and the values are the corresponding macro definitions.</p><p>To run all the tests, select Product ... Test or press cmd-u.</p></li></ul></li></ul></li></ul></li></ul><p>Macro definitions are similar to function definitions. They begin with the <code>macro</code> keyword and are followed by a name, parameter list, and return type.</p><h2 id="macro-types" tabindex="-1">Macro Types</h2><ul><li><code>@freestanding(expression)</code> - creates code that returns a value</li><li><code>@freestanding(declaration)</code> - creates one or more declarations</li><li><code>@attached(peer)</code> - adds peer declarations next to an existing declaration</li><li><code>@attached(accessor)</code> - adds accessors to a property of a type</li><li><code>@attached(memberAttribute)</code> - adds attributes to declarations in a type</li><li><code>@attached(member)</code> - adds declarations inside a type on which it is applied</li><li><code>@attached(conformance)</code> - adds protocol conformances to a type</li></ul><p>Freestanding macros are invoked with a <code>#</code>. Attached macros are invoked with a <code>@</code>.</p><h2 id="freestanding-macros" tabindex="-1">Freestanding Macros</h2><p>Freestanding macro definitions begin with <code>@freestanding(expression)</code> and can be applied to any expression.</p><p>The source code of the expression is made available to the macro in an abstract syntax tree (AST).</p><p>The macro can transform the AST to provide the result AST which is used to generate source code that is then passed to the compiler.</p><h2 id="attached-macros" tabindex="-1">Attached Macros</h2><p>Attached macros augument Swift declarations for entities they decorate such as variables, functions, enums, structs, and classes.</p><h2 id="generics-in-macros" tabindex="-1">Generics in Macros</h2><p>Macros can be declared to use generic types in order to make them usable in more scenarios.</p><h2 id="debugging-macros" tabindex="-1">Debugging Macros</h2><p>To view the AST made available to a custom macro, set a breakpoint in the macro implementation and run a test that uses the macro. In the debugger, use the <code>po</code> command to pretty-print a variable that holds the AST.</p><h2 id="using-custom-macros" tabindex="-1">Using Custom Macros</h2><p>To use custom macros in a Swift project:</p><ul><li>Open the project in Xcode.</li><li>Right-click the top entry in the Project Navigator.</li><li>Select &quot;Add Package Dependencies...&quot;.</li><li>In the dialog that appears, click the &quot;Add Local...&quot; button.</li><li>Check the checkboxes for each of the packages that define the macros to be used.</li><li>Click the &quot;Add Package&quot; button.</li></ul><p>In each file that wishes to use the macros:</p><ul><li>Add <code>import {package-name}</code></li><li>Add macro invocations in the appropriate places in the source code.</li></ul><p>To see learn about a given macro, option-click an invocation to open a dialog containing the documentation.</p><p>To see the code generated by a given macro, right-click its invocation and select &quot;Expand Macro&quot;.</p><h2 id="invoking-macros" tabindex="-1">Invoking Macros</h2><p>A macro is invoked by preceding its name with a pound sign (<code>#</code>).</p><h2 id="unit-tests" tabindex="-1">Unit Tests</h2><p>Macro unit tests typically call the <code>assertMacroExpansion</code> function. That function takes a <code>diagnostics</code> argument whose value is an array of diagnostic messages that should be emitted when the macro is invoked incorrectly, such as when an attached macro is applied to the wrong kind of declaration.</p><p>Macros typically throw specific cases of a custom enum that conforms to the <code>CustomStringConvertible</code> and <code>Error</code> protocols. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token class-name">MyCustomError</span><span class="token punctuation">:</span> <span class="token class-name">CustomStringConvertible</span><span class="token punctuation">,</span> <span class="token class-name">Error</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> badThing1<br>    <span class="token keyword">case</span> badThing2<br><br>    <span class="token keyword">var</span> description<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span><br>        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span><br>            <span class="token keyword">case</span> <span class="token punctuation">.</span>badThing1<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"first bad thing happened"</span></span><br>            <span class="token keyword">case</span> <span class="token punctuation">.</span>badThing2<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"second bad thing happened"</span></span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>When non-test code uses a macro in a way that throws an error, the error message will appear in Xcode next to the offending line just like other compiler generated errors.</p><h2 id="examples" tabindex="-1">Examples</h2><ul><li><p><a href="https://github.com/mvolkmann/TypeInitMacro?v=1.0.21" rel="noopener" target="_blank">TypeInitMacro</a></p><p>This macro adds a member-wise initializer to a <code>class</code> or <code>struct</code>.</p></li></ul></article>