<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Project Structure</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#groups">Groups</a></li><li><a href="#group-and-file-order">Group and file order</a></li><li><a href="#view-models">View Models</a></li><li><a href="#services">Services</a></li><li><a href="#constants">Constants</a></li><li><a href="#order-within-files">Order Within Files</a></li><li><a href="#pragma-marks">Pragma Marks</a></li><li><a href="#indentation-and-wrapping-style">Indentation and wrapping style</a></li><li><a href="#use-swiftlint">Use SwiftLint</a></li><li><a href="#use-swiftformat">Use SwiftFormat</a></li><li><a href="#access-specifiers">Access Specifiers</a></li><li><a href="#protocols">Protocols</a></li><li><a href="#preference-for-async%2Fawait-over-completion-handlers-(callbacks)">Preference for async/await over completion handlers (callbacks)</a></li><li><a href="#emojis-in-debug-messages">Emojis in Debug Messages</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p>This post documents my recommended structure and practices for SwiftUI projects.</p><h2 id="groups" tabindex="-1">Groups</h2><p>Most files in a project should be placed in a group. Group names typically begin with an uppercase letter and do not contain spaces.</p><p>Recommended group names include:</p><ul><li><p>Config</p><p>This group includes files like <code>Assets.xcassets</code> and <code>.plist</code> files</p></li><li><p>Extensions</p><p>This group contains files that define extensions to built-in structs like <code>Date</code>, <code>String</code>, and <code>View</code>. These tend to be copied from project to project as they evolve. The names of files in this group should end with &quot;Extension&quot;.</p></li><li><p>Models</p><p>This group contains files that define model structs, classes, and enums. Instances of these hold all the data used by the app. The names of files in this group do not need to end with &quot;Model&quot;.</p></li><li><p>Screens</p><p>This group contains files that implement entire screens of the app as opposed to sections of a screen. Screens typically use views defined in the Views group. The names of files in this group should end with &quot;Screen&quot;.</p></li><li><p>Services</p><p>This group contains files that abstract away the details of network communication and interactions of packages like Core Data, CloudKit, and HealthKit. The names of files in this group should end with &quot;Service&quot;.</p></li><li><p>Views</p><p>This group contains files that define views used by screens and other views. The names of files in this group do not need to end with &quot;View&quot;.</p></li><li><p>ViewModels</p><p>This group contains files that define classes that inherit from <code>ObservableObject</code>, define <code>@Published</code> properties, and define methods that operate on the data they encapsulate. Views can use the properties and methods in these classes. The names of files in this group should end with &quot;ViewModel&quot;.</p></li></ul><h2 id="group-and-file-order" tabindex="-1">Group and file order</h2><p>Files not in any group, such as the main <code>*App.swift</code> belong above all the groups. The groups follow these files and should be in alphabetical order. The files within each group should be in alphabetical order.</p><h2 id="view-models" tabindex="-1">View Models</h2><p>In strict implementations of the MVVM pattern views get all their state data from view models and delegate all their non-view logic to view models.</p><p>In less strict implementations of the MVVM pattern, state data and logic that is specific to a single view is implemented in the view using <code>@State</code> properties. Only state data and logic that is used by multiple views is implemented in view model classes.</p><h2 id="services" tabindex="-1">Services</h2><p>Services are <code>.swift</code> files that abstract away the details of network communication and interactions with packages like Core Data, CloudKit, and HealthKit. View and view model source files should prefer using methods of services instead of directly coding such interactions.</p><h2 id="constants" tabindex="-1">Constants</h2><p>The Swift naming convention for constants is the same as for variables. They begin with a lowercase letter and use camel-case. This differs from most other programming languages that use all uppercase.</p><p>There are several ways to define constants in Swift.</p><p>One approach is to define static properties.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">let</span> defaultName <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Anonymous"</span></span><br><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">let</span> defaultSize <span class="token operator">=</span> <span class="token number">6.2</span></code></pre><p>Another approach is to wrap them in a case-less <code>enum</code>. Using an <code>enum</code> instead of a <code>struct</code> or <code>class</code> prevents creating instances of the wrapping construct.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token class-name">MyConstants</span> <span class="token punctuation">{</span><br>    <span class="token keyword">static</span> <span class="token keyword">let</span> <span class="token keyword">static</span> <span class="token keyword">let</span> defaultName <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Anonymous"</span></span><br>    <span class="token keyword">static</span> <span class="token keyword">let</span> <span class="token keyword">static</span> <span class="token keyword">let</span> defaultSize <span class="token operator">=</span> <span class="token number">6.2</span><br><span class="token punctuation">}</span></code></pre><p>Yet another approach is to use a normal <code>enum</code>. This has the advantage that <code>switch</code> statements can enforce exhaustive handling of the cases. However, it requires all cases to have the same type.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token class-name">MyConstants</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> defaultSize <span class="token operator">=</span> <span class="token number">6.2</span><br>    <span class="token keyword">case</span> smallSize <span class="token operator">=</span> <span class="token number">3.1</span><br>    <span class="token keyword">case</span> largeSize <span class="token operator">=</span> <span class="token number">13.1</span><br><span class="token punctuation">}</span></code></pre><h2 id="order-within-files" tabindex="-1">Order Within Files</h2><p>A recommended order for groups of items in a source file is:</p><ol><li>initializers</li><li>constants</li><li>state properties (properties with property wrappers like <code>@Environment</code>, <code>@EnvironmentObject</code>, <code>@Published</code>, and <code>@State</code>)</li><li>non-state properties (both normal and computed)</li><li>methods</li></ol><h2 id="pragma-marks" tabindex="-1">Pragma Marks</h2><p>Files over a certain size in number of lines should include pragma marks to separate sections. This adds labels in the Xcode final breadcrumb dropdown which makes it easier to select and jump to a specific item.</p><p>Each pragma mark is a single-line comment following the pattern:</p><pre class="language-swift"><code class="language-swift"><span class="token comment">// MARK: - section-name</span></code></pre><p>Including the hyphen adds a divider line in the breadcrumb dropdown.</p><h2 id="indentation-and-wrapping-style" tabindex="-1">Indentation and wrapping style</h2><p>Use 4-space indentation.</p><p>Most lines that are longer than 80 characters should be wrapped to be no longer than that in order to allow comfortably viewing two or three files side-by-side.</p><p><code>Array</code> and <code>Dictionary</code> literals that do not fit on a single line should place each item on a separate line, indented by four additional spaces. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token comment">// SwiftFormat "--wrapcollections before-first" does this.</span><br><span class="token keyword">let</span> colorNames <span class="token operator">=</span> <span class="token punctuation">[</span><br>    <span class="token string-literal"><span class="token string">"Red"</span></span><span class="token punctuation">,</span><br>    <span class="token string-literal"><span class="token string">"Green"</span></span><span class="token punctuation">,</span><br>    <span class="token string-literal"><span class="token string">"Blue"</span></span><br><span class="token punctuation">]</span><br><br><span class="token comment">// SwiftFormat "--wrapcollections before-first" does this.</span><br><span class="token keyword">let</span> colorNameToHex <span class="token operator">=</span> <span class="token punctuation">[</span><br>    <span class="token string-literal"><span class="token string">"Red"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"ff0000"</span></span><span class="token punctuation">,</span><br>    <span class="token string-literal"><span class="token string">"Green"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"00ff00"</span></span><span class="token punctuation">,</span><br>    <span class="token string-literal"><span class="token string">"Blue"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"0000ff"</span></span><br><span class="token punctuation">]</span></code></pre><p>Function signatures and calls that do not fit on a single line should place each parameter/argument on a separate line, indented by four additional spaces. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token comment">// SwiftFormat "--wrapparameters before-first" does this.</span><br><span class="token keyword">func</span> <span class="token function-definition function">myVeryLongFunctionName</span><span class="token punctuation">(</span><br>    veryLongLabelNumber1<span class="token punctuation">:</span> <span class="token class-name">Type1</span><span class="token punctuation">,</span><br>    veryLongLabelNumber2<span class="token punctuation">:</span> <span class="token class-name">Type2</span><span class="token punctuation">,</span><br>    veryLongLabelNumber3<span class="token punctuation">:</span> <span class="token class-name">Type3</span><br><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">ReturnType</span> <span class="token punctuation">{</span><br>    <span class="token operator">...</span> code goes here <span class="token operator">...</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// SwiftFormat "--wraparguments before-first" does this.</span><br><span class="token function">myVeryLongFunctionName</span><span class="token punctuation">(</span><br>    veryLongLabelNumber1<span class="token punctuation">:</span> veryLongValueNumber1<span class="token punctuation">,</span><br>    veryLongLabelNumber2<span class="token punctuation">:</span> veryLongValueNumber2<span class="token punctuation">,</span><br>    veryLongLabelNumber3<span class="token punctuation">:</span> veryLongValueNumber3<br><span class="token punctuation">)</span></code></pre><h2 id="use-swiftlint" tabindex="-1">Use SwiftLint</h2><p>See <a href="./SwiftLint/">SwiftLint</a>. Avoid enforcing code rules whose violations cannot be detected by this tool.</p><h2 id="use-swiftformat" tabindex="-1">Use SwiftFormat</h2><p>See <a href="./SwiftFormat/">SwiftFormat</a>. Avoid requiring formatting that cannot be automated using this tool.</p><h2 id="access-specifiers" tabindex="-1">Access Specifiers</h2><p>Apply the most restrictive access specifiers possible to avoid unintentionally access items. For example, most properties and many methods in structs and classes should be <code>private</code>.</p><h2 id="protocols" tabindex="-1">Protocols</h2><p>There are two ways for a type to implement a protocol, directly or indirectly using an extension.</p><p>In the direct approach, all protocols implemented by a type are specified at the beginning of the type definition. Methods required by each protocol are defined inside the definition of the type.</p><p>Here is an example of the direct approach. While the example defines an <code>enum</code>, the same approach can be used with <code>struct</code> and <code>class</code> definitions.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token class-name">HTTPError</span><span class="token punctuation">:</span> <span class="token class-name">Error</span><span class="token punctuation">,</span> <span class="token class-name">LocalizedError</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> <span class="token function">badStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><br>    <span class="token keyword">case</span> badUrl<br>    <span class="token keyword">case</span> jsonEncode<br><br>    <span class="token keyword">public</span> <span class="token keyword">var</span> message<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span> <span class="token punctuation">{</span><br>        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span><br>        <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">badStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">:</span><br>            <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"bad status </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">status</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><br>        <span class="token keyword">case</span> <span class="token punctuation">.</span>badUrl<span class="token punctuation">:</span><br>            <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"bad URL"</span></span><br>        <span class="token keyword">case</span> <span class="token punctuation">.</span>jsonEncode<span class="token punctuation">:</span><br>            <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"JSON encoding failed"</span></span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>In the indirect approach, each protocol implemented by a type is associated with it using a separate extension. This has the benefit of making it clear which methods are associated with each protocol being implemented.</p><p>Here is an example of the direct approach:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token class-name">HTTPError</span><span class="token punctuation">:</span> <span class="token class-name">Error</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> <span class="token function">badStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><br>    <span class="token keyword">case</span> badUrl<br>    <span class="token keyword">case</span> jsonEncode<br><span class="token punctuation">}</span><br><br><span class="token keyword">extension</span> <span class="token class-name">HTTPError</span><span class="token punctuation">:</span> <span class="token class-name">LocalizedError</span> <span class="token punctuation">{</span><br>    <span class="token keyword">public</span> <span class="token keyword">var</span> message<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span> <span class="token punctuation">{</span><br>        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span><br>        <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">badStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">:</span><br>            <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"bad status </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">status</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><br>        <span class="token keyword">case</span> <span class="token punctuation">.</span>badUrl<span class="token punctuation">:</span><br>            <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"bad URL"</span></span><br>        <span class="token keyword">case</span> <span class="token punctuation">.</span>jsonEncode<span class="token punctuation">:</span><br>            <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"JSON encoding failed"</span></span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Most Swift developers seem to prefer the indirect approach.</p><h2 id="preference-for-async%2Fawait-over-completion-handlers-(callbacks)" tabindex="-1">Preference for async/await over completion handlers (callbacks)</h2><p>Many older APIs provide asynchronous functions that take completion handler functions, otherwise known as callbacks. Callers pass in a function that is invoked when the asynchronous processing completes.</p><p>Newer APIs utilize the Swift <code>async</code> and <code>await</code> keywords.</p><p>Calls to functions that take a completion handler can be wrapped in an <code>async</code> function so they can be used in a more modern way. This pattern is illustrated by the following contrived example. both <code>myAsyncFunction</code> and <code>oldStyleFunction</code> could take arguments.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token keyword">throws</span> <span class="token operator">-></span> <span class="token class-name">SomeReturnType</span> <span class="token punctuation">{</span><br>    <span class="token comment">// The "return" here is only necessary if some code precedes it.</span><br>    <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token keyword">await</span> withCheckedThrowingContinuation <span class="token punctuation">{</span> continuation <span class="token keyword">in</span><br>        <span class="token comment">// The trailing closure here is the completion handler.</span><br>        <span class="token function">oldStyleFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> result<span class="token punctuation">,</span> error <span class="token keyword">in</span><br>            <span class="token keyword">if</span> <span class="token keyword">let</span> error <span class="token operator">=</span> error <span class="token punctuation">{</span><br>                continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>throwing<span class="token punctuation">:</span> error<span class="token punctuation">)</span><br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">let</span> result <span class="token operator">=</span> result <span class="token punctuation">{</span><br>                continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>returning<span class="token punctuation">:</span> result<span class="token punctuation">)</span><br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>                continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>throwing<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"no result found"</span></span><span class="token punctuation">)</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="emojis-in-debug-messages" tabindex="-1">Emojis in Debug Messages</h2><p>In order to make debugging messages stand out in the console, begin them with an emoji such as ✅ or ❌.</p><p>To add an emoji in Xcode, press cmd-ctrl-space.</p></article>