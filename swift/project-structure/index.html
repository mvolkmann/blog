<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Project Structure</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#groups">Groups</a></li><li><a href="#group-and-file-order">Group and file order</a></li><li><a href="#view-models">View Models</a></li><li><a href="#services">Services</a></li><li><a href="#constants">Constants</a></li><li><a href="#order-within-files">Order Within Files</a></li><li><a href="#pragma-marks">Pragma Marks</a></li><li><a href="#indentation-and-wrapping-style">Indentation and wrapping style</a></li><li><a href="#use-swiftlint">Use SwiftLint</a></li><li><a href="#use-swiftformat">Use SwiftFormat</a></li><li><a href="#preference-for-async%2Fawait-over-completion-handlers-(callbacks)">Preference for async/await over completion handlers (callbacks)</a></li></ol></nav></aside><article><h2 id="overview">Overview</h2><p>This post documents my recommended structure and practices for SwiftUI projects.</p><h2 id="groups">Groups</h2><p>Most files in a project should be placed in a group. Group names typically begin with an uppercase letter and do not contain spaces.</p><p>Recommended group names include:</p><ul><li><p>Config</p><p>This group includes files like <code>Assets.xcassets</code> and <code>.plist</code> files</p></li><li><p>Extensions</p><p>This group contains files that define extensions to builtin structs like <code>Date</code>, <code>String</code>, and <code>View</code>. These tend to be copied from project to project as they evolve. The names of files in this group should end with &quot;Extension&quot;.</p></li><li><p>Models</p><p>This group contains files that define model structs, classes, and enums. Instances of these hold all the data used by the app. The names of files in this group do not need to end with &quot;Model&quot;.</p></li><li><p>Screens</p><p>This group contains files that implement entire screens of the app as opposed to sections of a screen. Screens typically use views defined in the Views group. The names of files in this group should end with &quot;Screen&quot;.</p></li><li><p>Services</p><p>This group contains files that abstract away the details of network communication and interactions of packages like Core Data, CloudKit, and HealthKit. The names of files in this group should end with &quot;Service&quot;.</p></li><li><p>Views</p><p>This group contains files that define views used by screens and other views. The names of files in this group do not need to end with &quot;View&quot;.</p></li><li><p>ViewModels</p><p>This group contains files that define classes that inherit from <code>ObservableObject</code>, define <code>@Published</code> properties, and define methods that operate on the data they encapsulate. Views can use the properties and methods in these classes. The names of files in this group should end with &quot;ViewModel&quot;.</p></li></ul><h2 id="group-and-file-order">Group and file order</h2><p>Files not in any group, such as the main <code>*App.swift</code> belong above all the groups. The groups follow these files and should be in alphabetical order. The files within each group should be in alphabetical order.</p><h2 id="view-models">View Models</h2><p>In strict implementations of the MVVM pattern views get all their state data from view models and delegate all their non-view logic to view models.</p><p>In less strict implementations of the MVVM pattern, state data and logic that is specific to a single view is implemented in the view using <code>@State</code> properties. Only state data and logic that is used by multiple views is implemented in view model classes.</p><h2 id="services">Services</h2><p>Services are <code>.swift</code> files that abstract away the details of network communication and interactions with packages like Core Data, CloudKit, and HealthKit. View and view model source files should prefer using methods of services instead of directly coding such interactions.</p><h2 id="constants">Constants</h2><p>The Swift naming convention for constants is the same as for variables. They begin with a lowercase letter and use camel-case. This differs from most other programming languages that use all uppercase.</p><p>There are several ways to define constants in Swift.</p><p>One approach is to define static properties.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">let</span> defaultName <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Anonymous"</span></span><br><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">let</span> defaultSize <span class="token operator">=</span> <span class="token number">6.2</span></code></pre><p>Another approach is to wrap them in a case-less <code>enum</code>. Using an <code>enum</code> instead of a <code>struct</code> or <code>class</code> prevents creating instances of the wrapping construct.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token class-name">MyConstants</span> <span class="token punctuation">{</span><br>    <span class="token keyword">static</span> <span class="token keyword">let</span> <span class="token keyword">static</span> <span class="token keyword">let</span> defaultName <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Anonymous"</span></span><br>    <span class="token keyword">static</span> <span class="token keyword">let</span> <span class="token keyword">static</span> <span class="token keyword">let</span> defaultSize <span class="token operator">=</span> <span class="token number">6.2</span><br><span class="token punctuation">}</span></code></pre><p>Yet another approach is to use a normal <code>enum</code>. This has the advantage that <code>switch</code> statements can enforce exhaustive handling of the cases. However, it requires all cases to have the same type.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token class-name">MyConstants</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> defaultSize <span class="token operator">=</span> <span class="token number">6.2</span><br>    <span class="token keyword">case</span> smallSize <span class="token operator">=</span> <span class="token number">3.1</span><br>    <span class="token keyword">case</span> largeSize <span class="token operator">=</span> <span class="token number">13.1</span><br><span class="token punctuation">}</span></code></pre><h2 id="order-within-files">Order Within Files</h2><p>A recommended order for groups of items in a source file is:</p><ol><li>initializers</li><li>constants</li><li>state properties (properties with property wrappers like <code>@Environment</code>, <code>@EnvironmentObject</code>, <code>@Published</code>, and <code>@State</code>)</li><li>non-state properties (both normal and computed)</li><li>methods</li></ol><h2 id="pragma-marks">Pragma Marks</h2><p>Files over a certain size in number of lines should include pragma marks to separate sections. This adds labels in the Xcode final breadcrumb dropdown which makes it easier to select and jump to a specific item.</p><p>Each pragma mark is a single-line comment following the pattern:</p><pre class="language-swift"><code class="language-swift"><span class="token comment">// MARK: - section-name</span></code></pre><p>Including the hyphen adds a divider line in the breadcrumb dropdown.</p><h2 id="indentation-and-wrapping-style">Indentation and wrapping style</h2><p>Use 4-space indentation.</p><p>Most lines that are longer than 80 characters should be wrapped to be no longer than that in order to allow comfortably viewing two or three files side-by-side.</p><p><code>Array</code> and <code>Dictionary</code> literals that do not fit on a single line should place each item on a separate line, indented by four additional spaces. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">let</span> colorNames <span class="token operator">=</span> <span class="token punctuation">[</span><br>    <span class="token string-literal"><span class="token string">"Red"</span></span><span class="token punctuation">,</span><br>    <span class="token string-literal"><span class="token string">"Green"</span></span><span class="token punctuation">,</span><br>    <span class="token string-literal"><span class="token string">"Blue"</span></span><br><span class="token punctuation">]</span><br><br><span class="token keyword">let</span> colorNameToHex <span class="token operator">=</span> <span class="token punctuation">[</span><br>    <span class="token string-literal"><span class="token string">"Red"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"ff0000"</span></span><span class="token punctuation">,</span><br>    <span class="token string-literal"><span class="token string">"Green"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"00ff00"</span></span><span class="token punctuation">,</span><br>    <span class="token string-literal"><span class="token string">"Blue"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"0000ff"</span></span><br><span class="token punctuation">]</span></code></pre><p>Function signatures and calls that do not fit on a single line should place each parameter/argument on a separate line, indented by four additional spaces. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myVeryLongFunctionName</span><span class="token punctuation">(</span><br>    veryLongLabelNumber1<span class="token punctuation">:</span> <span class="token class-name">Type1</span><span class="token punctuation">,</span><br>    veryLongLabelNumber2<span class="token punctuation">:</span> <span class="token class-name">Type2</span><span class="token punctuation">,</span><br>    veryLongLabelNumber3<span class="token punctuation">:</span> <span class="token class-name">Type3</span><br><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">ReturnType</span> <span class="token punctuation">{</span><br>    <span class="token operator">...</span> code goes here <span class="token operator">...</span><br><span class="token punctuation">}</span><br><br><span class="token function">myVeryLongFunctionName</span><span class="token punctuation">(</span><br>    veryLongLabelNumber1<span class="token punctuation">:</span> veryLongValueNumber1<span class="token punctuation">,</span><br>    veryLongLabelNumber2<span class="token punctuation">:</span> veryLongValueNumber2<span class="token punctuation">,</span><br>    veryLongLabelNumber3<span class="token punctuation">:</span> veryLongValueNumber3<br><span class="token punctuation">)</span></code></pre><h2 id="use-swiftlint">Use SwiftLint</h2><p>See <a href="./SwiftLint/">SwiftLint</a>.</p><h2 id="use-swiftformat">Use SwiftFormat</h2><p>See <a href="./SwiftFormat/">SwiftFormat</a>.</p><h2 id="preference-for-async%2Fawait-over-completion-handlers-(callbacks)">Preference for async/await over completion handlers (callbacks)</h2><p>Many older APIs provide asynchronous functions that take completion handler functions, otherwise known as callbacks. Callers pass in a function that is invoked when the asynchronous processing completes.</p><p>Newer APIs utilize the Swift <code>async</code> and <code>await</code> keywords.</p><p>Calls to functions that take a completion handler can be wrapped in an <code>async</code> function so they can be used in a more modern way. This pattern is illustrated by the following contrived example. both <code>myAsyncFunction</code> and <code>oldStyleFunction</code> could take arguments.</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token keyword">throws</span> <span class="token operator">-></span> <span class="token class-name">SomeReturnType</span> <span class="token punctuation">{</span><br>    <span class="token comment">// The "return" here is only necessary if some code precedes it.</span><br>    <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token keyword">await</span> withCheckedThrowingContinuation <span class="token punctuation">{</span> continuation <span class="token keyword">in</span><br>        <span class="token comment">// The trailing closure here is the completion handler.</span><br>        <span class="token function">oldStyleFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> result<span class="token punctuation">,</span> error <span class="token keyword">in</span><br>            <span class="token keyword">if</span> <span class="token keyword">let</span> error <span class="token operator">=</span> error <span class="token punctuation">{</span><br>                continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>throwing<span class="token punctuation">:</span> error<span class="token punctuation">)</span><br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">let</span> result <span class="token operator">=</span> result <span class="token punctuation">{</span><br>                continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>returning<span class="token punctuation">:</span> result<span class="token punctuation">)</span><br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>                continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>throwing<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"no result found"</span></span><span class="token punctuation">)</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></article>