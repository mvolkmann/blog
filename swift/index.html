<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Swift</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#resources">Resources</a></li><li><a href="#installing">Installing</a></li><li><a href="#using-xcode">Using Xcode</a></li><li><a href="#using-the-interpreter">Using the Interpreter</a></li><li><a href="#built-in-primitive-types">Built-in Primitive Types</a><ol><li><a href="#characters-and-strings">Characters and Strings</a></li><li><a href="#ranges">Ranges</a></li></ol></li><li><a href="#built-in-collection-types">Built-in Collection Types</a><ol><li><a href="#arrays">Arrays</a></li><li><a href="#dictionaries">Dictionaries</a></li><li><a href="#sets">Sets</a></li><li><a href="#tuples">Tuples</a></li></ol></li><li><a href="#variables">Variables</a></li><li><a href="#control-structures">Control Structures</a><ol><li><a href="#conditional-logic">Conditional Logic</a></li><li><a href="#iteration">Iteration</a></li></ol></li><li><a href="#functions">Functions</a></li><li><a href="#protocols">Protocols</a></li><li><a href="#tools">Tools</a><ol><li><a href="#xcode">Xcode</a></li></ol></li></ol></nav></aside><article><h2 id="overview">Overview</h2><p>THIS IS A WORK IN PROGRESS!</p><p><a href="https://swift.org?v=1.0.18" rel="noopener" target="_blank">Swift</a> is an open source programming language created by Apple. Key facts about Swift include the following:</p><ul><li>introduced by Apple at the 2014 WWDC conference</li><li>became open source under an Apache license in December 2015</li><li>goals are to be safe, fast, and expressive</li><li>strongly typed with type inference</li><li>supports both object-oriented and functional programming</li><li>built on <a href="https://llvm.org?v=1.0.18" rel="noopener" target="_blank">LLVM</a> (Low Level Virtual Machine)</li><li>interoperates with <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/?v=1.0.18" rel="noopener" target="_blank">Objective-C</a> code</li><li>can be used to build applications for macOS, iOS, and Watch OS</li><li>can be used to build command-line applications</li><li>can be used to build server-side applications</li><li>a compiled language, but there is also an interpreter</li><li>supports closures, tuples, and generics</li><li>includes a <a href="https://developer.apple.com/documentation/swift/swift_standard_library?v=1.0.18" rel="noopener" target="_blank">Standard Library</a></li></ul><h2 id="resources">Resources</h2><ul><li>main site - <a href="https://swift.org?v=1.0.18" rel="noopener" target="_blank">https://swift.org</a></li><li><a href="https://cs193p.sites.stanford.edu?v=1.0.18" rel="noopener" target="_blank">Stanford CS193p - Developing Apps for iOS</a> course by Paul Hegarty - free</li><li><a href="https://www.hackingwithswift.com/100?v=1.0.18" rel="noopener" target="_blank">100 Days of Swift</a> by Paul Hudson - free</li><li><a href="https://www.udemy.com/course/ios-13-app-development-bootcamp/?v=1.0.18" rel="noopener" target="_blank">iOS &amp; Swift - The Complete iOS App Development Bootcamp</a> Udemy course by Angela Yu - $14.99</li><li><a href="https://www.apple.com/swift/playgrounds/?v=1.0.18" rel="noopener" target="_blank">Swift Playgrounds</a> iOS app - free</li></ul><h2 id="installing">Installing</h2><p>Swift can be installed on macOS, Windows 10, Amazon Linux 2, CentOS, and Ubuntu.</p><p>To install Swift on macOS, install Xcode from the macOS App Store. For other operating systems, download it from <a href="https://swift.org/download/?v=1.0.18" rel="noopener" target="_blank">Download Swift</a>.</p><h2 id="using-xcode">Using Xcode</h2><p>Xcode is an IDE from Apple for creating apps for iPhone, iPad, Mac, Apple Watch, and Apple TV.</p><p>To experiment with Swift:</p><ul><li>select File ... New Playground...</li><li>select a template such as &quot;Blank&quot; and press &quot;Next&quot;</li><li>enter a name for the playground</li><li>select the directory where it will be saved</li><li>enter code in the provided text editor</li><li>to run all of the code, click the square at the top of the console area</li><li>to run only the code up to and including a specific line, hover over the line and click the play button that appears</li><li><code>print</code> output appears in the console area at the bottom</li></ul><p>To developing an app:</p><ul><li>select one of the following:<ul><li>&quot;Create a new Xcode project&quot;</li><li>&quot;Clone an existing project&quot;</li><li>&quot;Open a project or file&quot;</li></ul></li></ul><h2 id="using-the-interpreter">Using the Interpreter</h2><p>To start the interpreter as a REPL (Read Eval Print Loop), enter <code>swift</code>. Then enter Swift statements to be evaluated. For example, enter <code>print(1 + 2)</code>.</p><p>To run the interpreter on lines of code in a file, enter <code>swift &lt; file-path</code>. For example, create the file <code>greet.swift</code> containing <code>print(&quot;Hello, World!&quot;)</code> and enter <code>swift &lt; greet.swift</code> to run it.</p><p>Interpreter commands begin with a colon. The most commonly used commands are described in the table below.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>:exit</code></td><td>exits the interpreter</td></tr><tr><td><code>:help</code></td><td>prints</td></tr></tbody></table><h2 id="built-in-primitive-types">Built-in Primitive Types</h2><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Bool</code></td><td>boolean; literal values are <code>true</code> and <code>false</code></td></tr><tr><td><code>UInt</code></td><td>unsigned integer; same number of bits as platform (32 or 64)</td></tr><tr><td><code>Int</code></td><td>signed integer; same number of bits as platform (32 or 64)</td></tr><tr><td><code>Float</code></td><td>32-bit floating point number</td></tr><tr><td><code>Double</code></td><td>64-bit floating point number</td></tr><tr><td><code>Character</code></td><td>single character</td></tr><tr><td><code>String</code></td><td>text</td></tr><tr><td><code>Range</code></td><td>interval from lower bound to upper bound (exclusive)</td></tr><tr><td><code>ClosedRange</code></td><td>interval from lower bound to upper bound (inclusive)</td></tr></tbody></table><h3 id="characters-and-strings">Characters and Strings</h3><p>Literal <code>Character</code> and single-line <code>String</code> values are both delimited by double-quotes. Multi-line <code>String</code> values are delimited by triple double-quotes.</p><h3 id="ranges">Ranges</h3><p>A literal <code>Range</code> including the numbers 2, 3, and 4 can be defined with <code>2..&lt;5</code> or <code>2...4</code>. This can be assigned to a variable. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">4</span></code></pre><p>To determine if a number is in a range, pass it to the <code>contains</code> method. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span><br><span class="token function">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span></code></pre><p>To iterate over the values in a range, use a <code>for-in</code> loop. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">for</span> n <span class="token keyword">in</span> r <span class="token punctuation">{</span><br>  <span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><h2 id="built-in-collection-types">Built-in Collection Types</h2><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Array</code></td><td>indexed collection of values with the same type</td></tr><tr><td><code>Dictionary</code></td><td>collection of key/value pairs</td></tr><tr><td><code>Set</code></td><td>unordered collection of values with the same type and no duplicates</td></tr><tr><td>tuple</td><td>fixed-length, ordered collection of values that have type that can differ</td></tr></tbody></table><h3 id="arrays">Arrays</h3><p>Array properties include the following:</p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>capacity</code></td><td>number of elements that can be held without allocating more space</td></tr><tr><td><code>count</code></td><td>number of elements</td></tr><tr><td><code>first</code></td><td>first element</td></tr><tr><td><code>isEmpty</code></td><td><code>Bool</code> value indicating whether <code>count</code> is zero</td></tr><tr><td><code>last</code></td><td>last element</td></tr></tbody></table><p>Array methods include, but are not limited to the following:</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>allSatisfy((Element) -&gt; Bool) -&gt; Bool</code></td><td>determines if all elements match a predicate</td></tr><tr><td><code>append(Element)</code></td><td>adds a new element at the end</td></tr><tr><td><code>append(contentsOf: S)</code></td><td>adds the elements in <code>S</code> at the end</td></tr><tr><td><code>compactMap&lt;T&gt;((Element) -&gt; T) -&gt; [T]</code></td><td>returns an array of the non-nil values returned by the function</td></tr><tr><td><code>contains(Element) -&gt; Bool</code></td><td>determines if an element is a member</td></tr><tr><td><code>contains(where: (Element) -&gt; Bool) -&gt; Bool</code></td><td>determines if any element matches a predicate</td></tr><tr><td><code>drop(while: (Element) -&gt; Bool) -&gt; ArraySlice&lt;Element&gt;</code></td><td>returns a subsequence of the elements after those at the beginning that match a predicate</td></tr><tr><td><code>dropFirst(Int) -&gt; ArraySlice&lt;Element&gt;</code></td><td>returns a subsequence of the elements after the first n</td></tr><tr><td><code>dropLast(Int) -&gt; ArraySlice&lt;Element&gt;</code></td><td>returns a subsequence of the elements before the last n</td></tr><tr><td><code>enumerated(t) -&gt; EnumeratedSequence</code></td><td>returns a subsequence of (n, x) pairs where n is an index and x is the element at that index</td></tr><tr><td><code>first(where: (Element) -&gt; Bool) -&gt; Element?</code></td><td>returns the first element that matches a predicate</td></tr><tr><td><code>firstIndex(of: Element) -&gt; Int?</code></td><td>returns the index of the first element matching element</td></tr><tr><td><code>firstIndex(where: (Element) -&gt; Bool) -&gt; Int?</code></td><td>returns the index of the first element that matches a predicate</td></tr><tr><td><code>flatMap&lt;T&gt;((Element) -&gt; T) -&gt; [T]</code></td><td>like <code>map</code>, but concatenates the results</td></tr><tr><td><code>forEach((Element) -&gt; Void)</code></td><td>passes each element to a given function</td></tr><tr><td><code>last(where: (Element) -&gt; Bool) -&gt; Element?</code></td><td>returns the last element that matches a predicate</td></tr><tr><td><code>lastIndex(of: Element) -&gt; Int?</code></td><td>returns the index of the last element matching element</td></tr><tr><td><code>lastIndex(where: (Element) -&gt; Bool) -&gt; Int?</code></td><td>returns the index of the last element that matches a predicate</td></tr><tr><td><code>insert(Element, at: Int)</code></td><td>inserts a new element at the given index</td></tr><tr><td><code>joined(String) -&gt; String</code></td><td>returns the contenation of the elements with a separator between each</td></tr><tr><td><code>lazy</code></td><td>returns a sequence that can be used lazily by another function</td></tr><tr><td><code>map&lt;T&gt;((Element) -&gt; T) -&gt; [T]</code></td><td>returns an Array of the results of calling a function on each element</td></tr><tr><td><code>max() -&gt; Element?</code></td><td>returns the maximum element</td></tr><tr><td><code>max((Element, Element) -&gt; Bool) -&gt; Element?</code></td><td>returns the maximum element as determined by a comparator</td></tr><tr><td><code>min() -&gt; Element?</code></td><td>returns the minimum element</td></tr><tr><td><code>min((Element, Element) -&gt; Bool) -&gt; Element?</code></td><td>returns the minimum element as determined by a comparator</td></tr><tr><td><code>partition(by: (Element) -&gt; Bool) -&gt; Int</code></td><td>reorders the elements using a predicate so all false are before all true</td></tr><tr><td><code>popLast() -&gt; Element?</code></td><td>removes the last element and returns it</td></tr><tr><td><code>prefix(Int) -&gt; ArraySlice&lt;Element&gt;</code></td><td>returns a subsequence of the first n elements</td></tr><tr><td><code>prefix(while: (Element) -&gt; Bool) -&gt; ArraySlice&lt;Element&gt;</code></td><td>returns a subsequence of the first elements that match a predicate</td></tr><tr><td><code>randomElement()</code></td><td>a random element</td></tr><tr><td><code>reduce(Result, (Result, Element) -&gt; Result) -&gt; Result</code></td><td>takes an initial value and a function; returns result of combining elements</td></tr><tr><td><code>remove(at: Int) -&gt; Element</code></td><td>removes the element at a given index and returns it</td></tr><tr><td><code>removeFirst() -&gt; Element</code></td><td>removes the first element and returns it</td></tr><tr><td><code>removeFirst(Int)</code></td><td>removes a given number of elements from the beginning</td></tr><tr><td><code>removeLast() -&gt; Element</code></td><td>removes the last element and returns it</td></tr><tr><td><code>removeLast(Int)</code></td><td>removes a given number of elements from the end</td></tr><tr><td><code>removeSubrange(Range&lt;Int&gt;)</code></td><td>removes the elements in the range</td></tr><tr><td><code>removeAll(keepingCapacity: Bool)</code></td><td>removes all elements, optionally keeping the capacity</td></tr><tr><td><code>removeAll(where: (Element) -&gt; Bool)</code></td><td>removes all elements that match a predicate</td></tr><tr><td><code>replaceSubrange(Range&lt;Int&gt;, with: C)</code></td><td>replaces elements in the range with elements in <code>C</code></td></tr><tr><td><code>reserveCapacity(Int)</code></td><td>reserves enough space for at least the given number of elements</td></tr><tr><td><code>reverse()</code></td><td>reverses the elements in place</td></tr><tr><td><code>reversed() -&gt; ReversedCollection</code></td><td>returns a view of the elements in reverse order</td></tr><tr><td><code>shuffle()</code></td><td>shuffles the elements in place</td></tr><tr><td><code>shuffled()</code></td><td>returns a new array of the elements in shuffled order</td></tr><tr><td><code>sort()</code></td><td>sorts the elements in place</td></tr><tr><td><code>sort(by: (Element, Element) -&gt; Bool)</code></td><td>sorts the elements in place using a given comparator</td></tr><tr><td><code>sorted() -&gt; [Element]</code></td><td>returns a new array of the elements in sorted order</td></tr><tr><td><code>sorted(by: (Element, Element) -&gt; Bool) -&gt; [Element]</code></td><td>returns a new array of the elements in sorted using a given comparator</td></tr><tr><td><code>subscript(Int)</code></td><td>element at a given index</td></tr><tr><td><code>subscript(Range&lt;Int&gt;)</code></td><td><code>ArraySlice</code> of the elements in the given range</td></tr><tr><td><code>suffix(Int) -&gt; ArraySlice&lt;Element&gt;</code></td><td>returns a subsequence of the last n elements</td></tr><tr><td><code>suffix(while: (Element) -&gt; Bool) -&gt; ArraySlice&lt;Element&gt;</code></td><td>returns a subsequence of the last elements that match a predicate</td></tr><tr><td><code>swapAt(Int, Int)</code></td><td>swaps the elements at the given indexes</td></tr></tbody></table><p>Do <code>popLast</code> and <code>removeLast</code> have the same functionality?</p><h3 id="dictionaries">Dictionaries</h3><h3 id="sets">Sets</h3><h3 id="tuples">Tuples</h3><p>To define a tuple type, provide a list of elements types in parentheses. For example, <code>(Bool, Int, String)</code>.</p><h2 id="variables">Variables</h2><p>Variables are declared with the <code>let</code> (immutable) and <code>var</code> (mutable) keywords. Variable names can be followed by a colon and a type. They can also be followed by <code>=</code> and an initial value. The type can be omitted if the desired type can be inferred from the initial value.</p><p>For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">let</span> name1<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"Mark"</span> <span class="token comment">// type and initial value</span><br><br><span class="token keyword">let</span> name2 <span class="token operator">=</span> <span class="token string">"Mark"</span> <span class="token comment">// only value; String type is inferred</span><br><br><span class="token keyword">var</span> score1<span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token comment">// only type; can't use until initialized</span><br>score1 <span class="token operator">=</span> <span class="token number">19</span> <span class="token comment">// initializes</span><br><br><span class="token keyword">var</span> score2 <span class="token operator">=</span> <span class="token number">19</span> <span class="token comment">// only value; Int type is inferred</span></code></pre><h2 id="control-structures">Control Structures</h2><p>Swift does not require parentheses around conditions in control structures. It does require the code to be executed to be in a block surrounded by curly braces.</p><h3 id="conditional-logic">Conditional Logic</h3><p>Conditional logic is implemented with the <code>if</code> statement. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">if</span> score1 <span class="token operator">==</span> <span class="token number">21</span><span class="token punctuation">,</span> score2 <span class="token operator">&lt;=</span> <span class="token number">19</span> <span class="token punctuation">{</span> <span class="token comment">// same as score1 == 21 &amp;&amp; score2 &lt;= 19</span><br>  <span class="token function">print</span><span class="token punctuation">(</span>'<span class="token builtin">Player</span> <span class="token number">1</span> has won by at least <span class="token number">2</span><span class="token punctuation">.</span>`<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><h3 id="iteration">Iteration</h3><p>To iterate over all the elements of an array, use a for-in loop. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Maisey"</span><span class="token punctuation">,</span> <span class="token string">"Ramsay"</span><span class="token punctuation">,</span> <span class="token string">"Oscar"</span><span class="token punctuation">,</span> <span class="token string">"Comet"</span><span class="token punctuation">]</span><br><span class="token keyword">for</span> name <span class="token keyword">in</span> names <span class="token punctuation">{</span><br>    <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><h2 id="functions">Functions</h2><p>Functions are defined using the <code>func</code> keyword, followed by the function name, the parameter list in parentheses, and an optional return type preceded by <code>-&gt;</code>. The parentheses are required even for functions that have no parameters. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>n1<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> n2<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> n1 <span class="token operator">*</span> n2<br><span class="token punctuation">}</span><br><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 5</span></code></pre><p>If the body of the function is a single expression, the <code>return</code> keyword` is not required to return its value. The previous function can rewritten as follows:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>n1<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> n2<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span><br>    n1 <span class="token operator">*</span> n2<br><span class="token punctuation">}</span><br><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 5</span></code></pre><p>If the return type can be inferred, the return type can be omitted. The previous function can rewritten as follows:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>n1<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> n2<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    n1 <span class="token operator">*</span> n2<br><span class="token punctuation">}</span><br><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 5</span></code></pre><p>When the return type of a function cannot be inferred and no return type is specified, it defaults to <code>Void</code> which is an empty tuple (<code>()</code>).</p><p>Parameters must have a name and type. They can also have an &quot;argument label&quot; that is the name callers must use when providing a value. The argument label defaults to the parameter name. Typically argument labels are omitted and callers use the parameter names.</p><p>A parameter can specify a default value by including an equal sign (<code>=</code>) followed by a value after the type. Doing so makes the corresponding argument optional. All parameters with default values must follow those that do not have a default value.</p><p>Calls to a function must provided all the required arguments. Each argument is specified by the argument label, a colon, and a value. These must appear in the same orders as the corresponding parameters. The rationale for this is that it can make some calls more expressive, almost like sentences. It is useful to think of the argument labels as being part of the function name.</p><p>When an argument label of <code>_</code> is specified, the function must be called with only a value for that parameter. Otherwise calls must include the argument label. A function can have a mixture of parameters with argument labels and parameters with none (indicated by <code>_</code>).</p><p>To call a function, specify the function name followed by arguments in parentheses. The parentheses are required even when not passing any arguments.</p><p>For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'Hello, World!'</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// outputs Hello, World!</span></code></pre><p>Anonymous functions can be used at the values of variables and arguments. They are written with the following syntax: <code>{ (parameter-list) -&gt; return-type in statements }</code>. The return type can be omitted when it can be inferred.</p><p>The following code defines and calls several anonymous functions.</p><pre class="language-swift"><code class="language-swift"><span class="token comment">// This function has no parameters.</span><br><span class="token keyword">let</span> printTime <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> date <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// now</span><br>    <span class="token keyword">let</span> dateFormatter <span class="token operator">=</span> <span class="token function">DateFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    dateFormatter<span class="token punctuation">.</span>dateFormat <span class="token operator">=</span> <span class="token string">"M/d/yyyy"</span><br>    <span class="token function">print</span><span class="token punctuation">(</span>dateFormatter<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> date<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><span class="token function">printTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><br><span class="token comment">// This function specifies all the types.</span><br><span class="token keyword">let</span> product <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token keyword">in</span> a <span class="token operator">*</span> b<span class="token punctuation">}</span><br><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">product</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token comment">// This function omits the return type because it can be inferred.</span><br><span class="token keyword">let</span> product2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">)</span> <span class="token keyword">in</span> a <span class="token operator">*</span> b<span class="token punctuation">}</span><br><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">product2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token comment">// This function has parameters with unspecified types.</span><br><span class="token comment">// It does not compile because the * operator cannot be applied to all types.</span><br><span class="token comment">//let product3 = {a, b in a * b}</span><br><span class="token comment">//print(product3(2, 3))</span><br><span class="token comment">// This is a very contrived example since</span><br><span class="token comment">// "print(2 * 3)" would do the same thing.</span><br><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">{</span>$<span class="token number">0</span> <span class="token operator">*</span> $<span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>A &quot;variadic&quot; parameter accepts multiple values of the same type. The parameter value will be a constant array of values. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">displaySum</span><span class="token punctuation">(</span>label<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> numbers<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>label<span class="token delimiter variable">)</span></span> = <span class="token interpolation"><span class="token delimiter variable">\(</span>sum<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>Function names can be overloaded based on their parameter types.</p><p>To return multiple values, return a tuple by returning a list of values inside parentheses. For example:</p><pre class="language-swift"><code class="language-swift"><span class="token constant">TODO</span><span class="token punctuation">:</span> <span class="token builtin">Write</span> a function that takes a color and returns a tuple<br><span class="token constant">TODO</span><span class="token punctuation">:</span> containing the amounts of red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> and blue <span class="token keyword">in</span> the color<span class="token punctuation">.</span></code></pre><p>By default, parameters cannot be modified in function bodies. Adding the keyword <code>inout</code> before their type changes this. Modifying the values of these parameters changes the value of the corresponding argument in the caller. This only works if the value passed in is a variable (<code>var</code>) rather than a constant (<code>let</code>). This seems like a feature to avoid!</p><p>The type of a function is describe by its parameter types and return type. For example, the type of the <code>displaySum</code> function above is <code>(String, Int) -&gt; Void</code>. Function types can be used for variable, parameter, and return types. This means that compatible functions can be assigned variables, passed to functions, and returned from functions.</p><p>Functions can defined in the bodies of other functions to scope their usage. Otherwise they are global and can be called from anywhere. Nested functions can be returned by their enclosing function to allow them to be called from outside.</p><h2 id="protocols">Protocols</h2><p>A protocol is like an interface in other programming languages. It describes a set of method signatures. TODO: Can it also describe constants and fields?</p><ul><li><code>Collection</code></li><li><code>CustomDebugStringConvertible</code></li><li><code>CustomReflectable</code></li><li><code>Equatable</code></li></ul><h2 id="tools">Tools</h2><p>Is there an equivalent of ESLint for Swift?</p><p>Some options for Swift code formatting are <a href="https://github.com/nicklockwood/SwiftFormat?v=1.0.18" rel="noopener" target="_blank">SwiftFormat</a> and <a href="https://github.com/apple/swift-format?v=1.0.18" rel="noopener" target="_blank">swift-format</a>.</p><p>To install SwiftFormat, enter <code>brew install swiftformat</code>. To format a <code>.swift</code> file, enter <code>swiftformat file-name.swift</code>. To format all the <code>.swift</code> files in the current directory, enter <code>swiftformat *.swift</code>.</p><h3 id="xcode">Xcode</h3><p>Xcode 13 (still in beta as of 8/8/21) adds support for Vim key bindings. To enable Vim key bindings, select Preferences ... Text Editing ... Editing ... Enable Vim key bindings.</p></article>