<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>NumPy library</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#creating-a-numpy-array">Creating a NumPy Array</a></li><li><a href="#getting-information-about-an-array">Getting Information About an Array</a></li><li><a href="#element-access">Element Access</a></li><li><a href="#operations-on-one-array">Operations on One Array</a></li><li><a href="#operations-on-two-arrays">Operations on Two Arrays</a></li></ol></nav></aside><article><h2 id="overview">Overview</h2><p><a href="https://numpy.org/?v=1.0.15" rel="noopener" target="_blank">NumPy</a> is a Python library for scientific computing. It is primarily implemented in optimized C code. It is an alternative to MatLab for use in Python.</p><p>NumPy supports many operations on matrices. <a href="https://www.scipy.org/?v=1.0.15" rel="noopener" target="_blank">SciPy</a> builds on NumPy to add support for even more mathematical operations. NumPy is also a dependency of the pandas package.</p><p>If you have installed either SciPy or pandas, you already have NumPy. Otherwise, install it by entering <code>pip install numpy</code>. To use it, <code>import numpy as np</code>.</p><p>A primary feature of NumPy is that it uses NumPy arrays to store and operate on data. Typically the data in these arrays is numbers, but it can also be any other type. NumPy arrays have many advantages over Python lists including:</p><ul><li>Type checking of each element is not needed because NumPy arrays are homogeneous.</li><li>Memory requirements are smaller because the representation of each data value requires less bytes than the equivalent Python representation.</li><li>NumPy array elements are stored in contiguous memory, so access is faster.</li><li>Some operations on element values can be performed in parallel by taking advantage of Single Instruction, Multiple Data (SIMD) vector processing.</li><li>Memory caching can be more effective utilized which results in faster element access.</li></ul><h2 id="creating-a-numpy-array">Creating a NumPy Array</h2><p>Many function described below accept a <code>dtype</code> argument to specify the data type of the array elements. When this is not specified, the data type is inferred or has a default.</p><p>In all function below that accept a number of rows and columns, any number of dimension sizes can be specified, including one.</p><table><thead><tr><th>To create ...</th><th>Use ...</th></tr></thead><tbody><tr><td>array from CSV file</td><td><code>a = np.genfromtxt(file_path, delimiter=',')</code></td></tr><tr><td>1D array from a list</td><td><code>a = np.array([v1, v2, ...])</code></td></tr><tr><td>1D array from a tuple</td><td><code>a = np.array((v1, v2, ...))</code></td></tr><tr><td>2+D array from lists</td><td><code>a = np.array([[v1, v2, ...], [w1, w2, ...]])</code></td></tr><tr><td>2+D array from tuples</td><td><code>a = np.array(((v1, v2, ...), (w1, w2, ...)))</code></td></tr><tr><td>array with all zero values</td><td><code>a = np.zeros((rows, cols), dtype=np.type)</code></td></tr><tr><td>array with all one values</td><td><code>a = np.ones((rows, cols), dtype=np.type)</code></td></tr><tr><td>array with all a specific value</td><td><code>a = np.full((rows, cols), value, dtype=np.type)</code></td></tr><tr><td>array with same shape as another<br>and all a specific value</td><td><code>a = np.full_like(other_array, v), value, dtype=np.type)</code> or<br><code>a = np.full(other_array.shape, v, dtype=np.type)</code></td></tr><tr><td>array with uninitialized values</td><td><code>a = np.empty((rows, cols), dtype=np.type)</code><br>Values come from whatever happens to be at the memory location.</td></tr><tr><td>1D array with range of values</td><td><code>a = np.arange(start, end, step, dtype=np.type)</code><br>Values can be integer or float.<br><code>start</code> is inclusive and defaults to 0.<br><code>end</code> is exclusive and has no default.<br><code>step</code> defaults to 1.</td></tr><tr><td>1D array with evenly spaced values</td><td><code>a = np.linspace(start, end, count, dtype=np.type)</code><br><code>end</code> is inclusive.<br><code>count</code> is the number values to produce.</td></tr><tr><td>array with random float values</td><td><code>a = np.random.rand(rows, cols)</code><br>Values are between 0 (inclusive) and 1 (exclusive).</td></tr><tr><td>array with random integer values</td><td><code>a = np.random.randint(min, max, size=(rows, cols))</code><br><code>min</code> defaults to zero and is inclusive.<br><code>max</code> has no default and is exclusive.</td></tr><tr><td>identity matrix (creates n x n array)</td><td><code>a = np.identity(n, dtype=np.type)</code></td></tr><tr><td>copy of existing array</td><td><code>b = a.copy()</code></td></tr><tr><td>copy of existing array, but use specified data type</td><td><code>b = a.astype(np.type)</code><br>truncates if necessary</td></tr><tr><td>repeated copies elements in existing array</td><td>`b = np.repeat(a, times, axis={0</td></tr></tbody></table><h2 id="getting-information-about-an-array">Getting Information About an Array</h2><table><thead><tr><th>Information</th><th>Attribute</th></tr></thead><tbody><tr><td>number of dimensions</td><td><code>a.dim</code></td></tr><tr><td>shape (size of each dimension)</td><td><code>a.shape</code></td></tr><tr><td>data type of elements</td><td><code>a.dtype</code></td></tr><tr><td>number of elements (product of dimension sizes)</td><td><code>a.size</code></td></tr><tr><td>size of each element in bytes</td><td><code>a.itemsize</code></td></tr><tr><td>total size (<code>a.size * a.itemsize</code>)</td><td><code>a.nbytes</code></td></tr></tbody></table><h2 id="element-access">Element Access</h2><p>In all function below that accept row and column indexes, any number of indexes can be specified, including one.</p><p>In the tables that follow, some abbreviations are used for arguments.</p><ul><li>Row index values below are abbreviated as <code>ri</code>.</li><li>Column index values below are abbreviated as <code>ci</code>.</li><li>Row start indexes (<code>rsi</code>) and column start indexes (<code>csi</code>) are inclusive and default to zero.</li><li>Row end indexes (<code>rei</code>) and column end indexes (<code>cei</code>) are exclusive and default to length.</li><li>Negative index values can be used to count from the end of a dimension where <code>-1</code> is the last element.</li></ul><table><thead><tr><th>Operation</th><th>Code</th></tr></thead><tbody><tr><td>get element value</td><td><code>a[ri, ci]</code></td></tr><tr><td>get entire row</td><td><code>a[ri, :]</code></td></tr><tr><td>get entire column</td><td><code>a[:, ci]</code></td></tr><tr><td>get specific columns from a row</td><td><code>a[ri, [ci1, ci2, ...]]</code></td></tr><tr><td>get range of columns from a row</td><td><code>a[ri, csi:cei:step]</code></td></tr><tr><td>set element value</td><td><code>a[ri, ci] = v</code></td></tr><tr><td>set all elements in a row to a value</td><td><code>a[ri, :] = v</code></td></tr><tr><td>set all elements in a column to a value</td><td><code>a[:, ci] = v</code></td></tr><tr><td>set all elements in a row to values</td><td><code>a[ri, :] = [v1, v2, ...]</code><br>must provide all values</td></tr><tr><td>set all elements in a column to values</td><td><code>a[:, ci] = [v1, v2, ...]</code><br>must provide all values</td></tr><tr><td>set range of elements in a row to values</td><td><code>a[ri, csi:cei] = [v1, v2, ...]</code></td></tr><tr><td>set range of elements in a column to values</td><td><code>a[rsi:rei, ci] = [v1, v2, ...]</code></td></tr></tbody></table><h2 id="operations-on-one-array">Operations on One Array</h2><p>NumPy supports many operations that produce new arrays from the elements in existing arrays.</p><p>Here is a sampling of some that create a new array from the elements of an existing array.</p><table><thead><tr><th>Operation</th><th>Code</th></tr></thead><tbody><tr><td>add and create new array</td><td><code>b = a + v</code></td></tr><tr><td>add in place</td><td><code>a += v</code></td></tr><tr><td>subtract</td><td><code>b = a - v</code></td></tr><tr><td>multiply</td><td><code>b = a \* v</code></td></tr><tr><td>divide</td><td><code>b = a / v</code></td></tr><tr><td>reciprocal</td><td><code>b = np.reciprocal(a)</code><br>works with floats, but not integers</td></tr><tr><td>exponentiation</td><td><code>b = a \*\* v</code></td></tr><tr><td>square</td><td><code>b = np.square(a)</code></td></tr><tr><td>square root</td><td><code>b = np.sqrt(a)</code></td></tr><tr><td>sine</td><td><code>b = np.sin(a)</code></td></tr><tr><td>cosine</td><td><code>b = np.cos(a)</code></td></tr><tr><td>tangent</td><td><code>b = np.tan(a)</code></td></tr><tr><td>absolute value</td><td><code>b = np.absolute(a)</code> or<br><code>b = np.fabs(a)</code></td></tr><tr><td>round to nearest integer</td><td><code>b = np.rint(a)</code></td></tr><tr><td>floor</td><td><code>b = np.floor(a)</code></td></tr><tr><td>ceiling</td><td><code>b = np.ceil(a)</code></td></tr><tr><td>truncate</td><td><code>b = np.trunc(a)</code></td></tr><tr><td>sign (-1, 0, or 1)</td><td><code>b = np.sign(a)</code></td></tr><tr><td>convert degrees to radians</td><td><code>b = np.radians(a)</code> or <code>b = np.deg2rad(a)</code></td></tr><tr><td>convert radians to degrees</td><td><code>b = np.degrees(a)</code> or <code>b = np.rad2deg(a)</code></td></tr><tr><td>create array of same shape<br>containing boolean values</td><td><code>b = {condition involving a}</code><br>can use all relational and logical operators<br>example: <code>b = a &gt; 50</code><br>example: <code>b = (a &gt; 50) &amp; (a &lt; 100)</code></td></tr><tr><td>create 1D array of elements that meet criteria</td><td><code>b = a[{condition involving a}]</code><br>example: <code>b = a[a &gt; 50]</code></td></tr><tr><td>create 1D array of elements<br>in a 1D array at specified indexes</td><td><code>b = a[[i1, i2, ...]]</code></td></tr><tr><td>determine if any value in a row meets criteria</td><td><code>b = np.any({condition involving a}, axis=1)</code><br>returns 1D array of booleans for each row</td></tr><tr><td>determine if any value in a column meets criteria</td><td><code>b = np.any({condition involving a}, axis=0)</code><br>returns 1D array of booleans for each column</td></tr><tr><td>determine if all values in a row meets criteria</td><td><code>b = np.all({condition involving a}, axis=1)</code><br>returns 1D array of booleans for each row</td></tr><tr><td>determine if all values in a column meets criteria</td><td><code>b = np.all({condition involving a}, axis=0)</code><br>returns 1D array of booleans for each column</td></tr></tbody></table><h2 id="operations-on-two-arrays">Operations on Two Arrays</h2><p>Here is a sampling of operations that combine corresponding elements of two arrays to create elements in a new array.</p><table><thead><tr><th>Operation</th><th>Code</th></tr></thead><tbody><tr><td>add elements</td><td><code>b = np.add(a1, a2)</code></td></tr><tr><td>subtract elements</td><td><code>b = np.subtract(a1, a2)</code></td></tr><tr><td>multiply elements</td><td><code>b = np.multiply(a1, a2)</code></td></tr><tr><td>divide elements</td><td><code>b = np.divide(a1, a2)</code></td></tr><tr><td>maximum</td><td><code>b = np.maximum(a1, a2)</code> or<br><code>b = np.fmax(a1, a2)</code><br>element-wise only for 1D arrays</td></tr><tr><td>minimum</td><td><code>b = np.minimum(a1, a2)</code> or<br><code>b = np.fmin(a1, a2)</code><br>element-wise only for 1D arrays</td></tr><tr><td>greatest common divisor</td><td><code>b = np.gcd(a1, a2)</code><br>can also pass two numbers</td></tr><tr><td>lowest common multiple</td><td><code>b = np.lcm(a1, a2)</code><br>can also pass two numbers</td></tr></tbody></table><p>Here is a sampling of other operations on two arrays.</p><table><thead><tr><th>Operation</th><th>Code</th></tr></thead><tbody><tr><td>minimum element</td><td><code>v = np.min(a)</code></td></tr><tr><td>maximum element</td><td><code>v = np.max(a)</code></td></tr><tr><td>sum of elements</td><td><code>v = np.sum(a)</code></td></tr><tr><td>determinant</td><td><code>v = np.linalg.det(a)</code></td></tr><tr><td>matrix multiplication</td><td><code>b = np.matmul(a1, a2)</code><br>The number of columns in <code>a1</code> must<br>equal the number of rows in <code>a2</code>.</td></tr></tbody></table><p>The <code>np.linalg</code> package provides many more functions in addition to <code>det</code>. See <a href="https://numpy.org/doc/stable/reference/routines.linalg.html?v=1.0.15" rel="noopener" target="_blank">Linear algebra (numpy.linalg)</a>.</p></article>