<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>OCaml</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#notable-features">Notable Features</a></li><li><a href="#resources">Resources</a></li><li><a href="#usage">Usage</a></li><li><a href="#derived-languages">Derived Languages</a></li><li><a href="#installing">Installing</a></li><li><a href="#toolchain">Toolchain</a></li><li><a href="#help">Help</a></li><li><a href="#vs-code">VS Code</a></li><li><a href="#expressions">Expressions</a></li><li><a href="#repl">REPL</a></li><li><a href="#comments">Comments</a></li><li><a href="#primitive-types">Primitive Types</a></li><li><a href="#type-conversions">Type Conversions</a></li><li><a href="#idiomatic-names">Idiomatic Names</a></li><li><a href="#keywords">Keywords</a></li><li><a href="#operators">Operators</a></li><li><a href="#variables">Variables</a><ol><li><a href="#type-variables">Type Variables</a></li></ol></li><li><a href="#references">References</a></li><li><a href="#custom-types">Custom Types</a></li><li><a href="#variant-types">Variant Types</a><ol><li><a href="#option-variant-type">Option Variant Type</a></li><li><a href="#interpreter">Interpreter</a></li></ol></li><li><a href="#conditonal-logic">Conditonal Logic</a><ol><li><a href="#if-expression">if expression</a></li><li><a href="#match-expression">match expression</a></li></ol></li><li><a href="#iteration">Iteration</a></li><li><a href="#collections">Collections</a><ol><li><a href="#tuples">Tuples</a></li><li><a href="#lists">Lists</a></li><li><a href="#association-lists">Association Lists</a></li><li><a href="#arrays">Arrays</a></li><li><a href="#sets">Sets</a></li><li><a href="#records">Records</a></li><li><a href="#maps">Maps</a></li><li><a href="#hashtbl">Hashtbl</a></li></ol></li><li><a href="#functions">Functions</a></li><li><a href="#modules">Modules</a><ol><li><a href="#stdlib-module">Stdlib Module</a></li><li><a href="#printf-module">Printf Module</a></li><li><a href="#base-module">Base Module</a></li></ol></li><li><a href="#signatures">Signatures</a></li><li><a href="#functors">Functors</a></li><li><a href="#exception-handling">Exception Handling</a></li><li><a href="#source-files">Source Files</a></li><li><a href="#input%2Foutput">Input/Output</a></li><li><a href="#object-oriented-features">Object-oriented Features</a></li><li><a href="#dune">Dune</a><ol><li><a href="#creating">Creating</a></li><li><a href="#manually-creating">Manually Creating</a></li><li><a href="#building">Building</a></li><li><a href="#running">Running</a></li><li><a href="#cleaning">Cleaning</a></li><li><a href="#utop">utop</a></li><li><a href="#example-project">Example Project</a></li><li><a href="#unit-tests">Unit Tests</a></li><li><a href="#multiple-executables">Multiple Executables</a></li></ol></li><li><a href="#opam-libraries">opam Libraries</a><ol><li><a href="#switches">Switches</a></li></ol></li><li><a href="#pretty-printing">Pretty Printing</a></li><li><a href="#generating-documentation">Generating Documentation</a></li><li><a href="#http-servers">HTTP Servers</a><ol><li><a href="#dream">Dream</a></li></ol></li><li><a href="#jane-street-modules">Jane Street Modules</a></li><li><a href="#converting-ocaml-to-javascript">Converting OCaml to JavaScript</a></li><li><a href="#preprocessors">Preprocessors</a></li><li><a href="#suppressing-errors">Suppressing Errors</a></li><li><a href="#concurrency">Concurrency</a></li></ol></nav></aside><article><figure style="width: 30%"><img alt="OCaml logo" style="border: 0" src="/blog/assets/ocaml-logo.png?v=1.1.1"></figure><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://ocaml.org?v=1.1.1" rel="noopener" target="_blank">OCaml</a> is &quot;an industrial-strength functional programming language with an emphasis on expressiveness and safety.&quot; It was released in 1996 which is the same year that Java was released.</p><p>OCaml answers the question &quot;Can a programming language implement a type system so strong that it is nearly never necessary to specify types?&quot; OCaml uses a variant of the Hindley–Milner type system, which is a type inference algorithm for statically typed functional programming languages. The Hindley–Milner type system has the ability to infer the most general types of expressions without requiring explicit type annotations in many cases.</p><p>The Caml programming language, released in 1985, is the predecessor of OCaml. The name is short for &quot;Categorical Abstract Machine Language&quot;. OCaml is short for &quot;Objective Caml&quot;. It adds support for object-oriented programming and a more expressive type system.</p><p>OCaml is a member of the <a href="https://en.wikipedia.org/wiki/ML_(programming_language)" target="_blank">ML</a> (short for Meta Language) family of programming languages. Other dialects of ML include Standard ML and F#. (F# is basically a port of OCaml to the .NET platform.) ML influenced the design of many other languages including Clojure, Elm, Erlang, Haskell, Rust, and Scala.</p><p>F# is to C# as Scala and Clojure are to Java. They are ML-inspired languages that interoperate with an underlying non-ML language.</p><p>OCaml has an interpreter, a compiler that compiles to bytecode, and a compiler that creates native executables.</p><p>The OCaml compilers are implemented in OCaml. They are fast compared to the compilers for Haskell and Rust.</p><p>OCaml source files have the extension <code>.ml</code> which stands for &quot;meta language&quot;.</p><p>The performance of OCaml is generally about 50% that of C.</p><p>OCaml supports Foreign Function Interface (FFI) mechanisms to call C functions.</p><h2 id="notable-features" tabindex="-1">Notable Features</h2><p>OCaml has a number of notable features including:</p><ul><li>strong static type checking</li><li>strong type inference (almost never need to specify types)</li><li>most terse syntax possible for defining and calling functions</li><li>pattern matching with many ways to match</li><li>automatic function currying</li><li>functional programming (not as pure as Haskell, but more pragmatic)</li><li>object-oriented programming (though not often used)</li><li>variant types (like enums with associated values)</li><li>polymorphic types (OCaml's version of generics)</li><li>interesting implementing of modules</li><li>pragmatic approach to mutability (immutable by default, but can opt-in to some mutability)</li><li>automatic garbage collection</li><li>fast compared to other non-systems programming languages</li><li>interoperable with C</li><li>package management with OPAM</li><li>comes with an interpreter and two compilers (one to produce bytecode and one to produce native executables)</li><li>Dune build system</li><li>great REPL (utop)</li></ul><h2 id="resources" tabindex="-1">Resources</h2><ul><li><p><a href="https://ocaml.org" target="_blank">OCaml home page</a></p><p>Click the &quot;Playground&quot; link to experiment with writing OCaml code online.</p></li><li><p><a href="http://ocamlverse.net/content/ecosystem.html" target="_blank">OCamlverse Ecosystem</a></p></li><li><p><a href="https://learnxinyminutes.com/docs/ocaml/" target="_blank">Learn X in Y minutes</a> Where X=OCaml</p></li><li><p><a href="https://cs3110.github.io/textbook/cover.html" target="_blank">OCaml Programming: Correct + Efficient + Beautiful</a> book used in Cornell CS 3110 course</p></li><li><p><a href="https://www.youtube.com/watch?v=MUcka_SvhLw&list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU" target="_blank">OCaml Programming</a> course from Dr. Michael Ryan Clarkson at Cornell University</p></li><li><p><a href="https://dev.realworldocaml.org" target="_blank">Real World OCaml</a> book</p></li><li><p><a href="https://ocaml-book.com" target="_blank">OCaml from the Very Beginning</a> book</p></li><li><p><a href="https://caml.inria.fr/pub/old_caml_site/humps/" target="_blank">The Caml Humps</a> collection of links to Caml-related tools, libraries, code samples, and tips</p></li><li><p><a href="https://en.wikipedia.org/wiki/OCaml" target="_blank">OCaml Wikipedia page</a></p></li><li><p><a href="https://ilyasergey.net/YSC2229/" target="_blank">Introductory Data Structures and Algorithms</a> course from Yale-NUS College</p></li></ul><h2 id="usage" tabindex="-1">Usage</h2><p>Ahrefs uses OCaml in its backend systems and data processing pipelines for Search Engine Optimization (SEO) tools and data analysis.</p><p>Bloomberg created BuckleScript which compiles OCaml code to JavaScript. In 2022, BuckleScript was renamed to ReScript.</p><p>Citrix uses OCaml in the Hypervisor software.</p><p>Coq is an interactive theorem prover implemented in OCaml.</p><p>Docker uses OCaml in their desktop software for Windows and macOS.</p><p>Facebook uses OCaml for many things including:</p><ul><li>Hack programming language (extends PHP with static types)</li><li>Facebook Messager (the web version)</li><li>Flow static type system for JavaScript</li><li>Infer static analyzer for Java, C, C++, and Objective-C</li></ul><p>Haxe is a high-level cross-platform programming language that can be compiled to run on many platforms. Its compiler is implemented in OCaml.</p><p>Jane Street uses OCaml for all their financial software, including algorithmic trading. They are one of the largest users and supporters of OCaml.</p><p>LexiFi uses OCaml in their financial software for derivatives pricing and risk management.</p><p>T3 uses OCaml for algorithmic trading, quantitative analysis, risk management, and other financial software.</p><h2 id="derived-languages" tabindex="-1">Derived Languages</h2><p><a href="https://reasonml.github.io" target="_blank">Reason</a> is a syntax extension and toolchain for OCaml developed by Facebook. It provides a more JavaScript-like syntax while retaining full compatibility with the OCaml language and its libraries. The syntax of Reason is more familiar to JavaScript developers than OCaml. It also supports JSX.</p><p><a href="https://melange.re/v3.0.0/" target="_blank">Melange</a> is a set of tools that work with OCaml and Reason code to generate and interoperate with JavaScript. It can generate React components.</p><p><a href="https://coq.inria.fr" target="_blank">Coq</a> is a formal proof system that is primarily implemented in OCaml.</p><h2 id="installing" tabindex="-1">Installing</h2><p>To install the OCaml package manager &quot;opam&quot; for Linux and macOS, enter the following shell command which completes in a few seconds:</p><pre class="language-bash"><code class="language-bash"><span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">"sh &lt;(curl -fsSL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)"</span></code></pre><p>To install for windows, see <a href="https://ocaml.org/install" target="_blank">Install OCaml on Windows</a>.</p><p>After installing <code>opam</code>, enter <code>opam init</code> which takes over five minutes to complete.</p><p>To install tools for development, enter the following shell command which takes about four minutes to complete:</p><pre class="language-bash"><code class="language-bash">opam <span class="token function">install</span> ocaml-lsp-server odoc ocamlformat utop</code></pre><p>Each of these tools have a dependency on <code>dune</code>, so that is also installed.</p><p>To begin using the tools in your current shell, enter <code>eval $(opam env)</code>.</p><h2 id="toolchain" tabindex="-1">Toolchain</h2><p>The OCaml toolchain consists of the following components that provide everything needed to write, compile, test, debug, and profile OCaml programs and libraries.</p><ul><li>The <code>ocaml</code> interpreter interactive toplevel executes code interactively for testing small code snippets and exploring language features.</li><li>The <code>ocamlc</code> compiler compiles source code into bytecode that can run on any platform. It creates files with the extensions <code>.cmo</code> and <code>.cmi</code> (for interfaces). The <code>-o</code> flag typical typically specifies an output file with a <code>.byte</code> extension that is passed to the <code>ocamlrun</code> coommand. The <code>.cmo</code> and <code>.cmi</code> files are not needed to run the <code>.byte</code> file, but incremental recompilation relies on them.</li><li>The <code>ocamlrun</code> command executes a bytecode file.</li><li>The <code>ocamlopt</code> compiler compiles source code into an optimized, platform-specific executable.</li><li>The <code>opam</code> package Manager installs libraries and tools, manages dependency versions, and upgrades them.</li><li>The <code>ocamlbuild</code> (predecessor to <code>dune</code>) and <code>dune</code> (modern) build systems simplify building complex and managing dependencies.</li><li>The <code>ocamldoc</code> tool generates documentation from OCaml source code annotations. This is in maintenance mode. Using <code>odoc</code> through Dune is preferred.</li><li>The <code>ocamldebug</code> debugger is used to debug OCaml programs.</li><li>The <code>ocamlprof</code> tool profiles OCaml programs to analyze their performance and identify bottlenecks.</li><li>The standard library provides commonly needed functions and data structures. It includes modules for strings, lists, arrays, I/O operations, and more.</li></ul><p>A module is a collection of named values that can be constants, functions, and types. An <code>open</code> expression brings the names defined in a module into the current scope. An <code>include</code> expression inserts the code as if it was part of the file. Circular dependencies between modules are not allowed.</p><p>Suppose we have the file <code>my_module.ml</code> containing <code>let add a b = a + b</code> and we have the file <code>main.ml</code> containing the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> My_module<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> sum <span class="token operator">=</span> add <span class="token number">1</span> <span class="token number">2</span> <span class="token keyword">in</span><br>  print_int sum</code></pre><p>Ending a source file that is the starting point of a program with <code>let () =</code> followed by an expression is:</p><ul><li>not required, but ...</li><li>ensures that the result of the expression will be the unit value</li><li>makes it clear that the purpose of the expression is the side effects it produces</li></ul><p>It is recommended to create a Dune project, move these files in the project <code>bin</code> directory, and run it with <code>dune exec {project-name}</code>. See the Dune section below for more detail.</p><p>However, there are several options for building and running a project without using Dune.</p><p>To compile this to an executable and run it, enter <code>ocamlopt my_module.ml main.ml -o main</code> and <code>./main</code>.</p><p>To compile this to bytecode and run it, enter <code>ocamlc my_module.ml main.ml -o main.byte</code> and <code>ocamlrun main.byte</code>.</p><p>To compile this to an executable and run it by specifying only the main source file, enter <code>ocamlbuild main.native</code> and <code>./main.native</code>. The <code>ocamlbuild</code> command creates a <code>_build</code> directory containing many intermediate files that are not needed to run the program.</p><p>To compile this to bytecode and run it by specifying only the main source file, enter <code>ocamlbuild -cflags -g main.byte</code> and <code>ocamlrun main.byte</code>.</p><h2 id="help" tabindex="-1">Help</h2><p>For help on OCaml, see:</p><ul><li><a href="https://tinyurl.com/discord-ocaml" target="_blank">OCaml Discord</a></li><li><a href="https://discuss.ocaml.org/" target="_blank">OCaml Discourse</a></li><li><a href="https://github.com/lindig/ocaml-style" target="_blank">OCaml style guide</a></li></ul><h2 id="vs-code" tabindex="-1">VS Code</h2><p>Install the &quot;OCaml Platform&quot; extension from OCaml Labs.</p><p>Create the file <code>.ocamlformat</code> in each project root directory containing at least the following in order for VS Code to format OCaml code on save.</p><pre class="language-text"><code class="language-text">profile = default<br>version = 0.26.1</code></pre><p>It may be necessary to copy the <code>.ocamlformat</code> into every subdirectory that contains its own <code>dune-project</code> file.</p><p>Sometimes after code changes VS Code flags errors that aren't real. Running &quot;Developer: Reload Window&quot; from the command palette clears them. This issue may go away if you run <code>dune build -w</code> (for watch mode) in a terminal window. Doing this is useful anyway because there may be errors that <code>dune build</code> will flag, but the LSP used in VS Code will not.</p><h2 id="expressions" tabindex="-1">Expressions</h2><p>An expression in OCaml can be:</p><ul><li>a literal (ex. <code>true</code>, <code>3</code>, <code>3.14</code>, or &quot;hello&quot;)</li><li>a variable (ex. <code>x</code>)</li><li>a variable declaration (ex. <code>let x = 3</code>),</li><li>a keyword expression (ex. <code>if ...</code> or <code>for ...</code>)</li><li>a function declaration</li><li>a function call</li><li>a series of any of the above separated by semicolons where only the last one is allowed to have a value other than the unit value</li></ul><p>When using a series of expressions, the expressions before the last can be calls to functions that return a value (not unit) if the <code>ignore</code> function is used. That function takes any value and returns the unit value <code>()</code>.</p><p>The following code shows two ways to ignore the return value of a function. Assume the <code>add_dog</code> function returns a <code>dog</code> record.</p><pre class="language-ocaml"><code class="language-ocaml">ignore <span class="token punctuation">(</span>add_dog <span class="token string">"Comet"</span> <span class="token string">"Whippet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>add_dog <span class="token string">"Oscar"</span> <span class="token string">"German Shorthaired Pointer"</span> <span class="token operator">|></span> ignore<span class="token punctuation">;</span><br>print_endline <span class="token string">"finished adding dogs"</span></code></pre><h2 id="repl" tabindex="-1">REPL</h2><p>OCaml has two REPLs. A basic one can be started by entering <code>ocaml</code>. A better one is <code>utop</code> which is short for &quot;Universal Toplevel&quot;. The <code>utop</code> command provides a more interactive, user-friendly interface that includes line editing, syntax highlighting, command history, and tab completion.</p><p>In either REPL the expressions you enter are only evaluated when they are terminated by a double semicolon (<code>;;</code>). This allows entering a series of expressions that are separated from each other by a single colon and allows them to span multiple lines. For example:</p><pre class="language-ocaml"><code class="language-ocaml">print_int <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> print_int <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;;</span> <span class="token comment">(* 56 *)</span></code></pre><p>Double semicolons are only used in REPL sessions, not in source files (except when assigning global identifiers).</p><p>When an expression is entered, <code>utop</code> will output its name, inferred type, and value. For example, entering <code>let x = 7;;</code> will output <code>val x : int = 7;</code>.</p><p>If the expression does not have a name, the part to the left of the colon will be a dash. For example, entering a raw value like <code>7;;</code> or an anonymous function like <code>fun x -&gt; x * x;;</code> will do this. But entering a named function like <code>let square x = x * x;;</code> will output the name.</p><p>Use the left and right arrow keys to move the cursor within the expression and make edits.</p><p>Use the up and down arrow keys to recall previously entered expressions. They can be edited and executed again.</p><p>To show the type of an expression <code>e</code>, enter <code>#show e;;</code></p><p>To load definitions in an OCaml source file into the REPL, enter <code>#use &quot;{file-path}&quot;;;</code>. This enables using all the types and functions defined in the source file inside the REPL.</p><p>To trace the follow of function execution, enter <code>#trace {fn-name};;</code>. Then enter a call to the function. This is especially useful for recursive functions. To stop tracing the function, enter <code>#untrace {fn-name};;</code>.</p><p>To exit the REPL, press ctrl-d or enter #quit.</p><p>To specify OCaml code to run every time <code>utop</code> is started, place it in the file <code>.ocamllint</code> in the current directory.</p><p>There is also an iOS app called &quot;OCaml&quot; for evaluating OCaml expressions.</p><h2 id="comments" tabindex="-1">Comments</h2><p>Comments in OCaml code begin with <code>(*</code> and end with <code>*)</code>. They can span any number of lines.</p><p>Comments can be nested.</p><p>Doc comments provided documentation that can be extracted from source files. They begin with <code>(**</code> and end with <code>*)</code>. Their content is similar to JSDoc comments, including the use of <code>@param</code> and <code>@return</code> annotations. There are three variations of doc comments, floating, item, and label.</p><h2 id="primitive-types" tabindex="-1">Primitive Types</h2><p>OCaml supports the following primitive types. Their sizes depend on the CPU.</p><ul><li><code>bool</code> - 1 byte with the literal values <code>true</code> and <code>false</code></li><li><code>char</code> - 1 byte ASCII, not Unicode</li><li><code>int</code> - 8 or 4 bytes</li><li><code>float</code> - 8 bytes</li><li><code>string</code> - sequence of bytes, not Unicode characters</li></ul><p>Literal chars are delimited by single quotes.</p><p>Literal strings are delimited by double quotes. The <code>^</code> operator is used to concatenate strings.</p><p>The <code>Char</code> and <code>String</code> modules provide many functions for operating on values of these types.</p><p>For Unicode support, see the libraries <code>Uutf</code>, <code>Uutf_string</code>, and <code>ocaml-unicode</code>.</p><p>Primitive values are expressions that do not require additional evaluation.</p><p>OCaml does not support null values.</p><h2 id="type-conversions" tabindex="-1">Type Conversions</h2><p>The OCaml standard library provides many functions for converting a value from one type to another. Examples include:</p><ul><li><code>float_of_int</code></li><li><code>int_of_float</code> - <code>truncate</code> is an alias</li><li><code>int_of_char</code></li><li><code>char_of_int</code></li><li><code>string_of_bool</code></li><li><code>bool_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>bool_of_string_opt</code> - returns <code>None</code> if conversion fails</li><li><code>string_of_int</code></li><li><code>int_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>int_of_string_opt</code> - returns <code>None</code> if conversion fails</li><li><code>string_of_float</code></li><li><code>float_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>float_of_string_opt</code> - returns <code>None</code> if conversion fails</li></ul><p>To convert a <code>char</code> expression <code>c</code> to a <code>string</code> value, use <code>String.make 1 c</code>. There is no <code>string_of_char</code> function.</p><h2 id="idiomatic-names" tabindex="-1">Idiomatic Names</h2><p>It is idiomatic in OCaml for</p><ul><li>variable and class names to use snake_case with all lowercase letters</li><li>module names to use CamelCase, starting with an uppercase letter</li></ul><p>It is idiomatic in OCaml for the name of a function that</p><ul><li>transforms a value of type x to a value of type y to be <code>y_of_x</code></li><li>returns a <code>Option</code> value to end in <code>_opt</code></li><li>raises an exception to end in <code>_exc</code></li></ul><h2 id="keywords" tabindex="-1">Keywords</h2><p>OCaml reserves the use of the following identifiers: <code>and</code>, <code>as</code>, <code>assert</code>, <code>asr</code>, <code>begin</code>, <code>class</code>, <code>constraint</code>, <code>do</code>, <code>done</code>, <code>downto</code>, <code>else</code>, <code>end</code>, <code>exception</code>, <code>external</code>, <code>false</code>, <code>for</code>, <code>fun</code>, <code>function</code>, <code>functor</code>, <code>if</code>, <code>in</code>, <code>include</code>, <code>inherit</code>, <code>initializer</code>, <code>land</code>, <code>lazy</code>, <code>let</code>, <code>lor</code>, <code>lsl</code>, <code>lsr</code>, <code>lxor</code>, <code>match</code>, <code>method</code>, <code>mod</code>, <code>module</code>, <code>mutable</code>, <code>new</code>, <code>nonrec</code>, <code>object</code>, <code>of</code>, <code>open</code>, <code>or</code>, <code>private</code>, <code>rec</code>, <code>sig</code>, <code>struct</code>, <code>then</code>, <code>to</code>, <code>true</code>, <code>try</code>, <code>type</code>, <code>val</code>, <code>virtual</code>, <code>when</code>, <code>while</code>, and <code>with</code>.</p><h2 id="operators" tabindex="-1">Operators</h2><p>OCaml operators only operate on specific types. This enables type inference of function return types because the compiler can determine the types required by its code. It is a very important way in which OCaml differs from most other programming languages.</p><p>Operators for <code>float</code> values are the same as those for <code>int</code> values, but with a <code>.</code> added to the end.</p><p>The arithmetic operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>~-</code></td><td>int negation</td></tr><tr><td><code>+</code></td><td>int addition</td></tr><tr><td><code>-</code></td><td>int subtraction</td></tr><tr><td><code>*</code></td><td>int multiplication</td></tr><tr><td><code>/</code></td><td>int division</td></tr><tr><td><code>~-.</code></td><td>float negation</td></tr><tr><td><code>+.</code></td><td>float addition</td></tr><tr><td><code>-.</code></td><td>float subtraction</td></tr><tr><td><code>*.</code></td><td>float multiplication</td></tr><tr><td><code>/.</code></td><td>float division</td></tr><tr><td><code>**</code></td><td>float exponentiation</td></tr></tbody></table><p>The <code>-</code> and <code>-.</code> operators can also be used for unary negation, but in some cases the meaning is ambiguous. That is why the <code>~-</code> and <code>~-.</code> operators are provided.</p><p>There are no operators like <code>++</code> and <code>--</code> to increment or decrement a number. Instead use the functions <code>succ</code> and <code>pred</code> to get the successor or predecessor.</p><p>There is no exponentiation operator for <code>int</code> values.</p><p>The string operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>^</code></td><td>string concatenation</td></tr><tr><td><code>^^</code></td><td>format string concatenation</td></tr></tbody></table><p>The relational and logical operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>==</code></td><td>same object</td></tr><tr><td><code>!=</code></td><td>not same object</td></tr><tr><td><code>=</code></td><td>structural equality</td></tr><tr><td><code>&lt;&gt;</code></td><td>structural inequality</td></tr><tr><td><code>&lt;</code></td><td>less than</td></tr><tr><td><code>&gt;</code></td><td>greater than</td></tr><tr><td><code>&lt;=</code></td><td>less than or equal</td></tr><tr><td><code>&gt;=</code></td><td>greater than equal</td></tr><tr><td><code>&amp;&amp;</code></td><td>boolean and</td></tr><tr><td><code>||</code></td><td>boolean or</td></tr></tbody></table><p>The <code>=</code> operator is also used for assignment.</p><p>The remaining operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>!</code></td><td>gets ref value (dereferences)</td></tr><tr><td><code>:=</code></td><td>sets ref value (assigns)</td></tr><tr><td><code>@</code></td><td>list concatenation</td></tr><tr><td><code>|&gt;</code></td><td>reverse function application (aka pipe forward)</td></tr><tr><td><code>@@</code></td><td>evalutes function call on right, then uses result in expression on left</td></tr></tbody></table><p>The function application operator <code>@@</code> provides an alternative to surrounding a function call with parentheses. It has lower precedence than function application. The <code>@@</code> operator cannot follow <code>assert</code> because that is not a normal function.</p><p>For example, the two expressions passed to <code>printf</code> below are equivalent. In both cases, <code>sum 3 4</code> is evaluated first, <code>double</code> that result is evaluateed next, and <code>printf</code> is evaluated last.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> sum a b <span class="token operator">=</span> a <span class="token operator">+</span> b<br><span class="token keyword">let</span> double a <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  printf <span class="token string">"result = %d\n"</span> <span class="token punctuation">(</span>double <span class="token punctuation">(</span>sum <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  printf <span class="token string">"result = %d\n"</span> <span class="token operator">@@</span> double <span class="token operator">@@</span> sum <span class="token number">3</span> <span class="token number">4</span></code></pre><p>Most OCaml operators are implemented as binary functions. To use them as functions, wrap them in parentheses. For example, <code>a + b</code> is the same as <code>(+) a b</code>. Adding spaces inside the parentheses is optional, but is required for the <code>*</code> operator because <code>(*</code> is interpreted as the beginning of a comment.</p><p>Operator functions can be passed to functions like <code>List.filter</code>.</p><p>The following code demonstrates writing a function that takes a comparison function which can be a logical operator. The <code>choose</code> function takes two lists and a comparison function. It returns a new list where each element is the element from the first or second list at the same index where comparing them using the comparison function evaluates to true.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> choose list1 list2 cmp_fun <span class="token operator">=</span><br>  <span class="token comment">(* match is described in the "Conditional Logic" section. *)</span><br>  <span class="token keyword">match</span> <span class="token punctuation">(</span>list1<span class="token punctuation">,</span> list2<span class="token punctuation">)</span> <span class="token keyword">with</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">(* both lists are empty; return empty list *)</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">_</span> <span class="token operator">-></span> list2 <span class="token comment">(* first list is empty; return second list *)</span><br>  <span class="token operator">|</span> <span class="token punctuation">_</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> list1 <span class="token comment">(* second list is empty; return first list *)</span><br>  <span class="token operator">|</span> h1 <span class="token punctuation">::</span> t1<span class="token punctuation">,</span> h2 <span class="token punctuation">::</span> t2 <span class="token operator">-></span><br>      <span class="token keyword">if</span> cmp_fun h1 h2 <span class="token keyword">then</span><br>        h1 <span class="token punctuation">::</span> choose t1 t2 cmp_fun <span class="token comment">(* add h1 to result list *)</span><br>      <span class="token keyword">else</span> h2 <span class="token punctuation">::</span> choose t1 t2 cmp_fun <span class="token comment">(* add h2 to result list *)</span><br><br><span class="token keyword">let</span> l1 <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token number">10</span> <span class="token punctuation">]</span><br><span class="token keyword">let</span> l2 <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token number">4</span> <span class="token punctuation">]</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  List<span class="token punctuation">.</span>iter<br>    <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span><br>      print_int x<span class="token punctuation">;</span><br>      print_string <span class="token string">" "</span><span class="token punctuation">)</span><br>    <span class="token punctuation">(</span>choose l1 l2 <span class="token punctuation">(</span> <span class="token operator">></span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">(* relational operator passed here *)</span></code></pre><p>The result is <code>[7; 3; 4; 8; 9; 10]</code>.</p><p>Custom binary operators can be defined using an allowed set of characters. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">type</span> point <span class="token operator">=</span> <span class="token punctuation">{</span> x <span class="token punctuation">:</span> float<span class="token punctuation">;</span> y <span class="token punctuation">:</span> float <span class="token punctuation">}</span><br><br><span class="token comment">(* This operator adds to points. *)</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span> <span class="token operator">+!</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>p1 <span class="token punctuation">:</span> point<span class="token punctuation">)</span> <span class="token punctuation">(</span>p2 <span class="token punctuation">:</span> point<span class="token punctuation">)</span> <span class="token punctuation">:</span> point <span class="token operator">=</span><br>  <span class="token punctuation">{</span> x <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">+.</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span> y <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">+.</span> p2<span class="token punctuation">.</span>y <span class="token punctuation">}</span><br><br><span class="token comment">(* This shadows the built-in + operator to perform subtraction instead,<br>   but only in the current scope. *)</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span> <span class="token operator">+</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>n1 <span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token punctuation">(</span>n2 <span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token punctuation">:</span> int <span class="token operator">=</span> n1 <span class="token operator">-</span> n2<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">2.0</span> <span class="token punctuation">}</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">4.0</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">6.0</span> <span class="token punctuation">}</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> p3 <span class="token operator">=</span> p1 <span class="token operator">+!</span> p2 <span class="token keyword">in</span><br>  printf <span class="token string">"(%f, %f)\n"</span> p3<span class="token punctuation">.</span>x p3<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> n1 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">and</span> n2 <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">in</span><br>  printf <span class="token string">"%d\n"</span> <span class="token punctuation">(</span>n1 <span class="token operator">+</span> n2<span class="token punctuation">)</span> <span class="token comment">(* -1 *)</span></code></pre><h2 id="variables" tabindex="-1">Variables</h2><p>Variables are immutable. An exception is that variables in a REPL can be reassigned.</p><p>Identifier names must start with a lowercase letter unless they refer to a module, constructor, or &quot;polymorphic variant tag&quot;. They can contain letters, digits, and the underscore character. They can also end with a single quote to create pairs of names like <code>x</code> and <code>x'</code> (for x prime). Technically an indentfier can contain any number of single quotes and they can appear anywhere except at the beginning, but doing this is odd!</p><p>A <code>let</code> expression binds an identifier to the value of an expression whose scope is the expression that follows the <code>in</code> keyword. The value of a <code>let</code> expression is the value of its expression with all occurrences of the identifier replaced with its value. For example, the value of this <code>let</code> expression is <code>3</code>:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span><br>a <span class="token operator">+</span> b</code></pre><p>It is a common error to write <code>let variable = expression;</code> instead of <code>let variable = expression in</code>. When this is done, your editor should flag it with the message &quot;Warning 10: this expression should have type unit&quot;. If you compile the code, the message &quot;Error: Syntax error&quot; will be output and will refer to the last line in the file, which is unhelpful.</p><p>The code above can also use the <code>and</code> keyword as follows:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span> a <span class="token operator">+</span> b</code></pre><p>Note how the expression that follows a <code>let</code> expression can be another <code>let</code> expression in order to place multiple identifiers in the scope of the final expression.</p><p>Identifers bound by <code>let</code> expressions go out-of-scope after they are evaluated.</p><p>The type of a variable can be specified, but typically this is omitted because the type can be inferred.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token punctuation">:</span> int <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> b <span class="token punctuation">:</span> int <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span><br>a <span class="token operator">+</span> b</code></pre><p>While it is not required to include a space on both sides of the colon when specifying a type, it is customary and the ocamlformat code formatter will add them.</p><p>Let definitions omit the <code>in</code> keyword. They create global definitions that do not go out of scope after they are evaluated. They are not expressions, so they do not have a value.</p><p>The following example binds three global identifiers. Note how a double semicolon is used to terminate the assignments of global identifiers.</p><p>In order to call a function that takes no arguments, such as <code>print_newline</code>, it must be &quot;passed&quot; the &quot;unit&quot; value <code>()</code>. Without this it is just a reference to the function and not a call to it.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><br><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><br><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;;</span><br><br>print_int <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_int <span class="token punctuation">(</span>b <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="type-variables" tabindex="-1">Type Variables</h3><p>OCaml supports type variables which are similar to generics in other languages. Type variables serve as a placeholder for an unknown type. They are written with a single quote followed by a lowercase name.</p><p>Often the name is just <code>'a</code> and is pronounced &quot;alpha&quot;. If additional type variables are needed, it is common to use <code>'b</code> (beta) and <code>'c</code> (gamma).</p><p>For example, entering <code>[];;</code> in <code>utop</code> outputs type type <code>'a list</code> because it is a list where the type of the elements is unknown.</p><p>The following code demonstrates writing a function that uses parametric polymorphism to find the largest value in a list of values.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> max_element <span class="token punctuation">(</span>ls <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> list<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> option <span class="token operator">=</span><br>  <span class="token keyword">match</span> ls <span class="token keyword">with</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> None <span class="token comment">(* for an empty list *)</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span> x <span class="token punctuation">]</span> <span class="token operator">-></span><br>      Some x <span class="token comment">(* for a list with only one element *)</span><br>  <span class="token operator">|</span> hd <span class="token punctuation">::</span> tl <span class="token operator">-></span> <span class="token punctuation">(</span><br>      <span class="token keyword">match</span> max_element tl <span class="token keyword">with</span><br>      <span class="token operator">|</span> None <span class="token operator">-></span><br>          Some hd <span class="token comment">(* head is maximum if tail is empty *)</span><br>      <span class="token operator">|</span> Some max_tl <span class="token operator">-></span> Some <span class="token punctuation">(</span><span class="token keyword">if</span> hd <span class="token operator">></span> max_tl <span class="token keyword">then</span> hd <span class="token keyword">else</span> max_tl<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">9</span> <span class="token punctuation">]</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> max <span class="token operator">=</span> max_element numbers <span class="token keyword">in</span><br>  <span class="token keyword">match</span> max <span class="token keyword">with</span><br>  <span class="token operator">|</span> None <span class="token operator">-></span> print_endline <span class="token string">"empty list"</span><br>  <span class="token operator">|</span> Some max <span class="token operator">-></span> print_int max</code></pre><h2 id="references" tabindex="-1">References</h2><p>While variables are immutable, they can be bound to a reference that is mutable. References are created with the <code>ref</code> function which must be given an initial value. The initial value determines its type.</p><p>The <code>!</code> prefix operator dereferences a <code>ref</code> to obtain its value.</p><p>The <code>:=</code> operator assigns a new value to a <code>ref</code>.</p><p>For example, the following code sets the variable <code>score</code> to a reference to <code>0</code>. The <code>while</code> loop increments the value until it reaches 10.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> score <span class="token operator">=</span> ref <span class="token number">0</span> <span class="token keyword">in</span><br><span class="token keyword">while</span> <span class="token operator">!</span>score <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token keyword">do</span><br>  score <span class="token operator">:=</span> <span class="token operator">!</span>score <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  print_int <span class="token operator">!</span>score<span class="token punctuation">;</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token keyword">done</span></code></pre><p>Refs are actually single field records with a mutable field named <code>contents</code>.</p><p>Other kinds of values in OCaml that support mutation include arrays, record fields (when marked as <code>mutable</code>), Values created with the following standard library modules also support mutation: <code>Atomic</code>, <code>Bytes</code>, <code>Hashtbl</code>, <code>Mutex</code>, <code>Queue</code>, <code>Semaphore</code>, and <code>Stack</code>.</p><h2 id="custom-types" tabindex="-1">Custom Types</h2><p>The <code>type</code> keyword defines a custom type.</p><p>It can be used to simply create an alias for an existing type. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> weight <span class="token operator">=</span> float<br><span class="token keyword">type</span> point <span class="token operator">=</span> float <span class="token operator">*</span> float <span class="token comment">(* a tuple *)</span></code></pre><p>The <code>type</code> keyword can also be used to define variant types which are described in the next section.</p><h2 id="variant-types" tabindex="-1">Variant Types</h2><p>Variant types have many uses including enumerated values, error handling, and for representing data structures whose shape can vary.</p><p>&quot;Sum types&quot; (aka &quot;one-of types&quot;) describe alternatives. Primitive types like <code>int</code> and variant types describe below are examples of sum types.</p><p>&quot;Product types&quot; (aka &quot;each-of types&quot;) are types that can hold multiple pieces of data with differing types. Tuples and records are examples of product types.</p><p>Lists are sum types because they can be either an empty list or a head and tail (where the tail can be an empty list). Lists are also product types because they hold a head and a tail which have different types.</p><p>Each variant name is called a &quot;constructor&quot; (aka &quot;tag&quot;) and must begin with an uppercase letter. Each construtor can have an associated value of a type that is specified after the <code>of</code> keyword. The value types of the variants can differ.</p><p>To see all the constructors of a variant type in <code>utop</code>, enter <code>#show {variant-type}</code>.</p><p>Constructor expressions that do not use a value are referred to as &quot;constant variant expressions&quot;. The following code provides some examples:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> season <span class="token operator">=</span> Spring <span class="token operator">|</span> Summer <span class="token operator">|</span> Fall <span class="token operator">|</span> Winter<br><span class="token keyword">type</span> tense <span class="token operator">=</span> Spring <span class="token operator">|</span> Sprung <span class="token operator">|</span> Sprang<br><br><span class="token comment">(* The first vertical bar here is optional.<br>   When pattern matching a sum type, if all variants aren't matched,<br>   the warning "this pattern-matching is not exhaustive" will appear.<br>   Since both the season and tense types define a Spring constructor,<br>   we need to specify which variant type to use. *)</span><br><span class="token keyword">let</span> forecast <span class="token punctuation">:</span> season <span class="token operator">-></span> string <span class="token operator">=</span> <span class="token keyword">function</span><br>  <span class="token operator">|</span> Spring <span class="token operator">-></span> <span class="token string">"rain"</span><br>  <span class="token operator">|</span> Summer <span class="token operator">-></span> <span class="token string">"sun"</span><br>  <span class="token operator">|</span> Fall <span class="token operator">-></span> <span class="token string">"nice"</span><br>  <span class="token operator">|</span> Winter <span class="token operator">-></span> <span class="token string">"snow"</span><br><br><span class="token keyword">let</span> get_tense <span class="token punctuation">:</span> tense <span class="token operator">-></span> int <span class="token operator">=</span> <span class="token keyword">function</span><br>  <span class="token operator">|</span> Spring <span class="token operator">-></span> <span class="token number">1</span><br>  <span class="token operator">|</span> Sprang <span class="token operator">-></span> <span class="token number">2</span><br>  <span class="token operator">|</span> Sprung <span class="token operator">-></span> <span class="token number">3</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  print_endline <span class="token punctuation">(</span>forecast Winter<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Another option to avoid constructor name conflicts is to wrap the conflicting variant type in a struct.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">module</span> Tense <span class="token operator">=</span> <span class="token keyword">struct</span><br>  <span class="token comment">(* It is idiomatic for the main type in a module to be named "t". *)</span><br>  <span class="token keyword">type</span> t <span class="token operator">=</span> Spring <span class="token operator">|</span> Sprung <span class="token operator">|</span> Sprang<br><span class="token keyword">end</span><br><br><span class="token keyword">let</span> tense <span class="token operator">=</span> <span class="token keyword">function</span> Tense<span class="token punctuation">.</span>Spring <span class="token operator">-></span> <span class="token number">1</span> <span class="token operator">|</span> Tense<span class="token punctuation">.</span>Sprang <span class="token operator">-></span> <span class="token number">2</span> <span class="token operator">|</span> Tense<span class="token punctuation">.</span>Sprung <span class="token operator">-></span> <span class="token number">3</span></code></pre><p>One more option is to a prefix to the constructor names so they don't collide.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> season <span class="token operator">=</span> SSpring <span class="token operator">|</span> SSummer <span class="token operator">|</span> SFall <span class="token operator">|</span> SWinter<br><span class="token keyword">type</span> tense <span class="token operator">=</span> TSpring <span class="token operator">|</span> TSprung <span class="token operator">|</span> TSprang</code></pre><p>Variants that do use a value are referred to as &quot;non-constant variant expressions&quot;. The following code provides some examples:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* This can be used similarly to TypeScript type unions. *)</span><br><span class="token keyword">type</span> my_union <span class="token operator">=</span> BoolVal <span class="token keyword">of</span> bool <span class="token operator">|</span> IntVal <span class="token keyword">of</span> int <span class="token operator">|</span> StringVal <span class="token keyword">of</span> string<br><br><span class="token keyword">let</span> get_string <span class="token operator">=</span> <span class="token keyword">function</span><br><span class="token operator">|</span> BoolVal b <span class="token operator">-></span> string_of_bool b<br><span class="token operator">|</span> IntVal i <span class="token operator">-></span> string_of_int i<br><span class="token operator">|</span> StringVal s <span class="token operator">-></span> s<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> b <span class="token operator">=</span> BoolVal <span class="token boolean">true</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> i <span class="token operator">=</span> IntVal <span class="token number">10</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> s <span class="token operator">=</span> StringVal <span class="token string">"hello"</span> <span class="token keyword">in</span><br>  print_endline <span class="token punctuation">(</span>get_string i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  print_endline <span class="token punctuation">(</span>get_string s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  print_endline <span class="token punctuation">(</span>get_string b<span class="token punctuation">)</span></code></pre><p>The following code uses a variant type to describe shapes.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> point <span class="token operator">=</span> float <span class="token operator">*</span> float<br><br><span class="token keyword">type</span> shape <span class="token operator">=</span><br>  <span class="token operator">|</span> Circle <span class="token keyword">of</span> <span class="token punctuation">{</span> center <span class="token punctuation">:</span> point<span class="token punctuation">;</span> radius <span class="token punctuation">:</span> float <span class="token punctuation">}</span><br>  <span class="token operator">|</span> Rectangle <span class="token keyword">of</span> <span class="token punctuation">{</span> lower_left <span class="token punctuation">:</span> point<span class="token punctuation">;</span> width <span class="token punctuation">:</span> float<span class="token punctuation">;</span> height <span class="token punctuation">:</span> float <span class="token punctuation">}</span><br><br><span class="token keyword">let</span> area <span class="token operator">=</span> <span class="token keyword">function</span><br>  <span class="token operator">|</span> Circle <span class="token punctuation">{</span> radius <span class="token operator">=</span> r <span class="token punctuation">}</span> <span class="token operator">-></span> Float<span class="token punctuation">.</span>pi <span class="token operator">*.</span> r <span class="token operator">*.</span> r<br>  <span class="token operator">|</span> Rectangle <span class="token punctuation">{</span> width <span class="token operator">=</span> w<span class="token punctuation">;</span> height <span class="token operator">=</span> h <span class="token punctuation">}</span> <span class="token operator">-></span> w <span class="token operator">*.</span> h<br><br><span class="token keyword">let</span> center shape <span class="token operator">=</span><br>  <span class="token keyword">match</span> shape <span class="token keyword">with</span><br>  <span class="token operator">|</span> Circle <span class="token punctuation">{</span> center <span class="token operator">=</span> c <span class="token punctuation">}</span> <span class="token operator">-></span> c<br>  <span class="token operator">|</span> Rectangle <span class="token punctuation">{</span> lower_left <span class="token operator">=</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> width <span class="token operator">=</span> w<span class="token punctuation">;</span> height <span class="token operator">=</span> h <span class="token punctuation">}</span> <span class="token operator">-></span><br>      <span class="token punctuation">(</span>x <span class="token operator">+.</span> <span class="token punctuation">(</span>w <span class="token operator">/.</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y <span class="token operator">+.</span> <span class="token punctuation">(</span>h <span class="token operator">/.</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> c <span class="token operator">=</span> Circle <span class="token punctuation">{</span> center <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> radius <span class="token operator">=</span> <span class="token number">10.0</span> <span class="token punctuation">}</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> r <span class="token operator">=</span><br>    Rectangle <span class="token punctuation">{</span> lower_left <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> width <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span> height <span class="token operator">=</span> <span class="token number">5.0</span> <span class="token punctuation">}</span><br>  <span class="token keyword">in</span><br>  printf <span class="token string">"c area = %f\n"</span> <span class="token punctuation">(</span>area c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 314.159265 *)</span><br>  printf <span class="token string">"r area = %f\n"</span> <span class="token punctuation">(</span>area r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 50.0 *)</span><br>  <span class="token keyword">let</span> x<span class="token punctuation">,</span> y <span class="token operator">=</span> center c <span class="token keyword">in</span><br>  printf <span class="token string">"c center = (%f, %f)\n"</span> x y<span class="token punctuation">;</span> <span class="token comment">(* (0.0, 0.0) *)</span><br>  <span class="token keyword">let</span> x<span class="token punctuation">,</span> y <span class="token operator">=</span> center r <span class="token keyword">in</span><br>  printf <span class="token string">"r center = (%f, %f)\n"</span> x y<span class="token punctuation">;</span> <span class="token comment">(* (5.0, 2.5) *)</span></code></pre><p>Variant types can be parameterized. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token comment">(* A tree can be empty or it can have a node<br>   that holds a left tree, a value, and a right tree. *)</span><br><span class="token keyword">type</span> <span class="token type-variable function">'a</span> tree <span class="token operator">=</span> Empty <span class="token operator">|</span> Node <span class="token keyword">of</span> <span class="token type-variable function">'a</span> <span class="token operator">*</span> <span class="token type-variable function">'a</span> tree <span class="token operator">*</span> <span class="token type-variable function">'a</span> tree<br><br><span class="token keyword">let</span> <span class="token keyword">rec</span> depth_first_in_order tree <span class="token operator">=</span><br>  <span class="token keyword">match</span> tree <span class="token keyword">with</span><br>  <span class="token operator">|</span> Empty <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">(* do nothing *)</span><br>  <span class="token operator">|</span> Node <span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">-></span><br>      depth_first_in_order left<span class="token punctuation">;</span><br>      print_endline <span class="token keyword">value</span><span class="token punctuation">;</span><br>      depth_first_in_order right<br><br><span class="token comment">(* This holds names in a tree so that when<br>   printed with depth_first_in_order<br>   they will appear in sorted order. *)</span><br><span class="token keyword">let</span> family_tree <span class="token punctuation">:</span> string tree <span class="token operator">=</span><br>  Node<br>    <span class="token punctuation">(</span> <span class="token string">"Jeremy"</span><span class="token punctuation">,</span><br>      Node <span class="token punctuation">(</span><span class="token string">"Amanda"</span><span class="token punctuation">,</span> Empty<span class="token punctuation">,</span> Empty<span class="token punctuation">)</span><span class="token punctuation">,</span><br>      Node<br>        <span class="token punctuation">(</span> <span class="token string">"Meghan"</span><span class="token punctuation">,</span><br>          Node <span class="token punctuation">(</span><span class="token string">"Mark"</span><span class="token punctuation">,</span> Empty<span class="token punctuation">,</span> Empty<span class="token punctuation">)</span><span class="token punctuation">,</span><br>          Node <span class="token punctuation">(</span><span class="token string">"RC"</span><span class="token punctuation">,</span> Empty<span class="token punctuation">,</span> Node <span class="token punctuation">(</span><span class="token string">"Tami"</span><span class="token punctuation">,</span> Empty<span class="token punctuation">,</span> Empty<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> depth_first_in_order family_tree</code></pre><h3 id="option-variant-type" tabindex="-1">Option Variant Type</h3><p>The <a href="https://v2.ocaml.org/api/Option.html" target="_blank">Option</a> module defines a variant type represents an optional value. It has the constructors <code>None</code> and <code>Some</code> define by <code>type 'a option = None | Some of 'a</code>.</p><p>Functions that sometimes do not have a value to return use this type to represent their return value. For example, the <code>List.find_opt</code> function does this.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* The `open` keyword brings all the identifiers in a given module,<br>   `printf` in this case, into scope so they can be used<br>   without prefixing them with their module name. *)</span><br><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">"red"</span><span class="token punctuation">;</span> <span class="token string">"green"</span><span class="token punctuation">;</span> <span class="token string">"blue"</span> <span class="token punctuation">]</span><br><span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token string">"green"</span><br><span class="token keyword">let</span> result <span class="token operator">=</span> List<span class="token punctuation">.</span>find_opt <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span> x <span class="token operator">=</span> color<span class="token punctuation">)</span> colors<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">match</span> result <span class="token keyword">with</span><br>  <span class="token operator">|</span> Some c <span class="token operator">-></span> printf <span class="token string">"found %s\n"</span> c<br>  <span class="token operator">|</span> None <span class="token operator">-></span> print_endline <span class="token string">"failed to find green\n"</span></code></pre><p><a href="https://v2.ocaml.org/api/Option.html" target="_blank">Module Option</a> defines many functions that operate on an <code>Option</code> value. Many of these have operator equivalents.</p><p><code>Option.fold</code> is used to extract the value from an <code>Option</code> and provide a default value when it is <code>None</code>. For example, the following defines a function that gets the breed from a <code>dog option</code> value.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> dog_breed <span class="token operator">=</span> Option<span class="token punctuation">.</span>fold <span class="token label property">~some</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">fun</span> dog <span class="token operator">-></span> dog<span class="token punctuation">.</span>breed<span class="token punctuation">)</span> <span class="token label property">~none</span><span class="token punctuation">:</span><span class="token string">""</span></code></pre><p><code>Option.map</code> is used to apply a function to the value inside an <code>Option</code> and return a new <code>Option</code>. If it is <code>Some v</code> then the result of passing <code>v</code> to the function is returned in a <code>Some</code> variant. If it is <code>None</code> then <code>None</code> is returned. The operator <code>&gt;&gt;|</code> is often defined to use this.</p><p>For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> double x <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><br><span class="token keyword">let</span> is_even x <span class="token operator">=</span> x <span class="token operator">mod</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">7</span> <span class="token punctuation">]</span> <span class="token keyword">in</span><br>  List<span class="token punctuation">.</span>find_opt is_even numbers<br>  <span class="token operator">|></span> Option<span class="token punctuation">.</span>map double <span class="token operator">|></span> Option<span class="token punctuation">.</span>map string_of_int<br>  <span class="token operator">|></span> Option<span class="token punctuation">.</span><span class="token keyword">value</span> <span class="token label property">~default</span><span class="token punctuation">:</span><span class="token string">"no even found"</span><br>  <span class="token operator">|></span> print_endline<br>```<br><br><span class="token variant symbol">`Option</span><span class="token punctuation">.</span>bind` is used <span class="token keyword">in</span> reverse <span class="token keyword">function</span> application chains<br>so a <span class="token keyword">function</span> that returns an <span class="token variant symbol">`Option</span>` can have<br>the <span class="token keyword">value</span> inside it passed <span class="token keyword">to</span> the next <span class="token keyword">function</span> <span class="token keyword">in</span> the chain<span class="token punctuation">.</span><br>If any <span class="token keyword">function</span> returns <span class="token variant symbol">`None</span>`<span class="token punctuation">,</span> the remaining functions are not called<br><span class="token operator">and</span> the <span class="token keyword">value</span> <span class="token keyword">of</span> the entire chain is <span class="token variant symbol">`None</span>`<span class="token punctuation">.</span><br>The operator `<span class="token operator">>>=</span>` is often defined <span class="token keyword">to</span> use this<span class="token punctuation">.</span><br><br><span class="token punctuation">#</span><span class="token punctuation">#</span><span class="token punctuation">#</span> Result Variant Type<br><br>The <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"https://v2.ocaml.org/api/Result.html"</span> target<span class="token operator">=</span><span class="token string">"_blank"</span><span class="token operator">></span>Result<span class="token operator">&lt;/</span>a<span class="token operator">></span><br><span class="token keyword">module</span> defines a variant <span class="token keyword">type</span> represents<br>result <span class="token keyword">of</span> a <span class="token keyword">function</span> that can succeed <span class="token operator">or</span> fail<span class="token punctuation">.</span><br>It has the constructors <span class="token variant symbol">`OK</span>` <span class="token operator">and</span> <span class="token variant symbol">`Error</span>`<span class="token punctuation">.</span><br><br>For example<span class="token punctuation">:</span><br><br>``<span class="token variant symbol">`ocaml</span><br><span class="token keyword">let</span> divide numerator denomiator <span class="token operator">=</span><br>  <span class="token keyword">if</span> denomiator <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token keyword">then</span> Error <span class="token string">"cannot divide by zero"</span><br>  <span class="token keyword">else</span> Ok <span class="token punctuation">(</span>numerator <span class="token operator">/.</span> denomiator<span class="token punctuation">)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">5.0</span> <span class="token operator">and</span> d <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token keyword">in</span><br>  <span class="token keyword">match</span> divide n d <span class="token keyword">with</span><br>  <span class="token operator">|</span> Ok v <span class="token operator">-></span> print_endline <span class="token punctuation">(</span>string_of_float v<span class="token punctuation">)</span><br>  <span class="token operator">|</span> Error e <span class="token operator">-></span> print_endline e</code></pre><h3 id="interpreter" tabindex="-1">Interpreter</h3><p>Variant types can be used to build interpreters. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> expr <span class="token operator">=</span><br>  <span class="token operator">|</span> Int <span class="token keyword">of</span> int<br>  <span class="token operator">|</span> Add <span class="token keyword">of</span> expr <span class="token operator">*</span> expr<br>  <span class="token operator">|</span> Sub <span class="token keyword">of</span> expr <span class="token operator">*</span> expr<br>  <span class="token operator">|</span> Mul <span class="token keyword">of</span> expr <span class="token operator">*</span> expr<br>  <span class="token operator">|</span> Div <span class="token keyword">of</span> expr <span class="token operator">*</span> expr<br><br><span class="token keyword">let</span> <span class="token keyword">rec</span> eval <span class="token operator">=</span> <span class="token keyword">function</span><br>  <span class="token operator">|</span> Int n <span class="token operator">-></span> n<br>  <span class="token operator">|</span> Add <span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span> <span class="token operator">-></span> eval e1 <span class="token operator">+</span> eval e2<br>  <span class="token operator">|</span> Sub <span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span> <span class="token operator">-></span> eval e1 <span class="token operator">-</span> eval e2<br>  <span class="token operator">|</span> Mul <span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span> <span class="token operator">-></span> eval e1 <span class="token operator">*</span> eval e2<br>  <span class="token operator">|</span> Div <span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span> <span class="token operator">-></span> eval e1 <span class="token operator">/</span> eval e2<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> result <span class="token operator">=</span> eval <span class="token punctuation">(</span>Add <span class="token punctuation">(</span>Int <span class="token number">5</span><span class="token punctuation">,</span> Mul <span class="token punctuation">(</span>Int <span class="token number">3</span><span class="token punctuation">,</span> Int <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>  print_int result<span class="token punctuation">;</span><br>  <span class="token comment">(* 5 + (3 * 2) = 11 *)</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="conditonal-logic" tabindex="-1">Conditonal Logic</h2><p>Conditional logic is implemented with the <code>if</code> and <code>match</code> expressions.</p><h3 id="if-expression" tabindex="-1">if expression</h3><p>The syntax is <code>if expr1 then expr2 else expr3</code>.</p><p><code>expr1</code> must evaluate to a <code>bool</code>. Non-<code>bool</code> values are not automatically interpreted as a <code>bool</code>. For example, <code>0</code> is not treated as <code>false</code>.</p><p><code>expr3</code> must evaluate to the same type as <code>expr2</code> so the <code>if</code> expression always evaluates to the same type.</p><p>For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> sign <span class="token operator">=</span> <span class="token keyword">if</span> result <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token string">"positive"</span><br>  <span class="token keyword">else</span> <span class="token keyword">if</span> result <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token string">"negative"</span><br>  <span class="token keyword">else</span> <span class="token string">"zero"</span></code></pre><p>To include multiple expressions after <code>then</code> or <code>else</code>, surround them with parentheses and separate them with semicolons. The value will be the value of the final expression.</p><p>As an alternative to parentheses, the <code>begin</code> and <code>end</code> keywords can be used. But OCaml editor extensions may automatically replaces those with parentheses.</p><p>Unless the <code>then</code> branch produces a unit result, an <code>else</code> branch is required.</p><p>An <code>if</code> expression can be used where other languages use a ternary operator.</p><h3 id="match-expression" tabindex="-1">match expression</h3><p>A <code>match</code> expression performs pattern matching. It takes an expression whose value is to be matched and a set of branches. Each branch begins with a vertical bar (<code>|</code>) followed by a pattern, the characters <code>-&gt;</code>, and code to execute when the pattern is matched. The vertical bar before the first branch is optional.</p><p>A <code>match</code> expression is somewhat like a <code>switch</code> statement in other programming languages. You can think of the vertical bar at the beginning of each branch as being like the <code>case</code> keyword in those languages.</p><p>The type of a <code>match</code> expression is the type of its branch expressions, which must all evaluate to the same type.</p><p>The patterns must be exhaustive, meaning that there must be a pattern that matches every possible value. Using the catch-all <code>_</code> as the final pattern satisfies this.</p><p>The patterns can match:</p><ul><li>a constant (ex. <code>| 7</code> or <code>| &quot;summer&quot;</code>)</li><li>a range of characters (ex. <code>| 'a' .. 'f'</code>)</li><li>a guard using the <code>when</code> keyword (ex. <code>| n when 7 &lt;= n &amp;&amp; n &lt;= 9</code>)</li><li>a variant type constructor (ex. <code>| None</code> or <code>| Some x</code>)</li><li>a tuple (ex. <code>| (_, &quot;summer&quot;, temperature)</code> which means we don't care about the first element, the second element must be <code>&quot;summer&quot;</code>, and want to capture the third element)</li><li>a list (ex. <code>| []</code> or <code>| [&quot;summer&quot;; other]</code> or <code>| first :: second :: rest</code>)</li><li>an array (ex. <code>| [||]</code> or <code>| [|&quot;summer&quot;; other|]</code>)</li><li>a record (ex. <code>| {name = n; age = a}</code>)</li><li>a variable to match anything and bind the value to it</li><li>the catch-all <code>_</code> which doesn't bind the value</li><li>multiple match expressions (ex. <code>| 7 | 8 | 9</code>)</li></ul><p>The patterns are check in the order they are specified and the first matching pattern is used, so their order matters.</p><p>The value of a <code>match</code> expression is the value of the matched pattern.</p><p>There is a warning if the branches are not exhaustive. At runtime if no branch matches, a <code>Match_failure</code> exception is raised.</p><p>For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  Random<span class="token punctuation">.</span>self_init <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> n <span class="token operator">=</span> Random<span class="token punctuation">.</span>int <span class="token number">10</span> <span class="token keyword">in</span><br>  print_int n<span class="token punctuation">;</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">match</span> n <span class="token keyword">with</span><br>  <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">-></span> print_string <span class="token string">"small"</span><br>  <span class="token operator">|</span> n <span class="token keyword">when</span> <span class="token number">4</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">7</span> <span class="token operator">-></span> print_string <span class="token string">"medium"</span><br>  <span class="token operator">|</span> <span class="token punctuation">_</span> <span class="token operator">-></span> print_string <span class="token string">"large"</span></code></pre><p>The <code>function</code> keyword is useful in functions that immediately <code>match</code> on the last parameter. It simplfies the code by removing the need to list the last parameter and replacing <code>match {last-parameter} with</code> with just <code>function</code>. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> season <span class="token operator">=</span> Winter <span class="token operator">|</span> Spring <span class="token operator">|</span> Summer <span class="token operator">|</span> Fall<br><br><span class="token keyword">let</span> weather s <span class="token operator">=</span><br>  <span class="token keyword">match</span> s <span class="token keyword">with</span><br>  <span class="token operator">|</span> Winter <span class="token operator">-></span> <span class="token string">"cold"</span><br>  <span class="token operator">|</span> Spring <span class="token operator">-></span> <span class="token string">"cool"</span><br>  <span class="token operator">|</span> Summer <span class="token operator">-></span> <span class="token string">"hot"</span><br>  <span class="token operator">|</span> Fall <span class="token operator">-></span> <span class="token string">"perfect"</span><br><br><span class="token comment">(* same as previous function *)</span><br><span class="token keyword">let</span> weather2 <span class="token operator">=</span> <span class="token keyword">function</span><br>  <span class="token operator">|</span> Winter <span class="token operator">-></span> <span class="token string">"cold"</span><br>  <span class="token operator">|</span> Spring <span class="token operator">-></span> <span class="token string">"cool"</span><br>  <span class="token operator">|</span> Summer <span class="token operator">-></span> <span class="token string">"hot"</span><br>  <span class="token operator">|</span> Fall <span class="token operator">-></span> <span class="token string">"perfect"</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  print_endline <span class="token punctuation">(</span>weather Fall<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* perfect *)</span><br>  print_endline <span class="token punctuation">(</span>weather2 Fall<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* perfect *)</span></code></pre><h2 id="iteration" tabindex="-1">Iteration</h2><p>The <code>for</code> and <code>while</code> keywords support imperative iteration. It is more typical in OCaml to use recursion for iteration.</p><p>A <code>for</code> loop specifies start and stop values, but it cannot specify a step size.</p><p>The expression inside a <code>for</code> loop must have a unit value, which means that the loop itself doesn't return a value.</p><p>There are no <code>break</code> or <code>continue</code> statements like in other languages.</p><p>The following code demonstates <code>for</code> loops.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">to</span> <span class="token number">5</span> <span class="token keyword">do</span><br>    printf <span class="token string">"%d\n"</span> i<br>  <span class="token keyword">done</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">downto</span> <span class="token number">1</span> <span class="token keyword">do</span><br>    printf <span class="token string">"%d\n"</span> i<br>  <span class="token keyword">done</span></code></pre><p>A <code>while</code> loop specifies a boolean condition. This might be an expression involving a <code>ref</code> whose value changes or a function that returns a value to be tested. The loop terminates when the condition evaluates to <code>false</code>.</p><p>The following code demonstates <code>while</code> loops.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> i <span class="token operator">=</span> ref <span class="token number">1</span> <span class="token keyword">in</span><br>  <span class="token keyword">while</span> <span class="token operator">!</span>i <span class="token operator">&lt;=</span> <span class="token number">5</span> <span class="token keyword">do</span><br>    printf <span class="token string">"%d\n"</span> <span class="token operator">!</span>i<span class="token punctuation">;</span><br>    i <span class="token operator">:=</span> <span class="token operator">!</span>i <span class="token operator">+</span> <span class="token number">1</span><br>  <span class="token keyword">done</span></code></pre><p>To iterate over collections like lists and arrays it's best to use <code>iter</code> functions instead of <code>for</code> or <code>while</code> loops.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">5</span> <span class="token punctuation">]</span> <span class="token keyword">in</span><br>  List<span class="token punctuation">.</span>iter <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span> printf <span class="token string">"%d\n"</span> x<span class="token punctuation">)</span> numbers<span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token operator-like-punctuation punctuation">[|</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">5</span> <span class="token operator-like-punctuation punctuation">|]</span> <span class="token keyword">in</span><br>  Array<span class="token punctuation">.</span>iter <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span> printf <span class="token string">"%d\n"</span> x<span class="token punctuation">)</span> numbers</code></pre><h2 id="collections" tabindex="-1">Collections</h2><p>OCaml has built-in support for many kinds of collections. The most commonly used are tuples, lists, arrays, and maps.</p><table><thead><tr><th>Collection</th><th>Primary Use Case</th></tr></thead><tbody><tr><td><code>list</code></td><td>unbounded length; access elements by walking from head</td></tr><tr><td><code>tuple</code></td><td>bounded length (typically only 2 or 3); access elements by position</td></tr><tr><td><code>array</code></td><td>bounded length; access elements by index</td></tr><tr><td><code>Set</code></td><td>immutable collection of values with no duplicates according to a <code>compare</code> function</td></tr><tr><td><code>Map</code></td><td>immutable collection of key/value pairs; access values by key</td></tr><tr><td><code>Hashtbl</code></td><td>mutable collection of key/value pairs; access values by key</td></tr><tr><td><code>record</code></td><td>fixed set of fields accessed by name</td></tr></tbody></table><p>Each of these collection types are described in more detail below. All but <code>Set</code>, <code>Map</code> and <code>Hashtbl</code> have a literal syntax.</p><ul><li><code>tuple</code> - <code>(expr1, expr2, ...)</code></li><li><code>list</code> - <code>[ expr1; expr2; ... ]</code></li><li><code>array</code> - <code>[| expr1; expr2; ... |]</code></li><li><code>record</code> - <code>{ k1 = expr1; k2 = expr2; ... }</code></li></ul><p>Also see:</p><ul><li><a href="https://v2.ocaml.org/api/Array.html" target="_blank">Module Array</a></li><li><a href="https://v2.ocaml.org/api/Hashtbl.html" target="_blank">Module Hashtbl</a></li><li><a href="https://v2.ocaml.org/api/List.html" target="_blank">Module List</a></li><li><a href="https://v2.ocaml.org/api/Map.html" target="_blank">Module Map</a></li><li><a href="https://v2.ocaml.org/api/Queue.html" target="_blank">Module Queue</a></li><li><a href="https://v2.ocaml.org/api/Seq.html" target="_blank">Module Seq</a></li><li><a href="https://v2.ocaml.org/api/Set.html" target="_blank">Module Set</a></li><li><a href="https://v2.ocaml.org/api/Stack.html" target="_blank">Module Stack</a></li></ul><h3 id="tuples" tabindex="-1">Tuples</h3><p>A tuple is an immutable, ordered collection of values whose types can differ.</p><p>To create a tuple, surround the elements in parentheses and separate them with commas. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br><span class="token comment">(* Can use destructuring to extract the values. *)</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span>b<span class="token punctuation">,</span> n<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=</span> t <span class="token keyword">in</span><br>printf <span class="token string">"b = %b, n = %d, c = %s\n"</span> b n c</code></pre><p>In practice it is rare for a tuple to contain more than three values. Tuples with two elements are referred to as a &quot;pair&quot; and those with three elements are referred to as a &quot;triple&quot;.</p><p>The parentheses shown above for creating and destructuring a tuple are optional.</p><p>The variable <code>t</code> above has the type <code>bool * int * string</code> which is referred to as a &quot;product type&quot; (based on tuples being similar to cartesian products).</p><p>Fun fact: The Greek word &quot;aster&quot; means &quot;star&quot;, so it makes sense to refer to the asterisk character as &quot;star&quot;.</p><p>For pairs, the <code>fst</code> function returns the first element and the <code>snd</code> function returns the second. There are no built-in functions for operating on longer tuples.</p><p>To get a specific element from a tuple of a certain length, use pattern matching. For example, the following function gets the third element from any 4-element tuple.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* This shows three ways to write a function that<br>   returns the third elemet of a 4-element tuple `t`. *)</span><br><span class="token keyword">let</span> third_of_4 t <span class="token operator">=</span> <span class="token keyword">match</span> t <span class="token keyword">with</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d <span class="token operator">-></span> c<br><span class="token keyword">let</span> third_of_4 t <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">_</span><span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token punctuation">_</span> <span class="token operator">=</span> t <span class="token keyword">in</span> c<br><span class="token keyword">let</span> third_of_4 <span class="token punctuation">(</span><span class="token punctuation">_</span><span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> v<br><br><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"alpha"</span><span class="token punctuation">,</span> <span class="token string">"beta"</span><span class="token punctuation">,</span> <span class="token string">"gamma"</span><span class="token punctuation">,</span> <span class="token string">"delta"</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>print_endline <span class="token punctuation">(</span>third_of_4 t<span class="token punctuation">)</span> <span class="token comment">(* gamma *)</span></code></pre><p>You can think of tuples like records (described later) where the fields are accessed by position rather than name.</p><h3 id="lists" tabindex="-1">Lists</h3><p>A list is an immutable, ordered collection of values that all have the same type. Lists are implemented as singly linked lists.</p><p>To create an empty list, use a pair of square brackets that is pronounced &quot;nil&quot;. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> issues <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre><p>To create a non-empty list, surround the elements in square brackets and separate them with semicolons. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">;</span> <span class="token string">"green"</span><span class="token punctuation">;</span> <span class="token string">"blue"</span><span class="token punctuation">]</span></code></pre><p>Using commas instead of semicolons is a common error. When that is done, a list containing a single tuple is created.</p><p>A non-empty list is represented by a head that holds an element value and a tail that holds the remainder which is another list that may be empty.</p><p>To create a new list by adding an element to the beginning of an existing list, use the <code>::</code> operator which is pronounced &quot;cons&quot; (short for &quot;construct&quot;). The right side of this operator must be a list and the left side must be an expression that evaluates to the same type as elements in the list on the right. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> new_list <span class="token operator">=</span> element <span class="token punctuation">::</span> old_list</code></pre><p>The <code>color</code> list above was written with syntactic sugar for the following which is evaluated from right to left to construct the final list:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token string">"red"</span> <span class="token punctuation">::</span> <span class="token string">"green"</span> <span class="token punctuation">::</span> <span class="token string">"blue"</span> <span class="token punctuation">::</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre><p>To create a new list by concatenating two lists, use the <code>@</code> operator. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> new_list <span class="token operator">=</span> list1 <span class="token operator">@</span> list2</code></pre><p>The type of a list is written as <code>T list</code> where <code>T</code> is the type of the elements. For example, the type of a list of <code>float</code> values is <code>float list</code>. The type of an empty list <code>[]</code> is <code>'a list</code> where <code>'a</code> is a type variable that represents an unknown type.</p><p>List elements can themselves be lists, but all the elements must then also be lists with the same element type. The sublists are not required to have the same length. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> seasons <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token punctuation">[</span><span class="token string">"spring"</span><span class="token punctuation">;</span> <span class="token string">"rain"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span><span class="token string">"summer"</span><span class="token punctuation">;</span> <span class="token string">"heat"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span><span class="token string">"fall"</span><span class="token punctuation">;</span> <span class="token string">"nice"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span><span class="token string">"winter"</span><span class="token punctuation">;</span> <span class="token string">"cold"</span><span class="token punctuation">]</span><br><span class="token punctuation">]</span></code></pre><p>The type of <code>seasons</code> is <code>string list list</code>.</p><p>The <code>match</code> can be used to recursively process a list. For example, the following code computes the sum of a list of integers. By convention, the name <code>hd</code> is used for the head of a list and <code>tl</code> is used for the tail.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> sum list <span class="token operator">=</span><br>  <span class="token keyword">match</span> list <span class="token keyword">with</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> empty_value<br>  <span class="token operator">|</span> hd <span class="token punctuation">::</span> tl <span class="token operator">-></span> hd <span class="token operator">+</span> sum tl</code></pre><p>The standard library provides many functions that operate on lists. See <a href="https://v2.ocaml.org/api/List.html" target="_blank">Module List</a>. Some highlights include the following:</p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>List.exists</code></td><td>determines if a list contains at least one element that satisfies a predicate function</td></tr><tr><td><code>List.filter</code></td><td>creates a new list from the elements in an existing list that satisfy a predicate function</td></tr><tr><td><code>List.find</code></td><td>returns the first element that satisfies a predicate or raises <code>Not-found</code></td></tr><tr><td><code>List.find_opt</code></td><td>returns an <code>Option</code> that contains the first element that satisfies a predicate function</td></tr><tr><td><code>List.fold_left</code></td><td>reduces a list to a single value using an accumulator function</td></tr><tr><td><code>List.hd</code></td><td>returns the head of a list</td></tr><tr><td><code>List.iter</code></td><td>iterates over a list in a way that is useful when the function passed to it has a side effect and a result list is not needed</td></tr><tr><td><code>List.length</code></td><td>returns the length of a given list</td></tr><tr><td><code>List.map</code></td><td>creates a new list containing elements that are computed by passing each element in an existing list to a given function</td></tr><tr><td><code>List.map2</code></td><td>similar to <code>List.map</code>, but it operates on two lists, passing corresponding elements from each to a given function</td></tr><tr><td><code>List.mem</code></td><td>returns a <code>bool</code> that indicates whether a given value is a member</td></tr><tr><td><code>List.nth</code></td><td>takes a list and an index; returns the list element at the index</td></tr><tr><td><code>List.sort</code></td><td>returns a sorted list</td></tr><tr><td><code>List.sort_uniq</code></td><td>returns a sorted list with no duplicates</td></tr><tr><td><code>List.tl</code></td><td>returns the head of a list</td></tr></tbody></table><p>Since tuple elements are separated by commas and list elements are separated by semicolons, a list of tuples can be written as follows:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token punctuation">[</span><span class="token string">"alpha"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token string">"beta"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token string">"gamma"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span></code></pre><p>This evaluates to the following list of tuples:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"alpha"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token string">"beta"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token string">"gamma"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p>The following code demonstrates using the <code>List</code> module functions <code>map</code>, <code>filter</code>, and <code>fold_left</code>. See the section &quot;Pretty Printing&quot; for details on <code>[@@deriving show]</code>.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">type</span> int_list <span class="token operator">=</span> int list<br><span class="token punctuation">[</span><span class="token operator">@@</span>deriving show<span class="token punctuation">]</span><br><br><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">]</span><br><br><span class="token keyword">let</span> doubled <span class="token operator">=</span> List<span class="token punctuation">.</span>map <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> numbers<br><br><span class="token keyword">let</span> even_numbers <span class="token operator">=</span> List<span class="token punctuation">.</span>filter <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span> x <span class="token operator">mod</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> numbers<br><br><span class="token keyword">let</span> sum <span class="token operator">=</span> List<span class="token punctuation">.</span>fold_left <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> numbers<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  print_endline <span class="token punctuation">(</span>show_int_list doubled<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* [8; 2; 18; 14; 4] *)</span><br>  printf <span class="token string">"sum = %d\n"</span> sum<span class="token punctuation">;</span> <span class="token comment">(* sum = 23 *)</span><br>  print_endline <span class="token punctuation">(</span>show_int_list even_numbers<span class="token punctuation">)</span> <span class="token comment">(* [4; 2] *)</span></code></pre><p>The following code finds the maximum value in a list of numbers.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> list_max <span class="token punctuation">(</span>lst <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> list<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> option <span class="token operator">=</span><br>  <span class="token keyword">match</span> lst <span class="token keyword">with</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> None<br>  <span class="token operator">|</span> h <span class="token punctuation">::</span> t <span class="token operator">-></span> <span class="token punctuation">(</span><br>      <span class="token keyword">match</span> list_max t <span class="token keyword">with</span> None <span class="token operator">-></span> Some h <span class="token operator">|</span> Some m <span class="token operator">-></span> Some <span class="token punctuation">(</span>max h m<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">9</span> <span class="token punctuation">]</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> max <span class="token operator">=</span> list_max numbers <span class="token keyword">in</span><br>  <span class="token keyword">match</span> max <span class="token keyword">with</span><br>  <span class="token operator">|</span> None <span class="token operator">-></span> print_endline <span class="token string">"empty list"</span><br>  <span class="token operator">|</span> Some max <span class="token operator">-></span> print_int max</code></pre><p>Here is an easier way to find the maximum value in a list of numbers if we can assume the list is not empty.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> max_int x y <span class="token operator">=</span> <span class="token keyword">if</span> x <span class="token operator">></span> y <span class="token keyword">then</span> x <span class="token keyword">else</span> y<br><span class="token keyword">let</span> maximum <span class="token operator">=</span><br>  first <span class="token operator">=</span> List<span class="token punctuation">.</span>hd numbers <span class="token keyword">in</span><br>  List<span class="token punctuation">.</span>fold_left max_int first numbers</code></pre><p>The following code sorts a list of strings:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">;</span> <span class="token string">"green"</span><span class="token punctuation">;</span> <span class="token string">"blue"</span><span class="token punctuation">]</span> <span class="token operator">|></span> List<span class="token punctuation">.</span>sort compare</code></pre><h3 id="association-lists" tabindex="-1">Association Lists</h3><p>An association list is list of tuple pairs where the first value in each tuple is treated as a key and the second is treated as an associated value. Association lists are used in place of <code>Map</code> and <code>Hashtbl</code> collections when there are a small number of key/value pairs. This is because lookup in an association list can be slow where there are a large number of key/value pairs.</p><p>The <code>List</code> module provides the following functions for operating on association lists.</p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>assoc</code></td><td>returns the value associated with a given key or raises <code>Not_found</code></td></tr><tr><td><code>assoc_opt</code></td><td>returns the value associated with a given key in a <code>Some</code> or returns <code>None</code></td></tr><tr><td><code>mem_assoc</code></td><td>returns a <code>bool</code> indicating if a given key is present</td></tr><tr><td><code>remove_assoc</code></td><td>returns a new association list where the pair with a given key is removed</td></tr><tr><td><code>assq</code></td><td>same as <code>assoc</code> but compares keys with physical rather than structural equality</td></tr><tr><td><code>assq_opt</code></td><td>same as <code>assoc_opt</code> but compares keys with physical rather than structural equality</td></tr><tr><td><code>mem_assq</code></td><td>same as <code>mem_assoc</code> but compares keys with physical rather than structural equality</td></tr><tr><td><code>remove_assq</code></td><td>same as <code>remove_assoc</code> but compares keys with physical rather than structural equality</td></tr></tbody></table><p>For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Create an association list. *)</span><br><span class="token keyword">let</span> al1 <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"FF0000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"00FF00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"0000FF"</span><span class="token punctuation">)</span> <span class="token punctuation">]</span><br><br><span class="token comment">(* Create a new association list from al1<br>   where the "green" key/value pair is removed. *)</span><br><span class="token keyword">let</span> al2 <span class="token operator">=</span> List<span class="token punctuation">.</span>remove_assoc <span class="token string">"green"</span> al1<br><br><span class="token comment">(* Create a new association list from al1<br>   where the "yellow" key/value pair is added. *)</span><br><span class="token keyword">let</span> al3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"yellow"</span><span class="token punctuation">,</span> <span class="token string">"FFFF00"</span><span class="token punctuation">)</span> <span class="token punctuation">::</span> al2<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token comment">(* Get the value for the "red" key in al1. *)</span><br>  <span class="token keyword">assert</span> <span class="token punctuation">(</span>List<span class="token punctuation">.</span>assoc <span class="token string">"red"</span> al1 <span class="token operator">=</span> <span class="token string">"FF0000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">(* Determine if the key "red" is present in al1. *)</span><br>  <span class="token keyword">assert</span> <span class="token punctuation">(</span>List<span class="token punctuation">.</span>mem_assoc <span class="token string">"red"</span> al1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">(* Determine if the key "purple" is present in al1. *)</span><br>  <span class="token keyword">assert</span> <span class="token punctuation">(</span>not <span class="token punctuation">(</span>List<span class="token punctuation">.</span>mem_assoc <span class="token string">"purple"</span> al1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">(* Determine if the key "yellow" is present in al3. *)</span><br>  <span class="token keyword">assert</span> <span class="token punctuation">(</span>List<span class="token punctuation">.</span>mem_assoc <span class="token string">"yellow"</span> al3<span class="token punctuation">)</span></code></pre><h3 id="arrays" tabindex="-1">Arrays</h3><p>An array is a mutable, ordered collection of values that all have the same type. Its length is fixed.</p><p>To create an array, surround the elements in square brackets that have vertical bars inside them and separate them with semicolons. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token operator-like-punctuation punctuation">[|</span> <span class="token string">"red"</span><span class="token punctuation">;</span> <span class="token string">"green"</span><span class="token punctuation">;</span> <span class="token string">"blue"</span> <span class="token operator-like-punctuation punctuation">|]</span></code></pre><p>To get an element from an array, follow it with a dot and a zero-based index in parentheses (odd syntax). For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> color <span class="token operator">=</span> colors<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">(* "green" *)</span><br>OR<br><span class="token keyword">let</span> color <span class="token operator">=</span> Array<span class="token punctuation">.</span>get colors <span class="token number">1</span></code></pre><p>To modify an array element, use the <code>&lt;-</code> operator. For example:</p><pre class="language-ocaml"><code class="language-ocaml">colors<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token string">"yellow"</span><br>OR<br>Array<span class="token punctuation">.</span>set colors <span class="token number">1</span> <span class="token string">"yellow"</span></code></pre><p>The type of an array is written as <code>T array</code> where <code>T</code> is the type of the elements. For example, the type of an array of <code>float</code> values is <code>float array</code>.</p><p>An empty array is written as <code>[||]</code> and as the type <code>'a array</code> to indicate that the type of its elements is unknown.</p><p>The standard library <code>Array</code> module provides many functions that operate on arrays. See <a href="https://v2.ocaml.org/api/Array.html" target="_blank">Module Array</a>. Some highlights include the following:</p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>Array.append</code></td><td>creates a new array by concatenating two arrays</td></tr><tr><td><code>Array.concat</code></td><td>creates a new array by concatenating all the arrays in a list</td></tr><tr><td><code>Array.exists</code></td><td>determines if an array contains at least one element that matches a given predicate function</td></tr><tr><td><code>Array.iter</code></td><td>takes a function and an array; iterates over the array, passing each element the function; doesn't return a value, so this is used for side effects</td></tr><tr><td><code>Array.length</code></td><td>returns the length of a given array</td></tr><tr><td><code>Array.fold_left</code></td><td>reduces an array to a single value using an accumulator function</td></tr><tr><td><code>Array.sub</code></td><td>creates a new array that is a subset of an existing array</td></tr><tr><td><code>Array.to_list</code></td><td>creates a new list that contains the same elements as a given array</td></tr><tr><td><code>Array.of_list</code></td><td>creates a new array that contains the same elements as a given list</td></tr><tr><td><code>Array.map</code></td><td>creates a new array containing elements that are computed by passing each element in an existing array to a given function</td></tr></tbody></table><h3 id="sets" tabindex="-1">Sets</h3><p>The following code demonstrates creating and using two set types, one for <code>int</code> values and one for <code>dog</code> record values.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">module</span> IntSet <span class="token operator">=</span> Set<span class="token punctuation">.</span>Make <span class="token punctuation">(</span><span class="token keyword">struct</span><br>  <span class="token keyword">type</span> t <span class="token operator">=</span> int<br><br>  <span class="token keyword">let</span> compare <span class="token operator">=</span> compare<br><span class="token keyword">end</span><span class="token punctuation">)</span><br><br><span class="token keyword">type</span> dog <span class="token operator">=</span> <span class="token punctuation">{</span> name <span class="token punctuation">:</span> string<span class="token punctuation">;</span> breed <span class="token punctuation">:</span> string <span class="token punctuation">}</span><br><br><span class="token keyword">module</span> DogSet <span class="token operator">=</span> Set<span class="token punctuation">.</span>Make <span class="token punctuation">(</span><span class="token keyword">struct</span><br>  <span class="token keyword">type</span> t <span class="token operator">=</span> dog<br><br>  <span class="token keyword">let</span> compare a b <span class="token operator">=</span> compare a<span class="token punctuation">.</span>name b<span class="token punctuation">.</span>name<br><span class="token keyword">end</span><span class="token punctuation">)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> intSet <span class="token operator">=</span> IntSet<span class="token punctuation">.</span>of_list <span class="token punctuation">[</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token number">3</span> <span class="token punctuation">]</span> <span class="token keyword">in</span><br>  IntSet<span class="token punctuation">.</span>iter<br>    <span class="token punctuation">(</span><span class="token keyword">fun</span> n <span class="token operator">-></span><br>      print_int n<span class="token punctuation">;</span><br>      print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    intSet<span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> dogSet <span class="token operator">=</span><br>    DogSet<span class="token punctuation">.</span><span class="token punctuation">(</span><br>      empty<br>      <span class="token operator">|></span> add <span class="token punctuation">{</span> name <span class="token operator">=</span> <span class="token string">"Comet"</span><span class="token punctuation">;</span> breed <span class="token operator">=</span> <span class="token string">"Whippet"</span> <span class="token punctuation">}</span><br>      <span class="token operator">|></span> add <span class="token punctuation">{</span> name <span class="token operator">=</span> <span class="token string">"Oscar"</span><span class="token punctuation">;</span> breed <span class="token operator">=</span> <span class="token string">"GSP"</span> <span class="token punctuation">}</span><br>      <span class="token operator">|></span> add <span class="token punctuation">{</span> name <span class="token operator">=</span> <span class="token string">"Comet"</span><span class="token punctuation">;</span> breed <span class="token operator">=</span> <span class="token string">"Greyhound"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><br>  <span class="token keyword">in</span><br>  DogSet<span class="token punctuation">.</span>iter <span class="token punctuation">(</span><span class="token keyword">fun</span> dog <span class="token operator">-></span> printf <span class="token string">"%s is a %s.\n"</span> dog<span class="token punctuation">.</span>name dog<span class="token punctuation">.</span>breed<span class="token punctuation">)</span> dogSet</code></pre><h3 id="records" tabindex="-1">Records</h3><p>A record an immutable collections of fields. Record type names must begin with a lowercase letter. The fields can have differents types, including other record types. Records are similar to structs in other languages.</p><p>The following code defines a record type that describes an item available for purchase:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> item <span class="token operator">=</span> <span class="token punctuation">{</span><br>  description <span class="token punctuation">:</span> string<span class="token punctuation">;</span><br>  <span class="token keyword">mutable</span> price <span class="token punctuation">:</span> int<span class="token punctuation">;</span><br>  <span class="token keyword">mutable</span> weight <span class="token punctuation">:</span> float<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The field names must begin with a lowercase letter.</p><p>The field values are immutable by default, but can be made mutable by adding the <code>mutable</code> keywored before their field name.</p><p>To create a record, just supply values for each of the fields inside curly braces in any order. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> my_item <span class="token punctuation">:</span> item <span class="token operator">=</span> <span class="token punctuation">{</span> description <span class="token operator">=</span> <span class="token string">"milk"</span><span class="token punctuation">;</span> price <span class="token operator">=</span> <span class="token number">350</span><span class="token punctuation">;</span> weight <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token punctuation">}</span></code></pre><p>It is not necessary to specify the type of the record variable. But the field names and values must match some existing record type and no extra fields can be present.</p><p>Field values can be omitted if there is a variable in scope with the same name as the field. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> description <span class="token operator">=</span> <span class="token string">"milk"</span> <span class="token operator">and</span> price <span class="token operator">=</span> <span class="token number">350</span> <span class="token operator">and</span> weight <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> my_item <span class="token operator">=</span> <span class="token punctuation">{</span> description<span class="token punctuation">;</span> price<span class="token punctuation">;</span> weight <span class="token punctuation">}</span> <span class="token keyword">in</span><br><span class="token operator">..</span><span class="token punctuation">.</span></code></pre><p>To access a field value in a record, use dot syntax. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> p <span class="token operator">=</span> my_item<span class="token punctuation">.</span>price</code></pre><p>A field name must follow the dot, not an expression that evaluates to a field name. To lookup values based on an expression, use the <code>Map</code> module.</p><p>Fields can also be destructured using a <code>match</code>. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">match</span> my_item <span class="token keyword">with</span><br><span class="token operator">|</span> <span class="token punctuation">{</span>description<span class="token operator">=</span>d<span class="token punctuation">;</span> price<span class="token operator">=</span>p<span class="token punctuation">;</span> weight<span class="token operator">=</span>w<span class="token punctuation">}</span> <span class="token operator">-></span><br>    <span class="token comment">(* can use d, p, and w here *)</span></code></pre><p>Alternatively there is a shorthand for setting variables whose names match the field names.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">match</span> my_item <span class="token keyword">with</span><br><span class="token operator">|</span> <span class="token punctuation">{</span>description<span class="token punctuation">;</span> price<span class="token punctuation">;</span> weight<span class="token punctuation">}</span> <span class="token operator">-></span><br>    <span class="token comment">(* can use description, price, and weight here *)</span></code></pre><p>To modify a mutable field in a record, use the <code>&lt;-</code> operator. For example:</p><pre class="language-ocaml"><code class="language-ocaml">milk<span class="token punctuation">.</span>price <span class="token operator">&lt;-</span> <span class="token number">400</span></code></pre><p>To create a new record by copying fields from an existing one and using different values for some of its fields, use the <code>with</code> keyword. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> new_milk <span class="token operator">=</span> <span class="token punctuation">{</span> milk <span class="token keyword">with</span> price <span class="token operator">=</span> <span class="token number">325</span><span class="token punctuation">;</span> weight <span class="token operator">=</span> <span class="token number">1.5</span> <span class="token punctuation">}</span></code></pre><p>The following code demonstrates creating and using a list of records.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">type</span> item <span class="token operator">=</span> <span class="token punctuation">{</span><br>  description <span class="token punctuation">:</span> string<span class="token punctuation">;</span><br>  <span class="token keyword">mutable</span> weight <span class="token punctuation">:</span> float<span class="token punctuation">;</span><br>  <span class="token keyword">mutable</span> price <span class="token punctuation">:</span> int<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">let</span> eggs <span class="token operator">=</span> <span class="token punctuation">{</span> description <span class="token operator">=</span> <span class="token string">"eggs"</span><span class="token punctuation">;</span> weight <span class="token operator">=</span> <span class="token number">0.4</span><span class="token punctuation">;</span> price <span class="token operator">=</span> <span class="token number">275</span> <span class="token punctuation">}</span><br><span class="token keyword">let</span> milk <span class="token punctuation">:</span> item <span class="token operator">=</span> <span class="token punctuation">{</span> description <span class="token operator">=</span> <span class="token string">"milk"</span><span class="token punctuation">;</span> weight <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> price <span class="token operator">=</span> <span class="token number">350</span> <span class="token punctuation">}</span><br><span class="token keyword">let</span> new_milk <span class="token operator">=</span> <span class="token punctuation">{</span> milk <span class="token keyword">with</span> price <span class="token operator">=</span> <span class="token number">325</span><span class="token punctuation">;</span> weight <span class="token operator">=</span> <span class="token number">1.5</span> <span class="token punctuation">}</span><br><span class="token keyword">let</span> items <span class="token operator">=</span> <span class="token punctuation">[</span> eggs<span class="token punctuation">;</span> new_milk <span class="token punctuation">]</span><br><br><span class="token keyword">let</span> print_item item <span class="token operator">=</span><br>  printf <span class="token string">"%s: $%d (%f lbs)\n"</span> item<span class="token punctuation">.</span>description item<span class="token punctuation">.</span>price item<span class="token punctuation">.</span>weight<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  milk<span class="token punctuation">.</span>price <span class="token operator">&lt;-</span> <span class="token number">400</span><span class="token punctuation">;</span><br>  List<span class="token punctuation">.</span>iter print_item items<span class="token punctuation">;</span><br>  <span class="token keyword">let</span> total <span class="token operator">=</span> List<span class="token punctuation">.</span>fold_left <span class="token punctuation">(</span><span class="token keyword">fun</span> acc item <span class="token operator">-></span> acc <span class="token operator">+</span> item<span class="token punctuation">.</span>price<span class="token punctuation">)</span> <span class="token number">0</span> items <span class="token keyword">in</span><br>  printf <span class="token string">"Total: $%d\n"</span> total</code></pre><h3 id="maps" tabindex="-1">Maps</h3><p>A Map is an immutable collection of key/value pairs.</p><p>The standard library <code>Map</code> module provides many functions that operate on maps. Each of them return a new map that uses structual sharing to avoid making a copy of the whole map. See <a href="https://v2.ocaml.org/api/Map.html" target="_blank">Module Map</a>.</p><p>To create a map type that uses keys of a given type, call <code>Map.Make</code>. For example, the following creates a map type where the keys are strings.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">module</span> StringMap <span class="token operator">=</span> Map<span class="token punctuation">.</span>Make <span class="token punctuation">(</span>String<span class="token punctuation">)</span></code></pre><p>Module names, like <code>StringMap</code> above, must start with an uppercase letter.</p><p>To create an instance of this map type that starts empty, call the <code>empty</code> function on the map type. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> dog_map <span class="token operator">=</span> StringMap<span class="token punctuation">.</span>empty</code></pre><p>To create a new map from an existing one adding one key/value pair, call the <code>add</code> function on the map type passing it a key, a value, and an existing map. For example:</p><p>This code uses the <a href="https://erratique.ch/software/uuidm/doc/Uuidm/index.html" target="_blank">Uuidm</a> module to generate uuids that are used as keys in the map. It must be installed with <code>opam install uuidm</code>.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> generate_uuid <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Uuidm<span class="token punctuation">.</span><span class="token punctuation">(</span>v <span class="token variant symbol">`V4</span> <span class="token operator">|></span> to_string<span class="token punctuation">)</span><br><span class="token keyword">let</span> uuid <span class="token operator">=</span> generate_uuid <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> new_dog_map <span class="token operator">=</span> StringMap<span class="token punctuation">.</span>add uuid dog dog_map</code></pre><p>To create an instance of this map that that starts with some key/value pairs, use the <code>of_seq</code> function on the map type as shown in the code below.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> make_dog name breed <span class="token operator">=</span><br>  <span class="token keyword">let</span> uuid <span class="token operator">=</span> generate_uuid <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>  <span class="token punctuation">{</span> id <span class="token operator">=</span> uuid<span class="token punctuation">;</span> name<span class="token punctuation">;</span> breed <span class="token punctuation">}</span><br><span class="token keyword">let</span> comet <span class="token operator">=</span> make_dog <span class="token string">"Comet"</span> <span class="token string">"whippet"</span><br><span class="token keyword">let</span> oscar <span class="token operator">=</span> make_dog <span class="token string">"Oscar"</span> <span class="token string">"GSP"</span><br><span class="token keyword">let</span> dog_map <span class="token operator">=</span> StringMap<span class="token punctuation">.</span>of_seq <span class="token operator">@@</span> List<span class="token punctuation">.</span>to_seq <span class="token punctuation">[</span><br>  <span class="token punctuation">(</span>comet<span class="token punctuation">.</span>id<span class="token punctuation">,</span> comet<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">(</span>oscar<span class="token punctuation">.</span>id<span class="token punctuation">,</span> oscar<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">]</span></code></pre><p>To find a value in a map by its key, use the <code>find_first_opt</code> function on the map type. This returns an <code>Option</code> because it's possible the key will not be found. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> dog_opt <span class="token operator">=</span> StringMap<span class="token punctuation">.</span>find_first_opt <span class="token punctuation">(</span><span class="token keyword">fun</span> key <span class="token operator">-></span> key <span class="token operator">=</span> <span class="token string">"some-key"</span><span class="token punctuation">)</span> dog_map</code></pre><p>To change the value for a given key, use the <code>update</code> function on the map type.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> new_dog_map <span class="token operator">=</span> dog_map <span class="token operator">|></span> StringMap<span class="token punctuation">.</span>update <span class="token string">"some-key"</span> new_value</code></pre><p>To create a new map from an existing one where one key/value pair is removed, use the <code>remove</code> function on the map type. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> new_dog_map <span class="token operator">=</span> dog_map <span class="token operator">|></span> StringMap<span class="token punctuation">.</span>remove <span class="token string">"some-key"</span></code></pre><p>The following code demonstates all the operations described above.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">module</span> StringMap <span class="token operator">=</span> Map<span class="token punctuation">.</span>Make <span class="token punctuation">(</span>String<span class="token punctuation">)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> map <span class="token operator">=</span><br>    StringMap<span class="token punctuation">.</span>empty <span class="token operator">|></span> StringMap<span class="token punctuation">.</span>add <span class="token string">"a"</span> <span class="token string">"apple"</span> <span class="token operator">|></span> StringMap<span class="token punctuation">.</span>add <span class="token string">"b"</span> <span class="token string">"banana"</span><br>    <span class="token operator">|></span> StringMap<span class="token punctuation">.</span>update <span class="token string">"a"</span> <span class="token punctuation">(</span>Option<span class="token punctuation">.</span>map <span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token string">"apricot"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token operator">|></span> StringMap<span class="token punctuation">.</span>remove <span class="token string">"b"</span><br>  <span class="token keyword">in</span><br>  <span class="token keyword">let</span> a_fruit <span class="token operator">=</span> StringMap<span class="token punctuation">.</span>find_opt <span class="token string">"a"</span> map <span class="token keyword">in</span><br>  <span class="token keyword">match</span> a_fruit <span class="token keyword">with</span><br>  <span class="token operator">|</span> None <span class="token operator">-></span> print_endline <span class="token string">"No such fruit"</span><br>  <span class="token operator">|</span> Some fruit <span class="token operator">-></span> print_endline fruit</code></pre><p>The following code demonstrates using a <code>Map</code> to store a collection of dog descriptions and prints information about each dog.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> generate_uuid <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Uuidm<span class="token punctuation">.</span><span class="token punctuation">(</span>v <span class="token variant symbol">`V4</span> <span class="token operator">|></span> to_string<span class="token punctuation">)</span><br><br><span class="token keyword">module</span> StringMap <span class="token operator">=</span> Map<span class="token punctuation">.</span>Make <span class="token punctuation">(</span>String<span class="token punctuation">)</span><br><br><span class="token keyword">type</span> dog <span class="token operator">=</span> <span class="token punctuation">{</span> id <span class="token punctuation">:</span> string<span class="token punctuation">;</span> name <span class="token punctuation">:</span> string<span class="token punctuation">;</span> breed <span class="token punctuation">:</span> string <span class="token punctuation">}</span><br><br><span class="token keyword">let</span> add_dog map name breed <span class="token operator">=</span><br>  <span class="token keyword">let</span> uuid <span class="token operator">=</span> generate_uuid <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> dog <span class="token operator">=</span> <span class="token punctuation">{</span> id <span class="token operator">=</span> uuid<span class="token punctuation">;</span> name<span class="token punctuation">;</span> breed <span class="token punctuation">}</span> <span class="token keyword">in</span><br>  StringMap<span class="token punctuation">.</span>add uuid dog map<br><br><span class="token keyword">let</span> print_dog <span class="token punctuation">_</span> dog <span class="token operator">=</span> printf <span class="token string">"%s) %s is a %s.\n"</span> dog<span class="token punctuation">.</span>id dog<span class="token punctuation">.</span>name dog<span class="token punctuation">.</span>breed<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> dog_map <span class="token operator">=</span> StringMap<span class="token punctuation">.</span>empty <span class="token keyword">in</span><br>  <span class="token keyword">let</span> dog_map <span class="token operator">=</span> add_dog dog_map <span class="token string">"Comet"</span> <span class="token string">"whippet"</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> dog_map <span class="token operator">=</span> add_dog dog_map <span class="token string">"Oscar"</span> <span class="token string">"GSP"</span> <span class="token keyword">in</span><br>  StringMap<span class="token punctuation">.</span>iter print_dog dog_map</code></pre><h3 id="hashtbl" tabindex="-1">Hashtbl</h3><p>A <a href="https://ocaml.org/docs/hash-tables" target="_blank">Hashtbl</a> is similar to a <code>Map</code>, but it is mutable.</p><p>The <code>Hashtbl</code> module supports the following functions:</p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>Hashtbl.clear</code></td><td>removes all the key/value pairs and retains the bucket size</td></tr><tr><td><code>Hashtbl.copy</code></td><td>returns a copy of a <code>Hashtbl</code></td></tr><tr><td><code>Hashtbl.create</code></td><td>creates a <code>Hashtbl</code> instance</td></tr><tr><td><code>Hashtbl.add</code></td><td>adds a key/value pair</td></tr><tr><td><code>Hashtbl.filter_map_inplace</code></td><td>can modify the value for each key or remove it</td></tr><tr><td><code>Hashtbl.find</code></td><td>returns the first value for a given key or raises <code>Not-found</code></td></tr><tr><td><code>Hashtbl.find_all</code></td><td>returns a list of all values for a given key</td></tr><tr><td><code>Hashtbl.find_opt</code></td><td>returns an <code>Option</code> that contains the first value for a given key</td></tr><tr><td><code>Hashtbl.fold</code></td><td>computes a single value from all the key/value pairs</td></tr><tr><td><code>Hashtbl.iter</code></td><td>iterates over all the key/value pairs</td></tr><tr><td><code>Hashtbl.length</code></td><td>returns the number of key/value pairs</td></tr><tr><td><code>Hashtbl.mem</code></td><td>returns a boolean indicating whether a given key is a member</td></tr><tr><td><code>Hashtbl.remove</code></td><td>removes one key/value pair for a given key</td></tr><tr><td><code>Hashtbl.replace</code></td><td>replaces the value for a given key</td></tr><tr><td><code>Hashtbl.reset</code></td><td>removes all the key/value pairs and shrinks the bucket size</td></tr></tbody></table><p>Like with any module, if you call <code>open Hashtbl</code> then these function can be called without the <code>Hashtbl.</code> prefix.</p><p>To create a <code>Hashtbl</code> instance, call the <code>Hashtable.create</code> function passing it an estimate for the number of key/value pairs that will added. It can expand to hold more, but providing a good estimate can make add entries more efficient.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> my_hash <span class="token operator">=</span> Hashtbl<span class="token punctuation">.</span>create <span class="token number">10</span></code></pre><p>Initially the hashtable does not know the type of the keys and values. Once the first entry is added, those types will be fixed and all subsequent entries must use the same types for their keys and values.</p><p>The first argument to all the remaining functions is a <code>Hashtbl</code> instance, with the exception of the <code>iter</code> function where it is the last argument.</p><p>The <code>add</code> function can add multiple values for the same key, and can even add the same value multiple times. The previous values are not overwritten.</p><pre class="language-ocaml"><code class="language-ocaml">Hashtbl<span class="token punctuation">.</span>add my_hash <span class="token string">"whippet"</span> <span class="token string">"Rudy"</span><br>Hashtbl<span class="token punctuation">.</span>add my_hash <span class="token string">"whippet"</span> <span class="token string">"Dasher"</span><br>Hashtbl<span class="token punctuation">.</span>add my_hash <span class="token string">"whippet"</span> <span class="token string">"Comet"</span></code></pre><p>To have only one value for each key, use the <code>replace</code> function instead. The <code>replace</code> function adds a new key or replaces an existing one.</p><pre class="language-ocaml"><code class="language-ocaml">Hashtbl<span class="token punctuation">.</span>replace my_hash <span class="token string">"whippet"</span> <span class="token string">"Comet"</span></code></pre><p>The <code>find</code> function raises a <code>Not_found</code> exception if the key is not found.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> name <span class="token operator">=</span> Hashtbl<span class="token punctuation">.</span>find my_hash <span class="token string">"whippet"</span></code></pre><p>The <code>find_all</code> function returns an empty list if the key is not found.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> names <span class="token operator">=</span> Hashtbl<span class="token punctuation">.</span>find_all my_hash <span class="token string">"whippet"</span></code></pre><p>The <code>remove</code> function doesn't complain if the key being removed doesn't exist.</p><pre class="language-ocaml"><code class="language-ocaml">Hashtbl<span class="token punctuation">.</span>remove my_hash <span class="token string">"whippet"</span></code></pre><p>The following code demonstrates creating a <code>Hashtbl</code> that holds a collection of dogs. The keys are <code>dog</code> ids and the values are <code>dog</code> records.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">type</span> dog <span class="token operator">=</span> <span class="token punctuation">{</span> id <span class="token punctuation">:</span> string<span class="token punctuation">;</span> name <span class="token punctuation">:</span> string<span class="token punctuation">;</span> breed <span class="token punctuation">:</span> string <span class="token punctuation">}</span><br><br><span class="token comment">(* 10 is an estimate for the number of entries that will be added. *)</span><br><span class="token keyword">let</span> dog_map <span class="token operator">=</span> Hashtbl<span class="token punctuation">.</span>create <span class="token number">10</span><br><br><span class="token keyword">let</span> generate_uuid <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Uuidm<span class="token punctuation">.</span><span class="token punctuation">(</span>v <span class="token variant symbol">`V4</span> <span class="token operator">|></span> to_string<span class="token punctuation">)</span><br><br><span class="token keyword">let</span> add_dog name breed <span class="token operator">=</span><br>  <span class="token keyword">let</span> id <span class="token operator">=</span> generate_uuid <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>  Hashtbl<span class="token punctuation">.</span>add dog_map id <span class="token punctuation">{</span> id<span class="token punctuation">;</span> name<span class="token punctuation">;</span> breed <span class="token punctuation">}</span><br><br><span class="token keyword">let</span> print_dog dog <span class="token operator">=</span> printf <span class="token string">"%s is a %s (id=%s).\n"</span> dog<span class="token punctuation">.</span>name dog<span class="token punctuation">.</span>breed dog<span class="token punctuation">.</span>id<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  add_dog <span class="token string">"Comet"</span> <span class="token string">"Whippet"</span><span class="token punctuation">;</span><br>  add_dog <span class="token string">"Oscar"</span> <span class="token string">"GSP"</span><span class="token punctuation">;</span><br>  <span class="token comment">(* The function passed to `iter` takes a key and value from the Hashtbl. *)</span><br>  Hashtbl<span class="token punctuation">.</span>iter <span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">_</span> dog <span class="token operator">-></span> print_dog dog<span class="token punctuation">)</span> dog_map</code></pre><h2 id="functions" tabindex="-1">Functions</h2><p>OCaml functions are first-class. They can take other functions as arguments and can return new functions.</p><p>Function definitions must appear before any calls to them.</p><p>OCaml functions cannot be overridden based on their number of parameters or parameter types.</p><p>The syntax <code>a b c</code> means calling function <code>a</code> with the arguments <code>b</code> and <code>c</code>.</p><p>Another way to write this is to use the &quot;reverse function application&quot; operator <code>|&gt;</code> which is intended to look like a right pointing triangle. In fact, in fonts that support ligatures, it is displays as exactly that. Using this, the equivalent of <code>a b c</code> is c |&gt; b |&gt; a. This operator is typically used with functions that take a single argument. The following code demonstrates two ways to compute the squared value of the sine of an angle.</p><p>The body of a function definition, the part after the <code>=</code>, is an expression. An expression can be a semicolon-separated set of expressions, but typically there is only one. When there are more than one, all but the final expression serve to cause side effects and must have the unit type (no value). Often this use used for debug printing. The result of a function call is the value of the final expression.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> square x <span class="token operator">=</span> x <span class="token operator">*.</span> x<br><span class="token keyword">let</span> angle <span class="token operator">=</span> <span class="token number">0.78</span> <span class="token comment">(* radians *)</span><br><span class="token keyword">let</span> result1 <span class="token operator">=</span> square <span class="token punctuation">(</span>sin angle<span class="token punctuation">)</span><br><span class="token keyword">let</span> result2 <span class="token operator">=</span> angle <span class="token operator">|></span> sin <span class="token operator">|></span> square</code></pre><p>The OCaml syntax for defining and calling functions is inspired by lambda calculus.</p><p>In order to call a function that takes no arguments, such as <code>print_newline</code>, it must be &quot;passed&quot; the &quot;unit&quot; value <code>()</code>. Without this it is just a reference to the function and not a call to it.</p><p>Functions that only produce side effects do not return anything. Calls to them are expressions with &quot;unit type&quot;, represented by <code>()</code>. These are like &quot;statements&quot; in other languages. Some call them &quot;effectful expressions&quot;.</p><p>There are two ways to return early from a function ... using the <code>exit</code> (not typically used) or <code>raise</code> keywords (raises an exception).</p><p>Anonymous functions (aka lambdas) are defined using the <code>fun</code> function. For example the following function takes two <code>int</code> arguments and returns an <code>int</code>. Note how no parentheses are required and the parameters are just separated by spaces.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">fun</span> a b <span class="token operator">-></span> a <span class="token operator">+</span> b</code></pre><p>It is not necessary to specify these types. They are inferred from the function expression <code>a + b</code> based on the fact that the <code>+</code> operator only operates on <code>int</code> values and returns an <code>int</code> value.</p><p>The types can be specified if desired. The main reason to do so is to add documentation so readers of the code don't have to examine the function body to determine the types. To specify the parameter types and the return type, the function above can be written as the following.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">fun</span> <span class="token punctuation">(</span>a <span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token punctuation">(</span>b <span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token punctuation">:</span> int <span class="token operator">-></span> a <span class="token operator">+</span> b</code></pre><p>If this function definition is entered in a REPL, followed by <code>;;</code>, the output will be <code>- : int -&gt; int -&gt; int = &lt;fun&gt;</code>. The dash at the beginning indicates that the value does not have a name. The first and second occurrences of <code>int</code> are the types of the two parameters. The last <code>int</code> is the return type of the function. The <code>&lt;fun&gt;</code> after the <code>=</code> represents the bytecode for the function which cannot be printed.</p><p>When a function is called with fewer arguments than it has parameters, a new function is returned that is the result of partial application. That is why one arrow (<code>-&gt;</code>) for each parameter appears in the output.</p><p>In fact, the function definition above is just syntactic sugar for the following which only defines single-parameter function.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">fun</span> a <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token keyword">fun</span> b <span class="token operator">-></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Despite not having a name, this function can be invoked by surrounding it in parentheses. For example, the following evaluates to <code>5</code>. Note how no parentheses are required around the arguments which are just separated by a space.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token punctuation">(</span><span class="token keyword">fun</span> a b <span class="token operator">-></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token number">3</span></code></pre><p>Let's give a name to this function and invoke it in a couple of ways.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">fun</span> a b <span class="token operator">-></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token keyword">in</span><br>print_int <span class="token punctuation">(</span>add <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 3 *)</span><br><br><span class="token comment">(* Shorthand for previous way of defining this function *)</span><br><span class="token keyword">let</span> add a b <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token keyword">in</span><br>print_int <span class="token punctuation">(</span>add <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 3 *)</span></code></pre><p>In the call to <code>print_int</code> above, parentheses are needed around <code>add 1 2</code> so that is evaluated before the <code>print_int</code> function is called.</p><p>Let's use partial application to create a new function that only takes a single number and adds 5 to it.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> add5 <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>print_int <span class="token punctuation">(</span>add5 <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 7 *)</span></code></pre><p>In the expression <code>e1 e2 e3</code>, <code>e1</code> must evaluate to a function and it is passed the values of <code>e2</code> and <code>e3</code>. If <code>e2</code> or <code>e3</code> are not primitive values or variables, add parentheses around those expressions so they are evaluated before the function call to <code>e1</code> is evaluated. For example, our <code>add</code> function above can be called as follows:</p><pre class="language-ocaml"><code class="language-ocaml">add <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">(* 6 * 9 = 54 *)</span></code></pre><p>Labeled parameters allow them to be specified by name in calls. A function can have a mixture of labeled and unlabeled parameters. Unlabeled parameters are positional and must be passed in the order they are specified. Labeled parameters can be specified in any order and can be mixed into the unlabeled parameters.</p><p>To declare a labelled parameter, use the syntax <code>~arg_name:param_name</code> where <code>arg_name</code> is the name used in callsx and <code>param_name</code> is the name used in the function implementation. If <code>arg_name</code> is the same as <code>param_name</code>, this can be shortened to just <code>~arg_name</code>.</p><p>To pass an labeled argument, use the syntax <code>~arg_name:value</code>. For example, <code>~maximum:100</code>.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token comment">(* This doesn't use labeled parmeters. *)</span><br><span class="token keyword">let</span> rectangle_area1 length width <span class="token operator">=</span> length <span class="token operator">*.</span> width<br><br><span class="token comment">(* This does use labeled parmeters.<br>   The name between ~ and : is what will be used in calls.<br>   The name after the : is what will be used in the function body. *)</span><br><span class="token keyword">let</span> rectangle_area2 <span class="token label property">~length</span><span class="token punctuation">:</span>l <span class="token label property">~width</span><span class="token punctuation">:</span>w <span class="token operator">=</span> l <span class="token operator">*.</span> w<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  printf <span class="token string">"area1 = %f\n"</span> <span class="token punctuation">(</span>rectangle_area1 <span class="token number">8.5</span> <span class="token number">11.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  printf <span class="token string">"area2 = %f\n"</span> <span class="token punctuation">(</span>rectangle_area2 <span class="token label property">~length</span><span class="token punctuation">:</span><span class="token number">8.5</span> <span class="token label property">~width</span><span class="token punctuation">:</span><span class="token number">11.0</span><span class="token punctuation">)</span></code></pre><p>Labeled parameters can specify default values which makes them optional. Use the syntax <code>?arg-name:(param-name = default_value)</code>. If <code>arg_name</code> is the same as <code>param_name</code>, this can be shortened to just <code>?(arg_name = default_value)</code>. Optional labeled parameters must appear before the non-optional parameters.</p><p>Functions that have any optional parameters must have at least one positional parameter. This is required because OCaml does not surround arguments with parentheses and so needs a way to know when the last argument has been reached. When no positional parameters are needed, specify <code>()</code> as the last one. In this case calls to the function must also end with <code>()</code>.</p><p>For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token comment">(* When using optional parameters, there must be at least one<br>   that is not optional.  Adding `()` satisifies this. *)</span><br><span class="token keyword">let</span> greet <span class="token operator">?</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token punctuation">(</span>suffix <span class="token operator">=</span> <span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  printf <span class="token string">"Hello, %s%s\n"</span> name suffix<br><br><span class="token keyword">let</span> product <span class="token operator">?</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">)</span> b <span class="token operator">=</span> a <span class="token operator">*.</span> b<br><br><span class="token keyword">let</span> sum2 <span class="token operator">?</span>alpha<span class="token punctuation">:</span><span class="token punctuation">(</span>first <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token punctuation">(</span>beta <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> first <span class="token operator">+</span> beta<br><br><span class="token keyword">let</span> sum3 <span class="token operator">?</span>alpha<span class="token punctuation">:</span><span class="token punctuation">(</span>first <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token punctuation">(</span>beta <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token label property">~gamma</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> first <span class="token operator">+</span> beta <span class="token operator">+</span> gamma<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token comment">(* In calls to functions with no required parameters, include `()`.<br>     It doesn't matter where it appears in the argument list. *)</span><br>  greet <span class="token label property">~name</span><span class="token punctuation">:</span><span class="token string">"Mark"</span> <span class="token label property">~suffix</span><span class="token punctuation">:</span><span class="token string">"."</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* Hello, Mark. *)</span><br>  greet <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token label property">~name</span><span class="token punctuation">:</span><span class="token string">"Mark"</span><span class="token punctuation">;</span> <span class="token comment">(* Hello, Mark! *)</span><br>  greet <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">(* Hello, World! *)</span><br><br>  printf <span class="token string">"%f\n"</span> <span class="token punctuation">(</span>product <span class="token label property">~a</span><span class="token punctuation">:</span><span class="token number">8.5</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 17 *)</span><br>  printf <span class="token string">"%f\n"</span> <span class="token punctuation">(</span>product <span class="token number">8.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 8.5 *)</span><br><br>  printf <span class="token string">"%d\n"</span> <span class="token punctuation">(</span>sum2 <span class="token label property">~alpha</span><span class="token punctuation">:</span><span class="token number">3</span> <span class="token label property">~beta</span><span class="token punctuation">:</span><span class="token number">4</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 7 *)</span><br>  printf <span class="token string">"%d\n"</span> <span class="token punctuation">(</span>sum2 <span class="token label property">~alpha</span><span class="token punctuation">:</span><span class="token number">3</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 5 *)</span><br>  printf <span class="token string">"%d\n"</span> <span class="token punctuation">(</span>sum2 <span class="token label property">~beta</span><span class="token punctuation">:</span><span class="token number">4</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 5 *)</span><br>  printf <span class="token string">"%d\n"</span> <span class="token punctuation">(</span>sum3 <span class="token label property">~gamma</span><span class="token punctuation">:</span><span class="token number">5</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">(* 8 *)</span></code></pre><p>Recursive functions must be defined with <code>let rec</code>. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> factorial n <span class="token operator">=</span><br>  <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">then</span><br>    <span class="token comment">(* raises an exception *)</span><br>    failwith <span class="token string">"factorial is not defined for negative numbers"</span><br>  <span class="token keyword">else</span> <span class="token keyword">if</span> n <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token number">1</span><br>  <span class="token keyword">else</span> n <span class="token operator">*</span> factorial <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>The <code>failwith</code> keyword is sometimes used in place of code that is not ready to be written. For example, <code>failwith &quot;TODO&quot;</code>.</p><p>Function parameters can use destructuring to extract elements from tuples. This can also be done for lists and arrays, but those require special handling due to non-exhastive matching. The reason is that by definition tuple types have a known size, but list and array types do not. Recall that:</p><ul><li>The type of the tuple <code>(1, 2, 3)</code> is <code>int * int * int</code> which has a length of 3.</li><li>The type of the list <code>[1; 2; 3]</code> is <code>int list</code> which does not specify a length.</li><li>The type of the array <code>[|1; 2; 3|]</code> is <code>int array</code> which does not specify a length.</li></ul><p>The following code demonstrates ways to use destructuring of tuples, lists, and arrays.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token comment">(* This only handles tuples of length 4. *)</span><br><span class="token keyword">let</span> tuple2of4 <span class="token punctuation">(</span><span class="token punctuation">_</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> e<br><span class="token comment">(* alternate implementation *)</span><br><span class="token comment">(* let tuple2of4 tuple = match tuple with a, b, c, d -> b *)</span><br><br><span class="token comment">(* This only handles lists of length 4. *)</span><br><span class="token keyword">let</span> list2of4 <span class="token operator">=</span> <span class="token keyword">function</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span> <span class="token punctuation">_</span><span class="token punctuation">;</span> e<span class="token punctuation">;</span> <span class="token punctuation">_</span><span class="token punctuation">;</span> <span class="token punctuation">_</span> <span class="token punctuation">]</span> <span class="token operator">-></span> e<br>  <span class="token operator">|</span> <span class="token punctuation">_</span> <span class="token operator">-></span> failwith <span class="token string">"list must have length 4"</span><br><br><span class="token comment">(* This only handles arrays of length 4. *)</span><br><span class="token keyword">let</span> array2of4 <span class="token operator">=</span> <span class="token keyword">function</span><br>  <span class="token operator">|</span> <span class="token operator-like-punctuation punctuation">[|</span> <span class="token punctuation">_</span><span class="token punctuation">;</span> e<span class="token punctuation">;</span> <span class="token punctuation">_</span><span class="token punctuation">;</span> <span class="token punctuation">_</span> <span class="token operator-like-punctuation punctuation">|]</span> <span class="token operator">-></span> e<br>  <span class="token operator">|</span> <span class="token punctuation">_</span> <span class="token operator">-></span> failwith <span class="token string">"array must have length 4"</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>  <span class="token comment">(* This destructures a tuple in a variable declaration. *)</span><br>  <span class="token keyword">let</span> <span class="token punctuation">_</span><span class="token punctuation">,</span> second<span class="token punctuation">,</span> third<span class="token punctuation">,</span> <span class="token punctuation">_</span> <span class="token operator">=</span> t <span class="token keyword">in</span><br>  printf <span class="token string">"second in tuple is %s\n"</span> second<span class="token punctuation">;</span><br>  printf <span class="token string">"third in tuple is %s\n"</span> third<span class="token punctuation">;</span><br>  printf <span class="token string">"second in tuple is %s\n"</span> <span class="token punctuation">(</span>tuple2of4 t<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> l <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">"a"</span><span class="token punctuation">;</span> <span class="token string">"b"</span><span class="token punctuation">;</span> <span class="token string">"c"</span><span class="token punctuation">;</span> <span class="token string">"d"</span> <span class="token punctuation">]</span> <span class="token keyword">in</span><br>  printf <span class="token string">"second in list is %s\n"</span> <span class="token punctuation">(</span>list2of4 l<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token operator-like-punctuation punctuation">[|</span> <span class="token string">"a"</span><span class="token punctuation">;</span> <span class="token string">"b"</span><span class="token punctuation">;</span> <span class="token string">"c"</span><span class="token punctuation">;</span> <span class="token string">"d"</span> <span class="token operator-like-punctuation punctuation">|]</span> <span class="token keyword">in</span><br>  printf <span class="token string">"second in array is %s\n"</span> <span class="token punctuation">(</span>array2of4 a<span class="token punctuation">)</span></code></pre><p>A common OCaml idiom to hide the use of an accumulator parameter is to nest a function inside another. For example, see the <code>visit</code> function that is nested inside the <code>reverse_int_list</code> function here. This uses tail recursion so recursion does not cause the call stack to grow.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> reverse_int_list l <span class="token operator">=</span><br>  <span class="token keyword">let</span> <span class="token keyword">rec</span> visit acc l <span class="token operator">=</span><br>    <span class="token keyword">match</span> l <span class="token keyword">with</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> acc <span class="token operator">|</span> hd <span class="token punctuation">::</span> tl <span class="token operator">-></span> visit <span class="token punctuation">(</span>hd <span class="token punctuation">::</span> acc<span class="token punctuation">)</span> tl<br>  <span class="token keyword">in</span><br>  visit <span class="token punctuation">[</span><span class="token punctuation">]</span> l<br><br><span class="token keyword">let</span> <span class="token keyword">rec</span> print_int_list l <span class="token operator">=</span><br>  <span class="token keyword">match</span> l <span class="token keyword">with</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><br>  <span class="token operator">|</span> hd <span class="token punctuation">::</span> tl <span class="token operator">-></span><br>      print_int hd<span class="token punctuation">;</span><br>      print_char <span class="token char">' '</span><span class="token punctuation">;</span><br>      print_int_list tl<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">5</span> <span class="token punctuation">]</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> rev <span class="token operator">=</span> reverse_int_list numbers <span class="token keyword">in</span><br>  print_int_list rev<span class="token punctuation">;</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>OCaml does not make it easy to write variadic functions, which are functions that take a variable number of arguments. One approach is to take a list, but that requires all the values to have the same type. Another approach is to use a generalized algebraic data type (GADT), but that introduces complexity.</p><h2 id="modules" tabindex="-1">Modules</h2><p>A module provides a namespace for a collection of related named values that can be types, constants, and functions. Their names must begin with an uppercase letter and they use CamelCase by convention.</p><p>Every <code>.ml</code> source file defines a module. For example, the file <code>demo.ml</code> defines the module <code>Demo</code>.</p><p>A package is a collection of related modules.</p><p>Modules provides a way to identify multiple values that happen to have the same name. For example, the <code>List</code> and <code>Array</code> modules both define the <code>map</code> function.</p><p>Modules also serve to hide complexity.</p><p>A submodule can be defined with the syntax <code>module ModuleName = struct ... end</code>. This can be used to avoid placing module code in a separate file when it will only be used in one file.</p><p>The following code defines a module that contains functions for converting temperature values and demonstrates using it.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">module</span> Temperature <span class="token operator">=</span> <span class="token keyword">struct</span><br>  <span class="token keyword">let</span> c_of_f fahrenheit <span class="token operator">=</span> <span class="token punctuation">(</span>fahrenheit <span class="token operator">-.</span> <span class="token number">32.0</span><span class="token punctuation">)</span> <span class="token operator">*.</span> <span class="token punctuation">(</span><span class="token number">5.0</span> <span class="token operator">/.</span> <span class="token number">9.0</span><span class="token punctuation">)</span><br>  <span class="token keyword">let</span> f_of_c celsius <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">9.0</span> <span class="token operator">/.</span> <span class="token number">5.0</span> <span class="token operator">*.</span> celsius<span class="token punctuation">)</span> <span class="token operator">+.</span> <span class="token number">32.0</span><br><span class="token keyword">end</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  print_float <span class="token punctuation">(</span>Temperature<span class="token punctuation">.</span>c_of_f <span class="token number">100.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">(* 37.8. *)</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  print_float <span class="token punctuation">(</span>Temperature<span class="token punctuation">.</span>f_of_c <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">(* 32.0 *)</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Modules cannot be used like values. They cannot be assigned to a variable, passed to a function, or returned from a function.</p><p>Consider the following code which uses values from the <code>Hashtbl</code> module multiple times. There is no need to &quot;import&quot; the module as is done in many other programming languages.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> dog_table <span class="token operator">=</span> Hashtbl<span class="token punctuation">.</span>create <span class="token number">10</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  Hashtbl<span class="token punctuation">.</span>add dog_table <span class="token string">"Comet"</span> <span class="token string">"Whippet"</span><span class="token punctuation">;</span><br>  Hashtbl<span class="token punctuation">.</span>add dog_table <span class="token string">"Oscar"</span> <span class="token string">"GSP"</span><span class="token punctuation">;</span><br>  Hashtbl<span class="token punctuation">.</span>iter<br>    <span class="token punctuation">(</span><span class="token keyword">fun</span> name breed <span class="token operator">-></span> Printf<span class="token punctuation">.</span>printf <span class="token string">"%s is a %s.\n"</span> name breed<span class="token punctuation">)</span><br>    dog_table</code></pre><p>There are multiple ways to avoid repeating a module name every time the values it defines are referenced. The options include:</p><ul><li><p>global <code>open</code></p><p>Adding <code>open Hashtbl</code> at the top of a source file allows unprefixed names to be used anywhere in the source file. This works fine as long is the names don't collide with names defined in other modules that also use a global open.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Hashtbl<br><span class="token keyword">let</span> dog_table <span class="token operator">=</span> create <span class="token number">10</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  add dog_table <span class="token string">"Comet"</span> <span class="token string">"Whippet"</span><span class="token punctuation">;</span><br>  add dog_table <span class="token string">"Oscar"</span> <span class="token string">"GSP"</span><span class="token punctuation">;</span><br>  iter<br>    <span class="token punctuation">(</span><span class="token keyword">fun</span> name breed <span class="token operator">-></span> Printf<span class="token punctuation">.</span>printf <span class="token string">"%s is a %s.\n"</span> name breed<span class="token punctuation">)</span><br>    dog_table</code></pre></li><li><p>local <code>option</code></p><p>For example, <code>let open Hashtbl in</code> narrows the scope in which unprefixed names can be used to the expression that follows.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> dog_table <span class="token operator">=</span> Hashtbl<span class="token punctuation">.</span>create <span class="token number">10</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> <span class="token keyword">open</span> Hashtbl <span class="token keyword">in</span><br>  add dog_table <span class="token string">"Comet"</span> <span class="token string">"Whippet"</span><span class="token punctuation">;</span><br>  add dog_table <span class="token string">"Oscar"</span> <span class="token string">"GSP"</span><span class="token punctuation">;</span><br>  iter<br>    <span class="token punctuation">(</span><span class="token keyword">fun</span> name breed <span class="token operator">-></span> Printf<span class="token punctuation">.</span>printf <span class="token string">"%s is a %s.\n"</span> name breed<span class="token punctuation">)</span><br>    dog_table</code></pre></li><li><p>dot and parentheses</p><p>For example, <code>Hashtbl.(...)</code> narrows the scope in which unprefixed names can be used to the expression inside the parentheses.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> dog_table <span class="token operator">=</span> Hashtbl<span class="token punctuation">.</span>create <span class="token number">10</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  Hashtbl<span class="token punctuation">.</span><span class="token punctuation">(</span><br>    add dog_table <span class="token string">"Comet"</span> <span class="token string">"Whippet"</span><span class="token punctuation">;</span><br>    add dog_table <span class="token string">"Oscar"</span> <span class="token string">"GSP"</span><span class="token punctuation">;</span><br>    iter<br>      <span class="token punctuation">(</span><span class="token keyword">fun</span> name breed <span class="token operator">-></span> Printf<span class="token punctuation">.</span>printf <span class="token string">"%s is a %s.\n"</span> name breed<span class="token punctuation">)</span><br>      dog_table<br>  <span class="token punctuation">)</span></code></pre></li></ul><p>Modules can be nested to create a hierachy of namespaces, but it seems this is rarely used.</p><p>Circular dependencies between modules are not allowed.</p><h3 id="stdlib-module" tabindex="-1">Stdlib Module</h3><p>There is an implicit <code>open</code> for the module <code>Stdlib</code>, so all of its members can be accessed without the module name prefix.</p><p>Commonly used members include:</p><ul><li>many operators</li><li>many math functions</li><li>many type conversion functions</li><li>input/output functions</li><li><code>ref</code> and operators on them</li><li><code>result</code> variant type</li><li><code>exit</code> and <code>at_exit</code></li><li>a large number of standard library modules</li><li>tuple functions for pairs, <code>fst</code> and <code>snd</code></li><li><code>ceil</code> and <code>floor</code></li><li><code>failwith</code>, <code>invalid_arg</code>, and <code>raise</code></li><li>many exceptions</li><li><code>compare</code></li><li><code>max</code> and <code>min</code></li><li><code>nan</code></li><li><code>not</code></li><li>debugging dunderbars (ex. <code>__FILE__</code>, <code>__FUNCTION__</code>, and <code>__LINE__</code>)</li></ul><p>The following code demonstrates using the debugging dunderbar values.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> log file fn line <span class="token operator">=</span><br>  Printf<span class="token punctuation">.</span>printf <span class="token string">"file: %s; function: %s; line: %d\n"</span> file fn line<br><br><span class="token keyword">let</span> demo <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  print_endline <span class="token string">"entered demo"</span><span class="token punctuation">;</span><br>  log __FILE__ __FUNCTION__ __LINE__<span class="token punctuation">;</span><br>  print_endline <span class="token string">"exiting demo"</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> demo <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="printf-module" tabindex="-1">Printf Module</h3><p>The Printf module defines many functions that produce string output using a format string.</p><p>Perhaps the most commonly used function of these is <code>printf</code>. It takes a format string and a number of additional arguments equal to the number of placeholders in the format string. Commonly used placeholders include</p><ul><li><code>%s</code> for <code>string</code> values</li><li><code>%d</code> for <code>int</code> values</li><li><code>%f</code> for <code>float</code> values</li><li><code>%.2f</code> for <code>float</code> values with two decimal places</li><li><code>%B</code> for <code>bool</code> values (outputs &quot;true&quot; or &quot;false&quot;)</li></ul><p>Ending the format string with <code>%!</code> causes it to flush the output buffer.</p><h3 id="base-module" tabindex="-1">Base Module</h3><p>The Base module provides an alternative to TODO. It was developed by Jane Street. To use this:</p><ol><li><code>opam install base</code></li><li><code>open Base</code></li><li>Add <code>base</code> as a dependency in <code>dune</code> files.</li></ol><p>TODO: Test this and try the <code>**</code> and <code>**.</code> operators. TODO: What are the pros and cons of using this module?</p><h2 id="signatures" tabindex="-1">Signatures</h2><p>The concept of &quot;interfaces&quot; in other programming languages is supported in OCaml with &quot;signatures&quot;. These can be used to specify that multiple modules support the same set of functions.</p><p>A signature is defined with the syntax <code>module type ModuleTypeName = sig ... end</code>. It can contain the following kinds of specifications: <code>type</code>, <code>exception</code>, <code>val</code>, and <code>module type</code>.</p><p>The following code demonstrates defining a signature and two modules that conform to it.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">module</span> <span class="token keyword">type</span> Shape <span class="token operator">=</span> <span class="token keyword">sig</span><br>  <span class="token keyword">type</span> t<br><br>  <span class="token keyword">val</span> area <span class="token punctuation">:</span> t <span class="token operator">-></span> float<br><span class="token keyword">end</span><br><br><span class="token comment">(* float represents radius *)</span><br><span class="token keyword">module</span> Circle <span class="token punctuation">:</span> Shape <span class="token keyword">with</span> <span class="token keyword">type</span> t <span class="token operator">:=</span> float <span class="token operator">=</span> <span class="token keyword">struct</span><br>  <span class="token keyword">let</span> area radius <span class="token operator">=</span> Float<span class="token punctuation">.</span>pi <span class="token operator">*.</span> radius <span class="token operator">*.</span> radius<br>  <span class="token comment">(* Any extra values, including functions, define here<br>     that are not described in the `Shape` signature<br>     will be private to this module (not exposed outside).<br>     We say the module is "sealed". *)</span><br><span class="token keyword">end</span><br><br><span class="token comment">(* float * float represents length and width *)</span><br><span class="token keyword">module</span> Rectangle <span class="token punctuation">:</span> Shape <span class="token keyword">with</span> <span class="token keyword">type</span> t <span class="token operator">:=</span> float <span class="token operator">*</span> float <span class="token operator">=</span> <span class="token keyword">struct</span><br>  <span class="token keyword">let</span> area <span class="token punctuation">(</span>length<span class="token punctuation">,</span> width<span class="token punctuation">)</span> <span class="token operator">=</span> length <span class="token operator">*.</span> width<br><span class="token keyword">end</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> radius <span class="token operator">=</span> <span class="token number">5.0</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> circle_area <span class="token operator">=</span> Circle<span class="token punctuation">.</span>area radius <span class="token keyword">in</span><br>  printf <span class="token string">"Circle area: %.2f\n"</span> circle_area<span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> length <span class="token operator">=</span> <span class="token number">4.0</span> <span class="token operator">and</span> width <span class="token operator">=</span> <span class="token number">6.0</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> rectangle_area <span class="token operator">=</span> Rectangle<span class="token punctuation">.</span>area <span class="token punctuation">(</span>length<span class="token punctuation">,</span> width<span class="token punctuation">)</span> <span class="token keyword">in</span><br>  printf <span class="token string">"Rectangle area: %.2f\n"</span> rectangle_area</code></pre><p>Files with the <code>.mli</code> extension contain signatures of functions defined in the corresponding <code>.ml</code> file. This pair of files is called a &quot;compilation unit&quot;. Code that uses this unit can only access what the <code>.mli</code> file describes.</p><p>For example, see the definitions of the standard library modules in the GitHub repository for OCaml at <a href="https://github.com/ocaml/ocaml/tree/trunk/stdlib" target="_blank">ocaml/stdlib</a>. The file <code>list.mli</code> defines the signatures for the <code>List</code> module and the file <code>list.ml</code> defines the implementations.</p><p>The <code>is_empty</code> function has the signature</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">val</span> is_empty <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> list <span class="token operator">-></span> bool</code></pre><p>and the implementation</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> is_empty <span class="token operator">=</span> <span class="token keyword">function</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token boolean">true</span><br>  <span class="token operator">|</span> <span class="token punctuation">_</span> <span class="token punctuation">::</span> <span class="token punctuation">_</span> <span class="token operator">-></span> <span class="token boolean">false</span></code></pre><p>Files with the <code>.cmi</code> extension are compiled versions of <code>.mli</code> files and files with the <code>.cmo</code> extension are compiled versions of <code>.ml</code> files.</p><p>TODO: Can an OCaml class implement a signature?</p><h2 id="functors" tabindex="-1">Functors</h2><p>TODO: Describe these. See <a href="https://ocaml.org/docs/functors" target="_blank">Functors</a>.</p><h2 id="exception-handling" tabindex="-1">Exception Handling</h2><p>The built-in type <code>exn</code> is an <a href="https://v2.ocaml.org/manual/extensiblevariants.html" target="_blank">extensible variant type</a> that has constructors for all the built-in exceptions. Examples include <code>Division_by_zero</code>, <code>Failure</code>, <code>Invalid_argument</code>, and <code>Not_found</code>. For a full list, see <a href="https://v2.ocaml.org/api/index_exceptions.html" target="_blank">Index of exceptions</a>.</p><p>The <code>exception</code> keyword creates a custom exception that is added as a constructor of the <code>exn</code> type. Exceptions can optionally have an associated value of any type. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">exception</span> BadThingHappened<br><span class="token keyword">exception</span> TemperatureTooHigh <span class="token keyword">of</span> float</code></pre><p>The <code>raise</code> keyword raises a given exception. For example:</p><pre class="language-ocaml"><code class="language-ocaml">raise BadThingHappened<br>raise <span class="token punctuation">(</span>TemperatureTooHigh <span class="token number">99.9</span><span class="token punctuation">)</span></code></pre><p>There are predefined functions that simplify raising common exceptions.<br><code>failwith &quot;data not found&quot;</code> is short for <code>raise (Failure &quot;data not found&quot;)</code>.<br><code>invalid_arg &quot;bad 1st arg&quot;</code> is short for <code>raise (Invalid_argument &quot;bad 1st arg&quot;)</code>.</p><p>The <code>try</code> keyword enables catching exceptions raised by an expression. It is similar to the <code>match</code> keyword, but the branches must match on exceptions. The value of each branch must have the same type. If no branch matches a raised exception, the exception is re-raised. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">exception</span> TemperatureCrazy<br><span class="token keyword">exception</span> TemperatureHigh <span class="token keyword">of</span> float<br><br><span class="token keyword">let</span> evaluate_temperature temp <span class="token operator">=</span><br>  <span class="token keyword">if</span> temp <span class="token operator">>=</span> <span class="token number">120.0</span> <span class="token keyword">then</span> raise TemperatureCrazy<span class="token punctuation">;</span><br>  <span class="token keyword">if</span> temp <span class="token operator">>=</span> <span class="token number">100.0</span> <span class="token keyword">then</span> raise <span class="token punctuation">(</span>TemperatureHigh temp<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> temp <span class="token operator">&lt;</span> <span class="token number">32.0</span> <span class="token keyword">then</span> <span class="token string">"cold"</span> <span class="token keyword">else</span> <span class="token keyword">if</span> temp <span class="token operator">&lt;</span> <span class="token number">75.0</span> <span class="token keyword">then</span> <span class="token string">"hot"</span> <span class="token keyword">else</span> <span class="token string">"nice"</span><br><br><span class="token keyword">let</span> report_temperature t <span class="token operator">=</span><br>  <span class="token keyword">try</span> printf <span class="token string">"%.1f is %s\n"</span> t <span class="token punctuation">(</span>evaluate_temperature t<span class="token punctuation">)</span> <span class="token keyword">with</span><br>  <span class="token operator">|</span> TemperatureCrazy <span class="token operator">-></span> printf <span class="token string">"%.1f is a crazy temperature!\n"</span> t<br>  <span class="token operator">|</span> TemperatureHigh t <span class="token operator">-></span> printf <span class="token string">"%.1f is too hot!\n"</span> t<br><br><span class="token comment">(* Alternative that does the same thing and<br>   is good for matching both exceptions and other values.<br>   let report_temperature t =<br>     match evaluate_temperature t with<br>     | exception TemperatureCrazy -> printf "%.1f is a crazy temperature!\n" t<br>     | exception TemperatureHigh t -> printf "%.1f is too hot!\n" t<br>     | s -> printf "%.1f is %s\n" t s<br>*)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  report_temperature <span class="token number">80.0</span><span class="token punctuation">;</span><br>  <span class="token comment">(* "80.0 is nice" *)</span><br>  report_temperature <span class="token number">50.0</span><span class="token punctuation">;</span><br>  <span class="token comment">(* "50.0 is nice" *)</span><br>  report_temperature <span class="token number">20.0</span><span class="token punctuation">;</span><br>  <span class="token comment">(* "20.0 is cold" *)</span><br>  report_temperature <span class="token number">100.0</span><span class="token punctuation">;</span><br>  <span class="token comment">(* "100.0 is too hot!" *)</span><br>  report_temperature <span class="token number">120.0</span> <span class="token comment">(* "120.0 is a crazy temperature!" *)</span></code></pre><p>The built-in function <code>assert</code> takes a Boolean expression and raises an <code>Assert_failure</code> if if evaluates to false. This is good for verify conditions that must hold in order for the program to run correctly.</p><h2 id="source-files" tabindex="-1">Source Files</h2><p>The code in a source file is executed just as it would be in a REPL if it were terminated by a double semicolon.</p><p>Every source file defines a module. The identifiers it defines, including types, constants, and functions, can be used in other source files. The name of a module is inferred from its source file name by uppercasing its first letter. For example, the file <code>foo_bar.ml</code> defines the module <code>Foo_bar</code>.</p><p>Suppose this file defines the function <code>baz</code>. To call this function in another source file, use <code>Foo_bar.baz</code>. Alternatively, include an <code>open</code> statement to allow all the identifiers in a given module to be used in the current source file without prefixing them with their module name. If we have <code>open Foo_bar</code> then the <code>baz</code> function can be used without the <code>Foo_bar.</code> prefix.</p><p>OCaml source files contain the following kinds of statements:</p><ul><li><code>open</code> statements</li><li>constants defined with <code>let</code> definitions</li><li>functions defined with <code>let</code> definitions</li><li>an optional &quot;main&quot; expression that begins with <code>let () =</code></li></ul><p>Here's an example of a file named <code>math.ml</code> that defines a type, a constant, and some functions that can be used by other source files.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> point2d <span class="token operator">=</span> float <span class="token operator">*</span> float<br><br><span class="token keyword">let</span> pi <span class="token operator">=</span> Float<span class="token punctuation">.</span>pi<br><br><span class="token keyword">let</span> add a b <span class="token operator">=</span> a <span class="token operator">+</span> b<br><br><span class="token keyword">let</span> average numbers <span class="token operator">=</span><br>  <span class="token keyword">let</span> sum <span class="token operator">=</span> List<span class="token punctuation">.</span>fold_left <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> numbers <span class="token keyword">in</span><br>  <span class="token keyword">let</span> length <span class="token operator">=</span> List<span class="token punctuation">.</span>length numbers <span class="token keyword">in</span><br>  float_of_int sum <span class="token operator">/.</span> float_of_int length<br><br><span class="token comment">(* This demonstrates adding types to parameters and<br>   specifying the return type, all of which can be inferred. *)</span><br><span class="token keyword">let</span> distance <span class="token punctuation">(</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span> <span class="token punctuation">:</span> point2d<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token punctuation">:</span> point2d<span class="token punctuation">)</span> <span class="token punctuation">:</span> float <span class="token operator">=</span><br>  <span class="token keyword">let</span> dx <span class="token operator">=</span> x2 <span class="token operator">-.</span> x1 <span class="token keyword">in</span><br>  <span class="token keyword">let</span> dy <span class="token operator">=</span> y2 <span class="token operator">-.</span> y1 <span class="token keyword">in</span><br>  sqrt <span class="token punctuation">(</span><span class="token punctuation">(</span>dx <span class="token operator">*.</span> dx<span class="token punctuation">)</span> <span class="token operator">+.</span> <span class="token punctuation">(</span>dy <span class="token operator">*.</span> dy<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Here is a &quot;main&quot; source file, typically named <code>main.ml</code>, that uses things defined in <code>math.ml</code>. It defines a constant, a function, and a expression that is executed when this file is passed to the <code>ocaml</code> command.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Math<br><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> my_constant <span class="token operator">=</span> <span class="token number">7</span><br><br><span class="token keyword">let</span> square x <span class="token operator">=</span> x <span class="token operator">*</span> x <span class="token comment">(* a function *)</span><br><br><span class="token comment">(* Note the use of semicolons to separate<br>   the statements and expressions. *)</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token comment">(* This is a verbose way to print a value. *)</span><br>  print_string <span class="token string">"my_constant = "</span><span class="token punctuation">;</span><br>  print_int my_constant<span class="token punctuation">;</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">(* This is a more concise way to print a value. *)</span><br>  printf <span class="token string">"pi = %f\n"</span> pi<span class="token punctuation">;</span> <span class="token comment">(* defined in math.ml *)</span><br><br>  <span class="token comment">(* This calls a function defined in this file. *)</span><br>  printf <span class="token string">"square of %d = %d\n"</span> my_constant <span class="token punctuation">(</span>square my_constant<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">(* The remaining examples call functions defined in math.ml. *)</span><br>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">and</span> c <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">in</span><br>  printf <span class="token string">"sum of a and b = %d\n"</span> <span class="token punctuation">(</span>add a b<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">;</span> b<span class="token punctuation">;</span> c<span class="token punctuation">]</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> avg <span class="token operator">=</span> average numbers <span class="token keyword">in</span><br>  printf <span class="token string">"average of a, b, and c = %f\n"</span> avg<span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token operator">and</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> d <span class="token operator">=</span> distance p1 p2 <span class="token keyword">in</span> print_float d</code></pre><p>When these files appear in the <code>bin</code> directory of a Dune project, the program can be run by entering <code>dune exec {project-name}</code>.</p><p>To run this outside of a Dune project, create an executable by entering <code>ocamlopt math.ml main.ml -o demo</code> and run it by entering <code>./demo</code>.</p><p>The <code>module</code> keyword can be used to define a submodule. For example, the file <code>math.ml</code> defines the module <code>Geometry</code>. If it contains <code>module Geometry = struct ... end</code> then the things it defines are in the module <code>Math.Geometry</code>.</p><p>For example, suppose in a Dune project the file <code>lib/math.ml</code> contains the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> average numbers <span class="token operator">=</span><br>  <span class="token keyword">let</span> sum <span class="token operator">=</span> List<span class="token punctuation">.</span>fold_left <span class="token punctuation">(</span><span class="token operator">+.</span><span class="token punctuation">)</span> <span class="token number">0.0</span> numbers <span class="token keyword">in</span><br>  <span class="token keyword">let</span> length <span class="token operator">=</span> List<span class="token punctuation">.</span>length numbers <span class="token keyword">in</span><br>  sum <span class="token operator">/.</span> float_of_int length<br><br><span class="token keyword">module</span> Geometry <span class="token operator">=</span> <span class="token keyword">struct</span><br>  <span class="token keyword">let</span> rectangle_area width height <span class="token operator">=</span> width <span class="token operator">*.</span> height<br>  <span class="token keyword">let</span> rectangle_perimeter width height <span class="token operator">=</span> width <span class="token operator">*.</span> <span class="token number">2.0</span> <span class="token operator">+.</span> height <span class="token operator">*.</span> <span class="token number">2.0</span><br><span class="token keyword">end</span></code></pre><p>In the file <code>bin/main.ml</code> this can be used as follows:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Demo<span class="token punctuation">.</span>Math<br><span class="token comment">(* Can also add this: open Demo.Math.Geometry *)</span><br><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> avg <span class="token operator">=</span> average <span class="token punctuation">[</span><span class="token number">5.2</span><span class="token punctuation">;</span> <span class="token number">3.5</span><span class="token punctuation">]</span> <span class="token keyword">in</span><br>  printf <span class="token string">"average = %f\n"</span> avg<span class="token punctuation">;</span><br>  <span class="token keyword">let</span> area <span class="token operator">=</span> Geometry<span class="token punctuation">.</span>rectangle_area <span class="token number">5.2</span> <span class="token number">3.5</span> <span class="token keyword">in</span><br>  printf <span class="token string">"area = %f\n"</span> area</code></pre><h2 id="input%2Foutput" tabindex="-1">Input/Output</h2><p>The OCaml standard library provides many functions that read input.</p><p>The following functions read from <code>stdin</code>:</p><ul><li><code>read_line</code> - raises <code>End_of_file</code> if there is no more to read</li><li><code>read_int_opt</code> - returns <code>None</code> if conversion fails</li><li><code>read_int</code> - raises <code>Failure &quot;int_of_string&quot;</code> if conversion fails</li><li><code>read_float_opt</code> - returns <code>None</code> if conversion fails</li><li><code>read_float</code> - raises <code>Failure &quot;float_of_string&quot;</code> if conversion fails</li></ul><p>The OCaml standard library provides many functions that produce output.</p><p>The following functions write to <code>stdout</code>:</p><ul><li><code>print_bytes</code></li><li><code>print_char</code></li><li><code>print_endline</code> - prints a string followed by a newline</li><li><code>print_float</code></li><li><code>print_int</code></li><li><code>print_newline</code> - prints only a newline</li><li><code>print_string</code></li></ul><p>The following functions write to <code>stderr</code>:</p><ul><li><code>prerr_bytes</code></li><li><code>prerr_char</code></li><li><code>prerr_endline</code> - prints a string followed by a newline</li><li><code>prerr_float</code></li><li><code>prerr_int</code></li><li><code>prerr_newline</code> - prints only a newline</li><li><code>prerr_string</code></li></ul><p>The following program prompts for two numbers and outputs their product.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Make the printf function available. *)</span><br><span class="token keyword">open</span> Printf<span class="token punctuation">;;</span><br><br>print_string <span class="token string">"Enter the first number: "</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> num1 <span class="token operator">=</span> read_float <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br><br>print_string <span class="token string">"Enter the second number: "</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> num2 <span class="token operator">=</span> read_float <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br><br><span class="token keyword">let</span> product <span class="token operator">=</span> num1 <span class="token operator">*.</span> num2 <span class="token keyword">in</span><br>printf <span class="token string">"The product of %.2f and %.2f is %.2f\n"</span> num1 num2 product<span class="token punctuation">;</span></code></pre><p>The following program reads and prints all the lines in a text file using a <code>while</code> loop.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_in <span class="token string">"BeverlyHillbillies.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">try</span><br>  <span class="token keyword">while</span> <span class="token boolean">true</span> <span class="token keyword">do</span><br>    <span class="token comment">(* input_line reads from a given channel<br>       until a newline or the end is reached. *)</span><br>    <span class="token keyword">let</span> line <span class="token operator">=</span> input_line channel <span class="token keyword">in</span><br>    print_endline line<br>  <span class="token keyword">done</span><br><span class="token keyword">with</span> End_of_file <span class="token operator">-></span> close_in channel</code></pre><p>The following program reads and prints all the lines in a text file using recursion.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_in <span class="token string">"BeverlyHillbillies.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> <span class="token keyword">rec</span> loop <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">try</span><br>    <span class="token keyword">let</span> line <span class="token operator">=</span> input_line channel <span class="token keyword">in</span><br>    print_endline line<span class="token punctuation">;</span><br>    loop <span class="token punctuation">(</span><span class="token punctuation">)</span><br>  <span class="token keyword">with</span> End_of_file <span class="token operator">-></span> close_in channel<br><span class="token keyword">in</span><br>loop <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>The following program creates a text file and writes lines to it.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_out <span class="token string">"output.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">try</span><br>  <span class="token comment">(* output_string writes to a given channel. *)</span><br>  output_string channel <span class="token string">"line 1\n"</span><span class="token punctuation">;</span><br>  output_string channel <span class="token string">"line 2\n"</span><span class="token punctuation">;</span><br>  output_string channel <span class="token string">"line 3\n"</span><span class="token punctuation">;</span><br>  close_out channel<br><span class="token keyword">with</span> ex <span class="token operator">-></span> close_out channel</code></pre><h2 id="object-oriented-features" tabindex="-1">Object-oriented Features</h2><p>Classes offer an alternative to records. Both can define fields, but classes add the ability to define methods.</p><p>The following code demonstrates defining and using a class (<code>point</code>). Classes, like types, have lowercase names by convention.</p><p>A class definition serves as its single constructor. A class cannot define additional constructors, but functions can be written to create instances in additional ways.</p><p>The <code>point</code> class and the <code>origin</code> function are wrapped in a module to make it clear that they are related. Modules have names that start uppercase by convention.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">module</span> Geometry <span class="token operator">=</span> <span class="token keyword">struct</span><br><br>  <span class="token comment">(* Arguments passed to a constructor do not require a matching field<br>     and can be used in methods. *)</span><br>  <span class="token keyword">class</span> point <span class="token punctuation">(</span>x_init <span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token punctuation">(</span>y_init <span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token operator">=</span><br>    <span class="token comment">(* Can omit "(self)" if there are no references to it. *)</span><br>    <span class="token keyword">object</span> <span class="token punctuation">(</span>self<span class="token punctuation">)</span><br>      <span class="token comment">(* Instance variables are immutable by default,<br>         but can be made mutable. *)</span><br>      <span class="token keyword">val</span> <span class="token keyword">mutable</span> x <span class="token operator">=</span> x_init<br>      <span class="token keyword">val</span> <span class="token keyword">mutable</span> y <span class="token operator">=</span> y_init<br><br>      <span class="token comment">(* Getter methods can have the same name as the field they return,<br>         but often they start with "get_". *)</span><br>      <span class="token keyword">method</span> get_x <span class="token operator">=</span> x<br>      <span class="token keyword">method</span> get_y <span class="token operator">=</span> y<br>      <span class="token keyword">method</span> set_x new_x <span class="token operator">=</span> x <span class="token operator">&lt;-</span> new_x<br>      <span class="token keyword">method</span> set_y new_y <span class="token operator">=</span> y <span class="token operator">&lt;-</span> new_y<br><br>      <span class="token comment">(* This is a named constructor. *)</span><br>      <span class="token keyword">method</span> origin <span class="token operator">=</span> <span class="token keyword">new</span> point <span class="token number">0.0</span> <span class="token number">0.0</span><br>      <span class="token keyword">method</span> print <span class="token operator">=</span> printf <span class="token string">"(%f, %f)\n"</span> x y<br><br>      <span class="token keyword">method</span> translate dx dy <span class="token operator">=</span><br>        x <span class="token operator">&lt;-</span> x <span class="token operator">+.</span> dx<span class="token punctuation">;</span><br>        y <span class="token operator">&lt;-</span> y <span class="token operator">+.</span> dy<br>    <span class="token keyword">end</span><br><br>  <span class="token comment">(* This is the OCaml version of a named constructor. *)</span><br>  <span class="token keyword">let</span> origin <span class="token operator">=</span> <span class="token keyword">new</span> point <span class="token number">0.0</span> <span class="token number">0.0</span><br><span class="token keyword">end</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token comment">(* Use the new keyword to create an instance of the class. *)</span><br>  <span class="token comment">(* let p = new point 0.0 0.0 in *)</span><br>  <span class="token comment">(* This uses a named constructor function instead. *)</span><br>  <span class="token keyword">let</span> p <span class="token operator">=</span> Geometry<span class="token punctuation">.</span>origin <span class="token keyword">in</span><br><br>  <span class="token comment">(* Methods are called with # instead of dot. *)</span><br>  p<span class="token punctuation">#</span>set_x <span class="token number">1.0</span><span class="token punctuation">;</span><br>  p<span class="token punctuation">#</span>set_y <span class="token number">2.0</span><span class="token punctuation">;</span><br>  p<span class="token punctuation">#</span>translate <span class="token number">3.0</span> <span class="token number">4.0</span><span class="token punctuation">;</span><br><br>  <span class="token comment">(* There is no need to pass the unit value `()`<br>     to call methods that have no parameters. *)</span><br>  printf <span class="token string">"(%f, %f)\n"</span> p<span class="token punctuation">#</span>get_x p<span class="token punctuation">#</span>get_y<span class="token punctuation">;</span><br>  p<span class="token punctuation">#</span>print<span class="token punctuation">;</span><br><br>  <span class="token comment">(* The Oo.copy function makes a shallow copy of an object. *)</span><br>  <span class="token keyword">let</span> p2 <span class="token operator">=</span> Oo<span class="token punctuation">.</span>copy p <span class="token keyword">in</span><br>  p2<span class="token punctuation">#</span>set_x <span class="token number">5.0</span><span class="token punctuation">;</span><br>  p2<span class="token punctuation">#</span>print<span class="token punctuation">;</span><br><br>  <span class="token comment">(* Each object is assigned a unique id<br>     that can be accessed with Oo.id function. *)</span><br>  printf <span class="token string">"p id = %d\n"</span> <span class="token punctuation">(</span>Oo<span class="token punctuation">.</span>id p<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  printf <span class="token string">"p2 id = %d\n"</span> <span class="token punctuation">(</span>Oo<span class="token punctuation">.</span>id p2<span class="token punctuation">)</span></code></pre><p>Abstract classes are defined with &quot;class virtual&quot;. Methods can be defined with &quot;method virtual&quot; to require subclasses to implement them.</p><p>To inherit from another class, add &quot;inherit {class_name} {args}&quot; inside &quot;object (self)&quot; to call its constructor.</p><p>To enable calling superclass methods, add &quot;inherit {class_name} {args} as super&quot; and then use &quot;super#{method_name}&quot; to call them.</p><p>To coerce a subclass value to a superclass type, use <code>obj :&gt; {superclass}</code>.</p><p>The following code demonstrates defining an abstract class (<code>shape</code>) and classes that inherit from it (<code>circle</code> and <code>rectangle</code>). It also uses the <code>point</code> class defined above.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">module</span> Geometry <span class="token operator">=</span> <span class="token keyword">struct</span><br>  <span class="token keyword">class</span> point <span class="token punctuation">(</span>x_init <span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token punctuation">(</span>y_init <span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token operator">=</span><br>    <span class="token keyword">object</span> <span class="token punctuation">(</span>self<span class="token punctuation">)</span><br>      <span class="token keyword">val</span> <span class="token keyword">mutable</span> x <span class="token operator">=</span> x_init<br>      <span class="token keyword">val</span> <span class="token keyword">mutable</span> y <span class="token operator">=</span> y_init<br>      <span class="token keyword">method</span> get_x <span class="token operator">=</span> x<br>      <span class="token keyword">method</span> get_y <span class="token operator">=</span> y<br>      <span class="token keyword">method</span> set_x new_x <span class="token operator">=</span> x <span class="token operator">&lt;-</span> new_x<br>      <span class="token keyword">method</span> set_y new_y <span class="token operator">=</span> y <span class="token operator">&lt;-</span> new_y<br>      <span class="token keyword">method</span> print <span class="token operator">=</span> printf <span class="token string">"(%f, %f)\n"</span> x y<br><br>      <span class="token keyword">method</span> translate dx dy <span class="token operator">=</span><br>        x <span class="token operator">&lt;-</span> x <span class="token operator">+.</span> dx<span class="token punctuation">;</span><br>        y <span class="token operator">&lt;-</span> y <span class="token operator">+.</span> dy<br>    <span class="token keyword">end</span><br><br>  <span class="token keyword">let</span> origin <span class="token operator">=</span> <span class="token keyword">new</span> point <span class="token number">0.0</span> <span class="token number">0.0</span><br><br>  <span class="token keyword">class</span> <span class="token keyword">virtual</span> shape <span class="token punctuation">(</span>name_init <span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token operator">=</span><br>    <span class="token keyword">object</span><br>      <span class="token keyword">val</span> name <span class="token operator">=</span> name_init<br>      <span class="token keyword">method</span> name <span class="token operator">=</span> name<br>      <span class="token keyword">method</span> <span class="token keyword">virtual</span> area <span class="token punctuation">:</span> float<br>    <span class="token keyword">end</span><br><br>  <span class="token keyword">class</span> circle <span class="token punctuation">(</span>center_init <span class="token punctuation">:</span> point<span class="token punctuation">)</span> <span class="token punctuation">(</span>radius_init <span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token operator">=</span><br>    <span class="token keyword">object</span><br>      <span class="token keyword">inherit</span> shape <span class="token string">"circle"</span><br>      <span class="token keyword">val</span> center <span class="token operator">=</span> center_init<br>      <span class="token keyword">val</span> radius <span class="token operator">=</span> radius_init<br>      <span class="token keyword">method</span> area <span class="token operator">=</span> <span class="token number">3.14159</span> <span class="token operator">*.</span> radius <span class="token operator">*.</span> radius<br>    <span class="token keyword">end</span><br><br>  <span class="token keyword">class</span> rectangle <span class="token punctuation">(</span>lower_left_init <span class="token punctuation">:</span> point<span class="token punctuation">)</span> <span class="token punctuation">(</span>width_init <span class="token punctuation">:</span> float<span class="token punctuation">)</span><br>    <span class="token punctuation">(</span>height_init <span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token operator">=</span><br>    <span class="token keyword">object</span><br>      <span class="token keyword">inherit</span> shape <span class="token string">"rectangle"</span><br>      <span class="token keyword">val</span> lower_left <span class="token operator">=</span> lower_left_init<br>      <span class="token keyword">val</span> width <span class="token operator">=</span> width_init<br>      <span class="token keyword">val</span> height <span class="token operator">=</span> height_init<br>      <span class="token keyword">method</span> area <span class="token operator">=</span> width <span class="token operator">*.</span> height<br>    <span class="token keyword">end</span><br><span class="token keyword">end</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> p <span class="token operator">=</span> Geometry<span class="token punctuation">.</span>origin <span class="token keyword">in</span><br>  <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> Geometry<span class="token punctuation">.</span>circle p <span class="token number">5.0</span> <span class="token keyword">in</span><br>  printf <span class="token string">"%s area = %f\n"</span> c<span class="token punctuation">#</span>name c<span class="token punctuation">#</span>area<span class="token punctuation">;</span><br>  <span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token keyword">new</span> Geometry<span class="token punctuation">.</span>rectangle p <span class="token number">10.0</span> <span class="token number">5.0</span> <span class="token keyword">in</span><br>  printf <span class="token string">"%s area = %f\n"</span> r<span class="token punctuation">#</span>name r<span class="token punctuation">#</span>area</code></pre><h2 id="dune" tabindex="-1">Dune</h2><p><a href="https://dune.build" target="_blank">Dune</a> is a popular OCaml and Reason build system. It is used create, build, test, and run OCaml projects. It can also compile to JavaScript.</p><p>To install the <code>dune</code> command, enter <code>opam install dune</code>.</p><p>For help, enter <code>dune --help</code>.</p><h3 id="creating" tabindex="-1">Creating</h3><p><strong>To create a project</strong> that uses <code>dune</code>, cd to where the project should be created and enter <code>dune init project {project_name}</code>. This generates many files including:</p><ul><li>dune configuration file <code>dune-project</code></li><li>opam configuration file <code>{project_name}.opam</code></li><li><code>_build</code>, <code>bin</code>, <code>lib</code>, and <code>test</code> directories</li><li>main source file <code>bin/main.ml</code></li><li>unit test file <code>test/test_{project_name}.ml</code>.</li></ul><p>The <code>bin</code> directory holds source files that will be compiled to executables. These often use modules defines in the <code>lib</code> directory. It's a bit odd that it hold source files rather than executables created by a build process.</p><p>It is common to have a file in the <code>bin</code> directory named <code>main.ml</code>, but that name is not required. It is also common to end files in the <code>bin</code> directory with an expression that begins with <code>let () =</code>. This is similar to the main function in other languages.</p><p>The <code>lib</code> directory is the preferred location for source files that define reusable functions. One reason is that Dune supports implementing unit tests for files in the <code>lib</code> directory, but not for files in the <code>bin</code> directory.</p><p>The <code>test</code> directory holds test files for tests that are not included inline with the functions they test. Inline tests are typically preferred.</p><p>When using git for version control, the <code>_build</code> directory should be added in the <code>.gitignore</code> file.</p><p>The <code>bin</code>, <code>lib</code>, and <code>test</code> directories all contain a <code>dune</code> file that holds configurations options for that directory. These files use Lisp-like syntax. Each option is specified in by a name and value inside parentheses that is referred to as a &quot;<a href="https://dune.readthedocs.io/en/stable/dune-files.html" target="_blank">stanza</a>&quot;.</p><p>The <code>lib</code> directory can have subdirectories that contain <code>.ml</code> files and those can define additional types, constants, and functions. To make those accessible, add the following at the bottom of the <code>lib/dune</code> file:</p><pre class="language-text"><code class="language-text">(include_subdirs qualified)</code></pre><p>For example, if the project name is &quot;demo&quot; and <code>lib/sub/mod.ml</code> defines the function <code>greet</code> then <code>bin/main.ml</code> can refer to it with <code>Demo.Sub.Mod.greet</code>.</p><p>An alternative to adding subdirectories in the <code>lib</code> directory is to create additional top-level directories that each define a different library.</p><p>For example:</p><ul><li>Create the top-level directory <code>lib2</code>.</li><li>Create the file <code>lib2/dune</code> containing <code>(library (name demo2))</code></li><li>Create the file <code>lib2/mod.ml</code> containing <code>let greet () = print_endline &quot;Hello from lib2!&quot;</code></li><li>Update the <code>libraries</code> stanza in the <code>bin/dune</code> file to <code>(libraries demo demo2)</code></li><li>Add the call <code>Demo2.Mod.greet ()</code> in <code>bin/main.ml</code></li></ul><h3 id="manually-creating" tabindex="-1">Manually Creating</h3><p>A Dune project can be created by manually creating a directory containing the three files <code>dune-project</code>, <code>dune</code>, and <code>{project-name}.ml</code>.</p><p>Suppose the project name is &quot;my_dune_project&quot;. Here is a minimal <code>dune-project</code> file. The first line specifies that Dune version 3.14 is being used.</p><pre class="language-text"><code class="language-text">(lang dune 3.14)<br>(package<br>  (name my_dune_project)<br>  (depends ocaml dune))</code></pre><p>Here is a minimal <code>dune</code> file.</p><pre class="language-text"><code class="language-text">(executable<br>  (public_name my_dune_project))</code></pre><p>Here is a minimal OCaml source file with the same name as the project, <code>my_dune_project.ml</code>.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> print_endline <span class="token string">"Hello, World!"</span></code></pre><p>To run this project, enter <code>dune exec my_dune_project</code> This may take 5 to 10 seconds the first time it is run. It will be much faster for subsequent runs.</p><p>If you prefer to name the main source file <code>main.ml</code>, add the <code>(name main)</code> stanza in the <code>dune</code> file.</p><h3 id="building" tabindex="-1">Building</h3><p><strong>To build the project</strong>, enter <code>dune build</code>. This creates <code>_build/default/bin/main.exe</code>. To automatically rebuild the project when code changes are detected, add the <code>--watch</code> flag.</p><h3 id="running" tabindex="-1">Running</h3><p><strong>To run the project</strong>, enter <code>dune exec {executable_name}</code>. The executable name is specified in the <code>public_name</code> stanza found in the <code>bin/dune</code> file and defaults to the project name.</p><h3 id="cleaning" tabindex="-1">Cleaning</h3><p><strong>To clean a project</strong>, enter <code>dune clean</code>. This deletes the <code>_build</code> directory that contains generated files.</p><h3 id="utop" tabindex="-1">utop</h3><p><strong>To run <code>utop</code> with project libraries automatically available</strong>, enter <code>dune utop</code>. For example, in a project with a library named &quot;demo&quot;, a module named &quot;math_lib&quot;, and a function in that module named &quot;add&quot;, the following works: <code>Demo.Math_lib.add 1 2</code>.</p><h3 id="example-project" tabindex="-1">Example Project</h3><p>Let's walk through creating a small OCaml project with Dune.</p><ol><li><p><code>cd</code> to the directory where the project should be created.</p></li><li><p>Enter <code>dune init project demo</code></p></li><li><p><code>cd demo</code></p></li><li><p>Enter <code>dune exec demo</code>.</p></li><li><p>Verify that the output is &quot;Hello, World!&quot;.</p></li><li><p>Create the file <code>lib/math.ml</code> containing the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> pi <span class="token operator">=</span> Float<span class="token punctuation">.</span>pi<br><br><span class="token keyword">let</span> add a b <span class="token operator">=</span> a <span class="token operator">+.</span> b<br><br><span class="token keyword">let</span> average numbers <span class="token operator">=</span><br>  <span class="token keyword">let</span> sum <span class="token operator">=</span> List<span class="token punctuation">.</span>fold_left <span class="token punctuation">(</span><span class="token operator">+.</span><span class="token punctuation">)</span> <span class="token number">0.0</span> numbers <span class="token keyword">in</span><br>  <span class="token keyword">let</span> length <span class="token operator">=</span> List<span class="token punctuation">.</span>length numbers <span class="token keyword">in</span><br>  sum <span class="token operator">/.</span> float_of_int length</code></pre></li><li><p>Create the file <code>lib/points.ml</code> containing the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> point2d <span class="token operator">=</span> float <span class="token operator">*</span> float<br><br><span class="token comment">(* This demonstrates adding types to parameters and<br>   specifying the return type, all of which can be inferred. *)</span><br><span class="token keyword">let</span> distance <span class="token punctuation">(</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span> <span class="token punctuation">:</span> point2d<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token punctuation">:</span> point2d<span class="token punctuation">)</span> <span class="token punctuation">:</span> float <span class="token operator">=</span><br>  <span class="token keyword">let</span> dx <span class="token operator">=</span> x2 <span class="token operator">-.</span> x1 <span class="token keyword">in</span><br>  <span class="token keyword">let</span> dy <span class="token operator">=</span> y2 <span class="token operator">-.</span> y1 <span class="token keyword">in</span><br>  sqrt <span class="token punctuation">(</span><span class="token punctuation">(</span>dx <span class="token operator">*.</span> dx<span class="token punctuation">)</span> <span class="token operator">+.</span> <span class="token punctuation">(</span>dy <span class="token operator">*.</span> dy<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token keyword">let</span><span class="token operator">%</span>test <span class="token punctuation">_</span> <span class="token operator">=</span> distance <span class="token punctuation">(</span><span class="token number">1.</span><span class="token punctuation">,</span> <span class="token number">1.</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">4.</span><span class="token punctuation">,</span> <span class="token number">5.</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5.0</span></code></pre></li><li><p>Modify the file <code>bin/main.ml</code> to contain the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Note how open requires the library name AND the module name. *)</span><br><span class="token keyword">open</span> Demo<span class="token punctuation">.</span>Math<br><span class="token keyword">open</span> Demo<span class="token punctuation">.</span>Points<br><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> my_constant <span class="token operator">=</span> <span class="token number">7</span><br><br><span class="token keyword">let</span> square x <span class="token operator">=</span> x <span class="token operator">*</span> x <span class="token comment">(* a function *)</span><br><br><span class="token comment">(* Note the use of semicolons to separate the<br>   statements and expressions. *)</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token comment">(* This is a verbose way to print a value. *)</span><br>  print_string <span class="token string">"my_constant = "</span><span class="token punctuation">;</span><br>  print_int my_constant<span class="token punctuation">;</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">(* This is a more concise way to print a value. *)</span><br>  printf <span class="token string">"pi = %f\n"</span> pi<span class="token punctuation">;</span> <span class="token comment">(* defined in math.ml *)</span><br><br>  <span class="token comment">(* This calls a function defined in this file. *)</span><br>  printf <span class="token string">"square of %d = %d\n"</span> my_constant <span class="token punctuation">(</span>square my_constant<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">(* The remaining examples call functions defined in math.ml. *)</span><br>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2.0</span> <span class="token operator">and</span> b <span class="token operator">=</span> <span class="token number">3.0</span> <span class="token operator">and</span> c <span class="token operator">=</span> <span class="token number">2.5</span> <span class="token keyword">in</span><br>  printf <span class="token string">"sum of a and b = %f\n"</span> <span class="token punctuation">(</span>add a b<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">;</span> b<span class="token punctuation">;</span> c<span class="token punctuation">]</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> avg <span class="token operator">=</span> average numbers <span class="token keyword">in</span><br>  printf <span class="token string">"average of a, b, and c = %f\n"</span> avg<span class="token punctuation">;</span><br><br>  <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token operator">and</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> d <span class="token operator">=</span> distance p1 p2 <span class="token keyword">in</span> print_float d</code></pre><p>The <code>let () =</code> is required because at the module level, everthing needs to be in a binding. You could use <code>let _ =</code> instead which allows the expression to have any kind of value. But using <code>let () =</code> is preferred because it states that the expression does not return a value.</p></li><li><p>Enter <code>dune exec demo</code>.</p></li><li><p>Verify that the output is</p><pre class="language-text"><code class="language-text">my_constant = 7<br>pi = 3.141593<br>square of 7 = 49<br>sum of a and b = 5.000000<br>average of a, b, and c = 2.500000<br>1.41421356237</code></pre></li></ol><p>Signatures can be used to make some definitions in a module &quot;private&quot;. For example:</p><ol><li><p>Create the file <code>lib/geometry.ml</code> to define the implementation of the <code>Geometry</code> module.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> point <span class="token operator">=</span> float <span class="token operator">*</span> float<br><br><span class="token keyword">module</span> <span class="token keyword">type</span> Signatures <span class="token operator">=</span> <span class="token keyword">sig</span><br>  <span class="token keyword">val</span> distance <span class="token punctuation">:</span> point <span class="token operator">-></span> point <span class="token operator">-></span> float<br><span class="token keyword">end</span><br><br><span class="token keyword">module</span> Mod <span class="token punctuation">:</span> Signatures <span class="token operator">=</span> <span class="token keyword">struct</span><br>  <span class="token keyword">let</span> square x <span class="token operator">=</span> x <span class="token operator">*.</span> x<br>  <span class="token keyword">let</span> distance <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span> <span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token operator">=</span> sqrt <span class="token punctuation">(</span>square <span class="token punctuation">(</span>x1 <span class="token operator">-.</span> x2<span class="token punctuation">)</span> <span class="token operator">+.</span> square <span class="token punctuation">(</span>y1 <span class="token operator">-.</span> y2<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token keyword">end</span></code></pre></li><li><p>Create the file <code>lib/geometry.mli</code> to define the public interface of the <code>Geometry</code> module.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> point <span class="token operator">=</span> float <span class="token operator">*</span> float<br><span class="token keyword">val</span> distance <span class="token punctuation">:</span> point <span class="token operator">-></span> point <span class="token operator">-></span> float</code></pre><p>This does not expose the <code>square</code> function.</p></li><li><p>Call the distance function in <code>bin/main.ml</code>.</p><pre class="language-ocaml"><code class="language-ocaml">printf <span class="token string">"distance = %f\n"</span> <span class="token punctuation">(</span>Demo<span class="token punctuation">.</span>Geometry<span class="token punctuation">.</span>distance <span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This assumes the <code>public_name</code> of the executable is &quot;demo&quot;,</p></li></ol><h3 id="unit-tests" tabindex="-1">Unit Tests</h3><p>Dune supports several kinds of tests, including inline, expectation, and &quot;cram&quot; tests. Expection tests are similar to Jest snapshot tests. Cram tests describe the output of a shell session. Jest is a JavaScript test framework.</p><p>The following steps add tests to the <code>demo</code> project above and run them. It seems that tests can only be used in libraries defined in the <code>lib</code> directory, not in the <code>bin</code> directory.</p><ol><li><p>Enter <code>opam install ppx_inline_test</code> to enable only inline tests or enter <code>opam install ppx_expect</code> to enable both inline and expectation tests.</p><p>PPX is short for &quot;PreProcessor eXtension&quot;.</p></li><li><p>Change <code>lib/dune</code> to the following:</p><pre class="language-text"><code class="language-text">(library<br>  (name demo)<br>  (inline_tests)<br>  ; This only enables inline tests, not expectation tests.<br>  ; (preprocess (pps ppx_inline_test)))<br>  ; This enables both inline tests and expectation tests.<br>  (preprocess (pps ppx_expect)))</code></pre><p>Single line comments in <code>dune</code> files begin with <code>;</code>.</p></li><li><p>Add the following lines in <code>lib/math.ml</code>:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* This is an inline test for the add function. *)</span><br><span class="token keyword">let</span><span class="token operator">%</span>test <span class="token punctuation">_</span> <span class="token operator">=</span> add <span class="token number">1.2</span> <span class="token number">2.3</span> <span class="token operator">=</span> <span class="token number">3.5</span><br><br><span class="token comment">(* This is an expectation test for the average function. *)</span><br><span class="token keyword">let</span><span class="token operator">%</span>expect_test <span class="token punctuation">_</span> <span class="token operator">=</span><br>  print_float <span class="token punctuation">(</span>average <span class="token punctuation">[</span><span class="token number">2.0</span><span class="token punctuation">;</span> <span class="token number">3.0</span><span class="token punctuation">;</span> <span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span><span class="token operator">%</span>expect <span class="token string">"2.5"</span><span class="token punctuation">]</span></code></pre></li><li><p>Add the following lines in <code>lib/points.ml</code>:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span><span class="token operator">%</span>test <span class="token punctuation">_</span> <span class="token operator">=</span> distance <span class="token punctuation">(</span><span class="token number">1.</span><span class="token punctuation">,</span> <span class="token number">1.</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">4.</span><span class="token punctuation">,</span> <span class="token number">5.</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5.0</span></code></pre></li><li><p>Enter <code>dune test</code> or <code>dune test -w</code> to run in watch mode.</p><p>You'll see <code>dune runtest</code> in documentation, but <code>dune test</code> is shorter and is an alias.</p></li><li><p>Verify that there are no failed tests.</p><p>When all the tests pass, there is no output. If any expecation tests fail, but the actual values are correct, enter <code>dune promote</code> to update all the expected values.</p></li></ol><p>Tests can also be placed in the <code>test</code> directory. The following steps implement the same tests above in this way.</p><ol><li><p>Replace the contents of the <code>test/dune</code> file with the following:</p><pre class="language-text"><code class="language-text">(tests<br>  (libraries demo)<br>  (names add average)<br>)</code></pre><p>If there is only one test, <code>(tests</code> can be changed to <code>(test</code> and <code>(names</code> can be changed to <code>(name</code>.</p></li><li><p>Create the file <code>test/add.ml</code> containing the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Demo<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">assert</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>add <span class="token number">1.2</span> <span class="token number">2.3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3.5</span><span class="token punctuation">)</span></code></pre></li><li><p>Create the file <code>test/average.ml</code> containing the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Demo<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> print_float <span class="token punctuation">(</span>Math<span class="token punctuation">.</span>average <span class="token punctuation">[</span><span class="token number">2.0</span><span class="token punctuation">;</span> <span class="token number">3.0</span><span class="token punctuation">;</span> <span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 2.5 *)</span></code></pre></li><li><p>Create the file <code>test/average.expected</code> containing <code>2.5</code>.</p></li><li><p>Enter <code>dune test</code> and verify that all the tests pass.</p></li></ol><h3 id="multiple-executables" tabindex="-1">Multiple Executables</h3><p>A Dune project can host the code for multiple executables. This is ideal for a collection of sample programs that demonstrate various features of OCaml.</p><p>To create a project like this:</p><ol><li><p><code>cd</code> to the directory where the project will be created.</p></li><li><p>Enter <code>dune init project samples</code> where &quot;samples&quot; is the project name.</p></li><li><p><code>cd samples</code></p></li><li><p>Delete all the directories and files that will not be needed. These includes the directories <code>bin</code>, <code>lib</code>, and <code>test</code> and the file <code>samples.opam</code>.</p></li><li><p>Edit the <code>dune-project</code> file to only contain the following:</p><pre class="language-text"><code class="language-text">(lang dune 3.14)<br>(package<br>  (name samples)<br>  (depends ocaml dune))</code></pre></li><li><p>Create the file <code>dune</code> in the root directory of the project containing the following:</p><pre class="language-text"><code class="language-text">(executables<br>  (names program1 program2)<br>  (libraries lib1 lib2))</code></pre><p>Replace <code>program1</code> and <code>program2</code> with the names of your sample <code>.ml</code> files. Replace <code>lib1</code> and <code>lib2</code> with the names of any libraries you install using <code>opam</code> that are used by your sample programs.</p></li><li><p>To run one of your sample programs such as <code>foo.ml</code>, enter <code>dune exec ./foo.exe</code></p></li></ol><h2 id="opam-libraries" tabindex="-1">opam Libraries</h2><p><a href="https://opam.ocaml.org" target="_blank">opam</a> is a package manager for OCaml, similar to npm for JavaScript.</p><ol><li><p><code>dune init project date_formatting</code></p></li><li><p><code>cd date_formatting</code></p></li><li><p><code>opam install odate</code></p></li><li><p>Edit <code>bin/dune</code> and change the <code>libraries</code> stanza to <code>(libraries date_formatting odate)</code>.</p></li><li><p>Edit <code>bin/main.ml</code> and replace its contents with the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">module</span> Date <span class="token operator">=</span> ODate<span class="token punctuation">.</span>Unix<br><br><span class="token comment">(* For documentation for date/time format strings, see<br>   https://github.com/MLstate/opalang/blob/master/lib/stdlib/core/date/duration.opa#L472<br>   A is day of week, B is month, d is day of month, Y is year.<br>   a and b give abbreviations.<br>*)</span><br><span class="token keyword">let</span> date_format <span class="token operator">=</span> <span class="token string">"%A, %B %d %Y"</span><br><br><span class="token keyword">let</span> date_printer <span class="token operator">=</span><br>  <span class="token keyword">match</span> Date<span class="token punctuation">.</span>To<span class="token punctuation">.</span>generate_printer date_format <span class="token keyword">with</span><br>  <span class="token operator">|</span> Some p <span class="token operator">-></span> p<br>  <span class="token operator">|</span> None <span class="token operator">-></span> failwith <span class="token string">"could not generate printer"</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>  <span class="token keyword">let</span> s <span class="token operator">=</span> Date<span class="token punctuation">.</span>To<span class="token punctuation">.</span>string date_printer now <span class="token keyword">in</span><br>  print_endline s</code></pre></li><li><p><code>dune exec date_formatting</code></p></li></ol><h3 id="switches" tabindex="-1">Switches</h3><p>To use specific versions of packages in projects, create and activate switches. A switch is a collection of packages that are tied to an OCaml version and can specify versions of packages.</p><p>There are two kinds of switches, global switches that can be used by multiple projects and local switches that are tied to a specific project directory.</p><p>To create a global switch, enter <code>opam switch create {switch-name} {ocaml-version}</code>. For example, <code>opam switch my_project 5.1.1</code> The OCaml version cannot be omitted. Creating a new switch takes around four minutes to complete.</p><p>To change the current global switch, enter <code>opam switch {switch-name}</code> and <code>eval $(opam env)</code> to activate it.</p><p>To see the name of the currently activated global switch, enter <code>opam switch</code>.</p><p>To install packages in the currently activated global switch, enter <code>opam install {package-name}.{version}</code></p><p>To return to the default global switch, use the same commands to change to any switch, but specify the name &quot;default&quot;.</p><p>To list all the currently defined global switches, enter <code>opam switch list</code></p><p>To delete a global switch, enter <code>opam switch remove {switch-name}</code></p><p>Local switches are automatically selected and activated when you <code>cd</code> to a project directory that has one. To create one, cd to a project directory and enter <code>opm switch create .</code> Switches consume a lot of disk space, so creating a local switch for each project is not recommended.</p><p>An alternative to a local switch is to link a global switch to a project directory. To do this, <code>cd</code> to the project directory and enter <code>opam switch link {switch-name}</code></p><h2 id="pretty-printing" tabindex="-1">Pretty Printing</h2><p>See the library <a href="https://github.com/ocaml-ppx/ppx_deriving" target="_blank">ppx_deriving</a>. This supports a number plugins for deriving functions from types, including <code>enum</code>, <code>eq</code>, <code>fold</code>, <code>iter</code>, <code>make</code>, <code>map</code>, <code>ord</code>, <code>protobuf</code> <code>show</code>, and <code>yojson</code>.</p><p>PPX is short for &quot;PreProcessor eXtension&quot;. These can add support for new syntax and generate/transform code.</p><p>To use this in a Dune project:</p><ol><li><p>Install it by entering <code>opam install ppx_deriving</code>.</p></li><li><p>If using the <code>yojson</code> plugin, also enter <code>opam install ppx_deriving_yojson</code>.</p></li><li><p>Add the following stanza to the project <code>dune</code> file. Here we only use the <code>show</code> plugin which generates functions whose names begin with <code>show_</code> that return pretty-printed strings.</p><pre class="language-text"><code class="language-text">(preprocess (pps ppx_deriving.show ppx_deriving.yojson))</code></pre></li><li><p>Annotate types to be pretty-printed. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">type</span> int_list <span class="token operator">=</span> int list<br><span class="token punctuation">[</span><span class="token operator">@@</span>deriving show<span class="token punctuation">]</span></code></pre></li><li><p>Print instances of that type with the following:</p><pre class="language-ocaml"><code class="language-ocaml">print_endline <span class="token punctuation">(</span>show_int_list numbers<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h2 id="generating-documentation" tabindex="-1">Generating Documentation</h2><p>The odoc tool generates HTML-based documentation from <code>(** ... *)</code> commands in <code>.ml</code> source files. Those commands can contain directives like <code>@param</code> and <code>@result</code>.</p><p>This must be installed by entering <code>opam install odoc</code>.</p><p>Dune only generates documentation for public packages.</p><p>For example:</p><pre class="language-ocaml"><code class="language-ocaml">dune build <span class="token operator">@</span>doc</code></pre><p>TODO: Test this!</p><h2 id="http-servers" tabindex="-1">HTTP Servers</h2><p>There are several OCaml libraries for implementing HTTP servers that provide API endpoints. Popular options include:</p><ul><li><a href="https://aantron.github.io/dream/" target="_blank">Dream</a> - 1.5K GitHub stars</li><li>Opium - 747 GitHub stars</li><li>CoHTTP - 676 GitHub stars</li><li>Ocsigen - not in GitHub</li></ul><h3 id="dream" tabindex="-1">Dream</h3><p>The steps to use the <a href="https://aantron.github.io/dream/" target="_blank">Dream</a> web framework are:</p><ul><li><p>Install Dream by entering <code>opam install dream</code></p></li><li><p>cd to the directory where a new Dune project will be created.</p></li><li><p>Enter <code>dune init project dream_demo</code></p></li><li><p><code>cd dream_demo</code></p></li><li><p>Edit <code>bin/dune</code> and modify the <code>libraries</code> stanza to include <code>dream</code>.</p></li><li><p>Edit <code>bin/dune</code> and add the following at the end to enable use of HTML templates:</p><pre class="language-text"><code class="language-text">(rule<br>  (targets main.ml)<br>  (deps main.eml.ml)<br>  (action (run dream_eml %{deps} --workspace %{workspace_root})))</code></pre></li><li><p>Delete <code>bin/main.ml</code>.</p></li><li><p>Create <code>bin/main.eml.ml</code> with the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> hello who <span class="token operator">=</span><br>  <span class="token operator">&lt;</span>html<span class="token operator">></span><br>    <span class="token operator">&lt;</span>body<span class="token operator">></span><br>      <span class="token operator">&lt;</span>h1<span class="token operator">></span>Hello<span class="token punctuation">,</span> <span class="token operator">&lt;%</span>s who <span class="token operator">%>!&lt;/</span>h1<span class="token operator">></span><br>    <span class="token operator">&lt;/</span>body<span class="token operator">></span><br>  <span class="token operator">&lt;/</span>html<span class="token operator">></span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  Dream<span class="token punctuation">.</span>run<br>  <span class="token operator">@@</span> Dream<span class="token punctuation">.</span>logger<br>  <span class="token operator">@@</span> Dream<span class="token punctuation">.</span>router <span class="token punctuation">[</span><br>    Dream<span class="token punctuation">.</span>get <span class="token string">"/"</span> <span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">_</span> <span class="token operator">-></span> Dream<span class="token punctuation">.</span>html <span class="token punctuation">(</span>hello <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">]</span></code></pre></li><li><p>Enter <code>dune exec dream_demo --watch</code></p></li><li><p>Browse localhost:8080</p></li></ul><p>For a more advanced Dream app that places the HTML templates in separate source files, see <a href="https://github.com/mvolkmann/ocaml-examples/tree/main/dream_demo" target="_blank">dream_demo</a>.</p><p>Dream Templates are not well-supported in editors like VS Code. Many errors flagged in them are not real errors. If the templates are moved to separate files with the <code>.eml.html</code> file extension as recommended, hovering over OCaml values will not display their types.</p><p><img alt="OCaml Dream info" style="border: 0" src="/blog/assets/ocaml-dune-dream-dialect.png?v=1.1.1"></p><p>For an alternative to Dream templates which doesn't having tooling support issues, see <a href="https://github.com/yawaramin/dream-html" target="_blank">dream-html</a>.</p><h2 id="jane-street-modules" tabindex="-1">Jane Street Modules</h2><p>Jane Street created the modules <code>Base</code>, <code>Core_kernel</code>, and <code>Core</code>. The <code>Base</code> module is a minimal replacement for the OCaml standard library. The <code>Core_kernal</code> module extends <code>Base</code> and adds features. The <code>Core</code> module extends <code>Core_kernel</code> and adds UNIX APIs.</p><p>To use the <code>Base</code> module, install it with <code>opam install base</code>. In source files that use it, add <code>open Base</code>. This causes all values from the standard library to be marked as deprecated.</p><h2 id="converting-ocaml-to-javascript" tabindex="-1">Converting OCaml to JavaScript</h2><p>Here are the steps to compile an OCaml program to JavaScript using Dune.</p><ol><li><p>Install the &quot;js_of_ocaml&quot; compiler.</p><p>Enter <code>opam install js_of_ocaml-compiler</code>.</p></li><li><p>Modify the <code>dune</code> file.</p><p>It should contain the following where the main OCaml source file is <code>hello.ml</code>:</p><pre class="language-text"><code class="language-text">(executables<br>  (names hello)<br>  (modes js))</code></pre></li><li><p>Compile to JavaScript.</p><p>Enter <code>dune build ./hello.bc.js</code></p><p>This generates a ridiculous amount of JavaScript code ... over 9000 lines for a Hello World program. So this is not a serious option!</p></li><li><p>Run the code.</p><p>Enter <code>node _build/default/hello.bc.js</code></p></li></ol><h2 id="preprocessors" tabindex="-1">Preprocessors</h2><p>Preprocessors are programs that are called at compile time to alter or add source code.</p><p>For example, the syntax <code>[%get_env &quot;USER&quot;]</code> can be replaces by the value of the <code>USER</code> environment variable.</p><p>See <a href="https://ocaml.org/docs/metaprogramming" target="_blank">Preprocessors and PPXs</a></p><h2 id="suppressing-errors" tabindex="-1">Suppressing Errors</h2><p>Sometimes it is desirable to suppress certain errors. For example, you have have a record type that contains a field that is not yet being used, but will be used in the future.</p><p>There are a couple of ways to do this. One way is to add <code>[@warning &quot;-unused-field&quot;]</code> immediately after the <code>type</code> keyword that defines the record type. Another way when using Dune is to add the stanza <code>(flags (:standard -w -69))</code> to the <code>dune</code> file where 69 is the code for &quot;unused-field&quot; errors.</p><p>To see all the supported error codes, enter <code>ocaml -warn-help</code>.</p><h2 id="concurrency" tabindex="-1">Concurrency</h2><p>There are multiple OCaml libraries that support concurrency. The one that seems most popular is <a href="https://github.com/ocaml-multicore/eio" target="_blank">eio</a>.</p><p>To install eio, enter <code>opam install eio_main</code>.</p></article>