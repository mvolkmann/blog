<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>OCaml</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#installing">Installing</a></li><li><a href="#vs-code">VS Code</a></li><li><a href="#repl">REPL</a></li><li><a href="#comments">Comments</a></li><li><a href="#primitive-types">Primitive Types</a></li><li><a href="#type-conversions">Type Conversions</a></li><li><a href="#keywords">Keywords</a></li><li><a href="#operators">Operators</a></li><li><a href="#variables">Variables</a></li><li><a href="#references">References</a></li><li><a href="#functions">Functions</a></li><li><a href="#input%2Foutput">Input/Output</a></li><li><a href="#converting-ocaml-to-javascript">Converting OCaml to JavaScript</a></li><li><a href="#unorganized-content">Unorganized Content</a></li></ol></nav></aside><article><figure style="width: 30%"><img alt="OCaml logo" style="border: 0" src="/blog/assets/ocaml-logo.png?v=1.1.1"></figure><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://ocaml.org?v=1.1.1" rel="noopener" target="_blank">OCaml</a> is &quot;an industrial-strength functional programming language with an emphasis on expressiveness and safety.&quot;</p><p>The Caml programming language is the predecessor of OCaml. The name is short for &quot;Categorical Abstract Machine Language&quot;. OCaml is short for &quot;Objective Caml&quot;.</p><p>OCaml is a member of the ML family of programming languages.</p><p>Supposedly the OCaml compiler is much faster than the Haskell compiler. TODO: Verify this.</p><p>OCaml source files have the extension <code>.ml</code> which stands for &quot;meta language&quot;.</p><h2 id="installing" tabindex="-1">Installing</h2><p>To install the OCaml package manager &quot;opam&quot; for Linux and macOS, enter the following shell command which completes in a few seconds:</p><pre class="language-bash"><code class="language-bash"><span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">"sh &lt;(curl -fsSL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)"</span></code></pre><p>To install for windows, see <a href="https://ocaml.org/install" target="_blank">Install OCaml on Windows</a>.</p><p>After installing <code>opam</code>, enter <code>opam init</code> which takes over five minutes to complete.</p><p>To install tools for development, enter the following shell command which takes about four minutes to complete:</p><pre class="language-bash"><code class="language-bash">opam <span class="token function">install</span> ocaml-lsp-server odoc ocamlformat utop</code></pre><h2 id="vs-code" tabindex="-1">VS Code</h2><p>Install the &quot;OCaml Platform&quot; extension from OCaml Labs.</p><p>Create the file <code>.ocamlformat</code> in each project root directory containing at least the following in order for VS Code to format OCaml code on save.</p><pre class="language-text"><code class="language-text">profile = default<br>version = 0.26.1</code></pre><h2 id="repl" tabindex="-1">REPL</h2><p>OCaml has two REPLs. A basic one can be started by entering <code>ocaml</code>. A better one is <code>utop</code> which is short for &quot;Universal Toplevel&quot;. The <code>utop</code> command provides a more interactive, user-friendly interface that includes line editing, syntax highlighting, command history, and tab completion. In either REPL the expressions you enter are only evaluated when they are terminated by a double semicolon (<code>;;</code>). This allows expressions to span multiple lines.</p><p>Use the left and right arrow keys to move the cursor within the expression and make edits.</p><p>Use the up and down arrow keys to recall previously entered expressions. They can be edited and executed again.</p><p>To exit the REPL, press ctrl-d or enter #quit.</p><p>There is also an iOS app called &quot;OCaml&quot; for evaluating OCaml expressions.</p><h2 id="comments" tabindex="-1">Comments</h2><p>Comments in OCaml code begin with <code>(*</code> and end with <code>*)</code>. They can span any number of lines.</p><p>Comments can be nested.</p><p>Doc comments provided documentation that can be extracted from source files. They begin with <code>(**</code> and end with <code>*)</code>. Their content is similar to JSDoc comments, including the use of <code>@param</code> and <code>@return</code> annotations. There are three variations of doc comments, floating, item, and label.</p><h2 id="primitive-types" tabindex="-1">Primitive Types</h2><p>OCaml supports the following primitive types. Their sizes depend on the CPU.</p><ul><li><code>bool</code> - 1 byte with the literal values <code>true</code> and <code>false</code></li><li><code>int</code> - 8 or 4 bytes</li><li><code>float</code> - 8 bytes</li><li><code>string</code> - sequence of bytes, not Unicode characters</li></ul><p>Literal strings are delimited by double quotes. The <code>^</code> operator is used to concatenate strings.</p><p>For Unicode support, see the libraries <code>Uutf</code>, <code>Uutf_string</code>, and <code>ocaml-unicode</code>.</p><p>Primitive values are expressions that do not require additional evaluation.</p><h2 id="type-conversions" tabindex="-1">Type Conversions</h2><p>The OCaml standard library provides many functions for converting a value from one type to another. Examples include:</p><ul><li><code>float_of_int</code></li><li><code>int_of_float</code> - <code>truncate</code> is an alias</li><li><code>int_of_char</code></li><li><code>char_of_int</code></li><li><code>string_of_bool</code></li><li><code>bool_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>bool_of_string_opt</code> - returns <code>None</code> if conversion fails</li><li><code>string_of_int</code></li><li><code>int_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>int_of_string_opt</code> - returns <code>None</code> if conversion fails</li><li><code>string_of_float</code></li><li><code>float_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>float_of_string_opt</code> - returns <code>None</code> if conversion fails</li></ul><h2 id="keywords" tabindex="-1">Keywords</h2><p>OCaml reserves the use of the following identifiers: <code>and</code>, <code>as</code>, <code>assert</code>, <code>asr</code>, <code>begin</code>, <code>class</code>, <code>constraint</code>, <code>do</code>, <code>done</code>, <code>downto</code>, <code>else</code>, <code>end</code>, <code>exception</code>, <code>external</code>, <code>false</code>, <code>for</code>, <code>fun</code>, <code>function</code>, <code>functor</code>, <code>if</code>, <code>in</code>, <code>include</code>, <code>inherit</code>, <code>initializer</code>, <code>land</code>, <code>lazy</code>, <code>let</code>, <code>lor</code>, <code>lsl</code>, <code>lsr</code>, <code>lxor</code>, <code>match</code>, <code>method</code>, <code>mod</code>, <code>module</code>, <code>mutable</code>, <code>new</code>, <code>nonrec</code>, <code>object</code>, <code>of</code>, <code>open</code>, <code>or</code>, <code>private</code>, <code>rec</code>, <code>sig</code>, <code>struct</code>, <code>then</code>, <code>to</code>, <code>true</code>, <code>try</code>, <code>type</code>, <code>val</code>, <code>virtual</code>, <code>when</code>, <code>while</code>, and <code>with</code>.</p><h2 id="operators" tabindex="-1">Operators</h2><p>OCaml operators only operate on specific types. This enables type inference of function return types. Operators for <code>float</code> values are the same as those for <code>int</code> values, but with a <code>.</code> added to the end.</p><p>The arithmetic operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>~-</code></td><td>int negation</td></tr><tr><td><code>+</code></td><td>int addition</td></tr><tr><td><code>-</code></td><td>int subtraction</td></tr><tr><td><code>*</code></td><td>int multiplication</td></tr><tr><td><code>/</code></td><td>int division</td></tr><tr><td><code>~-.</code></td><td>float negation</td></tr><tr><td><code>+.</code></td><td>float addition</td></tr><tr><td><code>-.</code></td><td>float subtraction</td></tr><tr><td><code>*.</code></td><td>float multiplication</td></tr><tr><td><code>/.</code></td><td>float division</td></tr><tr><td><code>**</code></td><td>float exponentiation</td></tr></tbody></table><p>The string operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>^</code></td><td>string concatenation</td></tr><tr><td><code>^^</code></td><td>format string concatenation</td></tr></tbody></table><p>The logical operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>==</code></td><td>same object</td></tr><tr><td><code>!=</code></td><td>not same object</td></tr><tr><td><code>=</code></td><td>structural equality</td></tr><tr><td><code>&lt;&gt;</code></td><td>structural inequality</td></tr><tr><td><code>&lt;</code></td><td>less than</td></tr><tr><td><code>&gt;</code></td><td>greater than</td></tr><tr><td><code>&lt;=</code></td><td>less than or equal</td></tr><tr><td><code>&gt;=</code></td><td>greater than equal</td></tr><tr><td><code>&amp;&amp;</code></td><td>boolean and</td></tr><tr><td><code>||</code></td><td>boolean or</td></tr></tbody></table><p>The remaining operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>!</code></td><td>gets ref value</td></tr><tr><td><code>:=</code></td><td>sets ref value</td></tr><tr><td><code>@</code></td><td>list concatenation</td></tr><tr><td><code>|&gt;</code></td><td>reverse function application</td></tr></tbody></table><p>Most OCaml operators are implemented as binary functions. To use them as functions, wrap them in parentheses. For example, <code>a + b</code> is the same as <code>(+) a b</code>. Adding spaces inside the parentheses is optional, but is required for the <code>*</code> operator because <code>(*</code> is interpreted as the beginning of a comment. Operator functions can be passed to functions like <code>List.filter</code>.</p><p>Custom binary operators can be defined using an allowed set of characters.</p><h2 id="variables" tabindex="-1">Variables</h2><p>Variables are immutable, but they can refer to a &quot;ref&quot; which is mutable. (An exception is that variables in a REPL can be reassigned.)</p><p>Identifier names must start with a lowercase letter unless they refer to a module, constructor, or &quot;polymorphic variant tag&quot;. They can contain letters, digits, and the underscore character.</p><p>A <code>let</code> expression binds an identifier to the value of an expression whose scope is the expression that follows. The value of a <code>let</code> expression is the value of its expression with all occurrences of the identifier replaced with its value. For example, the value of this <code>let</code> expression is <code>3</code>:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span><br>a <span class="token operator">+</span> b</code></pre><p>Note how the expression that follows a <code>let</code> expression can be another <code>let</code> expression in order to place multiple identifiers in the scope of the final expression.</p><p>Identifers bound by <code>let</code> expressions go out-of-scope after they are evaluated.</p><p>The type of a variable can be specified, but typically this is omitted because the type can be inferred.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token punctuation">:</span> int <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> b <span class="token punctuation">:</span> int <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span><br>a <span class="token operator">+</span> b</code></pre><p>While it is not required to include a space on both sides of the colon when specifying a type, it is customary and the ocamlformat code formatter will add them.</p><p>Let definitions omit the <code>in</code> keyword. They create global definitions that do not go out of scope after they are evaluated. They are not expressions, so they do not have a value.</p><p>The following example binds three global identifiers. Note how double colons must be used to terminate several of the lines. Also, functions that take no arguments, like <code>print_newline</code>, must be passed the &quot;unit&quot; value <code>()</code>.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><br><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><br><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;;</span><br><br>print_int <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_int <span class="token punctuation">(</span>b <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="references" tabindex="-1">References</h2><p>References are used to create mutable values.</p><p>To define a mutable variable, use a <code>let</code> expression with the <code>ref</code> keyword. For example, the following code sets the variable <code>score</code> to a reference to <code>0</code>. The <code>while</code> loop increments the value until it reaches 10.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> score <span class="token operator">=</span> ref <span class="token number">0</span> <span class="token keyword">in</span><br><span class="token keyword">while</span> <span class="token operator">!</span>score <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token keyword">do</span><br>  score <span class="token operator">:=</span> <span class="token operator">!</span>score <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  print_int <span class="token operator">!</span>score<span class="token punctuation">;</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token keyword">done</span></code></pre><p>mutable variables must be initialized to assign a new value, name := new_value to get the value of a mutable variable (dereference), !name the assignment (:=) and dereference (!) operators are actually functions references are actually single field records with a mutable field named “contents” For more detail, see <a href="https://ocaml.org/docs/tour-of-ocaml#working-with-mutable-state">https://ocaml.org/docs/tour-of-ocaml#working-with-mutable-state</a></p><h2 id="functions" tabindex="-1">Functions</h2><p>functions are first-class; can take a arguments and return let square x = x _ x this is short for let square = fun x -&gt; x _ x (see anonymous functions below) could also write as let square (x : int) = x _ x note that parameters are not enclosed in parens, just separated by spaces in e1 e2 e3, e1 must evaluate to a function and it is passed the values of e2 and e3 if e2 or e3 are not primitive values or variables, add parens around those expressions so they are evaluated before the function call to e1 is evaluated to call this, square 5 note that arguments are not enclosed in parens, just separated by spaces (love this syntax!) This assigns a function value to the name “square”. Anonymous functions (aka lambdas) are written like fun x -&gt; x _ x When utop outputs the value of a function it will look like this:</p><ul><li>: t1 -&gt; t2 =<fun><fun>represents the unprintable function definition t1 is the type of the first parameter t2 is the return type the dash on the left means the function is anonymous fun x y -&gt; (x +. y) /. 2.0 is an anonymous function that computes the average of two float values utop describes it as - : float -&gt; float -&gt; float =<fun>the first two float types are the parameters and the last is the return type the use of two -&gt; tokens is a reminder that OCaml supports partial application the types of the parameters are inferred from how they are used in the function expression Unnamed parameters are positional. functions can have labelled parameters and they can have default values to declare a labelled parameter or pass an labelled argument, use ~{name}:{value} labelled arguments can appear in any order and be mixed with positional arguments when a function is called with fewer arguments than it has parameters, a new function is returned that is the result of partial application recursive functions must be defined with “let rec” optional parameters must be preceded by either ~ (for labelled) or ? (for positional); for example, ?(answer=42) ?(init = 0) is shorthand for ?init:(init = 0). The first “init” is the argument label and the second is the parameter name. They can differ just like in Swift.</fun></fun></fun></li></ul><h2 id="input%2Foutput" tabindex="-1">Input/Output</h2><p>The OCaml standard library provides many functions that read input.</p><p>The following functions read from <code>stdin</code>:</p><ul><li><code>read_line</code> - raises <code>End_of_file</code> if there is no more to read</li><li><code>read_int_opt</code> - returns <code>None</code> if conversion fails</li><li><code>read_int</code> - raises <code>Failure &quot;int_of_string&quot;</code> if conversion fails</li><li><code>read_float_opt</code> - returns <code>None</code> if conversion fails</li><li><code>read_float</code> - raises <code>Failure &quot;float_of_string&quot;</code> if conversion fails</li></ul><p>The OCaml standard library provides many functions that produce output.</p><p>The following functions write to <code>stdout</code>:</p><ul><li><code>print_bytes</code></li><li><code>print_char</code></li><li><code>print_endline</code> - prints a string followed by a newline</li><li><code>print_float</code></li><li><code>print_int</code></li><li><code>print_newline</code> - prints only a newline</li><li><code>print_string</code></li></ul><p>The following functions write to <code>stderr</code>:</p><ul><li><code>prerr_bytes</code></li><li><code>prerr_char</code></li><li><code>prerr_endline</code> - prints a string followed by a newline</li><li><code>prerr_float</code></li><li><code>prerr_int</code></li><li><code>prerr_newline</code> - prints only a newline</li><li><code>prerr_string</code></li></ul><p>The following program prompts for two numbers and outputs their product.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Make the printf function available. *)</span><br><span class="token keyword">open</span> Printf<span class="token punctuation">;;</span><br><br>print_string <span class="token string">"Enter the first number: "</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> num1 <span class="token operator">=</span> read_float <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br><br>print_string <span class="token string">"Enter the second number: "</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> num2 <span class="token operator">=</span> read_float <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br><br><span class="token keyword">let</span> product <span class="token operator">=</span> num1 <span class="token operator">*.</span> num2 <span class="token keyword">in</span><br>printf <span class="token string">"The product of %.2f and %.2f is %.2f\n"</span> num1 num2 product<span class="token punctuation">;</span></code></pre><p>The following program reads and prints all the lines in a text file using a <code>while</code> loop.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_in <span class="token string">"BeverlyHillbillies.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">try</span><br>  <span class="token keyword">while</span> <span class="token boolean">true</span> <span class="token keyword">do</span><br>    <span class="token comment">(* input_line reads from a given channel<br>       until a newline or the end is reached. *)</span><br>    <span class="token keyword">let</span> line <span class="token operator">=</span> input_line channel <span class="token keyword">in</span><br>    print_endline line<br>  <span class="token keyword">done</span><br><span class="token keyword">with</span> End_of_file <span class="token operator">-></span> close_in channel</code></pre><p>The following program reads and prints all the lines in a text file using recursion.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_in <span class="token string">"BeverlyHillbillies.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> <span class="token keyword">rec</span> loop <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">try</span><br>    <span class="token keyword">let</span> line <span class="token operator">=</span> input_line channel <span class="token keyword">in</span><br>    print_endline line<span class="token punctuation">;</span><br>    loop <span class="token punctuation">(</span><span class="token punctuation">)</span><br>  <span class="token keyword">with</span> End_of_file <span class="token operator">-></span> close_in channel<br><span class="token keyword">in</span><br>loop <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>The following program creates a text file and writes lines to it.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_out <span class="token string">"output.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">try</span><br>  <span class="token comment">(* output_string writes to a given channel. *)</span><br>  output_string channel <span class="token string">"line 1\n"</span><span class="token punctuation">;</span><br>  output_string channel <span class="token string">"line 2\n"</span><span class="token punctuation">;</span><br>  output_string channel <span class="token string">"line 3\n"</span><span class="token punctuation">;</span><br>  close_out channel<br><span class="token keyword">with</span> ex <span class="token operator">-></span> close_out channel</code></pre><h1 id="http-servers" tabindex="-1">HTTP Servers</h1><p>There are several OCaml libraries for implementing HTTP servers that provide API endpoints. Popular options include:</p><ul><li><a href="https://aantron.github.io/dream/" target="_blank">Dream</a> - 1.5K GitHub stars</li><li>Opium - 747 GitHub stars</li><li>CoHTTP - 676 GitHub stars</li><li>Ocsigen - not in GitHub</li></ul><h2 id="converting-ocaml-to-javascript" tabindex="-1">Converting OCaml to JavaScript</h2><p>See <a href="http://ocsigen.org/js_of_ocaml/latest/manual/overview">http://ocsigen.org/js_of_ocaml/latest/manual/overview</a>.</p><h2 id="unorganized-content" tabindex="-1">Unorganized Content</h2><p>Type Inference OCaml infers most types almost never need to specify the types of variables or function parameters can declare with a type annotation with the syntax (name : type)</p><p>Numeric Operators +, -, _, and / for int values +., -., _., and /. for float values This distinction is made to avoid having operators that are overloaded for multiple types.</p><p>Lists ordered collection of immutable elements that all have the same type syntax [ v1; v2; v3 ] creates a linked list Why did they choose semicolons instead of commas? a non-empty list is represented by a head that holds an element value and a tail that holds the remainder which is another list or empty list elements can themselves be lists, but all elements must then also be lists with the same type of elements to create a new list by adding an element to the beginning of an existing list, let new_list = element :: old_list to create a new list by concatenating two lists, let new_list = list1 @ list2 match can be used to recursive process a list; for example let rec sum list = match list with | [] -&gt; empty_value | head :: tail -&gt; head + sum tail standard library List functions List.map maps over one list List.map2 maps over two lists List.iter imperatively iterates over a list when the function has a side effect and a result list is not needed</p><p>Arrays ordered, fixed length collection of mutable elements that all elements that all have the same type syntax [| v1; v2; v3 |] creates an array Why did they choose semicolons instead of commas? indexed by integers starting from zero</p><p>Records like structs in other languages to define a record type, type book = { series : string; volume : int; title : string; author : string; mutable stock : int; } note how fields can be marked as “mutable”</p><p>Conditional Logic if-then-else is an expression if expr1 then expr2 else expr3 expr1 must evaluate to a bool int and other values are not automatically interpreted as a bool expr3 must evaluate to the same type as expr2 so the “if” expression always evaluates to the same type normally an else branch is required (maybe can omit if the then branch can evaluate to the “unit value” () The = operator is used for assignment AND for comparison. can be used where other languages use a ternary operator ex. let sign = if result &gt; 0 then “positive” else if result &lt; 0 then “negative” else “zero” pattern matching let sign = match …</p></article>