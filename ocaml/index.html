<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>OCaml</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#installing">Installing</a></li><li><a href="#help">Help</a></li><li><a href="#vs-code">VS Code</a></li><li><a href="#repl">REPL</a></li><li><a href="#comments">Comments</a></li><li><a href="#primitive-types">Primitive Types</a></li><li><a href="#type-conversions">Type Conversions</a></li><li><a href="#keywords">Keywords</a></li><li><a href="#operators">Operators</a></li><li><a href="#variables">Variables</a><ol><li><a href="#type-variables">Type Variables</a></li></ol></li><li><a href="#references">References</a></li><li><a href="#options">Options</a></li><li><a href="#tuples">Tuples</a></li><li><a href="#lists">Lists</a></li><li><a href="#arrays">Arrays</a></li><li><a href="#maps">Maps</a></li><li><a href="#functions">Functions</a></li><li><a href="#input%2Foutput">Input/Output</a></li><li><a href="#dune">Dune</a><ol><li><a href="#example-project">Example Project</a></li><li><a href="#unit-tests">Unit Tests</a></li></ol></li><li><a href="#converting-ocaml-to-javascript">Converting OCaml to JavaScript</a></li><li><a href="#unorganized-content">Unorganized Content</a></li></ol></nav></aside><article><figure style="width: 30%"><img alt="OCaml logo" style="border: 0" src="/blog/assets/ocaml-logo.png?v=1.1.1"></figure><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://ocaml.org?v=1.1.1" rel="noopener" target="_blank">OCaml</a> is &quot;an industrial-strength functional programming language with an emphasis on expressiveness and safety.&quot;</p><p>The Caml programming language is the predecessor of OCaml. The name is short for &quot;Categorical Abstract Machine Language&quot;. OCaml is short for &quot;Objective Caml&quot;.</p><p>OCaml is a member of the <a href="https://en.wikipedia.org/wiki/ML_(programming_language)" target="_blank">ML</a> (short for Meta Language) family of programming languages. Other dialects of ML include Standard ML and F#. ML influenced the design of many other languages including Clojure, Elm, Haskell, Erlang, Rust, and Scala.</p><p>Supposedly the OCaml compiler is much faster than the Haskell compiler. TODO: Verify this.</p><p>OCaml source files have the extension <code>.ml</code> which stands for &quot;meta language&quot;.</p><p>The financial company <a href="https://www.janestreet.com" target="_blank">Jane Street</a> is one of the largest users and supporters of OCaml.</p><h2 id="installing" tabindex="-1">Installing</h2><p>To install the OCaml package manager &quot;opam&quot; for Linux and macOS, enter the following shell command which completes in a few seconds:</p><pre class="language-bash"><code class="language-bash"><span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">"sh &lt;(curl -fsSL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)"</span></code></pre><p>To install for windows, see <a href="https://ocaml.org/install" target="_blank">Install OCaml on Windows</a>.</p><p>After installing <code>opam</code>, enter <code>opam init</code> which takes over five minutes to complete. TODO: Does this install dune which is a build tool?</p><p>To install tools for development, enter the following shell command which takes about four minutes to complete:</p><pre class="language-bash"><code class="language-bash">opam <span class="token function">install</span> ocaml-lsp-server odoc ocamlformat utop</code></pre><h2 id="help" tabindex="-1">Help</h2><p>For help on OCaml, see:</p><ul><li><a href="https://tinyurl.com/discord-ocaml" target="_blank">OCaml Discord</a></li><li><a href="https://discuss.ocaml.org/" target="_blank">OCaml Discourse</a></li><li><a href="https://github.com/lindig/ocaml-style" target="_blank">OCaml style guide</a></li></ul><h2 id="vs-code" tabindex="-1">VS Code</h2><p>Install the &quot;OCaml Platform&quot; extension from OCaml Labs.</p><p>Create the file <code>.ocamlformat</code> in each project root directory containing at least the following in order for VS Code to format OCaml code on save.</p><pre class="language-text"><code class="language-text">profile = default<br>version = 0.26.1</code></pre><p>Sometimes after code changes VS Code flags errors that aren't real. Running &quot;Developer: Reload Window&quot; from the command palette clears them. This issue may go away if you run <code>dune build -w</code> (for watch mode) in a terminal window.</p><h2 id="repl" tabindex="-1">REPL</h2><p>OCaml has two REPLs. A basic one can be started by entering <code>ocaml</code>. A better one is <code>utop</code> which is short for &quot;Universal Toplevel&quot;. The <code>utop</code> command provides a more interactive, user-friendly interface that includes line editing, syntax highlighting, command history, and tab completion. In either REPL the expressions you enter are only evaluated when they are terminated by a double semicolon (<code>;;</code>). This allows expressions to span multiple lines.</p><p>Use the left and right arrow keys to move the cursor within the expression and make edits.</p><p>Use the up and down arrow keys to recall previously entered expressions. They can be edited and executed again.</p><p>To load definitions in an OCaml source file into the REPL, enter <code>#use &quot;{file-path}&quot;;;</code>. This enables using all the types and functions defined in the source file inside the REPL.</p><p>To exit the REPL, press ctrl-d or enter #quit.</p><p>There is also an iOS app called &quot;OCaml&quot; for evaluating OCaml expressions.</p><h2 id="comments" tabindex="-1">Comments</h2><p>Comments in OCaml code begin with <code>(*</code> and end with <code>*)</code>. They can span any number of lines.</p><p>Comments can be nested.</p><p>Doc comments provided documentation that can be extracted from source files. They begin with <code>(**</code> and end with <code>*)</code>. Their content is similar to JSDoc comments, including the use of <code>@param</code> and <code>@return</code> annotations. There are three variations of doc comments, floating, item, and label.</p><h2 id="primitive-types" tabindex="-1">Primitive Types</h2><p>OCaml supports the following primitive types. Their sizes depend on the CPU.</p><ul><li><code>bool</code> - 1 byte with the literal values <code>true</code> and <code>false</code></li><li><code>int</code> - 8 or 4 bytes</li><li><code>float</code> - 8 bytes</li><li><code>string</code> - sequence of bytes, not Unicode characters</li></ul><p>Literal strings are delimited by double quotes. The <code>^</code> operator is used to concatenate strings.</p><p>For Unicode support, see the libraries <code>Uutf</code>, <code>Uutf_string</code>, and <code>ocaml-unicode</code>.</p><p>Primitive values are expressions that do not require additional evaluation.</p><h2 id="type-conversions" tabindex="-1">Type Conversions</h2><p>The OCaml standard library provides many functions for converting a value from one type to another. Examples include:</p><ul><li><code>float_of_int</code></li><li><code>int_of_float</code> - <code>truncate</code> is an alias</li><li><code>int_of_char</code></li><li><code>char_of_int</code></li><li><code>string_of_bool</code></li><li><code>bool_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>bool_of_string_opt</code> - returns <code>None</code> if conversion fails</li><li><code>string_of_int</code></li><li><code>int_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>int_of_string_opt</code> - returns <code>None</code> if conversion fails</li><li><code>string_of_float</code></li><li><code>float_of_string</code> - raises <code>Failure</code> if conversion fails</li><li><code>float_of_string_opt</code> - returns <code>None</code> if conversion fails</li></ul><h2 id="keywords" tabindex="-1">Keywords</h2><p>OCaml reserves the use of the following identifiers: <code>and</code>, <code>as</code>, <code>assert</code>, <code>asr</code>, <code>begin</code>, <code>class</code>, <code>constraint</code>, <code>do</code>, <code>done</code>, <code>downto</code>, <code>else</code>, <code>end</code>, <code>exception</code>, <code>external</code>, <code>false</code>, <code>for</code>, <code>fun</code>, <code>function</code>, <code>functor</code>, <code>if</code>, <code>in</code>, <code>include</code>, <code>inherit</code>, <code>initializer</code>, <code>land</code>, <code>lazy</code>, <code>let</code>, <code>lor</code>, <code>lsl</code>, <code>lsr</code>, <code>lxor</code>, <code>match</code>, <code>method</code>, <code>mod</code>, <code>module</code>, <code>mutable</code>, <code>new</code>, <code>nonrec</code>, <code>object</code>, <code>of</code>, <code>open</code>, <code>or</code>, <code>private</code>, <code>rec</code>, <code>sig</code>, <code>struct</code>, <code>then</code>, <code>to</code>, <code>true</code>, <code>try</code>, <code>type</code>, <code>val</code>, <code>virtual</code>, <code>when</code>, <code>while</code>, and <code>with</code>.</p><h2 id="operators" tabindex="-1">Operators</h2><p>OCaml operators only operate on specific types. This enables type inference of function return types because the compiler can determine the types required by its code.</p><p>Operators for <code>float</code> values are the same as those for <code>int</code> values, but with a <code>.</code> added to the end.</p><p>The arithmetic operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>~-</code></td><td>int negation</td></tr><tr><td><code>+</code></td><td>int addition</td></tr><tr><td><code>-</code></td><td>int subtraction</td></tr><tr><td><code>*</code></td><td>int multiplication</td></tr><tr><td><code>/</code></td><td>int division</td></tr><tr><td><code>~-.</code></td><td>float negation</td></tr><tr><td><code>+.</code></td><td>float addition</td></tr><tr><td><code>-.</code></td><td>float subtraction</td></tr><tr><td><code>*.</code></td><td>float multiplication</td></tr><tr><td><code>/.</code></td><td>float division</td></tr><tr><td><code>**</code></td><td>float exponentiation</td></tr></tbody></table><p>There are no operators like <code>++</code> and <code>--</code> to increment or decrement a number. Instead use the functions <code>succ</code> and <code>pred</code> to get the successor or predecessor.</p><p>There is no exponentiation operator for <code>int</code> values.</p><p>The string operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>^</code></td><td>string concatenation</td></tr><tr><td><code>^^</code></td><td>format string concatenation</td></tr></tbody></table><p>The relational and logical operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>==</code></td><td>same object</td></tr><tr><td><code>!=</code></td><td>not same object</td></tr><tr><td><code>=</code></td><td>structural equality</td></tr><tr><td><code>&lt;&gt;</code></td><td>structural inequality</td></tr><tr><td><code>&lt;</code></td><td>less than</td></tr><tr><td><code>&gt;</code></td><td>greater than</td></tr><tr><td><code>&lt;=</code></td><td>less than or equal</td></tr><tr><td><code>&gt;=</code></td><td>greater than equal</td></tr><tr><td><code>&amp;&amp;</code></td><td>boolean and</td></tr><tr><td><code>||</code></td><td>boolean or</td></tr></tbody></table><p>The remaining operators include:</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>!</code></td><td>gets ref value (dereferences)</td></tr><tr><td><code>:=</code></td><td>sets ref value (assigns)</td></tr><tr><td><code>@</code></td><td>list concatenation</td></tr><tr><td><code>|&gt;</code></td><td>reverse function application</td></tr></tbody></table><p>Most OCaml operators are implemented as binary functions. To use them as functions, wrap them in parentheses. For example, <code>a + b</code> is the same as <code>(+) a b</code>. Adding spaces inside the parentheses is optional, but is required for the <code>*</code> operator because <code>(*</code> is interpreted as the beginning of a comment.</p><p>Operator functions can be passed to functions like <code>List.filter</code>.</p><p>The following code demonstrates writing a function that takes a comparison function which can be a logical operator. The <code>choose</code> function takes two lists and a comparison function. It returns a new list where each element is the element from the first or second list at the same index where comparing them using the comparison function evaluates to true.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> choose list1 list2 cmp_fun <span class="token operator">=</span><br>  <span class="token keyword">match</span> <span class="token punctuation">(</span>list1<span class="token punctuation">,</span> list2<span class="token punctuation">)</span> <span class="token keyword">with</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">(* both lists are empty; return empty list *)</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">_</span> <span class="token operator">-></span> list2 <span class="token comment">(* first list is empty; return second list *)</span><br>  <span class="token operator">|</span> <span class="token punctuation">_</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> list1 <span class="token comment">(* second list is empty; return first list *)</span><br>  <span class="token operator">|</span> h1 <span class="token punctuation">::</span> t1<span class="token punctuation">,</span> h2 <span class="token punctuation">::</span> t2 <span class="token operator">-></span><br>      <span class="token keyword">if</span> cmp_fun h1 h2 <span class="token keyword">then</span><br>        h1 <span class="token punctuation">::</span> choose t1 t2 cmp_fun <span class="token comment">(* add h1 to result list *)</span><br>      <span class="token keyword">else</span> h2 <span class="token punctuation">::</span> choose t1 t2 cmp_fun <span class="token comment">(* add h2 to result list *)</span><br><br><span class="token keyword">let</span> l1 <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token number">10</span> <span class="token punctuation">]</span><br><span class="token keyword">let</span> l2 <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token number">4</span> <span class="token punctuation">]</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  List<span class="token punctuation">.</span>iter<br>    <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span><br>      print_int x<span class="token punctuation">;</span><br>      print_string <span class="token string">" "</span><span class="token punctuation">)</span><br>    <span class="token punctuation">(</span>choose l1 l2 <span class="token punctuation">(</span> <span class="token operator">></span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">(* relational operator passed here *)</span></code></pre><p>The result is <code>[7; 3; 4; 8; 9; 10]</code>.</p><p>Custom binary operators can be defined using an allowed set of characters.</p><h2 id="variables" tabindex="-1">Variables</h2><p>Variables are immutable. An exception is that variables in a REPL can be reassigned.</p><p>Identifier names must start with a lowercase letter unless they refer to a module, constructor, or &quot;polymorphic variant tag&quot;. They can contain letters, digits, and the underscore character. They can also end with a single quote to create pairs of names like <code>x</code> and <code>x'</code> (for x prime). Technically an indentfier can contain any number of single quotes and they can appear anywhere except at the beginning, but doing this is odd!</p><p>A <code>let</code> expression binds an identifier to the value of an expression whose scope is the expression that follows. The value of a <code>let</code> expression is the value of its expression with all occurrences of the identifier replaced with its value. For example, the value of this <code>let</code> expression is <code>3</code>:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span><br>a <span class="token operator">+</span> b</code></pre><p>The code above can also use the <code>and</code> keyword as follows:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span> a <span class="token operator">+</span> b</code></pre><p>Note how the expression that follows a <code>let</code> expression can be another <code>let</code> expression in order to place multiple identifiers in the scope of the final expression.</p><p>Identifers bound by <code>let</code> expressions go out-of-scope after they are evaluated.</p><p>The type of a variable can be specified, but typically this is omitted because the type can be inferred.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token punctuation">:</span> int <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> b <span class="token punctuation">:</span> int <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">in</span><br>a <span class="token operator">+</span> b</code></pre><p>While it is not required to include a space on both sides of the colon when specifying a type, it is customary and the ocamlformat code formatter will add them.</p><p>Let definitions omit the <code>in</code> keyword. They create global definitions that do not go out of scope after they are evaluated. They are not expressions, so they do not have a value.</p><p>The following example binds three global identifiers. Note how double colons must be used to terminate several of the lines. Also, functions that take no arguments, like <code>print_newline</code>, must be passed the &quot;unit&quot; value <code>()</code>.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><br><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><br><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;;</span><br><br>print_int <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_int <span class="token punctuation">(</span>b <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><br>print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="type-variables" tabindex="-1">Type Variables</h3><p>OCaml supports type variables which are similar to generics in other languages. Type variables serve as a placeholder for an unknown type. They are written with a single quote followed by a lowercase name.</p><p>Often the name is just <code>'a</code> and is pronounced &quot;alpha&quot;. If additional type variables are needed, it is common to use <code>'b</code> (beta) and <code>'c</code> (gamma).</p><p>For example, entering <code>[];;</code> in <code>utop</code> outputs type type <code>'a list</code> because it is a list where the type of the elements is unknown.</p><p>TODO: Add an example function that has a parameter whose type uses a type variable.</p><h2 id="references" tabindex="-1">References</h2><p>While variables are immutable, they can be bound to a reference that is mutable. References are created with the <code>ref</code> function which must be given an initial value. The initial value determines its type.</p><p>The <code>!</code> prefix operator dereferences a <code>ref</code> to obtain its value.</p><p>The <code>:=</code> operator assigns a new value to a <code>ref</code>.</p><p>For example, the following code sets the variable <code>score</code> to a reference to <code>0</code>. The <code>while</code> loop increments the value until it reaches 10.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> score <span class="token operator">=</span> ref <span class="token number">0</span> <span class="token keyword">in</span><br><span class="token keyword">while</span> <span class="token operator">!</span>score <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token keyword">do</span><br>  score <span class="token operator">:=</span> <span class="token operator">!</span>score <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  print_int <span class="token operator">!</span>score<span class="token punctuation">;</span><br>  print_newline <span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token keyword">done</span></code></pre><p>Refs are actually single field records with a mutable field named <code>contents</code>.</p><h2 id="options" tabindex="-1">Options</h2><p>The type <code>option</code> represents an optional value. The only valid values of this type are <code>None</code> and <code>Some</code>.</p><p>Functions that sometimes do not have a value to return use this type to represent their return value. For example, the <code>List.find_opt</code> function does this.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* makes the printf function available<br>   without writing Printf.printf *)</span><br><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">"red"</span><span class="token punctuation">;</span> <span class="token string">"green"</span><span class="token punctuation">;</span> <span class="token string">"blue"</span> <span class="token punctuation">]</span><br><span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token string">"green"</span><br><span class="token keyword">let</span> result <span class="token operator">=</span> List<span class="token punctuation">.</span>find_opt <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-></span> x <span class="token operator">=</span> color<span class="token punctuation">)</span> colors<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">match</span> result <span class="token keyword">with</span><br>  <span class="token operator">|</span> Some c <span class="token operator">-></span> printf <span class="token string">"found %s\n"</span> c<br>  <span class="token operator">|</span> None <span class="token operator">-></span> print_endline <span class="token string">"failed to find green\n"</span></code></pre><h2 id="tuples" tabindex="-1">Tuples</h2><p>A tuple is an immutable, ordered collection of values whose types can differ.</p><p>To create a tuple, surround the elements in parentheses and separate them with commas. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span></code></pre><p>This has the type <code>bool * int * string</code> which is referred to as a &quot;product type&quot;.</p><p>For tuples that only have two elements, the <code>fst</code> function returns the first element and the <code>snd</code> function returns the second.</p><p>To get a specific element from a tuple of a certain length, use pattern matching. For example, the following function gets the third element from any 4-element tuple.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> third_of_4 tuple <span class="token operator">=</span> <span class="token keyword">match</span> tuple <span class="token keyword">with</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d <span class="token operator">-></span> c<span class="token punctuation">;;</span><br><br><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"alpha"</span><span class="token punctuation">,</span> <span class="token string">"beta"</span><span class="token punctuation">,</span> <span class="token string">"gamma"</span><span class="token punctuation">,</span> <span class="token string">"delta"</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>print_endline <span class="token punctuation">(</span>third_of_4 t<span class="token punctuation">)</span> <span class="token comment">(* gamma *)</span></code></pre><h2 id="lists" tabindex="-1">Lists</h2><p>A list is an immutable, ordered collection of values that all have the same type. Lists are implemented as singly linked lists.</p><p>To create an empty list, use a pair of square brackets that is pronounced &quot;nil&quot;. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> issues <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre><p>To create a non-empty list, surround the elements in square brackets and separate them with semicolons. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">;</span> <span class="token string">"green"</span><span class="token punctuation">;</span> <span class="token string">"blue"</span><span class="token punctuation">]</span></code></pre><p>A non-empty list is represented by a head that holds an element value and a tail that holds the remainder which is another list that may be empty.</p><p>To create a new list by adding an element to the beginning of an existing list, use the <code>::</code> operator which is pronounced &quot;cons&quot; (short for &quot;construct&quot;). The right side of this operator must be a list and the left side must be an expression that evaluates to the same type as elements in the list on the right. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> new_list <span class="token operator">=</span> element <span class="token punctuation">::</span> old_list</code></pre><p>The <code>color</code> list above was written with syntactic sugar for the following which is evaluated from right to left to construct the final list:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token string">"red"</span> <span class="token punctuation">::</span> <span class="token string">"green"</span> <span class="token punctuation">::</span> <span class="token string">"blue"</span> <span class="token punctuation">::</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre><p>To create a new list by concatenating two lists, use the <code>@</code> operator. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> new_list <span class="token operator">=</span> list1 <span class="token operator">@</span> list2</code></pre><p>The type of a list is written as <code>T list</code> where <code>T</code> is the type of the elements. For example, the type of a list of <code>float</code> values is <code>float list</code>. The type of an empty list <code>[]</code> is <code>'a list</code> where <code>'a</code> is a type variable that represents an unknown type.</p><p>List elements can themselves be lists, but all the elements must then also be lists with the same element type. The sublists are not required to have the same length. For example:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> seasons <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token punctuation">[</span><span class="token string">"spring"</span><span class="token punctuation">;</span> <span class="token string">"rain"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span><span class="token string">"summer"</span><span class="token punctuation">;</span> <span class="token string">"heat"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span><span class="token string">"fall"</span><span class="token punctuation">;</span> <span class="token string">"nice"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span><span class="token string">"winter"</span><span class="token punctuation">;</span> <span class="token string">"cold"</span><span class="token punctuation">]</span><br><span class="token punctuation">]</span></code></pre><p>The type of <code>seasons</code> is <code>string list list</code>.</p><p>The <code>match</code> can be used to recursively process a list. For example, the following code computes the sum of a list of integers. By convention, the name <code>hd</code> is used for the head of a list and <code>tl</code> is used for the tail.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> <span class="token keyword">rec</span> sum list <span class="token operator">=</span><br>  <span class="token keyword">match</span> list <span class="token keyword">with</span><br>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> empty_value<br>  <span class="token operator">|</span> hd <span class="token punctuation">::</span> tl <span class="token operator">-></span> hd <span class="token operator">+</span> sum tl</code></pre><p>The standard library provides a large number of functions that operate on lists. See <a href="https://v2.ocaml.org/api/List.html" target="_blank">Module List</a>.</p><p>The <code>List.map</code> function maps over one list.</p><p>The <code>List.map2</code> function maps over two lists.</p><p>The <code>List.iter</code> function iterates over a list in a way that is useful when the function passed to it has a side effect and a result list is not needed.</p><p>Since tuple elements are separated by commas and list elements are separated by semicolons, a list of tuples can be written as follows:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token punctuation">[</span><span class="token string">"alpha"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token string">"beta"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token string">"gamma"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span></code></pre><p>This evaluates to the following list of tuples:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"alpha"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token string">"beta"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token string">"gamma"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h2 id="arrays" tabindex="-1">Arrays</h2><p>TODO: Clean up this section.</p><p>ordered, fixed length collection of mutable elements that all elements that all have the same type syntax [| v1; v2; v3 |] creates an array Why did they choose semicolons instead of commas? indexed by integers starting from zero</p><p>Records like structs in other languages to define a record type, type book = { series : string; volume : int; title : string; author : string; mutable stock : int; } note how fields can be marked as “mutable”</p><h2 id="maps" tabindex="-1">Maps</h2><p>A Map is an immutable collection of key/value pairs. See <a href="https://ocaml.org/docs/maps">https://ocaml.org/docs/maps</a>.</p><p>TODO: Add more to this section.</p><h2 id="functions" tabindex="-1">Functions</h2><p>OCaml functions are first-class. They can take other functions as arguments and can return new functions.</p><p>The syntax <code>a b c</code> means calling function <code>a</code> with the arguments <code>b</code> and <code>c</code>.</p><p>Another way to write this is to use the &quot;reverse function application&quot; operator <code>|&gt;</code> which is intended to look like a right pointing triangle. Using this, the equivalent of <code>a b c</code> is c |&gt; b |&gt; a. This operator is typically used with functions that take a single argument. The following code demonstrates two ways to compute the squared value of the sine of an angle.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> square x <span class="token operator">=</span> x <span class="token operator">*.</span> x<br><span class="token keyword">let</span> angle <span class="token operator">=</span> <span class="token number">0.78</span> <span class="token comment">(* radians *)</span><br><span class="token keyword">let</span> result1 <span class="token operator">=</span> square <span class="token punctuation">(</span>sin angle<span class="token punctuation">)</span><br><span class="token keyword">let</span> result2 <span class="token operator">=</span> angle <span class="token operator">|></span> sin <span class="token operator">|></span> square<br>```<br><br>Anonymous functions <span class="token punctuation">(</span>aka lambdas<span class="token punctuation">)</span> are defined using the <span class="token variant symbol">`fun</span>` <span class="token keyword">function</span><span class="token punctuation">.</span><br>For example the following <span class="token keyword">function</span><br>takes two <span class="token variant symbol">`int</span>` arguments <span class="token operator">and</span> returns an <span class="token variant symbol">`int</span>`<span class="token punctuation">.</span><br>Note how no parentheses are required <span class="token operator">and</span><br>the parameters are just separated by spaces<span class="token punctuation">.</span><br><br>``<span class="token variant symbol">`ocaml</span><br><span class="token keyword">fun</span> a b <span class="token operator">-></span> a <span class="token operator">+</span> b</code></pre><p>It is not necessary to specify these types. They are inferred from the function expression <code>a + b</code> based on the fact that the <code>+</code> operator only operates on <code>int</code> values and returns an <code>int</code> value.</p><p>The types can be specified if desired. The main reason to do so is to add documentation so readers of the code don't have to examine the function body to determine the types. To specify the parameter types and the return type, the function above can be written as the following.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">fun</span> <span class="token punctuation">(</span>a <span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token punctuation">(</span>b <span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token punctuation">:</span> int <span class="token operator">-></span> a <span class="token operator">+</span> b</code></pre><p>If this function definition is entered in a REPL, followed by <code>;;</code>, the output will be <code>- : int -&gt; int -&gt; int = &lt;fun&gt;</code>. The dash at the beginning indicates that the value does not have a name. The first and second occurrences of <code>int</code> are the types of the two parameters. The last <code>int</code> is the return type of the function. The <code>&lt;fun&gt;</code> after the <code>=</code> represents the bytecode for the function which cannot be printed.</p><p>Functions support partial application. That is why one arrow (<code>-&gt;</code>) for each parameter appears in the output.</p><p>In fact, the function definition above is just syntactic sugar for the following which only defines single-parameter function.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">fun</span> a <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token keyword">fun</span> b <span class="token operator">-></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Despite not having a name, this function can be invoked by surrounding it in parentheses. For example, the following evaluates to <code>5</code>. Note how no parentheses are required around the arguments which are just separated by a space.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token punctuation">(</span><span class="token keyword">fun</span> a b <span class="token operator">-></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token number">3</span></code></pre><p>Let's give a name to this function and invoke it in a couple of ways.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">fun</span> a b <span class="token operator">-></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token keyword">in</span><br>print_int <span class="token punctuation">(</span>add <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 3 *)</span><br><br><span class="token comment">(* Shorthand for previous way of defining this function *)</span><br><span class="token keyword">let</span> add a b <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token keyword">in</span><br>print_int <span class="token punctuation">(</span>add <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 3 *)</span></code></pre><p>Let's use partial application to create a new function that only takes a single number and adds 5 to it.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> add5 <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br>print_int <span class="token punctuation">(</span>add5 <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">(* 7 *)</span></code></pre><p>In the expression <code>e1 e2 e3</code>, <code>e1</code> must evaluate to a function and it is passed the values of <code>e2</code> and <code>e3</code>. If <code>e2</code> or <code>e3</code> are not primitive values or variables, add parentheses around those expressions so they are evaluated before the function call to <code>e1</code> is evaluated. For example, our <code>add</code> function above can be called as follows:</p><pre class="language-ocaml"><code class="language-ocaml">add <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">(* 6 * 9 = 54 *)</span></code></pre><p>Labelling parameters allows them to be specified by the labels in calls. Label names are not required to match their coresponding parameter names.</p><p>TODO: Finish cleaning up this section.</p><p>Unlabelled parameters are positional. functions can have labelled parameters and they can have default values to declare a labelled parameter or pass an labelled argument, use ~{name}:{value} labelled arguments can appear in any order and be mixed with positional arguments when a function is called with fewer arguments than it has parameters, a new function is returned that is the result of partial application recursive functions must be defined with “let rec” optional parameters must be preceded by either ~ (for labelled) or ? (for positional); for example, ?(answer=42) ?(init = 0) is shorthand for ?init:(init = 0). The first “init” is the argument label and the second is the parameter name. They can differ just like in Swift.</p><p>The following code demonstrates two ways to write functions that extract an element from a tuple.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Get the second element of a 4-element tuple using destructuring. *)</span><br><span class="token keyword">let</span> second <span class="token punctuation">(</span><span class="token punctuation">_</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">,</span> <span class="token punctuation">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> e<br><br><span class="token comment">(* Get the third element of a 4-element tuple using match. *)</span><br><span class="token keyword">let</span> third tuple <span class="token operator">=</span> <span class="token keyword">match</span> tuple <span class="token keyword">with</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d <span class="token operator">-></span> c<br><span class="token keyword">let</span> greek <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"alpha"</span><span class="token punctuation">,</span> <span class="token string">"beta"</span><span class="token punctuation">,</span> <span class="token string">"gamma"</span><span class="token punctuation">,</span> <span class="token string">"delta"</span><span class="token punctuation">)</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  print_endline <span class="token punctuation">(</span>second greek<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">(* beta *)</span><br>  print_endline <span class="token punctuation">(</span>third greek<span class="token punctuation">)</span><br><span class="token comment">(* gamma *)</span></code></pre><h2 id="input%2Foutput" tabindex="-1">Input/Output</h2><p>The OCaml standard library provides many functions that read input.</p><p>The following functions read from <code>stdin</code>:</p><ul><li><code>read_line</code> - raises <code>End_of_file</code> if there is no more to read</li><li><code>read_int_opt</code> - returns <code>None</code> if conversion fails</li><li><code>read_int</code> - raises <code>Failure &quot;int_of_string&quot;</code> if conversion fails</li><li><code>read_float_opt</code> - returns <code>None</code> if conversion fails</li><li><code>read_float</code> - raises <code>Failure &quot;float_of_string&quot;</code> if conversion fails</li></ul><p>The OCaml standard library provides many functions that produce output.</p><p>The following functions write to <code>stdout</code>:</p><ul><li><code>print_bytes</code></li><li><code>print_char</code></li><li><code>print_endline</code> - prints a string followed by a newline</li><li><code>print_float</code></li><li><code>print_int</code></li><li><code>print_newline</code> - prints only a newline</li><li><code>print_string</code></li></ul><p>The following functions write to <code>stderr</code>:</p><ul><li><code>prerr_bytes</code></li><li><code>prerr_char</code></li><li><code>prerr_endline</code> - prints a string followed by a newline</li><li><code>prerr_float</code></li><li><code>prerr_int</code></li><li><code>prerr_newline</code> - prints only a newline</li><li><code>prerr_string</code></li></ul><p>The following program prompts for two numbers and outputs their product.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* Make the printf function available. *)</span><br><span class="token keyword">open</span> Printf<span class="token punctuation">;;</span><br><br>print_string <span class="token string">"Enter the first number: "</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> num1 <span class="token operator">=</span> read_float <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br><br>print_string <span class="token string">"Enter the second number: "</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> num2 <span class="token operator">=</span> read_float <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span><br><br><span class="token keyword">let</span> product <span class="token operator">=</span> num1 <span class="token operator">*.</span> num2 <span class="token keyword">in</span><br>printf <span class="token string">"The product of %.2f and %.2f is %.2f\n"</span> num1 num2 product<span class="token punctuation">;</span></code></pre><p>The following program reads and prints all the lines in a text file using a <code>while</code> loop.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_in <span class="token string">"BeverlyHillbillies.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">try</span><br>  <span class="token keyword">while</span> <span class="token boolean">true</span> <span class="token keyword">do</span><br>    <span class="token comment">(* input_line reads from a given channel<br>       until a newline or the end is reached. *)</span><br>    <span class="token keyword">let</span> line <span class="token operator">=</span> input_line channel <span class="token keyword">in</span><br>    print_endline line<br>  <span class="token keyword">done</span><br><span class="token keyword">with</span> End_of_file <span class="token operator">-></span> close_in channel</code></pre><p>The following program reads and prints all the lines in a text file using recursion.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_in <span class="token string">"BeverlyHillbillies.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">let</span> <span class="token keyword">rec</span> loop <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">try</span><br>    <span class="token keyword">let</span> line <span class="token operator">=</span> input_line channel <span class="token keyword">in</span><br>    print_endline line<span class="token punctuation">;</span><br>    loop <span class="token punctuation">(</span><span class="token punctuation">)</span><br>  <span class="token keyword">with</span> End_of_file <span class="token operator">-></span> close_in channel<br><span class="token keyword">in</span><br>loop <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>The following program creates a text file and writes lines to it.</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> channel <span class="token operator">=</span> open_out <span class="token string">"output.txt"</span> <span class="token keyword">in</span><br><span class="token keyword">try</span><br>  <span class="token comment">(* output_string writes to a given channel. *)</span><br>  output_string channel <span class="token string">"line 1\n"</span><span class="token punctuation">;</span><br>  output_string channel <span class="token string">"line 2\n"</span><span class="token punctuation">;</span><br>  output_string channel <span class="token string">"line 3\n"</span><span class="token punctuation">;</span><br>  close_out channel<br><span class="token keyword">with</span> ex <span class="token operator">-></span> close_out channel</code></pre><h2 id="dune" tabindex="-1">Dune</h2><p><a href="https://dune.build" target="_blank">Dune</a> is a popular OCaml and Reason build system. It is used create, build, test, and run OCaml projects. It can also compile to JavaScript.</p><p>To install the <code>dune</code> command, enter <code>oam install dune</code>.</p><p>For help, enter <code>dune --help</code>.</p><p>To create a project that uses <code>dune</code>, cd to where the project should be created and enter <code>dune init project {project_name}</code>. This generates many files including:</p><ul><li>dune configuration file <code>dune-project</code></li><li>opan configuration file <code>{project_name}.opam</code></li><li><code>_build</code>, <code>bin</code>, <code>lib</code>, and <code>test</code> directories</li><li>main source file <code>bin/main.ml</code></li><li>unit test file <code>test/test_{project_name}.ml</code>.</li></ul><p>When using git for version control, the <code>_build</code> directory should be added in the <code>.gitignore</code> file.</p><p>The <code>bin</code>, <code>lib</code>, and <code>test</code> directories all contain a <code>dune</code> file that holds configurations options for that directory. These files using Lisp-like syntax.</p><p>To build the project, enter <code>dune build</code>. This creates <code>_build/default/bin/main.exe</code>. To automatically rebuild the project when code changes are detected, add the <code>--watch</code> flag.</p><p>To run the project, enter <code>dune exec {project_name}</code>.</p><h3 id="example-project" tabindex="-1">Example Project</h3><p>Let's walk through creating a small OCaml project with Dune.</p><ol><li><p><code>cd</code> to the directory where the project should be created.</p></li><li><p>Enter <code>dune init project demo</code></p></li><li><p><code>cd demo</code></p></li><li><p>Enter <code>dune exec demo</code>.</p></li><li><p>Verify that the output is &quot;Hello, World!&quot;.</p></li><li><p>Create the file <code>bin/math_local.ml</code> containing the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">let</span> add a b <span class="token operator">=</span> a <span class="token operator">+</span> b<br><span class="token keyword">let</span> average a b <span class="token operator">=</span> float_of_int <span class="token punctuation">(</span>add a b<span class="token punctuation">)</span> <span class="token operator">/.</span> <span class="token number">2.0</span></code></pre></li><li><p>Modify the file <code>bin/main.ml</code> to contain the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Printf<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><br>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">and</span> c <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">in</span><br>  printf <span class="token string">"sum = %d\n"</span> <span class="token punctuation">(</span>Math_local<span class="token punctuation">.</span>add a b<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  printf <span class="token string">"average = %f\n"</span> <span class="token punctuation">(</span>Math_local<span class="token punctuation">.</span>average b c<span class="token punctuation">)</span></code></pre><p>The <code>let () =</code> is required because at the module level, everthing needs to be in a binding. You could use <code>let _ =</code> instead which allows the expression to have any kind of value. But using <code>let () =</code> is preferred because it states that the expression does not return a value.</p></li><li><p>Enter <code>dune exec demo</code>.</p></li><li><p>Verify that the output is</p><pre class="language-text"><code class="language-text">sum = 3<br>average = 2.500000</code></pre></li><li><p>Now let's try defining the math functions in a library. Copy <code>lib/math_local.ml</code> to the <code>lib</code> directory and rename it to <code>math_lib.ml</code>.</p></li><li><p>Edit <code>bin/main.ml</code>.</p><p>Add the line <code>open Demo</code> at the beginning.<br>Change the two references to <code>Math_local</code> to <code>Math_lib</code>.</p></li><li><p>Enter <code>dune exec demo</code>.</p></li><li><p>Verify that the output is the same.</p></li></ol><h3 id="unit-tests" tabindex="-1">Unit Tests</h3><p>Dune supports several kinds of tests, including inline, expectation, and &quot;cram&quot; tests. Expection tests are similar to Jest snapshot tests. Cram tests describe the output of a shell session. Jest is a JavaScript test framework.</p><p>The following steps add tests to the <code>demo</code> project above and run them. It seems that tests can only be used in libraries defined in the <code>lib</code> directory, not in the <code>bin</code> directory.</p><ol><li><p>Enter <code>opam install ppx_inline_test</code> to enable only inline tests or enter <code>opam install ppx_expect</code> to enable both inline and expectation tests.</p></li><li><p>Change <code>lib/dune</code> to the following:</p><pre class="language-text"><code class="language-text">(library<br>  (name demo)<br>  (inline_tests)<br>  ; This only enables inline tests, not expectation tests.<br>  ; (preprocess (pps ppx_inline_test)))<br>  ; This enables both inline tests and expectation tests.<br>  (preprocess (pps ppx_expect)))</code></pre><p>Single line comments in <code>dune</code> files begin with <code>;</code>.</p></li><li><p>Add the following lines in <code>lib/math_lib.ml</code>:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token comment">(* This is an inline test for the add function. *)</span><br><span class="token keyword">let</span><span class="token operator">%</span>test <span class="token punctuation">_</span> <span class="token operator">=</span> add <span class="token number">1</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">3</span><br><br><span class="token comment">(* This is an expectation test for the average function. *)</span><br><span class="token keyword">let</span><span class="token operator">%</span>expect_test <span class="token punctuation">_</span> <span class="token operator">=</span><br>  print_float <span class="token punctuation">(</span>average <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">[</span><span class="token operator">%</span>expect <span class="token string">"2.5"</span><span class="token punctuation">]</span></code></pre></li><li><p>Enter <code>dune test</code> or <code>dune test -w</code> to run in watch mode.</p><p>You'll see <code>dune runtest</code> in documentation, but <code>dune test</code> is shorter and is an alias.</p></li><li><p>Verify that there are no failed tests.</p><p>When all the tests pass, there is no output. If any expecation tests fail, but the actual values are correct, enter <code>dune promote</code> to update all the expected values.</p></li></ol><p>Tests can also be placed in the <code>test</code> directory. The following steps implement the same tests above in this way.</p><ol><li><p>Replace the contents of the <code>test/dune</code> file with the following:</p><pre class="language-text"><code class="language-text">(tests<br>  (libraries demo)<br>  (names add average)<br>)</code></pre><p>If there is only one test, <code>(tests</code> can be changed to <code>(test</code> and <code>(names</code> can be changed to <code>(name</code>.</p></li><li><p>Create the file <code>test/add.ml</code> containing the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Demo<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">assert</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Math_lib<span class="token punctuation">.</span>add <span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span></code></pre></li><li><p>Create the file <code>test/average.ml</code> containing the following:</p><pre class="language-ocaml"><code class="language-ocaml"><span class="token keyword">open</span> Demo<br><br><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> print_float <span class="token punctuation">(</span>Math_lib<span class="token punctuation">.</span>average <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span></code></pre></li><li><p>Create the file <code>test/average.expected</code> containing <code>2.5</code>.</p></li><li><p>Enter <code>dune test</code> and verify that all the tests pass.</p></li></ol><h1 id="http-servers" tabindex="-1">HTTP Servers</h1><p>There are several OCaml libraries for implementing HTTP servers that provide API endpoints. Popular options include:</p><ul><li><a href="https://aantron.github.io/dream/" target="_blank">Dream</a> - 1.5K GitHub stars</li><li>Opium - 747 GitHub stars</li><li>CoHTTP - 676 GitHub stars</li><li>Ocsigen - not in GitHub</li></ul><h2 id="converting-ocaml-to-javascript" tabindex="-1">Converting OCaml to JavaScript</h2><p>See <a href="http://ocsigen.org/js_of_ocaml/latest/manual/overview">http://ocsigen.org/js_of_ocaml/latest/manual/overview</a>.</p><h2 id="unorganized-content" tabindex="-1">Unorganized Content</h2><p>Type Inference OCaml infers most types almost never need to specify the types of variables or function parameters can declare with a type annotation with the syntax (name : type)</p><p>Numeric Operators +, -, _, and / for int values +., -., _., and /. for float values This distinction is made to avoid having operators that are overloaded for multiple types.</p><p>Conditional Logic if-then-else is an expression if expr1 then expr2 else expr3 expr1 must evaluate to a bool int and other values are not automatically interpreted as a bool expr3 must evaluate to the same type as expr2 so the “if” expression always evaluates to the same type normally an else branch is required (maybe can omit if the then branch can evaluate to the “unit value” () The = operator is used for assignment AND for comparison. can be used where other languages use a ternary operator ex. let sign = if result &gt; 0 then “positive” else if result &lt; 0 then “negative” else “zero” pattern matching let sign = match …</p></article>