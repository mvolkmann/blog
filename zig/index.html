<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Zig</h2><aside></aside><article><p>These notes are currently in a very rough form!</p><ul><li>see <a href="https://blog.logrocket.com/getting-started-zig-programming-language/">https://blog.logrocket.com/getting-started-zig-programming-language/</a></li><li><a href="https://ziglang.org">https://ziglang.org</a></li><li>high performance systems programming language</li><li>suitable for applications that care deeply about performance and/or binary size which justify the tedium and verbosity of manual memory management</li><li>does it always catch when memory is not freed?</li><li>a complete toolchain for creating, developing, building, and testing apps written in Zig, C, and C++</li><li>includes a package manager, a build system API (used in build.zig files), cross-compilation support, and a test runner</li><li>mascot is a lizard</li><li>can use with existing apps that only use C or C++</li><li>the Zig language is a modern alternative to C with much of the same syntax (statements are terminated with a semicolon, conditions are in parentheses, …)</li><li>it was created by Andrew Kelly in 2016</li><li>maintained by the Zig Software Foundation (ZSF)</li><li>Bun, a JS/TS runtime and toolchain, is primarily written in Zig</li><li>Mach, a game engine and graphics toolkit, is implemented in Zig</li><li>supports low-level memory control using allocators<ul><li>page_allocator, c_allocator, ArenaAllocator, FixedBufferAllocator</li></ul></li><li>not memory-safe like Rust</li><li>no operator overloading</li><li>no exceptions; functions that can fail must return an error value (typically an enum?)</li><li>comptime blocks run at compile time; takes the place of preprocessor directives and macros</li><li>comptime variables are initialized at compile time</li><li>supports LLVM cross-compilation to integrate with C and C++</li><li>has a builtin testing framework that uses the <code>test</code> keyword followed by a description string and a block of code that implements the test; enter <code>zig test {file-path}</code> to run the tests in a given file</li><li>builds executables with <code>zig build-exe {file-path}</code>; flags can specify how the code should be optimized (for size, speed, speed and runtime safety, or none for debugging)</li><li><code>zig cc</code> is an alternate C/C++ compiler<ul><li>can build a platform-specific executable for the current platform</li><li>can build an executable for a specified platform</li><li>can find bugs that standard C/C++ compilers do not</li></ul></li></ul><p>To install, download a platform-specific zip file and unzip it. In macOS, enter “brew install zig”.</p><p>A recommended learning resource is ziglings at <a href="https://github.com/ratfactor/ziglings">https://github.com/ratfactor/ziglings</a>.</p><p>Hello World in Zig in the file hello.zig.</p><p>const std = @import(&quot;std&quot;);</p><p>pub fn main() void { std.debug.print(&quot;Hello {s}! {d}\n&quot;, .{&quot;Zig&quot;, 2023}); }</p><p>The print methods expects a certain type of struct as its second argument. Creating an instance with .{} uses that type. To build and run, enter zig run hello.zig To create an executable, enter zig build-exe --name hello hello.zig To customize the executable, add one of these compiler flags:</p><p>Compiler flag Runtime safety checks Optimizations -O Debug Yes No -O ReleaseSafe Yes Yes (speed) -O ReleaseSmall No Yes (size</p><p>To run the executable, enter ./hello To create a binary for a different OS, specify the -target option. For example, -target x86_64-windows</p><p>To create a new project, create a directory for it, cd to the directory, and enter <code>zip init-exe</code>. This creates the file <code>build.zig</code> and a <code>src</code> directory containing <code>main.zig</code>. <code>.zig</code> files often begin with <code>const std = @import(“std”);</code> The main function is defined with <code>pub fn main() !void { … }</code> The ! means the function can return an error value.</p><p>To create a new library, enter <code>zip init-lib</code>.</p><p>Data types include u8 (single byte unsigned integer), … Strings are delimited with double quotes.</p><p>The <code>defer</code> keyword specifies a function to be called when the function it is inside exits. This is often used to deallocate memory allocated on the line before. For example, <code>var allocator = std.heap.page_allocator; var myList = std.ArrayList(10).init(allocator); defer myList.deinit();</code> Also see <code>errdefer</code> which specifies a function to call if an error occurs in the current scope.</p><p>Zig standard library</p><ul><li>document this</li></ul><p>Comments</p><ul><li>single-line with //</li><li>no multi-line comments</li><li>doc comments begin with /// and document variables and functions</li><li>top-level comments begin with //! and document the current module</li></ul><p>Primitive Types</p><ul><li>Zig supports a large number of primitive types</li><li>signed integers: i8, i16, i32, i64, i128</li><li>unsigned integers: u8, u16, u32, u64, u128; u8 can hold a single character (literals in single quotes)</li><li>floating point: f16, f32, f64, f80, f128</li><li>isize, usize</li><li>C types: c_char, c_short, c_ushort, c_int, c_uint, c_long, c_ulong, c_longlong, c_ulonglong, c_longdouble</li><li>bool</li><li>anyopaque</li><li>void</li><li>noreturn</li><li>type</li><li>anyerror</li><li>comptime_int</li><li>comptime_float</li><li>“arbitrary bit-width integers can be referenced by using an identifier of i or u followed by digits. For example, the identifier i7 refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is 65535.”</li></ul><p>Primitive Values</p><ul><li>null, undefined</li><li>true, false</li></ul><p>Strings</p><ul><li>“String literals are constant single-item points to null-terminated byte arrays.”</li><li>var name = “Mark”;</li><li>dereferencing converts to array of characters</li><li>default encoding is UTF-8</li><li>multi-line string literals precede each line with <code>\\</code></li><li>to iterate over the bytes in a string (characters if ASCII), for (name) |byte| { … }</li><li><ul><li>operator can be used to create a string by concatenating characters; var name = ‘M’ + ‘a’ + ‘r’ + ‘k’</li></ul></li></ul><p>Arrays</p><ul><li>to create an array from a literal, const numbers = [_]u32{ 19, 21, 7 }; // _ indicates not specifying size</li><li>to initialize all elements to same value, const numbers = [_]u32{0} ** 3; // array of 3 zero elements</li><li>use var instead of const to make them mutable</li><li>have a <code>len</code> field</li><li>to get an array element, numbers[1]</li><li>to mutate an array element, numbers[1] = 3;</li><li>++ operator concatenates arrays, returning a new array<ul><li>applies to strings; var name = “Ma” ++ “rk”;</li></ul></li><li>** operator multiplies arrays, returning a new array</li><li>multidimensional arrays are created by nesting arrays<ul><li>var matrix = [3][3]f64 {</li><li>[_]f64{ 1.0, 2.0, 3.0 },</li><li>[_]f64{ 4.0, 5.0, 6.0 },</li><li>[_]f64{ 7.0, 8.0, 9.0 }</li><li>};</li><li>access elements with matrix[row][column]</li><li>iterate over with nested for loops</li><li>for (matrix, 0..) |row, rowIndex| {</li><li>for (row, 0..) |value, columnIndex| {</li><li><pre><code>// use value, rowIndex, and columnIndex here
</code></pre></li><li>}</li><li>}</li></ul></li></ul><p>Slices</p><ul><li>“A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime.”</li><li>like arrays, slices have a <code>len</code> field</li><li>to get a slice from an array, var mySlice = myArray[startIndex..endIndex]; // inclusive?</li><li>access and modify slice elements just like with array elements</li><li>do both perform bounds checking and generate a well-known error when outside?</li></ul><p>Vectors</p><ul><li>sets of primitive values or pointers</li><li>can operate on them in parallel using SIMD instructions if available using standard operators that return a new vector<ul><li>const v1 = @Vector(_, f32){ 1.2, 2.3, 3.4 }; // need to specify length instead of using _?</li><li>const v2 = @Vector(_, f32){ 9.8, 8.7, 7.6 };</li><li>const v3 = v1 + v2;</li></ul></li><li>vectors are compatible with fixed-length arrays with the same length or slices of arrays with the same length; can be assigned to each other</li></ul><p>Enumerations</p><ul><li>to define, const Color = enum { red, green, blue, };</li><li>to use, var color = Color.red;</li><li>to make tag values available, specify the tag type<ul><li>for example: const Color = enum(u8) { red, green, blue, }; // assigns 0, 1, and 2</li></ul></li><li>to define with specific values, const Color = enum(u8) { red = 10, green = 20, blue = 30, };</li></ul><p>Standard Library Data Structures</p><ul><li>ArrayList - “a contiguous, growable list of items in memory”</li><li>AutoArrayHashMap</li><li>AutoArrayHashMapUnmanaged</li><li>StringArrayHashMap</li><li>StringArrayHashMapUnmanaged</li><li>ArrayHashMap</li><li>BufMap</li><li>BufSet - a set of strings</li><li>AutoHashMap</li><li>AutoHashMapUnmanaged</li><li>StringHashMap</li><li>StringHashMapUnmanaged</li><li></li><li>more?</li><li>Set?</li></ul><p>Variables</p><ul><li>can declare at file scope or in function scopes</li><li>variables must be initialized, but an initialize to <code>undefined</code>; ex. <code>var score: u32 = 0; const maxScore = 10;</code></li><li>declare immutable variables with const or mutable variables with var; prefer const when possible</li><li>does it support type inference?</li><li>variable names cannot shadow those in outer scopes</li><li>names must start with a letter and contain letters, numbers, and underscores</li><li>non-conforming names can be used with <code>@“some name”</code></li><li>variables declared outside any function are referred to as “container-level variables”<ul><li>includes variables declared inside struct, union, enum, and opaque (similar to a struct; used for interacting with C code that doesn’t expose field details) definitions (only top-level ones?)</li></ul></li></ul><p>Optionals</p><ul><li>to allow a value to have a specific type or <code>null</code>, precede the type with <code>?</code></li><li>for example, const maybeNumber: ?i32 = null;</li><li>Zig prevents null references by using optional pointers whose usages are checked by the compiler</li><li>the <code>orelse</code> operator unwraps optional values and provides a value to use if it is null<ul><li>const ptr = optionalPtr orelse 0; // assumes optionalPtr is a pointer to an integer</li></ul></li></ul><p>Operators</p><ul><li>+, -, *, /, %</li><li>operator assignment: +=, -=, *=, /=, %/</li><li>bitwise: &lt;&lt;, &gt;&gt;, &amp;, |, ^, ~</li><li>bitwise assignment: &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^=</li><li>orelse, .?</li><li>and (not &amp;&amp;), or (not ||), ! (not not; inconsistent!)</li><li>catch</li><li>==, !=, &gt;, &gt;=, &lt;, &lt;=</li><li>array concatenation with ++</li><li>array multiplication with **</li><li>pointer dereference with .*</li><li>address of with &amp;</li><li>merge error sets with ||</li><li>many wrapping operators</li><li>many saturating operators</li><li>does not support the ++ and — operators found in C</li></ul><p>Structs</p><ul><li>struct types are defined with <code>const SomeName = struct { f1: type1, f2: type2 ,};</code></li><li>struct instances are created with <code>var someInstance = SomeName { .f1 = v1, .f2 = v2, };</code></li><li>anonymous struct syntax alternative: <code>var someInstance: SomeName = .{ .f1 = v1, .f2 = v2 };</code></li><li>can any field value be <code>undefined</code>?</li><li>to define a method in a struct, add a <code>pub</code> function inside its definition</li><li>to define a constant in a struct, add <code>pub const NAME = value;</code></li><li>structs can be used to implement generic functions<ul><li>“A generic data structure is simply a function that returns a type.”</li><li>this example from official docs returns an instance of a dynamically defined struct type for a linked list whose nodes hold values of a given type</li><li>Node is a nested type that is available through the returned type</li><li>fn LinkedList(comptime T: type) type {</li><li>return struct {</li><li><pre><code>// This just declares a type used for the struct fields below.
</code></pre></li><li><pre><code>pub const Node = struct {
</code></pre></li><li><pre><code>  prev: ?*Node, // optional value
</code></pre></li><li><pre><code>  next: ?*Node, // optional value
</code></pre></li><li><pre><code>  value: T
</code></pre></li><li><pre><code>};
</code></pre></li><li><pre><code>first: ?*Node,
</code></pre></li><li><pre><code>last: ?*Node,
</code></pre></li><li><pre><code>length: usize,
</code></pre></li><li>}</li><li>var numberList = LinkedList(i32) { .first = null, .last = null, .length = 0 };</li><li>const NumberList = LinkedList(i32);</li><li>var node = NumberList.Node { .prev = null, .next = null, .value = 19 };</li><li>var numberList = LinkedList(i32) { .first = @node, .last = &amp;node, .length = 1 };</li></ul></li></ul><p>Tuples</p><ul><li>defined by an anonymous struct with no field names</li><li>fields are given names that are integers starting from 0</li><li>access a field value with [index] syntax</li><li>const myTuple = { true, “hello”, @as(u32, 19) };</li><li>myTuple[1] is “hello”</li><li></li></ul><p>Unions</p><ul><li>defines a set of possible types for a value</li><li>const DataType = union { number: i32, truth: bool };</li><li>var data1 = DataType { .number = 19 };</li><li>var data2 = DataType { .truth = true };</li><li>anonymous union syntax alternative: <code>var data2: DataType = .{ .number = 19 };</code></li><li>tagged union types use an enum for their cases and can be used in switch expressions</li><li>const DataTypeTag = enum { number, truth };</li><li>const DataType = union(DataTagType) { number: i32, truth: bool };</li><li>can get the tag type of a union type with std.meta.Tag(DataType) which returns DataTypeTag</li></ul><p>Control Structures</p><ul><li>if statements are just like in C<ul><li>if (cond1) { … } else if (cond2) { … } else { … }</li><li>but they are expressions</li><li>the ternary operator is not supported, but an if expression can be used instead<ul><li>const value = if (condition) 19 else 21;</li></ul></li><li>to test whether a variable with an optional type is currently set to null, if (variable) |value| { use value here } else { value was null }; else part is optional</li><li>could use <code>unreachable</code> statement in else to intentionally crash; asserts that a code location should never be reached</li><li>can also just compare to null if value isn’t needed; if (variable == null) …</li></ul></li><li>switch statements are a bit different than in C<ul><li>cases are referred to as “branches”</li><li>branches do not fall through</li><li>switch (expression) {</li><li><pre><code>    1…10 =&gt; { // range of values
</code></pre></li><li><pre><code>        …
</code></pre></li><li><pre><code>    },
</code></pre></li><li><pre><code>    20, 30 =&gt; { // list of values
</code></pre></li><li><pre><code>        …
</code></pre></li><li><pre><code>    },
</code></pre></li><li><pre><code>    else =&gt; { // required unless the branches are exhaustive
</code></pre></li><li><pre><code>        …
</code></pre></li><li><pre><code>    }
</code></pre></li><li><pre><code>}
</code></pre></li><li>it must be possible to coerce all branch values to a common type</li><li>can switch on number and enum values; can it switch on string values?</li><li>switch statements can be used as expressions<ul><li>const result = switch (expression) {</li><li>1 =&gt; “single”,</li><li>2 =&gt; “couple”,</li><li>3 =&gt; “few”,</li><li>else =&gt; “many”</li><li>}</li></ul></li></ul></li><li>while loops are just like in C<ul><li>while (condition) { … }</li><li>while (condition) : (updates) { … }<ul><li>this uses while like a C for loop</li><li>for example, var i: i32 = 1; while (i &lt; 10) : (i += 1) { … }</li></ul></li><li>if condition is a function call that returns an optional value, the loop exits if null is returned<ul><li>for example, while (iterator.next()) |item| { … }</li></ul></li><li>can use break to exit (break :someLabel;)</li><li>can use continue to skip to the next iteration (continue :someLabel)</li><li>can break or continue or a labelled outer loop</li><li>outer: while (condition1) {</li><li>while (condition2) {</li><li><pre><code>if (condition3) break :outer;
</code></pre></li><li>}</li><li>}</li></ul></li><li>while loops are expressions<ul><li>to specify their value, <code>break someValue;</code></li><li>if the loop can exit without breaking, add an else clause to specify the value<ul><li>while (condition) { … } else someValue;</li></ul></li><li>else is only evaluated if the loop does not break</li></ul></li><li>while loops can catch errors when the condition is a function call that returns an error union type<ul><li>while (someFunction()) |value| {</li><li>// Process non-error value here.</li><li>} else |err| {</li><li>// Handle err here.</li><li>}</li><li>The else block is only evaluated if someFunction returns an error value.</li></ul></li><li>for loops are different than in C<ul><li>in this example, sequence is an array or a slice</li><li>for (sequence) |item| {</li><li><pre><code>…
</code></pre></li><li>}</li><li>to get both item values and indexes<ul><li>for (sequence, 0..) |item, index| { … }</li></ul></li><li>to iterate over a range of integers, for (start..end) |value| { … }</li><li>to iterate over multiple arrays or slices that have the same length at the same time, for (seq1, seq2) |v1, v2| { … }</li><li>to iterate over a sequence by value so the items can be mutated, for (&amp;sequence) |<em>item| { item.</em> = newValue }</li></ul></li><li>for loops are expressions<ul><li>to specify their value, <code>break someValue;</code></li><li>if the loop can exit without breaking, add an else clause to specify the value<ul><li>for (condition) { … } else someValue;</li></ul></li><li>else is only evaluated if the loop does not break</li></ul></li><li>like while loops, nested for loops can be labelled to enable breaking out of or continuing an outer loop</li></ul><p>Functions</p><ul><li>parameters are immutable; function bodies cannot modify them</li><li>primitive types are passed by value (copy)</li><li>Zig will decide whether to pass non-primitive types (structs, unions, and arrays) by value or reference based on which it determines is faster</li><li>to force pass by reference, pass a pointer<ul><li>to pass an argument by reference (a pointer), precede with &amp;</li><li>to accept a parameter as a pointer, precede type with *</li></ul></li><li>if there is no return value, the return type is void</li><li>if an error can be returned, precede the return type with !</li><li>to declare, fn someName(p1: type1, p2: type2) returnType { … }</li><li>to make available outside current source file and callable from C, precede with <code>export</code>; is this only for creating libraries?</li><li>to allow other source files to import the function, precede it with <code>pub</code></li><li>to define a type that is a pointer to a function and can be used as a argument type, const myFnType = *const fn (p1: type1, p2: type2) return type;</li><li>variable parameter types and reflection<ul><li>to allow any type of value to be passed as an argument, use <code>anytype</code> for the parameter type</li><li>inside the function, use the builtin function <code>@TypeOf(variableName)</code> to refer to the actual type</li><li>inside the function, use the builtin function <code>@typeInfo(variableName)</code> to get information about the actual type<ul><li>@typeInfo(@TypeOf) returns a std.builtin.Type object</li><li>what are the properties and methods on a Type object?</li></ul></li></ul></li><li>can use reflection to get details about the parameters and return type of a given function with <code>@typeInfo(@TypeOf(someFunction)).Fn</code> which gives an object with the fields <code>params</code> (an array of objects with <code>type</code> and <code>name</code>? fields?) and <code>return_type</code> (a type)</li></ul><p>Blocks</p><ul><li>lines of code surrounded by curly braces that define a variable scope</li><li>labelled blocks are expressions that return a value</li><li>const value = myLabel: { add code to compute value here; break :myLabel value }</li></ul><p>Errors</p><ul><li>The <code>try</code> keyword provides error handling.</li><li>Possible errors cannot be ignored.</li><li>The catch keyword is used to provide a default value for an expression that results in an error. - const number = parseU64(str, 10) catch 0; - can compute value with a labeled block - catch blk: { // do things - break :blk 13; - }; -</li><li>If no <code>catch</code> block is included, the error is returned to the caller</li><li>error sets are similar to enums and describe the errors that can be thrown by functions</li><li>example from official docs<ul><li>const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound };</li><li>const String = [_]u8; // TODO: Is this the proper way to describe a string type?</li><li>fn processFile(filePath: *String) FileOpenError { … }</li></ul></li></ul><p>Type Coercion and Casting</p><ul><li>Add detail on this!</li></ul><p>Memory Management</p><ul><li>Zig does not provide any memory management and has no runtime.</li><li>In C, memory is managed with the functions malloc, free, and realloc. These use a provided memory allocator.</li><li>Zig allows selection of a memory allocation strategy and does not choose a default strategy.</li><li>It is also possible to implement a custom allocator.</li><li>All functions and data structures that allocate memory take an Allocator argument that specifies the strategy to use.</li><li>The C strategy is available as std.heap.c_allocator.</li><li>Other provided allocations include:<ul><li>std.heap.FixedBufferAllocator</li><li>std.heap.ThreadSafeFixedBufferAllocator</li><li>std.heap.ArenaAllocator</li><li>std.testing.Allocator</li><li>std.testing.FailingAllocator</li><li>DESCRIBE EACH OF THESE</li><li>ARE THERE MORE PREDEFINED ALLOCATORS?</li></ul></li></ul><p>Builtin Functions</p><ul><li>list all of these</li><li>Async Functions</li><li>not currently supported, but will be in the future</li></ul><p>noreturn</p><ul><li>the type of functions that never finish</li><li>also the type of break, continue, return, unreachable, and the while construct <code>while (true) { … }</code></li></ul><p>Zig has an official style guide that is not enforced by the compiler</p><ul><li>4-space indentation</li><li>open braces on the same line or the last of wrapped lines</li><li>maximum line length is 100</li><li>function names should be camelCase<ul><li>but functions that return a type should be TitleCase</li></ul></li><li>type names should be TitleCase</li><li>variable names should be snake_case</li><li>names of files that define a struct should have the same name as the struct which uses TitleCase</li><li>all other file names should be snake_case</li><li>directory names should be snake_case</li><li>Is there a Zig code formatter?</li></ul></article>