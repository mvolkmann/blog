<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Zig</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#used-by">Used By</a></li><li><a href="#installing">Installing</a></li><li><a href="#getting-started">Getting Started</a></li><li><a href="#tools">Tools</a></li><li><a href="#resources">Resources</a></li><li><a href="#zig-projects">Zig Projects</a></li><li><a href="#comments">Comments</a></li><li><a href="#primitive-types">Primitive Types</a></li><li><a href="#variables">Variables</a></li><li><a href="#ranges">Ranges</a></li><li><a href="#control-structures">Control Structures</a><ol><li><a href="#if-expressions">if Expressions</a></li><li><a href="#switch-expressions">switch Expressions</a></li><li><a href="#while-expressions">while Expressions</a></li><li><a href="#for-expressions">for Expressions</a></li></ol></li><li><a href="#error-handling">Error Handling</a></li><li><a href="#unreachable-code-paths">Unreachable Code Paths</a></li><li><a href="#functions">Functions</a></li><li><a href="#standard-library">Standard Library</a></li><li><a href="#structs">Structs</a><ol><li><a href="#arraylist">ArrayList</a></li><li><a href="#hashmap">HashMap</a></li><li><a href="#multiarraylist">MultiArrayList</a></li></ol></li><li><a href="#tests-in-code">Tests in Code</a></li><li><a href="#stack-example">Stack Example</a></li><li><a href="#cleanup-everything-below-here!">CLEANUP EVERYTHING BELOW HERE!</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><figure style="width: 50%"><img alt="Ziggy, the Zig mascot" src="/blog/assets/ziggy.svg?v=1.0.22"><figcaption>Ziggy, the lizard Zig mascot</figcaption></figure><p><a href="https://ziglang.org?v=1.0.22" rel="noopener" target="_blank">Zig</a> is a free, open source, high performance, systems programming language. It is a modern alternative to C with much of the same syntax such as statements terminated with semicolons and conditions in parentheses.</p><p>Zig is suitable for applications that care deeply about performance and/or binary size. which justifies the tedium and verbosity of manual memory management. Zig does not provide automated garbage collection.</p><p>Zig provides a complete toolchain for creating, developing, building, and testing apps written in Zig, C, and C++. It supports LLVM cross-compilation to integrate with C and C++. There are advantages to building apps with the Zig compiler even if they have not Zig code and only use C and/or C++ code.</p><p>Zig emphasizes:</p><ul><li><p>No hidden control flow.</p><p>Examples of hidden control flow in other languages include exception handling, operator overloading, and destructors.</p></li><li><p>No hidden memory allocations.</p></li><li><p>No preprocessors or macros.</p><p>In place of these, Zig uses code that runs at compile-time, indicated by the <code>comptime</code> keyword.</p></li></ul><p>Zig includes:</p><ul><li>a package manager</li><li>a build system that is simpler that the combinations of build tools typically used with C and C++</li><li>a build system API (used in <code>build.zig</code> files)</li><li>cross-compilation support</li><li>a test runner.</li></ul><p>Zig was created by Andrew Kelly in 2016. It is maintained by the Zig Software Foundation (ZSF).</p><h2 id="used-by" tabindex="-1">Used By</h2><ul><li><p><a href="https://bun.sh?v=1.0.22" rel="noopener" target="_blank">Bun</a> - a JavaScript/TypeScript runtime and toolchain, is primarily written in Zig. Bun has many advantages over Node.js and Deno including much better performance.</p></li><li><p><a href="https://www.roc-lang.org?v=1.0.22" rel="noopener" target="_blank">Roc</a> - &quot;a fast, friendly, functional language&quot; &quot;Roc's compiler has always been written in Rust. Roc's standard library was briefly written in Rust, but was soon rewritten in Zig.&quot;</p></li><li><p><a href="https://machengine.org?v=1.0.22" rel="noopener" target="_blank">Mach</a> - a game engine and graphics toolkit, is implemented in Zig.</p></li></ul><h2 id="installing" tabindex="-1">Installing</h2><p>To install, download a platform-specific zip or tar file from the <a href="https://ziglang.org/download/?v=1.0.22" rel="noopener" target="_blank">Releases</a> page, expand it, move the directory this creates to a desired location, set the environment variable <code>ZIG_PATH</code> to point to this directory, and add <code>ZIG_PATH</code> to the list of directories in the <code>PATH</code> environment variable.</p><p>In macOS and easier option is to install Zig with Homebrew by entering <code>brew install zig</code>. However, this may currently only work on Macs with Intel-based processors.</p><p>For more detail on installation options, see <a href="https://ziglang.org/learn/getting-started/#installing-zig?v=1.0.22" rel="noopener" target="_blank">Installing Zig</a>.</p><h2 id="getting-started" tabindex="-1">Getting Started</h2><p>The following code, in the file <code>hello.zig</code> is a basic hello world program.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token comment">// s for string, d for decimal</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello {s}! {d}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token string">"Zig"</span><span class="token punctuation">,</span> <span class="token number">2023</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The print methods expects a certain type of struct as its second argument. Creating an instance with .{} uses that type.</p><p>To build and run this program, enter <code>zig run hello.zig</code>.</p><p>To create an executable, enter <code>zig build-exe --name hello hello.zig</code>. To create an executable for a different OS, specify the -target option. For example, <code>-target x86_64-windows</code>.</p><p>To customize the executable, add one of the following compiler flags. These cause the executable to be optimized for some combination of size, speed, and runtime safety.</p><table><thead><tr><th>Compiler flag</th><th>Runtime safety checks</th><th>Optimizations</th></tr></thead><tbody><tr><td>-O Debug</td><td>Yes</td><td>No</td></tr><tr><td>-O ReleaseSafe</td><td>Yes</td><td>Yes (speed)</td></tr><tr><td>-O ReleaseSmall</td><td>No</td><td>Yes (size)</td></tr></tbody></table><p>To run the executable, enter <code>./hello</code>.</p><p>To format a <code>.zig</code> source file, enter <code>zig fmt {file-name}.zig</code>.</p><p>There is no linter for Zig, but the Zig compiler provides more guidance than most compilers.</p><h2 id="tools" tabindex="-1">Tools</h2><p>For VS Code, see the extension <a href="https://github.com/ziglang/vscode-zig?v=1.0.22" rel="noopener" target="_blank">Zig Language</a>.</p><h2 id="resources" tabindex="-1">Resources</h2><ul><li><a href="https://ziglang.org?v=1.0.22" rel="noopener" target="_blank">Zig home page</a></li><li><a href="https://ziglang.org/documentation/master/std/#A;std?v=1.0.22" rel="noopener" target="_blank">Zig Standard Library</a></li><li><a href="https://blog.logrocket.com/getting-started-zig-programming-language/?v=1.0.22" rel="noopener" target="_blank">Getting started with the Zig programming language</a></li><li><a href="https://github.com/ratfactor/ziglings?v=1.0.22" rel="noopener" target="_blank">Ziglings</a> - &quot;A series of tiny broken programs ... By fixing them, you'll learn how to read and write Zig code.&quot;</li><li><a href="https://ziglearn.org?v=1.0.22" rel="noopener" target="_blank">ziglearn.org</a></li></ul><h2 id="zig-projects" tabindex="-1">Zig Projects</h2><p>To create a new project, create a directory for it, cd to the directory, and enter <code>zig init-exe</code>. This creates the file <code>build.zig</code> and a <code>src</code> directory containing the file <code>main.zig</code>.</p><p>The file <code>build.zig</code> is a build script that uses the compiler API. Modify this file to change the characteristics of executable that is produced.</p><p>The file <code>main.sig</code> is the starting point of the application. Like many <code>.zig</code> files, this begins by importing the standard library with <code>const std = @import(&quot;std&quot;);</code> It also defines the main function with <code>pub fn main() !void { ... }</code>. The <code>!</code> means the function can return an error value.</p><p>To run the app, enter <code>zig build run</code>.</p><h2 id="comments" tabindex="-1">Comments</h2><p>Single-line comments begin with <code>//</code>.</p><p>Zig does not support multi-line comments. It relies on code editors to make it easy to comment and uncomment ranges of lines.</p><p>Top-level comments begin with <code>//!</code>. These are used to document the current module (source file).</p><p>Doc comments begin with <code>///</code>. These are used to document variables and functions.</p><h2 id="primitive-types" tabindex="-1">Primitive Types</h2><p>Zig supports a large number of primitive types.</p><ul><li>signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code></li><li>unsigned integers: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> The <code>u8</code> type can be used to hold a single character. Single character literals are enclosed in single quotes.</li><li>floating point: <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code></li><li><code>isize</code>, <code>usize</code></li><li>C types: <code>c_char</code>, <code>c_short</code>, <code>c_ushort</code>, <code>c_int</code>, <code>c_uint</code>, <code>c_long</code>, <code>c_ulong</code>, <code>c_longlong</code>, <code>c_ulonglong</code>, <code>c_longdouble</code></li><li><code>bool</code></li><li><code>anyopaque</code></li><li><code>void</code></li><li><code>noreturn</code></li><li><code>type</code></li><li><code>anyerror</code></li><li><code>comptime_int</code></li><li><code>comptime_float</code></li></ul><p>In addition to these primitive types, &quot;arbitrary bit-width integers can be referenced by using an identifier of <code>i</code> or <code>u</code> followed by digits.&quot; For example, the identifier <code>u3</code> refers to an unsigned 3-bit integer. &quot;The maximum allowed bit-width of an integer type is 65535.&quot;</p><h2 id="variables" tabindex="-1">Variables</h2><h2 id="ranges" tabindex="-1">Ranges</h2><p>Ranges of numbers have an inclusive lower bound and an upper bound that is either exclusive or inclusive. For example, the range <code>5..7</code> includes the values 5 and 6 and the range <code>5...7</code> includes the values 5, 6 and 7.</p><h2 id="control-structures" tabindex="-1">Control Structures</h2><p>Zig supports four control structures, <code>if</code>, <code>switch</code>, <code>while</code>, and <code>for</code>. All of these can be used as expressions that result in a value.</p><h3 id="if-expressions" tabindex="-1">if Expressions</h3><p>The syntax for <code>if</code> expressions is nearly identical to that of C <code>if</code> statements. The most basic form follows:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">if</span> <span class="token punctuation">(</span>cond1<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// code goes here</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cond2<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// code goes here</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token comment">// code goes here</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example that includes random number generation and simplifies output of strings type is typically <code>[]const u8</code>.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token comment">// The value of the first argument to print must be known at compile time.</span><br><span class="token keyword">fn</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">comptime</span> text<span class="token punctuation">:</span> <span class="token class-name"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token builtin-type keyword">u8</span></span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token function">print</span><span class="token punctuation">(</span>text <span class="token operator">++</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token comment">// prng is short for pseudo random number generator.</span><br>    <span class="token keyword">var</span> prng <span class="token operator">=</span> std<span class="token punctuation">.</span>rand<span class="token punctuation">.</span>DefaultPrng<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token label">blk</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><br>        <span class="token keyword">var</span> seed<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">u64</span></span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><br>        <span class="token comment">// try can only be used inside a function.</span><br>        <span class="token keyword">try</span> std<span class="token punctuation">.</span>os<span class="token punctuation">.</span><span class="token function">getrandom</span><span class="token punctuation">(</span>std<span class="token punctuation">.</span>mem<span class="token punctuation">.</span><span class="token function">asBytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>seed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">break</span> <span class="token punctuation">:</span><span class="token label">blk</span> seed<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Generate a random integer from 1 to 3.</span><br>    <span class="token keyword">const</span> value <span class="token operator">=</span> prng<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intRangeAtMost</span><span class="token punctuation">(</span><span class="token builtin-type keyword">u8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"value = {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"other"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Zig does not support the ternary operator from C. An <code>if</code> expression can be used instead. The following example sets the variable <code>value</code> to either <code>19</code> or <code>21</code>.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token number">19</span> <span class="token keyword">else</span> <span class="token number">21</span><span class="token punctuation">;</span></code></pre><p>An <code>if</code> expression can test whether a variable with an optional type is currently set to <code>null</code>. If not, the value is unwrapped and made available in the body.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">if</span> <span class="token punctuation">(</span>variable<span class="token punctuation">)</span> <span class="token operator">|</span>value<span class="token operator">|</span> <span class="token punctuation">{</span><br>    <span class="token comment">// use value here</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// optional part</span><br>    <span class="token comment">// value was null</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example that demonstrates using an optional integer.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function">report</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">:</span> <span class="token class-name"><span class="token operator">?</span><span class="token builtin-type keyword">i8</span></span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span> <span class="token operator">|</span>value<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"value = {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"value is null\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> wrapper<span class="token punctuation">:</span> <span class="token class-name"><span class="token operator">?</span><span class="token builtin-type keyword">i8</span></span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br>    <span class="token function">report</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    wrapper <span class="token operator">=</span> <span class="token number">19</span><span class="token punctuation">;</span><br>    <span class="token function">report</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The following code demonstrates testing whether a variable with an optional type is currently set to null without unwrapping the value.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">if</span> <span class="token punctuation">(</span>variable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// code goes here</span><br><span class="token punctuation">}</span></code></pre><h3 id="switch-expressions" tabindex="-1">switch Expressions</h3><p>The syntax for <code>switch</code> expressions is a bit different than in C <code>switch</code> statements.</p><p>Cases are referred to as &quot;branches&quot;. Branches can match a single value, a list of values, or a range of values. These are followed by the <code>=&gt;</code> operator which is followed by an expression, a statement, or a block of code.</p><p>It must be possible to coerce all branch values to a common type. Supported branch value types include numbers and enums. Switching on strings is not supported.</p><p>Here is an example that demonstrates all the branch options:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token comment">// The value of the first argument to print must be known at compile time.</span><br><span class="token keyword">fn</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">comptime</span> text<span class="token punctuation">:</span> <span class="token class-name"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token builtin-type keyword">u8</span></span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token function">print</span><span class="token punctuation">(</span>text <span class="token operator">++</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token comment">// prng is short for pseudo random number generator.</span><br>    <span class="token keyword">var</span> prng <span class="token operator">=</span> std<span class="token punctuation">.</span>rand<span class="token punctuation">.</span>DefaultPrng<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token label">blk</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><br>        <span class="token keyword">var</span> seed<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">u64</span></span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><br>        <span class="token comment">// try can only be used inside a function.</span><br>        <span class="token keyword">try</span> std<span class="token punctuation">.</span>os<span class="token punctuation">.</span><span class="token function">getrandom</span><span class="token punctuation">(</span>std<span class="token punctuation">.</span>mem<span class="token punctuation">.</span><span class="token function">asBytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>seed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">break</span> <span class="token punctuation">:</span><span class="token label">blk</span> seed<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Generate a random integer from 1 to 3.</span><br>    <span class="token keyword">const</span> value <span class="token operator">=</span> prng<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intRangeAtMost</span><span class="token punctuation">(</span><span class="token builtin-type keyword">u8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"value = {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token number">1</span> <span class="token operator">=></span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>        <span class="token comment">// Double-dot ranges have an exclusive upper bound.</span><br>        <span class="token comment">// Triple-dot ranges have an inclusive upper bound.</span><br>        <span class="token number">2</span><span class="token operator">...</span><span class="token number">5</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">// braces are only required for multiple statements</span><br>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"two to five"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>        <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"six, eight, or ten"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>        <span class="token comment">// The else branch must be specified</span><br>        <span class="token comment">// unless the other branches are exhaustive.</span><br>        <span class="token keyword">else</span> <span class="token operator">=></span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"other"</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of a <code>switch</code> expression used to obtain a value:</p><pre class="language-zig"><code class="language-zig">    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token number">1</span> <span class="token operator">=></span> <span class="token string">"single"</span><span class="token punctuation">,</span><br>        <span class="token number">2</span> <span class="token operator">=></span> <span class="token string">"couple"</span><span class="token punctuation">,</span><br>        <span class="token number">3</span> <span class="token operator">=></span> <span class="token string">"few"</span><span class="token punctuation">,</span><br>        <span class="token keyword">else</span> <span class="token operator">=></span> <span class="token string">"many"</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"result = {s}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here is an example of switching on an <code>enum</code> value. The <code>else</code> branch is not needed because the branches are exhaustive.</p><pre class="language-zig"><code class="language-zig">    <span class="token keyword">const</span> <span class="token class-name">Color</span> <span class="token operator">=</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span> red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">var</span> favorite <span class="token operator">=</span> Color<span class="token punctuation">.</span>blue<span class="token punctuation">;</span><br>    <span class="token comment">// var favorite: Color = .blue; // alternate syntax</span><br>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>favorite<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token punctuation">.</span>red <span class="token operator">=></span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hot"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token punctuation">.</span>green <span class="token operator">=></span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"warm"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token punctuation">.</span>blue <span class="token operator">=></span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"cold"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span></code></pre><h3 id="while-expressions" tabindex="-1">while Expressions</h3><p>The syntax for <code>while</code> expressions is nearly identical to that of C <code>while</code> statements.</p><p>Here are examples of <code>while</code> expressions that demonstrate using the <code>break</code> and <code>continue</code> statements which can optionally be followed by a label to jump to an outer loop.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> value<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">u8</span></span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This loop outputs 1, 2, 3.</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>    <span class="token comment">// This loop outputs 1, 2, 4, 5.</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><br><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>A <code>while</code> expression can be used like a <code>C</code> <code>for</code> loop where a single update is specified in a second pair of parentheses (referred to as a &quot;continue expression&quot;) that is separated from the first pair with a colon. Here is an example.</p><pre class="language-zig"><code class="language-zig">    value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token comment">// This loop outputs 1, 2, 3.</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span></code></pre><p>If the condition passed to a <code>while</code> expression evaluates to <code>null</code>, the loop exits. This can be used to iterate over the return values of a function that has a optional return type. Here is an example:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token keyword">var</span> counter<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">u8</span></span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">fn</span> <span class="token function">nextCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">?</span><span class="token builtin-type keyword">u8</span></span> <span class="token punctuation">{</span><br>    counter <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> counter<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token comment">// This loop terminates when the nextCounter function returns null.</span><br>    <span class="token comment">// It outputs 2, 4, 6.</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">nextCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span>c<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>A <code>while</code> expression can be used to obtain a value. The value is specified by a <code>break</code> statement with a value. If it is possible for the loop to exit without hitting a <code>break</code> statement, add an <code>else</code> clause to specify the value. The <code>else</code> clause is only evaluated if the loop does not <code>break</code>. Here is an example:</p><pre class="language-zig"><code class="language-zig">    value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>    <span class="token comment">// result is "triple" if value starts a 1</span><br>    <span class="token comment">// and "not found" if value starts at 0.</span><br>    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token string">"triple"</span><span class="token punctuation">;</span><br>        value <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token string">"not found"</span><span class="token punctuation">;</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"result = {s}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>A <code>while</code> expression can catch errors when its expression evaluates to an error. The <code>else</code> clause is only evaluated if an error occurs. Here is an example:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token comment">// TODO: Can errors contain associated data?</span><br><span class="token keyword">const</span> FetchError <span class="token operator">=</span> <span class="token keyword">error</span><span class="token punctuation">{</span>TooBig<span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">var</span> count<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">u8</span></span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">fn</span> <span class="token function">fetchCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name">FetchError<span class="token operator">!</span><span class="token builtin-type keyword">u8</span></span> <span class="token punctuation">{</span><br>    count <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">)</span> FetchError<span class="token punctuation">.</span>TooBig <span class="token keyword">else</span> count<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token comment">// This loop terminates when the fetchCount function returns an error.</span><br>    <span class="token comment">// It outputs 2, 4, 6 followed by "error.TooBig".</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fetchCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span>c<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token operator">|</span>err<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"err = {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>err<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h3 id="for-expressions" tabindex="-1">for Expressions</h3><p>The syntax for <code>for</code> expressions is very different from C <code>for</code> statements. They can be used in several ways.</p><p>A <code>for</code> expression can iterate over the items in an array or slice. Here is an example.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token comment">// Create an array of numbers.</span><br>    <span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token class-name"><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token builtin-type keyword">u8</span></span><span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This loop outputs all the numbers.</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">)</span> <span class="token operator">|</span>number<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>number<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Create a slice from an inclusive index to an exclusive index.</span><br>    <span class="token keyword">const</span> slice <span class="token operator">=</span> numbers<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This loop outputs 20, 30, 40</span><br>    <span class="token comment">// which are the numbers at index 1, 2, and 3.</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>slice<span class="token punctuation">)</span> <span class="token operator">|</span>number<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>number<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>A <code>for</code> expression can iterate over a range of integers. Here is an example:</p><pre class="language-zig"><code class="language-zig">    <span class="token comment">// Iterate over a range of numbers where</span><br>    <span class="token comment">// the first is included and the last is not.</span><br>    <span class="token comment">// This loop outputs 10, 11, 12, 13, 14, but not 15.</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">..</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">|</span>number<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>number<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span></code></pre><p>A <code>for</code> expression can iterate over any number of arrays and slices at the same time. Each must have the same length. Here is an example:</p><pre class="language-zig"><code class="language-zig">    <span class="token keyword">const</span> letters <span class="token operator">=</span> <span class="token string">"ABCDE"</span><span class="token punctuation">;</span><br>    <span class="token comment">// This loop outputs the ASCII code of each letter</span><br>    <span class="token comment">// followed by the number at the same index.</span><br>    <span class="token comment">// The letters and numbers arrays must have the same length.</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>letters<span class="token punctuation">,</span> numbers<span class="token punctuation">)</span> <span class="token operator">|</span>letter<span class="token punctuation">,</span> number<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} - {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span> letter<span class="token punctuation">,</span> number <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span></code></pre><p>An open-ended range starting from zero can be iterated over at the same time as other arrays or slices. Here is an example that outputs the index of each value in the `numbers`` array along with the corresponding number:</p><pre class="language-zig"><code class="language-zig">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">..</span><span class="token punctuation">,</span> numbers<span class="token punctuation">)</span> <span class="token operator">|</span>index<span class="token punctuation">,</span> number<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} - {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span> index<span class="token punctuation">,</span> number <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span></code></pre><p>To mutate array or slice items in a loop, iterate over pointers to the items. Here is an example:</p><pre class="language-zig"><code class="language-zig">    <span class="token keyword">var</span> mutable <span class="token operator">=</span> <span class="token class-name"><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token builtin-type keyword">u8</span></span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>mutable<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">*</span>item<span class="token operator">|</span> <span class="token punctuation">{</span><br>        item<span class="token operator">.*</span> <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// doubles</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">const</span> expected <span class="token operator">=</span> <span class="token class-name"><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token builtin-type keyword">u8</span></span><span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token comment">// If this fails, the output is "error: TestExpectedEqual"</span><br>    <span class="token comment">// followed by a stack trace.</span><br>    <span class="token comment">// It does not indicate which items are not equal.</span><br>    <span class="token keyword">try</span> std<span class="token punctuation">.</span>testing<span class="token punctuation">.</span><span class="token function">expectEqualSlices</span><span class="token punctuation">(</span><span class="token builtin-type keyword">u8</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutable<span class="token punctuation">,</span> <span class="token operator">&amp;</span>expected<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>A <code>for</code> expression can be used to obtain a value. The value is specified by a <code>break</code> statement with a value. If it is possible for the loop to exit without hitting a <code>break</code> statement, add an <code>else</code> clause to specify the value. The <code>else</code> clause is only evaluated if the loop does not <code>break</code>. Here is an example:</p><pre class="language-zig"><code class="language-zig">    <span class="token comment">// result is "triple" if the range starts a 1</span><br>    <span class="token comment">// and "not found" if the range starts at 0.</span><br>    <span class="token comment">// It seems "for" expressions can use double-dot ranges,</span><br>    <span class="token comment">// but not triple-dot ranges. Why?</span><br>    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token string">"triple"</span><span class="token punctuation">;</span><br>        value <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token string">"not found"</span><span class="token punctuation">;</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"result = {s}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Like <code>while</code> expressions, <code>for</code> expressions can use <code>break</code> and <code>continue</code> statements which can optionally be followed by a label to jump to an outer loop.</p><h2 id="error-handling" tabindex="-1">Error Handling</h2><p>Errors are represented by enum values. TODO: Can they carry additional data?</p><p>TODO: Add more detail here!</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><br><span class="token keyword">const</span> DemoError <span class="token operator">=</span> <span class="token keyword">error</span><span class="token punctuation">{</span>Demo<span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">fn</span> <span class="token function">demo</span><span class="token punctuation">(</span>good<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">bool</span></span><span class="token punctuation">)</span> <span class="token class-name">DemoError<span class="token operator">!</span><span class="token builtin-type keyword">u8</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>good<span class="token punctuation">)</span> <span class="token number">19</span> <span class="token keyword">else</span> DemoError<span class="token punctuation">.</span>Demo<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Only need ! in return type if errors are not caught.</span><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token comment">// Not catching possible errors.</span><br>    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"result = {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Catching possible errors.</span><br>    <span class="token comment">// result = demo(false) catch |err| {</span><br>    result <span class="token operator">=</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword">catch</span> <span class="token operator">|</span>err<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"err = {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>err<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">return</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"result = {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="unreachable-code-paths" tabindex="-1">Unreachable Code Paths</h2><p>The <code>unreachable</code> statement asserts that a code path should never be reached. This calls the builtin <code>panic</code> function with the message &quot;reached unreachable code&quot; which terminates the application and outputs a stack trace.</p><h2 id="functions" tabindex="-1">Functions</h2><h2 id="standard-library" tabindex="-1">Standard Library</h2><p>TODO: Add detail here.</p><h2 id="structs" tabindex="-1">Structs</h2><p>A <code>struct</code> is a custom type that holds a collection of fields and optional methods. Here is an example:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> sqrt <span class="token operator">=</span> std<span class="token punctuation">.</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">;</span><br><span class="token keyword">const</span> expect <span class="token operator">=</span> std<span class="token punctuation">.</span>testing<span class="token punctuation">.</span>expect<span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function">square</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">f32</span></span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">f32</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> std<span class="token punctuation">.</span>math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token builtin-type keyword">f32</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> <span class="token class-name">Point</span> <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">f32</span></span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">f32</span></span><span class="token punctuation">,</span><br><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">distanceToOrigin</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">f32</span></span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">square</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">square</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">distanceTo</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">f32</span></span> <span class="token punctuation">{</span><br>        <span class="token keyword">const</span> dx <span class="token operator">=</span> self<span class="token punctuation">.</span>x <span class="token operator">-</span> other<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>        <span class="token keyword">const</span> dy <span class="token operator">=</span> self<span class="token punctuation">.</span>y <span class="token operator">-</span> other<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>        <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">square</span><span class="token punctuation">(</span>dx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">square</span><span class="token punctuation">(</span>dy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">test</span> <span class="token string">"Point struct"</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">distanceToOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">distanceTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>Point<span class="token punctuation">.</span><span class="token function">distanceTo</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Iterating over struct fields:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> my_val <span class="token operator">=</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">inline</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token punctuation">.</span>meta<span class="token punctuation">.</span><span class="token function">fields</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span>something<span class="token operator">|</span> <span class="token punctuation">{</span><br>        std<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token builtin">@field</span> <span class="token punctuation">(</span>my_val<span class="token punctuation">,</span> something <span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>A struct responsible for managing its own memory:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">pub</span> <span class="token keyword">const</span> <span class="token class-name">PathManager</span> <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    paths<span class="token punctuation">:</span> std<span class="token punctuation">.</span><span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token builtin-type keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    allocator<span class="token punctuation">:</span> <span class="token class-name">std<span class="token punctuation">.</span>mem<span class="token punctuation">.</span>Allocator</span><span class="token punctuation">,</span><br><br>    <span class="token comment">// ...</span><br><br>    <span class="token keyword">fn</span> <span class="token function">appendFilePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span> <span class="token class-name"><span class="token operator">*</span>PathManager</span><span class="token punctuation">,</span> path<span class="token punctuation">:</span> <span class="token class-name"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token builtin-type keyword">u8</span></span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>        <span class="token keyword">const</span> dir <span class="token operator">=</span> std<span class="token punctuation">.</span>fs<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">const</span> file <span class="token operator">=</span> <span class="token keyword">try</span> dir<span class="token punctuation">.</span><span class="token function">openFile</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token punctuation">.</span>read _only <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">const</span> metadata <span class="token operator">=</span> <span class="token keyword">try</span> file<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>metadata<span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            std<span class="token punctuation">.</span>fs<span class="token punctuation">.</span>File<span class="token punctuation">.</span>Kind<span class="token punctuation">.</span>file <span class="token operator">=></span> <span class="token punctuation">{</span><br>                <span class="token keyword">const</span> abs_path <span class="token operator">=</span> <span class="token keyword">try</span> dir<span class="token punctuation">.</span><span class="token function">realpathAlloc</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>allocator<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><br>                <span class="token keyword">errdefer</span> self<span class="token punctuation">.</span>allocator<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">)</span><span class="token punctuation">;</span><br>                <span class="token keyword">try</span> self<span class="token punctuation">.</span>paths<span class="token punctuation">.</span><span class="token function">append</span> <span class="token punctuation">(</span>abs_path<span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><span class="token punctuation">,</span><br>            std<span class="token punctuation">.</span>fs<span class="token punctuation">.</span>File<span class="token punctuation">.</span>Kind<span class="token punctuation">.</span>directory <span class="token operator">=></span> <span class="token punctuation">{</span><br>                <span class="token keyword">var</span> next_dir <span class="token operator">=</span> <span class="token keyword">try</span> dir<span class="token punctuation">.</span><span class="token function">openIterableDir</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                <span class="token keyword">defer</span> next_dir<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                <span class="token keyword">var</span> iter <span class="token operator">=</span> next_dir<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">try</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span>entry<span class="token operator">|</span> <span class="token punctuation">{</span><br>                    <span class="token keyword">const</span> next_path <span class="token operator">=</span> <span class="token keyword">try</span> std<span class="token punctuation">.</span>fs<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>allocator<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name"><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token builtin-type keyword">u8</span></span><span class="token punctuation">{</span> path<span class="token punctuation">,</span> entry<span class="token punctuation">.</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                    <span class="token keyword">defer</span> self<span class="token punctuation">.</span>allocator<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>next_path<span class="token punctuation">)</span><span class="token punctuation">;</span><br>                    <span class="token keyword">try</span> self<span class="token punctuation">.</span><span class="token function">appendFilePaths</span><span class="token punctuation">(</span>next_path<span class="token punctuation">)</span><span class="token punctuation">;</span><br>                <span class="token punctuation">}</span><br>            <span class="token punctuation">}</span><span class="token punctuation">,</span><br>            <span class="token keyword">else</span> <span class="token operator">=></span> <span class="token keyword">return</span><span class="token punctuation">,</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Using the custom struct above:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> allocator <span class="token operator">=</span> std<span class="token punctuation">.</span>heap<span class="token punctuation">.</span>page_allocator<span class="token punctuation">;</span><br>    <span class="token keyword">var</span> manager <span class="token operator">=</span> <span class="token keyword">try</span> PathManager<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>allocator<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name"><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token builtin-type keyword">u8</span></span><span class="token punctuation">{</span> <span class="token string">"src"</span><span class="token punctuation">,</span> <span class="token string">"test"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">defer</span> manager<span class="token punctuation">.</span><span class="token function">deinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>TODO: Add an example of a generic struct using <code>comptime</code>.</p><h3 id="arraylist" tabindex="-1">ArrayList</h3><p>The <a href="https://ziglang.org/documentation/master/std/#A;std:ArrayList?v=1.0.22" rel="noopener" target="_blank">ArrayList</a> data structure is &quot;a contiguous, growable list of items in memory.&quot;</p><p>Instances of <code>ArrayList</code> have the fields <code>items</code>, <code>capacity</code>, and <code>allocator</code>. Instances have the methods <code>append</code>, <code>appendSlice</code>, <code>clone</code>, <code>deinit</code>, <code>getLast</code>, <code>getLastOrNull</code>, <code>init</code>, <code>insert</code>, <code>insertSlice</code>, <code>orderedRemove</code>, <code>pop</code>, <code>popOrNull</code>, <code>replaceRange</code>, <code>writer</code>, and many more.</p><p>Here is an example that creates an <code>ArrayList</code> instance, adds items to it, and iterates over them.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> print <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><span class="token keyword">const</span> allocator <span class="token operator">=</span> std<span class="token punctuation">.</span>heap<span class="token punctuation">.</span>page_allocator<span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> list <span class="token operator">=</span> std<span class="token punctuation">.</span><span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token builtin-type keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">defer</span> list<span class="token punctuation">.</span><span class="token function">deinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// frees when function exits</span><br>    <span class="token comment">// The append method can return an error if the allocator</span><br>    <span class="token comment">// cannot allocate enough memory for the item being added.</span><br>    <span class="token keyword">try</span> list<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> list<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This loop outputs 19 and 21.</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token operator">|</span>value<span class="token operator">|</span> <span class="token punctuation">{</span><br>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h3 id="hashmap" tabindex="-1">HashMap</h3><p>The <a href="https://ziglang.org/documentation/master/std/#A;std:HashMap?v=1.0.22" rel="noopener" target="_blank">HashMap</a> data structure is a collection of key/value pairs.</p><p>TODO: Add an example.</p><h3 id="multiarraylist" tabindex="-1">MultiArrayList</h3><p>The <a href="https://ziglang.org/documentation/master/std/#A;std:MultiArrayList?v=1.0.22" rel="noopener" target="_blank">MultiArrayList</a> data structure &quot;stores a list of a struct or tagged union type&quot;. &quot;Instead of storing a single list of items, MultiArrayList stores separate lists for each field of the struct or lists of tags and bare unions.&quot;</p><p>TODO: Add an example.</p><h2 id="tests-in-code" tabindex="-1">Tests in Code</h2><p>Unit tests can be included in source files in order to test the functions they define.</p><p>Each test is described by the <code>test</code> keyword followed by a function name or a test description string and a block of code that uses the <code>expect</code> function to make assertions.</p><p>Tests are executed by running <code>zig test {file-name}.zig</code>.</p><p>Here is a basic example:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> expect <span class="token operator">=</span> std<span class="token punctuation">.</span>testing<span class="token punctuation">.</span>expect<span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">i32</span></span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">i32</span></span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">i32</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">test</span> <span class="token class-name">add</span> <span class="token punctuation">{</span> <span class="token comment">// uses a function name</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// passes</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">test</span> <span class="token string">"add works"</span> <span class="token punctuation">{</span> <span class="token comment">// uses a description string</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// passes</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fails</span><br><span class="token punctuation">}</span></code></pre><p>If an <code>expect</code> call fails, its test stops, but other tests are still run. The output includes the following:</p><ul><li>a message of the form &quot;Test [{m}/{n}] test.{test-description}... FAIL (TestUnexpectedResult)&quot; for each failed test</li><li>a stack trace is output that shows the failing <code>expect</code> (only one of them?)</li><li>a summary of the form &quot;{n1} passed; {n2} skipped; {n3} failed&quot;</li></ul><h2 id="stack-example" tabindex="-1">Stack Example</h2><p>This example is based on the Primeagen video at <a href="https://www.youtube.com/watch?v=xIPrwrBAU2c?v=1.0.22" rel="noopener" target="_blank">Zig Data Structure Katas</a>.</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> std <span class="token operator">=</span> <span class="token builtin">@import</span><span class="token punctuation">(</span><span class="token string">"std"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> log <span class="token operator">=</span> std<span class="token punctuation">.</span>debug<span class="token punctuation">.</span>print<span class="token punctuation">;</span><br><span class="token keyword">const</span> Allocator <span class="token operator">=</span> std<span class="token punctuation">.</span>mem<span class="token punctuation">.</span>Allocator<span class="token punctuation">;</span> <span class="token comment">// memory allocator interface</span><br><span class="token keyword">const</span> expect <span class="token operator">=</span> std<span class="token punctuation">.</span>testing<span class="token punctuation">.</span>expect<span class="token punctuation">;</span><br><br><span class="token comment">// This creates a struct that represents</span><br><span class="token comment">// a stack whose values are a given type.</span><br><span class="token keyword">fn</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">comptime</span> T<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">type</span></span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">type</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>        <span class="token keyword">const</span> <span class="token class-name">Node</span> <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span> next<span class="token punctuation">:</span> <span class="token operator">?</span><span class="token operator">*</span>Node <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// Gets the type of the struct we are inside.</span><br>        <span class="token keyword">const</span> Self <span class="token operator">=</span> <span class="token builtin">@This</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        length<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">usize</span></span><span class="token punctuation">,</span><br>        head<span class="token punctuation">:</span> <span class="token class-name"><span class="token operator">?</span><span class="token operator">*</span>Node</span><span class="token punctuation">,</span> <span class="token comment">// optional pointer</span><br>        allocator<span class="token punctuation">:</span> <span class="token class-name">Allocator</span><span class="token punctuation">,</span> <span class="token comment">// passed to init below</span><br><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">init</span><span class="token punctuation">(</span>allocator<span class="token punctuation">:</span> <span class="token class-name">Allocator</span><span class="token punctuation">)</span> <span class="token class-name">Self</span> <span class="token punctuation">{</span><br>            <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>allocator <span class="token operator">=</span> allocator <span class="token punctuation">}</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">deinit</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span> <span class="token class-name"><span class="token operator">*</span>Self</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>            <span class="token keyword">while</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> _ <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            self<span class="token operator">.*</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span> <span class="token class-name"><span class="token operator">*</span>Self</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>            <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token keyword">try</span> self<span class="token punctuation">.</span>allocator<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">;</span><br>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><br>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>head<span class="token punctuation">;</span><br>            self<span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>            self<span class="token punctuation">.</span>head <span class="token operator">=</span> node<span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span> <span class="token class-name"><span class="token operator">*</span>Self</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token operator">?</span>T</span> <span class="token punctuation">{</span><br>            <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token operator">|</span>unwrapped<span class="token operator">|</span> <span class="token punctuation">{</span><br>                <span class="token keyword">defer</span> self<span class="token punctuation">.</span>allocator<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>unwrapped<span class="token punctuation">)</span><span class="token punctuation">;</span><br>                self<span class="token punctuation">.</span>length <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>                self<span class="token punctuation">.</span>head <span class="token operator">=</span> unwrapped<span class="token punctuation">.</span>next<span class="token punctuation">;</span><br>                <span class="token keyword">return</span> unwrapped<span class="token punctuation">.</span>value<span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><br>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">print</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span> <span class="token class-name"><span class="token operator">*</span>Self</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>            <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"\nStack length is {}.\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>self<span class="token punctuation">.</span>length<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token keyword">var</span> node <span class="token operator">=</span> self<span class="token punctuation">.</span>head<span class="token punctuation">;</span><br>            <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">|</span>unwrapped<span class="token operator">|</span> <span class="token punctuation">{</span><br>                <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"=> {}\n"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>unwrapped<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                node <span class="token operator">=</span> unwrapped<span class="token punctuation">.</span>next<span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">test</span> <span class="token string">"stack"</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> IntStack <span class="token operator">=</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token builtin-type keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">var</span> stack <span class="token operator">=</span> IntStack<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>std<span class="token punctuation">.</span>testing<span class="token punctuation">.</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">defer</span> stack<span class="token punctuation">.</span><span class="token function">deinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">try</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">try</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    stack<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output is suppressed in tests</span><br><br>    <span class="token keyword">var</span> value <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    value <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    value <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token function">expect</span><span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="cleanup-everything-below-here!" tabindex="-1">CLEANUP EVERYTHING BELOW HERE!</h2><p>assignment syntax: [const|var] identifier[: type] = value; Can omit the type if it can be inferred from the value.</p><p>@as performs an explicit type coercion. const inferred_constant = @as(i32, 5); var inferred_variable = @as(u32, 5000);</p><p>Prefer const.</p><p>Value can be undefined if not known yet. Does the compiler enforce that it is set before it is used?</p><p>const array = [_]u8{ 'h', 'e', 'l', 'l', ‘o’]; This shows declaring an array where the length is inferred from the initial elements.</p><p>Arrays have a len field.</p><p>if condition must evaluate to a boolean. There are no other truths or falsely values.</p><p>expect must be called with try and takes a single boolean value.</p><p>When a while loop condition is an optional variable, does the capture in pipes comes before the optional colon and continue expression?</p><p>To call a function that returns a value and not use it, assign to _.</p><p>Function parameters are immutable.</p><p>Convention is to use snake case for variables and snake case for function names.</p><p>.{} makes a literal that's either an array literal or struct literal. Strings are just arrays too. There are no vararg functions in Zig, so functions that would be varargs in other languages take this kind of literal instead.</p><p>Using a for loop to modify array items:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">anyerror</span><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token punctuation">[</span>_Jus <span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>string<span class="token punctuation">)</span> \<span class="token operator">*</span>character<span class="token operator">|</span> <span class="token punctuation">{</span><br>        std<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{c}"</span><span class="token punctuation">,</span> •<span class="token punctuation">{</span>character<span class="token punctuation">.</span> <span class="token operator">*</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        character<span class="token operator">.*</span> <span class="token operator">=</span> <span class="token char">'d'</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token operator">|</span>character<span class="token operator">|</span> <span class="token punctuation">{</span><br>        std<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{c}"</span><span class="token punctuation">,</span> •<span class="token punctuation">{</span>character<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Can functions be defined like this? <code>const theFunc = fn() void { ... }</code></p><p>Example of a tagged union:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> <span class="token class-name">Tagged</span> <span class="token operator">=</span> <span class="token keyword">union</span> <span class="token punctuation">(</span>Tag<span class="token punctuation">)</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">u8</span></span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">f32</span></span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token builtin-type keyword">bool</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">anyerror</span><span class="token operator">!</span><span class="token builtin-type keyword">void</span></span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token class-name">Tagged</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">1.5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token punctuation">.</span>a <span class="token operator">=></span> <span class="token operator">|</span>×<span class="token operator">|</span> std<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"a: {}"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token punctuation">.</span>b <span class="token operator">=></span> <span class="token operator">|</span>x<span class="token operator">|</span> std<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"b: {}"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token punctuation">.</span>c <span class="token operator">=></span> <span class="token operator">|</span>x<span class="token operator">|</span> std<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"c: ("</span> <span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Do switch branch ranges require three dots and slice ranges require two dots? Runtime safety includes array bounds checking, … To get a pointer to the data of a variable, use &amp;var. To dereference a pointer, use var.<em>; his syntax can be used with chaining with the value is a struct; ex. personPtr.</em>.firstName ? When the value of a non-const pointer is a number, shorthand operators can be used to modify the value; ex. numPtr.* += 1; The values of const pointers cannot be modified. To use a for loop to iterate over an array (not a slice), do you have to dereference it with &amp; to turn it into a slice? arr[n..] returns a slice from index n to the end. Can create a slice from an array, another slice, or a. multi-pointer (define). Use @enumToInt(enumValue) to get its ordinal value. Enum definitions can contain const and var variables that become namespaced to the enum type, and not associated with individual instances. Can enum instances have associated data? I think not. Generally want to define types like a enums at the global scope instead of inside a function.</p><p>Are strings just byte slices?</p><p>Each enum ordinal value is the previous plus one unless specified. enums can define methods that can be called on instances. Can call on an instance OR pass an instance to it. An enum type can be inferred; ex. Color.red vs. .red</p><p>In a type definition, can refer to the type with @This()</p><p>Knows how to print struct instances with an empty format specifier. Struct Fields can be given default values. Structs can define methods.</p><p>std.debug.print or <a href="http://std.log.info">std.log.info</a> ? What else can output to stdout?</p><p>Zig Software Foundation is a non-profit organization dedicated to improving the craft of software engineering as a whole.</p><p>Zig is a C/C++ compiler toolchain and build system that can be used to simplify maintenance of your existing projects.</p><p>Zig is a simple, powerful programming language that excels in the most demanding environments.</p><p>defer allows specifying freeing of memory immediately after it is allocated. defer runs when its block exits, not only when a function exits</p><p>Work on zig started in August 2015 - first commit.</p><p>About pointer dereference syntax ... &quot;&quot;&quot; ident.* does seem weird at first glance, but it allows for much nicer chaining - instead of something like (*foo).bar (or even doing what C does and introducing a whole new operator -&gt; for that special case), you can just do foot.bar, and the nice thing is that it works over multiple levels of indirection (even in C before I've had to do (*foo)-&gt;bar). Regarding ], I assume you're talking about the calls to <a href="http://std.log.info">std.log.info</a>. Those are creating empty tuples for the format arguments - <a href="http://std.log.info">std.log.info</a> takes two arguments, a format string and a tuple of the values to interpolate into it, much like e.g. printf in C. Quite often in the video he actually uses {×} to specify a format argument. An alternative syntax here would be to use varargs</p><p>in an earlier phase of its design Zig did have varargs, and they were used here, but for a few reasons it was decided to remove them from the language and replace them with tuples in cases like these. Yes, it results in a few extra characters when you're logging constant messages, but in practice that's not really an issue, and removing varargs had advantages for the language from the perspective of simplicity.</p><p>I don't know why this chaining you consider to be better. To me, it's just different, not better or worse. And bringing confusion without having significan... Read more</p><p>how do you consider (<em>foo) -&gt;bar (or worse, (</em>(*foo)).bar) to be better than foo.** bar? This situation can get even worse with more complex structures, &quot;&quot;&quot;</p><p>Learn about async/await. Zig strives for having only one way to accomplish each task. Learn about arena allocators.</p><ul><li>Functions can specify the type of errors they can return by preceding the ! in the return type with an error type or probably an error set.</li><li>Precede function return types with ? if null can be returned.</li><li>Investigate Zig string libraries.</li><li>does it always catch when memory is not freed?</li><li>supports low-level memory control using allocators<ul><li>page_allocator, c_allocator, ArenaAllocator, FixedBufferAllocator, GeneralPurposeAllocator, std.testing.allocator</li></ul></li><li>not memory-safe like Rust</li><li>no operator overloading</li><li>no exceptions; functions that can fail must return an error value (typically an enum?)</li><li>comptime blocks run at compile time; takes the place of preprocessor directives and macros</li><li>comptime variables are initialized at compile time</li><li>has a builtin testing framework that uses the <code>test</code> keyword followed by a description string and a block of code that implements the test; enter <code>zig test {file-path}</code> to run the tests in a given file</li><li><code>zig cc</code> is an alternate C/C++ compiler<ul><li>can build a platform-specific executable for the current platform</li><li>can build an executable for a specified platform</li><li>can find bugs that standard C/C++ compilers do not</li></ul></li></ul><p>From <a href="http://ziglearn.org">ziglearn.org</a>:</p><p>Blocks in Zig are expressions and can be given labels, which are used to yield values. Here, we are using a label called blk. Blocks yield values, meaning that they can be used in place of a value. The value of an empty block + is a value of the type void</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">test</span> <span class="token string">"labelled blocks"</span><br>    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token label">bik</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><br>        <span class="token keyword">var</span> sum<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">u32</span></span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>        <span class="token keyword">var</span> i<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">u32</span></span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> sum <span class="token operator">+=</span> i<span class="token punctuation">;</span><br>        <span class="token keyword">break</span> blk sum<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">expect</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">expect</span> <span class="token punctuation">(</span><span class="token builtin">@Type0f</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin-type keyword">u32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>This can be seen as being equivalent to C's i++.</p><pre class="language-zig"><code class="language-zig"><span class="token label">blk</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> tmp <span class="token operator">=</span> i<span class="token punctuation">;</span><br>    i <span class="token operator">+=</span> <span class="token number">1</span><br>    <span class="token keyword">break</span> <span class="token punctuation">:</span><span class="token label">blk</span> tmp<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Are these the same return types? !i32 anyerror!i32</p><p>Learn about anonymous structs. Can they be used like JavaScript objects.</p><p>Printing type names:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">try</span> allocator<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token builtin-type keyword">u8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">try</span> allocator<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token builtin-type keyword">u8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> m3 <span class="token operator">=</span> <span class="token keyword">try</span> allocator<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token builtin-type keyword">u8</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>std<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{s}"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token builtin">@typeName</span> <span class="token punctuation">(</span><span class="token builtin">@Type0f</span><span class="token punctuation">(</span>m3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>See zig-arena-allocator.jpg in Downloads.</p><p>Lambdas are not supported, but there aren't often needed in Zig. You can do something like this instead with a struct:</p><pre class="language-zig"><code class="language-zig"><span class="token keyword">var</span> map <span class="token operator">=</span> std<span class="token punctuation">.</span><span class="token function">StringArrayHashMap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token builtin-type keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">defer</span> map<span class="token punctuation">.</span><span class="token function">deinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">try</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">try</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">try</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> <span class="token class-name">SortContext</span> <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    keys<span class="token punctuation">:</span> <span class="token class-name"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token builtin-type keyword">u8</span></span><span class="token punctuation">,</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">lessThan</span><span class="token punctuation">(</span>ctx<span class="token punctuation">:</span> <span class="token builtin">@This</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a_index<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">usize</span></span><span class="token punctuation">,</span> b_index<span class="token punctuation">:</span> <span class="token class-name"><span class="token builtin-type keyword">usize</span></span><span class="token punctuation">)</span> <span class="token class-name"><span class="token builtin-type keyword">bool</span></span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> std<span class="token punctuation">.</span>mem<span class="token punctuation">.</span><span class="token function">lessThan</span><span class="token punctuation">(</span><span class="token builtin-type keyword">u8</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>a_index<span class="token punctuation">]</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>b_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>map<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">SortContext</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>keys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keys</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>See zig-error-with-associated-data.jpg in Downloads.</p><p>See zig-struct-with-method.png in Downloads. See zig-struct-with-method-calling-2-ways.png in Downloads. See zig-generics.jpg in Downloads. See zip-enum-and-associated-data.jpg in Downloads.</p><p>Demonstrate calling your own C and C++. ode from Zig. No support for interfaces. Errors cannot hold associated data. Use out parameters. Can transpile Zig to C. having a trailing comma after the last field in a struct changes how zig formats the code. It will keep each field on a separate line. If you remove the trailing comma from the last field, and all the fields will fit on a single line, then the formatter will do that.</p><p>To create a new library, enter <code>zip init-lib</code>.</p><p>Data types include u8 (single byte unsigned integer), … Strings are delimited with double quotes.</p><p>The <code>defer</code> keyword specifies a function to be called when the function it is inside exits. This is often used to deallocate memory allocated on the line before. For example, <code>var allocator = std.heap.page_allocator; var myList = std.ArrayList(10).init(allocator); defer myList.deinit();</code> Also see <code>errdefer</code> which specifies a function to call if an error occurs in the current scope.</p><p>Constant and variable declarations must be initialized to some value. When can the type be inferred from the initial value? If the initial value is “undefined” (means uninitialized), does the compiler enforce that it is assigned before it is used? I assume this is different from making it nullable with a “?” before the type.</p><p>To declare an array,</p><ul><li>can be const or var</li><li>number of elements comes first, then the type, then the initial values in curly braces</li><li>ex. const name = [3]i32{10, 20, 30};</li><li>ex. var name = [_]i32{10, 20, 30}; // length is inferred from initial values</li></ul><p>Zig standard library</p><ul><li>document this</li></ul><p>Primitive Values</p><ul><li>null, undefined</li><li>true, false</li></ul><p>Strings</p><ul><li>“String literals are constant single-item points to null-terminated byte arrays.”</li><li>var name = “Mark”;</li><li>dereferencing converts to array of characters</li><li>default encoding is UTF-8</li><li>multi-line string literals precede each line with <code>\\</code></li><li>to iterate over the bytes in a string (characters if ASCII), for (name) |byte| { … }</li><li><ul><li>operator can be used to create a string by concatenating characters; var name = ‘M’ + ‘a’ + ‘r’ + ‘k’</li></ul></li></ul><p>Arrays</p><ul><li>to create an array from a literal, const numbers = [_]u32{ 19, 21, 7 }; // _ indicates not specifying size</li><li>to initialize all elements to same value, const numbers = [_]u32{0} ** 3; // array of 3 zero elements</li><li>use var instead of const to make them mutable</li><li>have a <code>len</code> field</li><li>to get an array element, numbers[1]</li><li>to mutate an array element, numbers[1] = 3;</li><li>++ operator concatenates arrays, returning a new array<ul><li>applies to strings; var name = “Ma” ++ “rk”;</li></ul></li><li>** operator multiplies arrays, returning a new array</li><li>multidimensional arrays are created by nesting arrays<ul><li>var matrix = [3][3]f64 {</li><li>[_]f64{ 1.0, 2.0, 3.0 },</li><li>[_]f64{ 4.0, 5.0, 6.0 },</li><li>[_]f64{ 7.0, 8.0, 9.0 }</li><li>};</li><li>access elements with matrix[row][column]</li><li>iterate over with nested for loops</li><li>for (matrix, 0..) |row, rowIndex| {</li><li>for (row, 0..) |value, columnIndex| {</li><li><pre><code>// use value, rowIndex, and columnIndex here
</code></pre></li><li>}</li><li>}</li></ul></li></ul><p>Slices</p><ul><li>“A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime.”</li><li>like arrays, slices have a <code>len</code> field</li><li>to get a slice from an array, var mySlice = myArray[startIndex..endIndex]; // inclusive?</li><li>access and modify slice elements just like with array elements</li><li>do both perform bounds checking and generate a well-known error when outside?</li></ul><p>Vectors</p><ul><li>sets of primitive values or pointers</li><li>can operate on them in parallel using SIMD instructions if available using standard operators that return a new vector<ul><li>const v1 = @Vector(_, f32){ 1.2, 2.3, 3.4 }; // need to specify length instead of using _?</li><li>const v2 = @Vector(_, f32){ 9.8, 8.7, 7.6 };</li><li>const v3 = v1 + v2;</li></ul></li><li>vectors are compatible with fixed-length arrays with the same length or slices of arrays with the same length; can be assigned to each other</li></ul><p>Enumerations</p><ul><li>to define, const Color = enum { red, green, blue, };</li><li>to use, var color = Color.red;</li><li>to make tag values available, specify the tag type<ul><li>for example: const Color = enum(u8) { red, green, blue, }; // assigns 0, 1, and 2</li></ul></li><li>to define with specific values, const Color = enum(u8) { red = 10, green = 20, blue = 30, };</li></ul><p>Standard Library Data Structures</p><ul><li>ArrayList - “a contiguous, growable list of items in memory”</li><li>AutoArrayHashMap</li><li>AutoArrayHashMapUnmanaged</li><li>StringArrayHashMap</li><li>StringArrayHashMapUnmanaged</li><li>ArrayHashMap</li><li>BufMap</li><li>BufSet - a set of strings</li><li>AutoHashMap</li><li>AutoHashMapUnmanaged</li><li>StringHashMap</li><li>StringHashMapUnmanaged</li><li></li><li>more?</li><li>Set?</li></ul><p>Variables</p><ul><li>can declare at file scope or in function scopes</li><li>variables must be initialized, but an initialize to <code>undefined</code>; ex. <code>var score: u32 = 0; const maxScore = 10;</code></li><li>declare immutable variables with const or mutable variables with var; prefer const when possible</li><li>does it support type inference?</li><li>variable names cannot shadow those in outer scopes</li><li>names must start with a letter and contain letters, numbers, and underscores</li><li>non-conforming names can be used with <code>@“some name”</code></li><li>variables declared outside any function are referred to as “container-level variables”<ul><li>includes variables declared inside struct, union, enum, and opaque (similar to a struct; used for interacting with C code that doesn’t expose field details) definitions (only top-level ones?)</li></ul></li></ul><p>Optionals</p><ul><li>to allow a value to have a specific type or <code>null</code>, precede the type with <code>?</code></li><li>for example, const maybeNumber: ?i32 = null;</li><li>Zig prevents null references by using optional pointers whose usages are checked by the compiler</li><li>the <code>orelse</code> operator unwraps optional values and provides a value to use if it is null<ul><li>const ptr = optionalPtr orelse 0; // assumes optionalPtr is a pointer to an integer</li></ul></li></ul><p>Operators</p><ul><li>+, -, *, /, %</li><li>operator assignment: +=, -=, *=, /=, %/</li><li>bitwise: &lt;&lt;, &gt;&gt;, &amp;, |, ^, ~</li><li>bitwise assignment: &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^=</li><li>orelse, .?</li><li>and (not &amp;&amp;), or (not ||), ! (not not; inconsistent!)</li><li>catch</li><li>==, !=, &gt;, &gt;=, &lt;, &lt;=</li><li>array concatenation with ++</li><li>array multiplication with **</li><li>pointer dereference with .*</li><li>address of with &amp;</li><li>merge error sets with ||</li><li>many wrapping operators</li><li>many saturating operators</li><li>does not support the ++ and — operators found in C</li></ul><p>Structs</p><ul><li>struct types are defined with <code>const SomeName = struct { f1: type1, f2: type2 ,};</code></li><li>struct instances are created with <code>var someInstance = SomeName { .f1 = v1, .f2 = v2, };</code></li><li>anonymous struct syntax alternative: <code>var someInstance: SomeName = .{ .f1 = v1, .f2 = v2 };</code></li><li>can any field value be <code>undefined</code>?</li><li>to define a method in a struct, add a <code>pub</code> function inside its definition</li><li>to define a constant in a struct, add <code>pub const NAME = value;</code></li><li>structs can be used to implement generic functions<ul><li>“A generic data structure is simply a function that returns a type.”</li><li>this example from official docs returns an instance of a dynamically defined struct type for a linked list whose nodes hold values of a given type</li><li>Node is a nested type that is available through the returned type</li><li>fn LinkedList(comptime T: type) type {</li><li>return struct {</li><li><pre><code>// This just declares a type used for the struct fields below.
</code></pre></li><li><pre><code>pub const Node = struct {
</code></pre></li><li><pre><code>  prev: ?*Node, // optional value
</code></pre></li><li><pre><code>  next: ?*Node, // optional value
</code></pre></li><li><pre><code>  value: T
</code></pre></li><li><pre><code>};
</code></pre></li><li><pre><code>first: ?*Node,
</code></pre></li><li><pre><code>last: ?*Node,
</code></pre></li><li><pre><code>length: usize,
</code></pre></li><li>}</li><li>var numberList = LinkedList(i32) { .first = null, .last = null, .length = 0 };</li><li>const NumberList = LinkedList(i32);</li><li>var node = NumberList.Node { .prev = null, .next = null, .value = 19 };</li><li>var numberList = LinkedList(i32) { .first = @node, .last = &amp;node, .length = 1 };</li></ul></li></ul><p>Tuples</p><ul><li>defined by an anonymous struct with no field names</li><li>fields are given names that are integers starting from 0</li><li>access a field value with [index] syntax</li><li>const myTuple = { true, “hello”, @as(u32, 19) };</li><li>myTuple[1] is “hello”</li><li></li></ul><p>Unions</p><ul><li>defines a set of possible types for a value</li><li>const DataType = union { number: i32, truth: bool };</li><li>var data1 = DataType { .number = 19 };</li><li>var data2 = DataType { .truth = true };</li><li>anonymous union syntax alternative: <code>var data2: DataType = .{ .number = 19 };</code></li><li>tagged union types use an enum for their cases and can be used in switch expressions</li><li>const DataTypeTag = enum { number, truth };</li><li>const DataType = union(DataTagType) { number: i32, truth: bool };</li><li>can get the tag type of a union type with std.meta.Tag(DataType) which returns DataTypeTag</li></ul><p>Functions</p><ul><li>parameters are immutable; function bodies cannot modify them</li><li>primitive types are passed by value (copy)</li><li>Zig will decide whether to pass non-primitive types (structs, unions, and arrays) by value or reference based on which it determines is faster</li><li>to force pass by reference, pass a pointer<ul><li>to pass an argument by reference (a pointer), precede with &amp;</li><li>to accept a parameter as a pointer, precede type with *</li></ul></li><li>if there is no return value, the return type is void</li><li>if an error can be returned, precede the return type with !</li><li>to declare, fn someName(p1: type1, p2: type2) returnType { … }</li><li>to make available outside current source file and callable from C, precede with <code>export</code>; is this only for creating libraries?</li><li>to allow other source files to import the function, precede it with <code>pub</code></li><li>to define a type that is a pointer to a function and can be used as a argument type, const myFnType = *const fn (p1: type1, p2: type2) return type;</li><li>variable parameter types and reflection<ul><li>to allow any type of value to be passed as an argument, use <code>anytype</code> for the parameter type</li><li>inside the function, use the builtin function <code>@TypeOf(variableName)</code> to refer to the actual type</li><li>inside the function, use the builtin function <code>@typeInfo(variableName)</code> to get information about the actual type<ul><li>@typeInfo(@TypeOf) returns a std.builtin.Type object</li><li>what are the properties and methods on a Type object?</li></ul></li></ul></li><li>can use reflection to get details about the parameters and return type of a given function with <code>@typeInfo(@TypeOf(someFunction)).Fn</code> which gives an object with the fields <code>params</code> (an array of objects with <code>type</code> and <code>name</code>? fields?) and <code>return_type</code> (a type)</li></ul><p>Blocks</p><ul><li>lines of code surrounded by curly braces that define a variable scope</li><li>labelled blocks are expressions that return a value</li><li>const value = myLabel: { add code to compute value here; break :myLabel value }</li></ul><p>Errors</p><ul><li>The <code>try</code> keyword provides error handling.</li><li>Possible errors cannot be ignored.</li><li>The catch keyword is used to provide a default value for an expression that results in an error. - const number = parseU64(str, 10) catch 0; - can compute value with a labeled block - catch blk: { // do things - break :blk 13; - }; -</li><li>If no <code>catch</code> block is included, the error is returned to the caller</li><li>error sets are similar to enums and describe the errors that can be thrown by functions</li><li>example from official docs<ul><li>const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound };</li><li>const String = [_]u8; // TODO: Is this the proper way to describe a string type?</li><li>fn processFile(filePath: *String) FileOpenError { … }</li></ul></li></ul><p>Type Coercion and Casting</p><ul><li>Add detail on this!</li></ul><p>Memory Management</p><ul><li>Zig does not provide any memory management and has no runtime.</li><li>In C, memory is managed with the functions malloc, free, and realloc. These use a provided memory allocator.</li><li>Zig allows selection of a memory allocation strategy and does not choose a default strategy.</li><li>It is also possible to implement a custom allocator.</li><li>All functions and data structures that allocate memory take an Allocator argument that specifies the strategy to use.</li><li>The C strategy is available as std.heap.c_allocator.</li><li>Other provided allocations include:<ul><li>std.heap.FixedBufferAllocator</li><li>std.heap.ThreadSafeFixedBufferAllocator</li><li>std.heap.ArenaAllocator</li><li>std.testing.Allocator</li><li>std.testing.FailingAllocator</li><li>DESCRIBE EACH OF THESE</li><li>ARE THERE MORE PREDEFINED ALLOCATORS?</li></ul></li></ul><p>Builtin Functions</p><ul><li>list all of these</li><li>Async Functions</li><li>not currently supported, but will be in the future</li></ul><p>noreturn</p><ul><li>the type of functions that never finish</li><li>also the type of break, continue, return, unreachable, and the while construct <code>while (true) { … }</code></li></ul><p>Zig has an official style guide that is not enforced by the compiler</p><ul><li>4-space indentation</li><li>open braces on the same line or the last of wrapped lines</li><li>maximum line length is 100</li><li>function names should be camelCase<ul><li>but functions that return a type should be TitleCase</li></ul></li><li>type names should be TitleCase</li><li>variable names should be snake_case</li><li>names of files that define a struct should have the same name as the struct which uses TitleCase</li><li>all other file names should be snake_case</li><li>directory names should be snake_case</li></ul></article>