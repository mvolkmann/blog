const FIRST_CHAR = 'a-zA-Z_$',
  OTHER_CHAR = FIRST_CHAR + '0-9',
  IDENTIFIER = `[${FIRST_CHAR}][${OTHER_CHAR}]*`,
  REFERENCE_RE = new RegExp(`^this.${IDENTIFIER}$`),
  REFERENCES_RE = new RegExp(`this.${IDENTIFIER}`, 'g'),
  SKIP = 5;
export function createElement(t, e, s) {
  const r = document.createElement(t);
  if (e) for (const [t, s] of Object.entries(e)) r.setAttribute(t, s);
  return s && (r.innerHTML = s), r;
}
const defaultForType = t => (t === Number ? 0 : t !== Boolean && '');
function isPrimitive(t) {
  const e = typeof t;
  return 'string' === e || 'number' === e || 'boolean' === e;
}
function updateAttribute(t, e, s) {
  if (!isPrimitive(s)) return;
  const r = t.getAttribute(e);
  'boolean' == typeof s
    ? s
      ? r !== e && t.setAttribute(e, e)
      : t.removeAttribute(e)
    : r !== s && t.setAttribute(e, String(s));
}
function updateValue(t, e, s) {
  t instanceof CSSRule ? t.style.setProperty(e, s) : updateAttribute(t, e, s);
}
class Wrec extends HTMLElement {
  static #t = new Map();
  static #e = new Map();
  static _template = null;
  static css = '';
  static html = '';
  static formAssociated = !1;
  static processed = !1;
  static properties = {};
  static propToExprsMap = null;
  #s = this.constructor;
  #r = new Map();
  #o;
  #i = null;
  #n = new Map();
  propToParentPropMap = new Map();
  constructor() {
    super(), this.attachShadow({mode: 'open'});
    const t = this.#s;
    t.properties || (t.properties = {});
    let e = WrecIndexed['#propToComputedMap'];
    e || (WrecIndexed['#propToComputedMap'] = new Map()),
      (e = t.propToExprsMap),
      e || (t.propToExprsMap = new Map()),
      t.formAssociated &&
        ((this.#i = this.attachInternals()),
        (this.#o = new FormData()),
        this.#i.setFormValue(this.#o));
  }
  attributeChangedCallback(t, e, s) {
    const r = Wrec.getPropName(t),
      o = this.#a(r, String(s));
    (this[r] = o), this.#p(r, String(o));
  }
  #c(t, e, s, r) {
    t.addEventListener(r, t => {
      const s = t.target;
      this[e] = s.value;
    });
    let o = this.#n.get(e);
    o || ((o = []), this.#n.set(e, o)),
      o.push(s ? {element: t, attrName: s} : t);
  }
  #l() {
    const t = this.#s;
    let e = t._template;
    if (!e) {
      e = t._template = document.createElement('template');
      let s = t.css ? `<style>${t.css}</style>` : '';
      (s += t.html), (e.innerHTML = s);
    }
    this.shadowRoot?.replaceChildren(e.content.cloneNode(!0));
  }
  connectedCallback() {
    this.#h(),
      this.#u(),
      this.#l(),
      requestAnimationFrame(() => {
        this.shadowRoot && (this.#m(this.shadowRoot), this.#d(this.shadowRoot));
        (this.#s.processed = !0), this.#f();
      });
  }
  #f() {
    const t = this.#s,
      {properties: e} = t;
    for (const [t, {computed: s}] of Object.entries(e))
      s && (this[t] = this.#E(s));
  }
  #u() {
    const t = this.#s,
      {observedAttributes: e, properties: s} = t;
    for (const [t, r] of Object.entries(s)) this.#b(t, r, e);
  }
  #b(t, e, s) {
    const r = Wrec.getAttrName(t);
    e.required &&
      !this.hasAttribute(r) &&
      this.#g(this, t, 'is a required attribute');
    const {type: o, value: i} = e,
      n =
        o === Boolean
          ? i || this.hasAttribute(r)
          : s.includes(r) && this.hasAttribute(r)
          ? this.#R(t, r)
          : i || defaultForType(o),
      a = '#' + t;
    (this[a] = n),
      e.computed && this.#A(t, e),
      Object.defineProperty(this, t, {
        enumerable: !0,
        get() {
          return this[a];
        },
        set(s) {
          const i = this[a];
          if (s === i) return;
          this[a] = s;
          const n = WrecIndexed['#propToComputedMap'].get(t) || [];
          for (const [t, e] of n) this[t] = this.#E(e);
          if (isPrimitive(s) && this.hasAttribute(r)) {
            s !== (o === Boolean ? this.hasAttribute(r) : this.#R(t, r)) &&
              updateAttribute(this, t, s);
          }
          this.#v(t);
          const p = this.propToParentPropMap.get(t);
          if (p) {
            this.getRootNode().host[p] = s;
          }
          isPrimitive(s) && this.#p(t, s),
            this.propertyChangedCallback &&
              this.propertyChangedCallback(t, i, s),
            e.dispatch &&
              this.dispatchEvent(
                new CustomEvent('change', {
                  bubbles: !0,
                  composed: !0,
                  detail: {propName: t}
                })
              );
        }
      });
  }
  static elementName() {
    return this.name.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
  }
  #C(t) {
    const e = t instanceof Wrec;
    for (const s of t.getAttributeNames()) {
      const r = t.getAttribute(s),
        o = this.#T(t, r);
      if (o) {
        const r = this[o];
        void 0 === r && this.#x(t, s, o), (t[o] = r);
        let [i, n] = s.split(':');
        'value' === i &&
          (n ? t.setAttribute(i, this[o]) : (n = 'change'),
          this.#c(t, o, i, n)),
          e && t.propToParentPropMap.set(Wrec.getPropName(i), o);
      }
      this.#M(r, t, s);
    }
  }
  #E(expr) {
    return (() => eval(expr)).call(this);
  }
  #N(t) {
    const {localName: e} = t;
    if ('style' === e) {
      const {sheet: e} = t,
        s = e?.cssRules ?? [],
        r = Array.from(s);
      for (const t of r)
        if (t.constructor === CSSStyleRule) {
          const e = Array.from(t.style);
          for (const s of e)
            if (s.startsWith('--')) {
              const e = t.style.getPropertyValue(s);
              this.#M(e, t, s);
            }
        }
    } else {
      let s = t.textContent?.trim() ?? '';
      s ||
        t.childNodes.forEach(t => {
          t.nodeType === Node.COMMENT_NODE &&
            (s += t?.textContent?.trim() ?? '');
        });
      const r = this.#T(t, s);
      'textarea' === e && r
        ? (this.#c(t, r, null, 'change'), (t.textContent = this[r]))
        : this.#M(s, t);
    }
  }
  static getAttrName(t) {
    let e = Wrec.#t.get(t);
    return (
      e ||
        ((e = t.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()),
        Wrec.#t.set(t, e)),
      e
    );
  }
  static getPropName(t) {
    let e = Wrec.#e.get(t);
    return (
      e ||
        ((e = t.replace(/-([a-z])/g, (t, e) => e.toUpperCase())),
        Wrec.#e.set(t, e)),
      e
    );
  }
  #d(t) {
    const e = Array.from(t.querySelectorAll('*'));
    for (const t of e) this.#C(t), t.firstElementChild || this.#N(t);
  }
  static get observedAttributes() {
    return Object.keys(this.properties || {}).map(Wrec.getAttrName);
  }
  #T(t, e) {
    if (!e || !REFERENCE_RE.test(e)) return;
    const s = e.substring(SKIP);
    return void 0 === this[s] && this.#x(t, '', s), s;
  }
  #v(t) {
    const e = this.#s.propToExprsMap.get(t) || [];
    for (const t of e) {
      const e = this.#E(t),
        s = this.#r.get(t) || [];
      for (const t of s)
        t instanceof HTMLElement
          ? this.#w(t, e)
          : updateValue(t.element, t.attrName, e);
    }
    requestAnimationFrame(() => {
      this.#y(t);
    });
  }
  static register() {
    const t = this.elementName();
    customElements.get(t) || customElements.define(t, this);
  }
  #A(t, e) {
    const {computed: s, uses: r} = e,
      o = WrecIndexed['#propToComputedMap'];
    function i(e, s) {
      let r = o.get(e);
      r || ((r = []), o.set(e, r)), r.push([t, s]);
    }
    const n = s.match(REFERENCES_RE) || [];
    for (const e of n) {
      const r = e.substring(SKIP);
      void 0 === this[r] && this.#x(null, t, r),
        'function' != typeof this[r] && i(r, s);
    }
    if (r) for (const t of r.split(',')) i(t, s);
  }
  #M(t, e, s = void 0) {
    if (!t) return;
    const r = this.#P(e, s, t);
    if (!r) {
      const r = t.replaceAll('this..', 'this.');
      return void (s
        ? updateValue(e, s, r)
        : 'textContent' in e && (e.textContent = r));
    }
    const o = this.#s;
    o.processed ||
      r.forEach(e => {
        const s = e.substring(SKIP),
          r = o.propToExprsMap;
        let i = r.get(s);
        i || ((i = []), r.set(s, i)), i.includes(t) || i.push(t);
      });
    let i = this.#r.get(t);
    i || ((i = []), this.#r.set(t, i)),
      i.push(s ? {element: e, attrName: s} : e);
    const n = this.#E(t);
    s ? updateValue(e, s, n) : this.#w(e, n);
  }
  #p(t, e) {
    this.#o && (this.#o.set(t, e), this.#i?.setFormValue(this.#o));
  }
  #g(t, e, s) {
    const r = this.#s,
      o = t instanceof HTMLElement ? t.localName : 'CSS rule';
    throw new Error(
      `component ${r.elementName()}` +
        (t ? `, element "${o}"` : '') +
        (e ? `, attribute "${e}"` : '') +
        ` ${s}`
    );
  }
  #x(t, e, s) {
    this.#g(t, e, `refers to missing property "${s}"`);
  }
  #R(t, e) {
    return this.#a(t, this.getAttribute(e));
  }
  #a(t, e) {
    if (e?.match(REFERENCES_RE)) return e;
    const s = this.#s,
      {type: r} = s.properties[t];
    if (r === String) return e;
    if (r === Number) {
      const s = Number(e);
      if (!isNaN(s)) return s;
      this.#g(null, t, `must be a number, but was "${e}"`);
    }
    if (r === Boolean)
      return (
        'true' === e ||
        ('false' !== e &&
          'null' !== e &&
          (e &&
            e !== t &&
            this.#g(
              null,
              t,
              'is a Boolean attribute, so its value must match attribute name or be missing'
            ),
          e === t))
      );
    this.#g(null, t, 'does not specify its type');
  }
  #y(t) {
    const e = this[t],
      s = this.#n.get(t) || [];
    for (const t of s)
      if (t instanceof HTMLElement)
        'textarea' === t.localName ? (t.value = e) : (t.textContent = e);
      else {
        const {element: s, attrName: r} = t;
        updateAttribute(s, r, e), (s[r] = e);
      }
  }
  #w(t, e) {
    const s = t instanceof HTMLElement,
      r = s ? t.localName : '',
      o = typeof e;
    'string' !== o &&
      'number' !== o &&
      this.#g(t, void 0, ' computed content is not a string or number'),
      'textarea' === r
        ? (t.value = e)
        : s && 'string' === o && e.trim().startsWith('<')
        ? ((t.innerHTML = e), this.#m(t), this.#d(t))
        : s && (t.textContent = e);
  }
  #h() {
    const t = this.#s,
      e = new Set(Object.keys(t.properties));
    for (const t of this.getAttributeNames())
      'id' !== t &&
        (t.startsWith('on') ||
          e.has(Wrec.getPropName(t)) ||
          this.#g(null, t, 'is not a supported attribute'));
  }
  #P(t, e, s) {
    const r = s.match(REFERENCES_RE);
    if (r)
      return (
        r.forEach(s => {
          const r = s.substring(SKIP);
          void 0 === this[r] && this.#x(t, e, r);
        }),
        r
      );
  }
  #m(t) {
    const e = Array.from(t.querySelectorAll('*'));
    for (const t of e) {
      const e = [];
      for (const s of Array.from(t.attributes)) {
        const r = s.name;
        if (r.startsWith('on')) {
          const o = r.slice(2).toLowerCase(),
            i = s.value;
          let n;
          this.#P(t, r, i),
            'function' == typeof this[i]
              ? (n = t => this[i](t))
              : (this.#P(t, r, i), (n = () => this.#E(i))),
            t.addEventListener(o, n),
            e.push(r);
        }
      }
      for (const s of e) t.removeAttribute(s);
    }
  }
}
const WrecIndexed = Wrec;
export default Wrec;
export const css = String.raw;
export const html = String.raw;
