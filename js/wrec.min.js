const CSS_PROPERTY_RE = /([a-zA-Z-]+)\s*:\s*([^;}]+)/g,
  FIRST_CHAR = 'a-zA-Z_$',
  OTHER_CHAR = FIRST_CHAR + '0-9',
  IDENTIFIER = `[${FIRST_CHAR}][${OTHER_CHAR}]*`,
  HTML_COMMENT_TEXT_RE = /<!--\s*(.*?)\s*-->/,
  HTML_ELEMENT_TEXT_RE = /<(\w+)(?:\s[^>]*)?>((?:[^<]|<(?!\w))*?)<\/\1>/g,
  REF_RE = new RegExp(`^this\\.${IDENTIFIER}$`),
  REFS_RE = new RegExp(`this\\.${IDENTIFIER}(\\.${IDENTIFIER})*`, 'g'),
  REFS_TEST_RE = new RegExp(`this\\.${IDENTIFIER}(\\.${IDENTIFIER})*`),
  SKIP = 5;
export function createElement(t, e, s) {
  const o = document.createElement(t);
  if (e) for (const [t, s] of Object.entries(e)) o.setAttribute(t, s);
  return s && (o.innerHTML = s), o;
}
const getPropName = t => t.substring(SKIP).split('.')[0];
function interpolate(t, e) {
  let s = t[0];
  return (
    e.forEach((e, o) => {
      s += e + t[o + 1];
    }),
    s
  );
}
const removeHtmlComments = t => t.replace(/<!--[\s\S]*?-->/g, '');
function replace(t, e, s, o) {
  return t.slice(0, e) + o + t.slice(e + s);
}
function stringToNumber(t) {
  const e = Number(t);
  if (isNaN(e)) throw new Error(`Cannot convert "${t}" to a number.`);
  return e;
}
const defaultForType = t =>
  t === String
    ? ''
    : t === Number
    ? 0
    : t !== Boolean && (t === Array ? [] : t === Object ? {} : void 0);
function isPrimitive(t) {
  const e = typeof t;
  return 'string' === e || 'number' === e || 'boolean' === e;
}
function updateAttribute(t, e, s) {
  if (!isPrimitive(s)) return;
  const o = t.getAttribute(e);
  'boolean' == typeof s
    ? s
      ? o !== e && t.setAttribute(e, e)
      : t.removeAttribute(e)
    : o !== s && t.setAttribute(e, String(s));
}
function updateValue(t, e, s) {
  t instanceof CSSRule ? t.style.setProperty(e, s) : updateAttribute(t, e, s);
}
class Wrec extends HTMLElement {
  static #t = new Map();
  static #e = new Map();
  static css = '';
  static html = '';
  static formAssociated = !1;
  static processed = !1;
  static properties = {};
  static propToComputedMap = null;
  static propToExprsMap = null;
  static template = null;
  #s = this.constructor;
  #o = new Map();
  #r;
  #i = null;
  #n = new Map();
  propToParentPropMap = new Map();
  #a = null;
  #p = new Map();
  constructor() {
    super(), this.attachShadow({mode: 'open'});
    const t = this.#s;
    t.properties || (t.properties = {}),
      t.propToComputedMap || (t.propToComputedMap = new Map()),
      t.propToExprsMap || (t.propToExprsMap = new Map()),
      t.formAssociated &&
        ((this.#i = this.attachInternals()),
        (this.#r = new FormData()),
        this.#i.setFormValue(this.#r));
  }
  attributeChangedCallback(t, e, s) {
    const o = Wrec.getPropName(t),
      r = this.#c(o, String(s));
    (this[o] = r), this.#l(o, String(r)), this.propertyChangedCallback(o, e, s);
  }
  #h(t, e, s, o) {
    t.addEventListener(o, t => {
      const s = t.target,
        {value: o} = s,
        {type: r} = this.#s.properties[e];
      this[e] = r === Number ? stringToNumber(o) : o;
    });
    let r = this.#n.get(e);
    r || ((r = []), this.#n.set(e, r)),
      r.push(s ? {element: t, attrName: s} : t);
  }
  #u() {
    const t = this.#s;
    let e = t.template;
    if (!e) {
      e = t.template = document.createElement('template');
      let s = t.css ? `<style>${t.css}</style>` : '';
      (s += t.html), (e.innerHTML = s);
    }
    this.shadowRoot?.replaceChildren(e.content.cloneNode(!0));
  }
  changed(t, e, s) {
    const o = this.#p.get(t);
    o && (this[o] = s);
  }
  connectedCallback() {
    this.#m(),
      this.#f(),
      this.#u(),
      requestAnimationFrame(() => {
        this.shadowRoot &&
          (this.#d(this.shadowRoot),
          this.#E(this.shadowRoot),
          (this.#s.processed = !0)),
          this.#b();
      });
  }
  #b() {
    const t = this.#s,
      {properties: e} = t;
    for (const [t, {computed: s}] of Object.entries(e))
      s && (this[t] = this.#g(s));
  }
  #f() {
    const t = this.#s,
      {observedAttributes: e, properties: s} = t;
    for (const [t, o] of Object.entries(s)) this.#T(t, o, e);
  }
  #T(t, e, s) {
    const o = Wrec.getAttrName(t);
    e.required &&
      !this.hasAttribute(o) &&
      this.#R(this, t, 'is a required attribute');
    const {type: r, value: i} = e,
      n =
        r === Boolean
          ? i || this.hasAttribute(o)
          : s.includes(o) && this.hasAttribute(o)
          ? this.#v(t, o)
          : i || defaultForType(r),
      a = '#' + t;
    (this[a] = n),
      e.computed && this.#M(t, e),
      Object.defineProperty(this, t, {
        enumerable: !0,
        get() {
          return this[a];
        },
        set(s) {
          this.#C(t, r, s),
            r === Number && 'string' == typeof s && (s = stringToNumber(s)),
            s.constructor !== r &&
              this.#R(
                null,
                t,
                `was set to a ${s.constructor.name}, but must be a ${r.name}`
              );
          const i = this[a];
          if (s === i) return;
          this[a] = s;
          const {stateProp: n} = this.#s.properties[t];
          n && this.#a.set(n, s);
          const p = this.#s.propToComputedMap.get(t) || [];
          for (const [t, e] of p) this[t] = this.#g(e);
          if (isPrimitive(s) && this.hasAttribute(o)) {
            s !== (r === Boolean ? this.hasAttribute(o) : this.#v(t, o)) &&
              updateAttribute(this, t, s);
          }
          this.#A(t);
          const c = this.propToParentPropMap.get(t);
          if (c) {
            this.getRootNode().host[c] = s;
          }
          isPrimitive(s) && this.#l(t, s),
            this.propertyChangedCallback(t, i, s),
            e.dispatch &&
              this.dispatchEvent(
                new CustomEvent('change', {
                  bubbles: !0,
                  composed: !0,
                  detail: {propName: t}
                })
              );
        }
      });
  }
  static elementName() {
    return this.name.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
  }
  #N(t) {
    const e = t instanceof Wrec;
    for (const s of t.getAttributeNames()) {
      const o = t.getAttribute(s),
        r = this.#y(t, o);
      if (r) {
        const o = this[r];
        void 0 === o && this.#w(t, s, r), (t[r] = o);
        let [i, n] = s.split(':');
        if ('value' === i) {
          if (n) {
            if (void 0 === t['on' + n]) {
              const e = 'refers to an unsupported event name';
              this.#R(t, s, e);
            }
            t.setAttribute(i, this[r]);
          } else n = 'change';
          this.#h(t, r, i, n);
        }
        e && t.propToParentPropMap.set(Wrec.getPropName(i), r);
      }
      this.#x(o, t, s);
    }
  }
  #g(expr) {
    return (() => eval(expr)).call(this);
  }
  #P(t) {
    const {localName: e} = t;
    if ('style' === e) {
      const {sheet: e} = t,
        s = e?.cssRules ?? [],
        o = Array.from(s);
      for (const t of o)
        if (t.constructor === CSSStyleRule) {
          const e = Array.from(t.style);
          for (const s of e)
            if (s.startsWith('--')) {
              const e = t.style.getPropertyValue(s);
              this.#x(e, t, s);
            }
        }
    } else {
      let s = '';
      if ('textarea' === e) {
        const e = t.textContent?.match(HTML_COMMENT_TEXT_RE);
        e && (s = e[1]);
      } else {
        const e = Array.from(t.childNodes).find(
          t => t.nodeType === Node.COMMENT_NODE
        );
        e && (s = e.textContent?.trim() ?? '');
      }
      if (s) {
        const o = this.#y(t, s);
        'textarea' === e && o
          ? (this.#h(t, o, null, 'change'), (t.textContent = this[o]))
          : this.#x(s, t);
      }
    }
  }
  static getAttrName(t) {
    let e = Wrec.#t.get(t);
    return (
      e ||
        ((e = t.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()),
        Wrec.#t.set(t, e)),
      e
    );
  }
  static getPropName(t) {
    let e = Wrec.#e.get(t);
    return (
      e ||
        ((e = t.replace(/-([a-z])/g, (t, e) => e.toUpperCase())),
        Wrec.#e.set(t, e)),
      e
    );
  }
  #E(t) {
    const e = Array.from(t.querySelectorAll('*'));
    for (const t of e) this.#N(t), t.firstElementChild || this.#P(t);
  }
  static get observedAttributes() {
    return Object.keys(this.properties || {}).map(Wrec.getAttrName);
  }
  propertyChangedCallback(t, e, s) {}
  #y(t, e) {
    if (!e || !REF_RE.test(e)) return;
    const s = getPropName(e);
    return void 0 === this[s] && this.#w(t, '', s), s;
  }
  #A(t) {
    const e = this.#s.propToExprsMap.get(t) || [];
    for (const t of e) {
      const e = this.#g(t),
        s = this.#o.get(t) || [];
      for (const t of s)
        t instanceof HTMLElement
          ? this.#S(t, e)
          : updateValue(t.element, t.attrName, e);
    }
    requestAnimationFrame(() => {
      this.#I(t);
    });
  }
  static register() {
    const t = this.elementName();
    customElements.get(t) || customElements.define(t, this);
  }
  #M(t, e) {
    const {computed: s, uses: o} = e,
      r = this.#s.propToComputedMap;
    function i(e, s) {
      let o = r.get(e);
      o || ((o = []), r.set(e, o)), o.push([t, s]);
    }
    const n = s.match(REFS_RE) || [];
    for (const e of n) {
      const o = e.substring(SKIP);
      void 0 === this[o] && this.#w(null, t, o),
        'function' != typeof this[o] && i(o, s);
    }
    if (o) for (const t of o.split(',')) i(t, s);
  }
  #x(t, e, s = void 0) {
    if (!t) return;
    const o = this.#_(e, s, t);
    if (!o) {
      const o = t.replaceAll('this..', 'this.');
      return void (s
        ? updateValue(e, s, o)
        : 'textContent' in e && (e.textContent = o));
    }
    const r = this.#s;
    r.processed ||
      o.forEach(e => {
        const s = getPropName(e);
        if ('function' == typeof this[s]) return;
        const o = r.propToExprsMap;
        let i = o.get(s);
        i || ((i = []), o.set(s, i)), i.includes(t) || i.push(t);
      });
    let i = this.#o.get(t);
    i || ((i = []), this.#o.set(t, i)),
      i.push(s ? {element: e, attrName: s} : e);
    const n = this.#g(t);
    s ? updateValue(e, s, n) : this.#S(e, n);
  }
  #l(t, e) {
    this.#r && (this.#r.set(t, e), this.#i?.setFormValue(this.#r));
  }
  #R(t, e, s) {
    const o = this.#s,
      r = t instanceof HTMLElement ? t.localName : 'CSS rule';
    throw new Error(
      `component ${o.elementName()}` +
        (t ? `, element "${r}"` : '') +
        (e ? `, attribute "${e}"` : '') +
        ` ${s}`
    );
  }
  #w(t, e, s) {
    this.#R(t, e, `refers to missing property "${s}"`);
  }
  #v(t, e) {
    return this.#c(t, this.getAttribute(e));
  }
  #c(t, e) {
    if (e?.match(REFS_RE)) return e;
    const s = this.#s,
      {type: o} = s.properties[t];
    return o === String
      ? e
      : o === Number
      ? stringToNumber(e)
      : o === Boolean
      ? 'true' === e ||
        ('false' !== e &&
          'null' !== e &&
          (e &&
            e !== t &&
            this.#R(
              null,
              t,
              'is a Boolean attribute, so its value must match attribute name or be missing'
            ),
          e === t))
      : void this.#R(null, t, 'does not specify its type');
  }
  #I(t) {
    const e = this[t],
      s = this.#n.get(t) || [];
    for (const t of s)
      if (t instanceof HTMLElement)
        'textarea' === t.localName ? (t.value = e) : (t.textContent = e);
      else {
        const {element: s, attrName: o} = t;
        updateAttribute(s, o, e), (s[o] = e);
      }
  }
  #S(t, e) {
    const s = t instanceof HTMLElement,
      o = s ? t.localName : '',
      r = typeof e;
    'string' !== r &&
      'number' !== r &&
      this.#R(t, void 0, ' computed content is not a string or number'),
      'textarea' === o
        ? (t.value = e)
        : s && 'string' === r && e.trim().startsWith('<')
        ? ((t.innerHTML = e), this.#d(t), this.#E(t))
        : s && (t.textContent = e);
  }
  useState(t, e) {
    this.#a = t;
    for (const [s, o] of Object.entries(e)) {
      this.#p.set(s, o);
      const e = t.get(s);
      void 0 !== e && (this[o] = e);
      this.#s.properties[o].stateProp = s;
    }
    t.addListener(this, Object.keys(e));
  }
  #m() {
    const t = this.#s,
      e = new Set(Object.keys(t.properties));
    for (const t of this.getAttributeNames())
      'id' !== t &&
        (t.startsWith('on') ||
          e.has(Wrec.getPropName(t)) ||
          this.#R(null, t, 'is not a supported attribute'));
  }
  #_(t, e, s) {
    const o = s.match(REFS_RE);
    if (o)
      return (
        o.forEach(s => {
          const o = getPropName(s);
          void 0 === this[o] && this.#w(t, e, o);
        }),
        o
      );
  }
  #C(t, e, s) {
    if (s instanceof e) return;
    let o = typeof s;
    'object' === o && (o = s.constructor.name),
      o !== e.name.toLowerCase() &&
        this.#R(null, t, `was set to a ${o}, but must be a ${e.name}`);
  }
  #d(t) {
    const e = Array.from(t.querySelectorAll('*'));
    for (const t of e) {
      const e = [];
      for (const s of Array.from(t.attributes)) {
        const o = s.name;
        if (o.startsWith('on')) {
          const r = o.slice(2).toLowerCase(),
            i = s.value;
          let n;
          this.#_(t, o, i),
            'function' == typeof this[i]
              ? (n = t => this[i](t))
              : (this.#_(t, o, i), (n = () => this.#g(i))),
            t.addEventListener(r, n),
            e.push(o);
        }
      }
      for (const s of e) t.removeAttribute(s);
    }
  }
}
export default Wrec;
export function css(t, ...e) {
  let s = interpolate(t, e);
  for (;;) {
    const t = CSS_PROPERTY_RE.exec(s);
    if (!t) break;
    const e = t[2];
    if (REFS_TEST_RE.test(e)) {
      const o = t[1];
      if (!o.startsWith('--')) {
        const r = `--${o}: ${e};\n        ${o}: var(--${o});`;
        s = replace(s, t.index, t[0].length, r);
      }
    }
  }
  return s;
}
export function html(t, ...e) {
  let s = interpolate(t, e);
  for (;;) {
    const t = HTML_ELEMENT_TEXT_RE.exec(s);
    if (!t) break;
    const e = removeHtmlComments(t[2]);
    if (REFS_TEST_RE.test(e)) {
      const o = `\x3c!-- ${e.trim()} --\x3e`;
      s = replace(s, t.index + t[0].indexOf('>') + 1, e.length, o);
    }
  }
  return s;
}
