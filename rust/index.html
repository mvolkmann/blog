<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Rust</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#why-use-rust">Why use Rust</a></li><li><a href="#why-use-another-programming-language">Why use another programming language</a></li><li><a href="#installing">Installing</a></li><li><a href="#learning-resources">Learning Resources</a></li><li><a href="#online-playground">Online Playground</a></li><li><a href="#compiling-and-running">Compiling and Running</a></li><li><a href="#vs-code">VS Code</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#toml">TOML</a></li><li><a href="#cargo">Cargo</a></li><li><a href="#formatting-code">Formatting Code</a></li><li><a href="#naming-conventions">Naming Conventions</a></li><li><a href="#syntax-highlights">Syntax Highlights</a></li><li><a href="#comments">Comments</a></li><li><a href="#attributes">Attributes</a></li><li><a href="#formatted-print">Formatted Print</a></li><li><a href="#variables">Variables</a></li><li><a href="#ownership-model">Ownership Model</a></li><li><a href="#dereference">Dereference</a></li><li><a href="#lifetimes">Lifetimes</a></li><li><a href="#error-handling">Error Handling</a></li><li><a href="#built-in-scalar-types">Built-in Scalar Types</a></li><li><a href="#built-in-compound-types">Built-in Compound Types</a></li><li><a href="#collections">Collections</a><ol><li><a href="#strings">Strings</a></li><li><a href="#vectors">Vectors</a></li><li><a href="#sets">Sets</a></li><li><a href="#maps">Maps</a></li></ol></li><li><a href="#slices">Slices</a></li><li><a href="#conditional-logic">Conditional Logic</a></li><li><a href="#standard-io">Standard IO</a></li><li><a href="#iteration-(looping)">Iteration (Looping)</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#functions">Functions</a></li><li><a href="#operators">Operators</a></li><li><a href="#ranges">Ranges</a></li><li><a href="#structs">Structs</a></li><li><a href="#type-aliases">Type Aliases</a></li><li><a href="#traits">Traits</a></li><li><a href="#modules">Modules</a></li><li><a href="#crates">Crates</a></li><li><a href="#futures">Futures</a></li><li><a href="#threads">Threads</a></li><li><a href="#standard-library">Standard Library</a></li><li><a href="#webassembly">WebAssembly</a></li></ol></nav></aside><article><p><img alt="Rust logo" style="width: 20%" src="/blog/assets/rust-logo.png" title="Rust logo"> <img alt="Rust mascot" style="width: 30%" src="/blog/assets/rustacean-ferris-crab.png" title="Rust mascot, Ferris the crab"></p><h2 id="overview">Overview</h2><p><a href="https://www.rust-lang.org/" rel="noopener" target="_blank">Rust</a> is a programming language for building reliable and efficient software.</p><p>Features of Rust include:</p><ul><li>fast</li><li>memory-efficient</li><li>rich, static type system with type inference</li><li>ownership model to guarantee memory-safety and thread-safety</li><li>targets LLVM, so runs on a wide variety of platforms that targets</li><li>can call and be called by C</li></ul><p>Rust was created at Mozilla by Graydon Hoare, with contributions from Dave Herman, Brendan Eich, and others. It was formally announced in 2010. Rust has been self-hosted (implemented in itself) since 2011. Version 1.0 was released in May 2015. A new point release is made every six weeks.</p><p>From <a href="https://doc.rust-lang.org/edition-guide/editions/" rel="noopener" target="_blank">rust-lang.org</a>, &quot;Every two or three years, we'll be producing a new edition of Rust. Each edition brings together the features that have landed into a clear package, with fully updated documentation and tooling.&quot;</p><p>Rust developers are referred to as &quot;Rustaceans&quot; which was derived from the word &quot;crustaceans&quot;. Rust mascot is Ferris the crab, a crustacean. The name is fitting because ferrous metals are subject to rust. Images of Ferris can be found at <a href="https://rustacean.net/" rel="noopener" target="_blank">rustacean.net</a>.</p><h2 id="why-use-rust">Why use Rust</h2><p><strong>Performance:</strong></p><p>The best way to get software performance is to use a &quot;systems&quot; language like C, C++, or Rust. One reason these languages are fast is because they do not provide automatic garbage collection that is slow and can run at unpredictable times. Systems languages also allow control over whether data is on the stack or on the heap.</p><p><strong>Safety:</strong></p><p>Software written in systems languages typically must take great care to avoid memory and threading issues. Memory issues include accessing memory after it has been freed, resulting in unpredictable behavior. Threading issues include race conditions where the order in which code runs is unpredictable, resulting in unpredictable results. Rust addresses both of these issues, resulting in code that is less likely to contain bugs.</p><p><strong>Immutable by default:</strong></p><p>A large source of errors in any software involves incorrect assumptions about where data is modified. Making variables immutable by default and requiring explicit indication of functions that are allowed to modify data significantly reduces these errors.</p><p><strong>Control over number sizes:</strong></p><p>One way to achieve performance in computationally intensive tasks is to store collections of numbers in contiguous memory for fast access and control the number of bytes used by each number.</p><p><strong>Ownership model:</strong></p><p>Manual garbage collection is error prone. Rust uses an &quot;ownership model&quot; where code is explicit about the single scope that owns each piece of data. When that scope ends, the data can be safely freed because no other scope can possibly be using the data.</p><p>Systems languages tend to be more complex that non-systems languages, requiring more time to learn and more time to write software in them. Rust is no exception. But some developers choose to use Rust in spite of this in order to gain the benefits described above. On the positive side, the Rust compiler catches many errors that would only be discovered at runtime with other systems languages. The Rust compiler also provides very detailed error messages that include suggestions on how to correct the errors.</p><h2 id="why-use-another-programming-language">Why use another programming language</h2><p><strong>Performance:</strong></p><p>If programming languages that provided automatic memory management (such as JavaScript/TypeScript, Python, and Go) are fast enough for the target application, Rust will be overkill.</p><p><strong>Learning Curve:</strong></p><p>The learning curve for Rust is quite high. It may be too much effort to bring an entire team up to speed on using it. For example, developers must constantly decide whether values or references should be passed to functions. The reason is that by default all values are passed by value, but nearly always it is best to pass non-primitive values by reference.</p><p><strong>Processor target:</strong></p><p>If the target platform uses a processor type that is not a target of LLVM, Rust cannot currently produce code that will run on it.</p><h2 id="installing">Installing</h2><p>Rust is installed using the <a href="" rel="noopener" target="_blank">rustup</a> tool. This enables having multiple versions of Rust installed and switching between them.</p><p>To install rustup in macOS, install <a href="" rel="noopener" target="_blank">homebrew</a> and then enter <code>brew install rustup</code>.</p><p>To install rustup in Linux (or macOS), enter the following command:</p><pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="token operator">|</span> <span class="token function">sh</span></code></pre><p>To install rustup in Windows, use <a href="https://chocolatey.org/" rel="noopener" target="_blank">Chocolately</a> or <a href="https://scoop.sh/" rel="noopener" target="_blank">Scoop</a>.</p><p>After installing rustup, enter <code>rustup-init</code>. This configures the use of Rust in the bash and zsh shells. When using the fish shell, add the following in <code>.config/fish/config.fish</code>:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">set</span> -x <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span> <span class="token environment constant">$HOME</span>/.cargo/bin</code></pre><p>Verify installation by entering <code>rustc --version</code>.</p><h2 id="learning-resources">Learning Resources</h2><ul><li><p><code>rustup doc</code> command</p><ul><li>displays local documentation installed along with Rust in default web browser</li><li>can read even when offline</li><li>includes<ul><li>&quot;The Rust Programming Language&quot; book</li><li>&quot;Rust by Example&quot; book</li><li>API documentation</li><li>&quot;The Rust Reference&quot; book which is more detailed than &quot;The Rust Programming Language&quot; book</li><li>&quot;The Cargo Book&quot; book</li><li>and much more</li></ul></li></ul></li><li><p><a href="https://www.rust-lang.org/" rel="noopener" target="_blank">Rust website</a></p></li><li><p><a href="https://doc.rust-lang.org/book/" rel="noopener" target="_blank">The Rust Programming Language</a> book</p><ul><li>free, open source book</li><li>from No Starch Press</li><li>can purchase a print copy</li></ul></li><li><p><a href="https://doc.rust-lang.org/stable/reference/" rel="noopener" target="_blank">The Rust Reference</a></p></li><li><p><a href="https://rust-lang-nursery.github.io/rust-cookbook/" rel="noopener" target="_blank">Rust Cookbook</a></p><ul><li>&quot;collection of simple examples that demonstrate good practices to accomplish common programming tasks&quot;</li></ul></li><li><p><a href="https://doc.rust-lang.org/stable/rust-by-example/" rel="noopener" target="_blank">Rust by Example</a></p><ul><li>free, online set of examples in many categories</li></ul></li><li><p><a href="https://github.com/rust-lang/rustlings" rel="noopener" target="_blank">Rustlings</a></p><ul><li>&quot;contains small exercises to get you used to reading and writing Rust code&quot;</li></ul></li><li><p><a href="https://exercism.io/tracks/rust" rel="noopener" target="_blank">exercism Rust track</a></p><ul><li>&quot;Code practice and mentorship for everyone&quot;</li><li>&quot;exercises across 52 languages&quot;</li></ul></li><li><p><a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/" rel="noopener" target="_blank">Programming Rust</a> book</p><ul><li>from O'Reilly</li></ul></li><li><p><a href="https://www.manning.com/livevideo/rust-in-motion?a_aid=cnichols&a_bid=6a993c2e" rel="noopener" target="_blank">Rust in Motion</a> video course</p><ul><li>from Manning</li></ul></li></ul><h2 id="online-playground">Online Playground</h2><p>To try Rust code online, browse the <a href="https://play.rust-lang.org/" rel="noopener" target="_blank">Rust Playground</a>. This includes access to the top 100 most downloaded crates (libraries) from <a href="https://crates.io/" rel="noopener" target="_blank">crates.io</a> and crates from the <a href="https://rust-lang-nursery.github.io/rust-cookbook/" rel="noopener" target="_blank">Rust Cookbook</a>.</p><p><img alt="Rust Playground" style="width: 100%" src="/blog/assets/rust-playground.png" title="Rust Playground"></p><p>All of the code must be entered in a single editor pane, simulating all of it being in a single file.</p><p>Press the ellipsis after the &quot;RUN&quot; button to open a popup with the following options:</p><ul><li>&quot;Run&quot; to build and run the code (<code>cargo run</code>)</li><li>&quot;Build&quot; to only build the code (<code>cargo build</code>)</li><li>&quot;Test&quot; to build the code and run the tests (<code>cargo test</code>)<br>Tests must be preceded by <code>#[test]</code> and no <code>main</code> function can be present.</li><li>&quot;ASM&quot; to build the code and show the generated assembly code</li><li>&quot;LLVM IR&quot; to build the code and show the generated LLVM intermediate representation (IR)</li><li>&quot;MIR&quot; to build the code and show the generated mid-level intermediate representation (MIR)</li><li>&quot;WASM&quot; to build a WebAssembly module for use in web browsers</li></ul><p>The &quot;RUN&quot; button will change to the last selected option so it can be re-executed by pressing the button.</p><p>Press the &quot;DEBUG&quot; button to open a popup for choosing between &quot;Debug&quot; and &quot;Release&quot; built modes.</p><p>Press the &quot;NIGHTLY&quot; button to open a popup for choosing a Rust version which can be &quot;Stable channel&quot; (default), &quot;Beta channel&quot;, or &quot;Nightly channel&quot;. The button text changes to indicate the selected version.</p><p>Press the ellipsis after the version button to open a popup with the following options:</p><ul><li>&quot;Edition&quot; sets the Rust edition to 2018 (default) or 2015</li><li>&quot;Backtrace&quot; to disable (default) or enable display of backtraces when a panic occurs<br>Enabling this slows performance a bit.</li></ul><p>Press the &quot;SHARE&quot; button to open a panel on the right side containing the following links:</p><ul><li>&quot;Permalink to the playground&quot; changes the URL to one which will recall the current code set to run with the current version of Rust.</li><li>&quot;Direct link to the gist&quot; navigates to the URL of the GitHub Gist where the code is stored. The code cannot be executed from here.</li><li>&quot;Embed code in link&quot; changes the URL to one which includes a base 64 encoded copy of the code as a query parameter. This is only appropriate for small code samples due to URL length limits.</li><li>&quot;Open a new thread in the Rust user forum&quot; does what the link implies, making it easy to ask questions about a code sample.</li><li>&quot;Open an issue on the Rust GitHub repository&quot; makes it easy to report a bug in Rust.</li></ul><p>Press the &quot;TOOLS&quot; button to open a popup with the following options:</p><ul><li>&quot;Rustfmt&quot; formats the code using the <code>rustfmt</code> tool.</li><li>&quot;Clippy&quot; runs the Clippy linter on the code.</li><li>&quot;Miri&quot; runs the program using the <a href="https://github.com/rust-lang/miri" rel="noopener" target="_blank">Miri interpreter</a> which is an experimental interpreter for Rust's mid-level intermediate representation (MIR). which detects some bugs not detected by press the &quot;RUN&quot; button?</li><li>&quot;Expand macros&quot; displays the code in the right panel with all the macro calls expanded in order to see what they actually do.</li></ul><p>Press the &quot;CONFIG&quot; button to open a popup with the following options:</p><ul><li>&quot;Style&quot; to switch between &quot;SIMPLE&quot; (no line numbers) and &quot;ADVANCED&quot; (line numbers)</li><li>&quot;Keybinding&quot; to choose between keybindings supported by the <a href="https://github.com/ajaxorg/ace" rel="noopener" target="_blank">Ace</a> (Cloud9) editor<br>These include ace, emacs, sublime, vim, and vscode.</li><li>&quot;Theme&quot; to choose from 30+ themes including cobalt, github, solarized light, solarized dark</li><li>&quot;Pair Characters&quot; to automatically insert closing <code>)</code>, <code>}</code>, and <code>]</code> character after <code>(</code>, <code>{</code>, and <code>[</code> characters</li><li>&quot;Orientation&quot; to arrange panes horizontally, vertically, or automatically choose based on window size</li><li>and advanced options to control generated assembly code</li></ul><p>There doesn't seem to be a way to select a font for the code.</p><p>Configuration options are saved in browser Local Storage so they can be applied to future sessions. The most recently entered code is also saved in Local Storage, but previously entered code is not.</p><h2 id="compiling-and-running">Compiling and Running</h2><p>Rust source files have a <code>.rs</code> file extension.</p><p>To compile a Rust source file, creating an executable with the same name and no file extension, and run it:</p><ul><li>open a terminal (or Windows Command Prompt),</li><li>cd to the directory containing a <code>.rs</code> file that defines a <code>main</code> function</li><li>enter <code>rustc name.rs</code></li><li>in macOS or Linux, enter <code>./name</code></li><li>in Windows, enter <code>name</code></li></ul><p>For example, the following is a Rust Hello World program:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Calls to names that end in <code>!</code> are actually calls to a macro rather than a function.</p><p>See the &quot;Cargo&quot; section for an alternative way to compile and run a Rust program.</p><h2 id="vs-code">VS Code</h2><p>Install the Rust extension which adds:</p><ul><li>syntax highlighting</li><li>code completion</li><li>code formatting</li><li>type documentation on hover</li><li>linting with error indicators with ability to apply suggestions</li><li>code snippets</li><li>rename refactoring</li><li>debugging</li><li>build tasks</li></ul><p>Add the following in <code>settings.json</code>:</p><pre class="language-json"><code class="language-json">  <span class="token property">"[rust]"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"rust-lang.rust"</span><span class="token punctuation">,</span><br>    <span class="token property">"editor.insertSpaces"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>    <span class="token property">"editor.tabSize"</span><span class="token operator">:</span> <span class="token number">4</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>Note that this extension only works if the opened folder contains a <code>Cargo.toml</code> file.</p><h2 id="terminology">Terminology</h2><ul><li><code>cargo</code><ul><li>command-line utility described later</li></ul></li><li>crate<ul><li>tree of modules</li><li>either a binary (bin) or a library (lib)</li></ul></li><li>module<ul><li>set of related values such as constants and functions</li></ul></li><li>package<ul><li><code>cargo</code> feature for building, testing, and sharing crates</li><li>set of related crates described by a <code>Cargo.toml</code> file;</li><li>contains any number of binaries and 0 or 1 library</li></ul></li><li>TOML<ul><li>configuration file format</li><li>stands for Tom's Obvious, Minimal Language</li></ul></li></ul><h2 id="toml">TOML</h2><p><a href="https://github.com/toml-lang/toml" rel="noopener" target="_blank">TOML</a> is a configuration file format that maps to a hash table.</p><p>Each key/value pair is described by a line with the syntax <code>key = value</code>. Keys are not surrounded by any delimiters. Supported value data types include string, integer, float, boolean, datetime, array (ordered list of values), and table (collection of key/value pairs). String values are surrounded by double quotes. Datetime values have the format <code>yyyy-mm-ddThh:mm:ss</code>. The time portion can be omitted and it can be followed by a time zone (<code>Z</code> for UTC or <code>+hh:mm</code> for an offset). Array elements are surrounded by square brackets and separated by commas.</p><p>Comments begin with <code>#</code> character and extend to the end of the line.</p><p>Sections and sub-sections are indicated by lines containing a name enclosed in square brackets. Think of these like keys whose values are objects.</p><h2 id="cargo">Cargo</h2><p>The <code>cargo</code> command is a CLI tool that is installed with Rust. While using it is not required, it is highly recommended. For help, enter <code>cargo --help</code> or just <code>cargo</code>.</p><p>The following table describes the <code>cargo</code> subcommands:</p><table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody><tr><td><code>bench</code></td><td>runs benchmarks for the current project</td></tr><tr><td><code>build</code></td><td>builds current project in the <code>target</code> directory</td></tr><tr><td><code>check</code></td><td>verifies current project builds without errors,<br>without generating code</td></tr><tr><td><code>clean</code></td><td>deletes <code>target</code> directory</td></tr><tr><td><code>clippy</code></td><td>checks current project for errors using the Clippy linter</td></tr><tr><td><code>doc</code></td><td>generates documentation for the current project</td></tr><tr><td><code>init</code></td><td>creates a Rust project in the current directory</td></tr><tr><td><code>install</code></td><td>installs an executable in <code>~/.cargo/bin</code> by default</td></tr><tr><td><code>new</code></td><td>creates a Rust project in a new subdirectory</td></tr><tr><td><code>publish</code></td><td>publishes package to the registry</td></tr><tr><td><code>run</code> or <code>r</code></td><td>builds and runs current project</td></tr><tr><td><code>search</code></td><td>searches registry for crates</td></tr><tr><td><code>test</code> or <code>t</code></td><td>runs tests in the current project</td></tr><tr><td><code>uninstall</code></td><td>removes executable from <code>~/.cargo/bin</code> by default</td></tr><tr><td><code>update</code></td><td>updates dependencies in <code>Cargo.lock</code></td></tr></tbody></table><p>The <code>cargo run</code> command creates a new directory containing Rust project that is initialized as a new Git repository. It contains a <code>Cargo.toml</code> configuration file that specifies the project name, version, authors, the Rust edition to use, and a list of project dependencies. It also contains a <code>src</code> directory with a <code>main.rs</code> file that is a simple hello world program.</p><p>To watch project files for changes and automatically run a <code>cargo</code> command when they do, enter <code>cargo install cargo-watch</code> one time and then enter <code>cargo watch -x subcommand</code>. The <code>-x</code> flag can be omitted in which case the subcommand defaults to <code>check</code>, not <code>run</code>. Typically you will want the subcommand to be <code>run</code>.</p><p>The <code>cargo build</code> command creates an executable in the <code>target/debug</code> directory. To create an optimized, production build, enter <code>cargo build --release</code> which creates an executable in the <code>target/release</code> directory. Benchmarking should be done on optimized builds.</p><h2 id="formatting-code">Formatting Code</h2><p>The most popular code formatting tool for Rust is <a href="" rel="noopener" target="_blank">rustfmt</a>. To install this, enter <code>cargo install rustfmt</code>. TODO: Is this installed by default by rustup?</p><p>To run it on all <code>.rs</code> files in the current directory, enter <code>rustfmt *.rs</code>.</p><h2 id="naming-conventions">Naming Conventions</h2><p>In general, names of &quot;types&quot; use PascalCase and names of &quot;value&quot; use snake_case.</p><table><thead><tr><th>Item</th><th>Naming Convention</th></tr></thead><tbody><tr><td>constants</td><td>SCREAMING_SNAKE_CASE</td></tr><tr><td>constructors</td><td>snake_case</td></tr><tr><td>crates</td><td>snake_case or kebab-case</td></tr><tr><td>enums</td><td>PascalCase</td></tr><tr><td>enums values</td><td>PascalCase</td></tr><tr><td>features</td><td>no convention</td></tr><tr><td>enums</td><td>PascalCase</td></tr><tr><td>file names</td><td>snake_case or kebab-case</td></tr><tr><td>functions</td><td>snake_case</td></tr><tr><td>lifetimes</td><td>'lowercase</td></tr><tr><td>macros</td><td>snake_case!</td></tr><tr><td>methods</td><td>snake_case</td></tr><tr><td>modules</td><td>snake_case</td></tr><tr><td>statics</td><td>SCREAMING_SNAKE_CASE</td></tr><tr><td>structs</td><td>PascalCase</td></tr><tr><td>traits</td><td>PascalCase</td></tr><tr><td>type parameters</td><td>PascalCase, but usually one letter</td></tr><tr><td>types</td><td>PascalCase</td></tr><tr><td>variables</td><td>snake_case</td></tr></tbody></table><p>The compiler outputs warnings when these naming conventions are not followed.</p><h2 id="syntax-highlights">Syntax Highlights</h2><ul><li>The preferred indentation is four spaces.</li><li>Statements must terminated by a semicolon.</li><li>Strings are delimited by double quotes.</li><li>Single characters are delimited by single quotes.</li><li>Items are made public using the <code>pub</code> keyword.</li><li>The dot (<code>.</code>) character is used to access struct fields and call instance methods.</li><li>The double colon (<code>::</code>) is used as a namespace separator (borrowed from C++) and to call static methods.</li><li>Conditions for conditional logic and iteration are not surrounded by any delimiter such as parentheses.</li><li>Statements associated with conditional logic and iteration must be in blocks surrounded by curly brackets.</li><li>Named functions are declared with the <code>fn</code> keyword.</li><li>Function return types follow the parameter list and <code>-&gt;</code>.</li><li>Functions that return nothing omit the <code>-&gt;</code> and return type.</li><li>Most statements are also expressions and evaluate to a value, including <code>if</code> and <code>match</code> statements.</li><li>If the last expression in a function does not end with a semicolon, it's value is returned.</li><li>There is no null type or value. Instead the wrapper enum types <code>Option</code> and <code>Result</code> are used.</li></ul><h2 id="comments">Comments</h2><p>Rust supports many comment syntaxes. &quot;Doc comments&quot; are included in generated HTML documentation that is generated by entering <code>cargo doc</code>. TODO: How do you generate it?</p><table><thead><tr><th>Syntax</th><th>Usage</th></tr></thead><tbody><tr><td><code>//</code></td><td>extends to end of current line</td></tr><tr><td><code>/* ... */</code></td><td>can span multiple lines</td></tr><tr><td><code>///</code></td><td>doc comment preceding the item it describes</td></tr><tr><td><code>//!</code></td><td>doc comment inside the item it describes</td></tr></tbody></table><p>Code inside doc comments that is surrounded by &quot;fences&quot; is run by the <code>rustdoc --test</code> command. For example:</p><ol><li><p>Create a project by entering <code>cargo new doc_test</code>.</p></li><li><p>Add the file <code>src/math.rs</code> containing the following:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">/// ```</span><br><span class="token comment">/// assert_eq!(math::average(vec![1.0, 2.0, 3.0, 4.0]), 2.5);</span><br><span class="token comment">/// ```</span><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">average</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> sum<span class="token punctuation">:</span> <span class="token keyword">f64</span> <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">f64</span> <span class="token comment">// return value</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Compile this to a library by entering <code>rustc --crate-type lib src/math.rs</code> This is needed because doc tests are only run on library crates.</p></li><li><p>Run the doc tests by entering <code>rustdoc -L . --test src/math.rs</code></p></li><li><p>To call the <code>average</code> function from another source file, modify <code>src/main.js</code> to match the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">math</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> avg <span class="token operator">=</span> <span class="token namespace">math<span class="token punctuation">::</span></span><span class="token function">average</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"average = {}"</span><span class="token punctuation">,</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre></li><li><p>To run this, enter <code>cargo run</code></p></li></ol><h2 id="attributes"><a name="attributes">Attributes</a></h2><p>Rust attributes are like &quot;decorators&quot; in other programming languages. They annotate an item in order to change its behavior. An attribute can be specified immediately before the declaration of an item with the syntax <code>#[attr]</code> or inside the declaration with the syntax <code>#![attr]</code>.</p><p>The following table summarizes commonly used attributes.</p><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td><code>allow(warning1, warning2, ...)</code></td><td>suppress specified warnings (ex. <code>dead_code</code> )</td></tr><tr><td><code>derive(trait1, trait2, ...)</code></td><td>automatically implement a list of traits on a <code>struct</code></td></tr><tr><td><code>doc</code></td><td>provides an alternate way to specify and format doc comments</td></tr><tr><td><code>should_panic</code></td><td>indicates that a test is expected to panic</td></tr><tr><td><code>test</code></td><td>annotates a function as a test</td></tr></tbody></table><p>For more, see the list at <a href="https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index" rel="noopener" target="_blank">Attributes</a>.</p><p>The table of provided traits in the &quot;Traits&quot; section indicates those can be automatically implemented. For more detail, see <a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html" rel="noopener" target="_blank">Derive</a>.</p><h2 id="formatted-print">Formatted Print</h2><p>The <code>std::fmt</code> namespace defines macros that format text.</p><table><thead><tr><th>Macro Name</th><th>Description</th></tr></thead><tbody><tr><td><code>format!</code></td><td>writes to a <code>String</code></td></tr><tr><td><code>print!</code></td><td>writes to stdout</td></tr><tr><td><code>println!</code></td><td>same as <code>print!</code>, but adds a newline</td></tr><tr><td><code>eprint!</code></td><td>writes to stderr</td></tr><tr><td><code>eprintln!</code></td><td>same as <code>eprint!</code>, but adds a newline</td></tr></tbody></table><p>All of these macros take a formatting string followed by zero or more expressions whose values are substituted into the formatting string where occurrences of <code>{}</code> appear. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} is {}."</span><span class="token punctuation">,</span> <span class="token string">"Rust"</span><span class="token punctuation">,</span> <span class="token string">"interesting"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Rust is interesting.</span></code></pre><p>To print a representation of a value for debugging purposes on a single line, use <code>{:?}</code>. To print each field of a struct on separate lines, use <code>{:#?}</code>. Custom structs must implement the <code>Debug</code> trait in order to use these. This is done by adding the line <code>#[derive(Debug)]</code> before their definitions.</p><p>The following table summarizes the supported format strings that can appear inside the curly brackets.</p><table><thead><tr><th>Format String</th><th>Description</th></tr></thead><tbody><tr><td><code>{:?}</code></td><td>debugging output on single line</td></tr><tr><td><code>{:#?}</code></td><td>debugging output on multiple lines</td></tr><tr><td><code>{n}</code></td><td>prints the argument at index n (zero-based)</td></tr><tr><td><code>{name}</code></td><td>prints the value with a given name</td></tr><tr><td><code>{:.n}</code></td><td>prints a number with <code>n</code> decimal places</td></tr><tr><td><code>{:.*}</code></td><td>prints a number with number of decimal places specified in value list</td></tr><tr><td><code>{:#X}</code></td><td>prints number as uppercase hexadecimal</td></tr><tr><td><code>{:#x}</code></td><td>prints number as lowercase hexadecimal</td></tr><tr><td><code>{:&lt;n}</code></td><td>print left justified in a width of n</td></tr><tr><td><code>{:&gt;n}</code></td><td>print right justified in a width of n</td></tr><tr><td><code>{:^n}</code></td><td>print centered in a width of n</td></tr></tbody></table><p>Here are some examples:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:#?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Point2D {</span><br><span class="token comment">//     x: 1.0,</span><br><span class="token comment">//     y: 2.0,</span><br><span class="token comment">// }</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{1} {0} {2} {1}"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// green red blue green</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><br>    <span class="token string">"{red} {green} {blue}"</span><span class="token punctuation">,</span><br>    blue<span class="token operator">=</span><span class="token string">"00F"</span><span class="token punctuation">,</span> green<span class="token operator">=</span><span class="token string">"0F0"</span><span class="token punctuation">,</span> red<span class="token operator">=</span><span class="token string">"F00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// F00 0F0 00F</span><br><br><span class="token keyword">let</span> pi <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token namespace">consts<span class="token punctuation">::</span></span><span class="token constant">PI</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:.4}"</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3.1416</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:.*}"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3.1416</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:#X}"</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0xF</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:#x}"</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0xf</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"A{:&lt;5}Z"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A123  Z</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"A{:>5}Z"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A  123Z</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"A{:^5}Z"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A 123 Z</span></code></pre><p>For more options, see <a href="https://doc.rust-lang.org/std/fmt/" rel="noopener" target="_blank">std::fmt</a>.</p><h2 id="variables">Variables</h2><p>Variables are immutable by default. For variables that hold non-primitive values such as structs and arrays, even their fields cannot be mutated.</p><p>The <code>mut</code> keyword marks a variable as mutable.</p><p>A variable declaration has the syntax <code>let name: type = value;</code> where the value is optional. However, a value must be assigned before the variable is referenced. The colon and the type can be omitted if it can be inferred from the value.</p><p>There are four ways to declare a &quot;variable&quot;.</p><table><thead><tr><th>Syntax</th><th>Meaning</th></tr></thead><tbody><tr><td><code>let name: type = value</code></td><td>immutable variable that must be assigned a value<br>before it is used and is thereafter immutable</td></tr><tr><td><code>let mut name: type = value</code></td><td>mutable variable that must be assigned a value<br>before it is used, but can be modified</td></tr><tr><td><code>const name: type = value</code></td><td>constant that must be assigned a value when it is declared</td></tr><tr><td><code>static name: type = value</code></td><td>immutable variable that lives for the duration of the program; typically <code>const</code> is preferred</td></tr><tr><td><code>static mut name: type = value</code></td><td>mutable variable that lives for the duration of the program;<br>can only mutate in <code>unsafe</code> functions</td></tr></tbody></table><p>Note that <code>const</code> and <code>static</code> declarations must be explicitly typed. They do not infer a type based on the assigned value. One rationale for this is that because their scope can extend to the entire crate, it is better to be explicit about the desired type.</p><p>Differences between constants and immutable statics include:</p><ul><li>The value of a <code>const</code> variable is copied everywhere it is used rather than sharing the memory. For values that do not use more bytes than a reference, this difference doesn't matter.</li><li><code>const</code> variables must be initialized when they are declared, but <code>static</code> variables can wait to do this until their first access using <code>std::lazy::Lazy</code> which is useful for expensive initializations. An example is compiling a regular expression.</li><li><code>pub static</code> variables can be accessed from C code, but <code>const</code> variables cannot.</li><li>For types that do not implement the <code>Copy</code> trait, <code>const</code> values can be assigned to variables but <code>static</code> values cannot because doing so would require copying. Note that all the scalar types like <code>bool</code>, <code>char</code>, <code>i32</code>, and <code>f64</code> implement the <code>Copy</code> trait.</li><li>Generic functions can declare <code>const</code> variables with a generic type (often named <code>T</code>), but cannot do so with <code>static</code> variables.</li></ul><p>TODO: Are statics a way to share data across functions, TODO: even those defined in separate files, without passing it?</p><h2 id="ownership-model">Ownership Model</h2><p>The Rust ownership model provides the following benefits:</p><ul><li>runtime speed achieved by eliminating the need for a garbage collector (GC)</li><li>more predictable performance since there are no GC pauses</li><li>safer memory access since there is no possibility of null pointer accesses or dangling pointer accesses (accessing memory that has already been freed)</li><li>safer parallel and concurrent processing since there is no possibility of data races causing unpredictable interactions between threads</li></ul><p>Memory management is handled by following these rules:</p><ol><li>Each value is referred to by a variable that is its owner.</li><li>Each value has one owner at a time, the owner can change over its lifetime.</li><li>When the owner goes out of the scope, the value is dropped.</li></ol><p>Variable values are stored either in the stack or the heap. Accessing stack data is faster, but data on the heap can grow and shrink and it can live beyond the scope that created it.</p><p>Variable values whose sizes are known at compile time are stored on the stack. This includes booleans (<code>bool</code> type), single characters (<code>char</code> type), numbers, tuples, and arrays. Variable values of all other types are stored in the heap. This includes:</p><ul><li>strings (<code>&amp;str</code> and <code>String</code>)</li><li>structs, even those that only contain fields with types that have a known size</li><li>collections from the <code>std::collections</code> namespace which defines sequences (<code>Vec</code>, <code>VecDeque</code>, and <code>LinkedList</code>), sets (<code>HashSet</code> and <code>BTreeSet</code>), and maps (<code>HashMap</code> and <code>BTreeMap</code>).</li></ul><p>A value of these types can be stored on the heap by using the <code>Box</code> type. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> heap_int<span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Note: Sometimes Rust stores <code>&amp;str</code> values on the stack but you cannot control that, so it's best to think of them as always being on the heap.</p><p>All code blocks are delimited by a pair of curly brackets and create a new scope. Each new scope can add data to the stack that is freed when that scope exits. Many keywords have an associated block, including <code>fn</code>, <code>if</code>, <code>loop</code>, <code>for</code>, and <code>while</code>.</p><p>Here are some examples that demonstrate ownership inside a single function:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token comment">// Because a is a scalar type (fixed size),</span><br>    <span class="token comment">// this makes a copy of a and assigns that to b</span><br>    <span class="token comment">// rather than moving ownership from a to b.</span><br>    <span class="token comment">// Both a and b can then be used.</span><br>    <span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"b = {}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a = {}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><br>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token comment">// Because c is on the heap and does not implement the Copy trait,</span><br>    <span class="token comment">// this moves ownership from c to d.</span><br>    <span class="token comment">// c can no longer be used.</span><br>    <span class="token keyword">let</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d = {}"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test</span><br>    <span class="token comment">//println!("c = {}", c); // error "value borrowed here after move"</span><br><br>    <span class="token comment">// The Copy trait requires also implementing the Clone trait.</span><br>    <span class="token comment">// We can also implement these traits manually, but that is more work.</span><br>    <span class="token attribute attr-name">#[derive(Clone, Copy, Debug)]</span><br>    <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>        x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>        y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token comment">// If the struct implements the Copy trait, as we have done above,</span><br>    <span class="token comment">// a copy is made.  Otherwise this moves ownership from e to f.</span><br>    <span class="token keyword">let</span> f <span class="token operator">=</span> e<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br>    <span class="token comment">// This fails if ownership has been moved from e to f.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"e = {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error "value borrowed here after move"</span><br><span class="token punctuation">}</span></code></pre><p>Ownership of a value can also be &quot;borrowed&quot; by any number of variables by getting a reference to a value. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span> <span class="token comment">// an immutable borrow</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"e = {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span></code></pre><p>Borrowing does not transfer ownership, so a borrow variable can go out of scope without freeing the memory associated with the original variable.</p><p>When a value is mutable and ownership is borrowed, the compiler will flag an error if the value is mutated after the borrow is created and before its last use. This is because references expect the data they reference to remain the same. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> e <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span> <span class="token comment">// f borrows a reference rather than taking ownership</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br><span class="token comment">// If f is used after this, the next line triggers the error</span><br><span class="token comment">// "cannot assign to `e.x` because it is borrowed".</span><br>e<span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">3.0</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"e = {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 4.0, y: 2.0 }</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// triggers error on mutation above</span></code></pre><p>Typically a borrow only needs to read a value. But when a value is mutable, we can create one mutable borrow as long as there are no immutable borrows. This allows changing the value through the borrow variable. The original variable cannot be accessed again until after the last access of the borrow variable. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> v1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// mutable variable</span><br><span class="token keyword">let</span> v2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> v1<span class="token punctuation">;</span> <span class="token comment">// mutable borrow</span><br><span class="token operator">*</span>v2 <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><br><br><span class="token comment">// The following statements cannot be reversed.</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"v2 = {}"</span><span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"v1 = {}"</span><span class="token punctuation">,</span> v1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>An alternative to borrowing is to clone data, but doing this is often unnecessarily inefficient. To clone a value whose type implements the <code>Clone</code> trait, call the <code>clone</code> method on it. For example, <code>let copy = v.clone();</code></p><p>When variables whose values are on the stack are passed to functions, the functions are given copies. This is true even if the parameters are declared to be mutable. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><span class="token punctuation">}</span></code></pre><p>When variables (not references) whose values are on the heap are passed to functions, copies are not made and ownership is transferred. When the function exits, the data is freed. The calling function can then no longer use variables that were passed in. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// Note that it is preferable to use &amp;str instead of String here</span><br><span class="token comment">// unless we need a mutable String as demonstrated below.</span><br><span class="token comment">// However, we want to demonstrate using an argument value</span><br><span class="token comment">// that is definitely in the heap.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error "borrow of moved value: `s`"</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// triggers error above</span><br><span class="token punctuation">}</span></code></pre><p>We can fix this by changing the function to return the reference. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br>    s<br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span></code></pre><p>When references to variables on the stack or heap are passed to functions, ownership is borrowed by the function. If the function exits by returning the reference, ownership is returned to the calling function. Otherwise the data is freed and the calling function can then no longer use the variable that was passed in. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// We could pass the i32 argument by reference,</span><br><span class="token comment">// but there is no benefit in doing that.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span></code></pre><p>To allow a function to modify data passed to it by reference, pass and receive mutable references. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token operator">*</span>i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br>    s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">" more"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// on stack</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// on heap</span><br>    <span class="token comment">// Even though i and s are mutable, the arguments to</span><br>    <span class="token comment">// my_function below do not need to be marked as mutable</span><br>    <span class="token comment">// unless that function requires them to be mutable.</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test more"</span><br><span class="token punctuation">}</span></code></pre><p>A function can create a value on the heap and return it. This transfers ownership to the caller rather than freeing the data. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br>    s <span class="token comment">// returns to caller, transferring ownership</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span></code></pre><p>Early we said that memory allocated in a scope is freed when that scope exits. However, there is an exception to this when ownership is transferred outside the block. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> a<span class="token punctuation">;</span><br><br>    <span class="token punctuation">{</span><br>        <span class="token comment">// Allocate inside block.</span><br>        <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// Move ownership to a which lives outside this block.</span><br>        a <span class="token operator">=</span> b<span class="token punctuation">;</span><br><br>        <span class="token comment">// If the previous line is changed to</span><br>        <span class="token comment">// a = &amp;b;</span><br>        <span class="token comment">// we get the error "`b` does not live long enough"</span><br>        <span class="token comment">// because a will no longer get ownership</span><br>        <span class="token comment">// and b will be freed at the end of the block.</span><br><br>        <span class="token comment">// Memory for b is not freed when this block exits</span><br>        <span class="token comment">// because b no longer owns it.</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// We can use the value here because</span><br>    <span class="token comment">// the lifetime of a has not ended yet.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here is a similar example using a closure:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> a <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> inner <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span> <span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        a <span class="token operator">=</span> b<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="dereference">Dereference</h2><p>The dereference operator is used to get the value of a reference. It isn't needed very often. This is because unlike in most programming languages that support references (or pointers), Rust does not require different syntax for accessing fields and methods based on whether an instance or a reference is used. It supplies &quot;automatic referencing and dereferencing&quot; in field access and method calls. In the case of method calls, it automatically adds <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> based on the method declaration of the <code>self</code> type.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><br>        <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token operator">&amp;&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token number">0.0</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p_ref <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p_ref<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1; same syntax with reference</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p_ref<span class="token punctuation">.</span><span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false; same syntax with reference</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example where dereference is needed:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// Implementing the PartialEq and PartialOrd traits</span><br><span class="token comment">// enables comparing instances.</span><br><span class="token attribute attr-name">#[derive(Debug, PartialEq, PartialOrd)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> <span class="token constant">ORIGIN</span><span class="token punctuation">:</span> <span class="token class-name">Point2D</span> <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">is_origin</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><br>    <span class="token comment">// We could just check whether x and y are zero,</span><br>    <span class="token comment">// but then we wouldn't need to dereference pt.</span><br>    <span class="token comment">//pt.x == 0.0 &amp;&amp; pt.y == 0.0</span><br><br>    <span class="token comment">// We can't compare a Point2D reference to a Point2D,</span><br>    <span class="token comment">// but we can dereference pt to get the Point2D instance</span><br>    <span class="token comment">// it references and then compare that to ORIGIN.</span><br>    <span class="token operator">*</span>pt <span class="token operator">==</span> <span class="token constant">ORIGIN</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p equal q? {}"</span><span class="token punctuation">,</span> p <span class="token operator">==</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p is origin? {:?}"</span><span class="token punctuation">,</span> <span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"q is origin? {:?}"</span><span class="token punctuation">,</span> <span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br><span class="token punctuation">}</span></code></pre><h2 id="lifetimes">Lifetimes</h2><p>Lifetimes ensure that memory does not get freed before a reference to it can use it. This is only a concern in functions that take two or more references and return one of them.</p><p>All reference parameters and reference return types have a lifetime, but the Rust compiler automatically determines them in most cases. When it cannot, you must explicitly specify them. This is typically only needed when reference parameters can be returned. Usually the same lifetime is used on all of them AND on the return reference type.</p><p>Lifetimes are specified appear before type names are are composed of a single quote followed by a name which is typically a single letter such as &quot;a&quot;. They only serve to indicate which items in a function signature have the same lifetime, not an actual duration.</p><p>The following code illustrates potential errors that lifetime checking prevents.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">a</span><span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> <span class="token function">b</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// This function signature results in</span><br><span class="token comment">// "explicit lifetime required" errors for s1 and s2.</span><br><span class="token comment">// and a "missing lifetime specifier" error on the return type.</span><br><span class="token comment">// This is because when more than one reference is passed to a function</span><br><span class="token comment">// AND one of them can be returned, Rust requires lifetime specifiers.</span><br><span class="token comment">//fn b(s1: &amp;String, s2: &amp;String) -> &amp;String {</span><br><br><span class="token comment">// This function signature includes lifetime specifiers.</span><br><span class="token comment">// Now we get an error on the call to function b above</span><br><span class="token comment">// because it might return the value of the local variable s2</span><br><span class="token comment">// which is freed when function a exits.</span><br><span class="token comment">// "s2" would not be available in the caller ("main" in this case).</span><br><span class="token keyword">fn</span> <span class="token function-definition function">b</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token class-name">String</span><span class="token punctuation">,</span> s2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token class-name">String</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> s1 <span class="token operator">></span> s2 <span class="token punctuation">{</span><br>        s1<br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        s2<br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"greatest is {}"</span><span class="token punctuation">,</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>To use more than one lifetime specifier in a function signature, list them after the function name inside angle brackets separated by commas. For example, <code>fn my_function&lt;'a, 'b&gt;(...)</code>.</p><p>To specify that lifetime <code>b</code> is at least as long as lifetime <code>a</code>, use <code>fn my_function&lt;'a, 'b: 'a&gt;(...)</code>.</p><h2 id="error-handling">Error Handling</h2><p>Rust does not support throwing and catching exceptions like many other programming languages. Instead, functions that can fail typically return the enum type <code>Option</code> or <code>Result</code>.</p><p>The <code>Option</code> enum has two values, <code>Some</code> which wraps a value and <code>None</code> which doesn't. For example, a function that takes a vector and returns the first element that matches some criteria could return <code>Some</code> wrapping the element, or <code>None</code> if no match is found. This is similar to the <code>Maybe</code> monad in Haskell.</p><p>The <code>Result</code> enum also has two values, <code>Ok</code> which wraps a value and <code>Err</code> which wraps an error description. For example, a function that reads all the text in a file could return <code>Ok</code> wrapping the text, or <code>Err</code> wrapping a description of why reading the file failed. This is similar to the <code>Either</code> monad in Haskell.</p><p>There are many ways to handle values from these enum types.</p><ol><li><p>Use a <code>match</code> statement. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">MathError</span> <span class="token punctuation">{</span><br>    <span class="token class-name">DivisionByZero</span> <span class="token comment">// used by divide2:w</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">divide1</span><span class="token punctuation">(</span>numerator<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> denominator<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> denominator <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token punctuation">{</span><br>        <span class="token class-name">None</span> <span class="token comment">// means there is no result, but doesn't explain why</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Some</span><span class="token punctuation">(</span>numerator <span class="token operator">/</span> denominator<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Commented lines below show an alternative way</span><br><span class="token comment">// to describe the error using a string.</span><br><span class="token comment">//const DIV_BY_ZERO: &amp;str = "divide by zero";</span><br><span class="token keyword">fn</span> <span class="token function-definition function">divide2</span><span class="token punctuation">(</span>numerator<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> denominator<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token class-name">MathError</span><span class="token operator">></span> <span class="token punctuation">{</span><br><span class="token comment">//fn divide(numerator: f64, denominator: f64) -> Result&lt;f64, &amp;'static str> {</span><br>    <span class="token keyword">if</span> denominator <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token class-name">MathError</span><span class="token punctuation">::</span><span class="token class-name">DivisionByZero</span><span class="token punctuation">)</span><br>        <span class="token comment">//Err(DIV_BY_ZERO)</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>numerator <span class="token operator">/</span> denominator<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">.</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">match</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// returns an Option enum</span><br>        <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"divide by zero"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">Some</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:.2}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">match</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// returns a Result enum</span><br>        <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token comment">//Err(msg) => println!("{}", msg),</span><br>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {:.2}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><br><span class="token punctuation">}</span></code></pre></li><li><p>Use <code>if let</code> statement.<br>We can replace the <code>match</code> statements in the previous example with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Use the <code>unwrap</code> method.<br>This extracts the value from an <code>Option</code> or <code>Result</code> enum. If the value is a <code>Some</code> or <code>Ok</code> then it succeeds. If the value is a <code>None</code> or <code>Err</code> then it panics, exiting the program. When it is an <code>Err</code> the message it wraps will be output. We can replace the <code>match</code> and <code>if let</code> statements above with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Use the <code>expect</code> method.<br>This is nearly the same as the <code>unwrap</code> method. The only difference is that we can supply a custom error message. We can replace the lines above with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"division failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"division failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Use the <code>?</code> operator.<br>If the value is a <code>Some</code> or <code>Ok</code> then it is unwrapped and returned. If the value is a <code>None</code> or <code>Err</code> then it is returned to the caller. The function in which this operator is used must declare the proper return type and return a value of that type. This allows the caller to handle errors, similar to re-throwing an exception in other programming languages.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The <code>?</code> operator is shorthand for the <code>try!</code> macro.</p><p>Uses of <code>?</code> can be chained in the same statement. For example, suppose the function <code>alpha</code> returns a <code>Result</code> whose wrapped value is an object with a method <code>beta</code> that returns a <code>Result</code> whose wrapped value is an object with a method <code>gamma</code> that returns a <code>Result</code>. We can get the value of this call sequences with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">alpha</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">beta</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">gamma</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span></code></pre></li></ol><h2 id="built-in-scalar-types">Built-in Scalar Types</h2><p>Rust defines four scalar (primitive) types which are boolean, character, integer, and floating point.</p><p>The boolean type name is <code>bool</code>. Its only values are <code>true</code> and <code>false</code>.</p><p>The character type name is <code>char</code>. Literal values are surrounded by single quotes. Its values are Unicode values of up to four bytes. TODO: Does every character use all four bytes?</p><p>The signed integer type names are <code>i{n}</code> where <code>{n}</code> is the number of bits which can be 8, 16, 32, 64, 128 or <code>size</code> which corresponds to either 32 or 64 depending on the processor architecture. The default type for literal integers is <code>i32</code> regardless of the processor.</p><p>Literal integer values can use the underscore character to separate thousands, millions, and so on. For example, the population of the U.S. in 2020 was approximately 330_676_544. Hex values begin with <code>0x</code>, octal values begin with <code>0o</code>, and binary values begin with <code>0b</code>.</p><p>The unsigned integer types are the same, but start with <code>u</code> instead of <code>i</code>.</p><p>Floating point type names are <code>f{n}</code> where <code>{n}</code> is 32 or 64. The default type for literal floats is <code>f64</code> regardless of the processor. Literal floating point values must include a decimal point to avoid being treated as integer values.</p><h2 id="built-in-compound-types">Built-in Compound Types</h2><p>Rust defines two compound (non-primitive) types which are tuple and array. These are distinct from the collection types that are described later.</p><p>A tuple is a fixed-length list of values that can be of different types. The syntax for a tuple type is <code>(type1, type2, ...)</code>. The syntax for a tuple value is <code>(value1, value2, ...)</code>. Individual values can be accessed by index or destructuring. It is not possible to iterate over the elements of a tuple.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token constant">TODO</span><span class="token punctuation">:</span> <span class="token constant">ADD</span> <span class="token constant">THIS</span></code></pre><p>An array is a fixed-length list of values that have the same type. The syntax for an array type is <code>[type, length]</code>. The syntax for an array value is <code>[value1, value2, ...]</code>. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> rgb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// A Rust string is a "compound collection", covered later.</span><br><span class="token keyword">let</span> sevens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// same as [7, 7, 7, 7, 7]</span></code></pre><p>Elements of an array can be accessed using square brackets and zero-based indexes. For example, <code>rgb[1]</code> is &quot;green&quot;.</p><p>A <code>Vec</code> (vector) is a variable-length list of values that have the same type.</p><p>In many cases to operate on an array or <code>Vec</code> you will want to obtain an <code>Iterator</code> and operate on that. For example, that is where you will find the methods <code>map</code>, <code>filter</code>, and <code>fold</code>.</p><h2 id="collections">Collections</h2><p>Rust defines many kinds of collections that hold a variable number of values. These include strings and collections in the <code>std::collections</code> namespace.</p><p>The <code>std::collections</code> namespace defines the following sequence types:</p><ul><li><code>Vec</code>: a resizable, ordered array of any kind of value where items can be efficiently added at the end</li><li><code>VecDeque</code>: like a <code>Vec</code>, but items can also be efficiently added at the beginning</li><li><code>LinkedList</code>: like a <code>Vec</code>, but it they can be efficiently split and appended</li></ul><p>The <code>std::collections</code> namespace defines the following map types:</p><ul><li><code>HashMap</code>: a collection of key/value pairs with efficient value lookup by key where keys and values can be any kind of value</li><li><code>BTreeMap</code>: like a <code>HashMap</code>, but sorted by key enabling efficient retrieval of values corresponding to the smallest key, largest key, closest key that is smaller or larger than some key value, or range of keys</li></ul><p>The <code>std::collections</code> namespace defines the following set types:</p><ul><li><code>HashSet</code>: a collection of unique values with efficient determination of whether a given value is a member</li><li><code>BTreeSet</code>: similar to storing only the keys in a <code>BTreeMap</code></li></ul><p>The <code>std::collections</code> namespace defines one more collection type that doesn't fall into the previous categories:</p><ul><li><code>BinaryHeap</code>: implements a priority queue where only the highest priority item is accessible</li></ul><h3 id="strings">Strings</h3><p>Strings are collections of UTF-8 encoded characters stored as a <code>Vec</code> of <code>u8</code> byte values. Literal values are surrounded by double quotes. Strings are more difficult to work with in Rust than in other languages. Rust trades simplicity here for better performance, concurrency, memory management.</p><p>There are two kinds of strings in Rust. The language defines the &quot;string slice&quot; type <code>&amp;str</code> and the standard library defines the <code>String</code> type. A <code>&amp;str</code> value has a fixed length. The compiler decides whether its data should be stored on the stack or in the heap. You just get a reference to it. A <code>String</code> value has a variable length and is stored in the heap.</p><p>Literal characters (just one) are surrounded by single quotes and have the type <code>char</code>. Literal strings (zero or more characters) are surrounded by double quotes and have the type <code>&amp;str</code>.</p><p>Typically variables for strings that do not require mutation should have the type <code>&amp;str</code> and those that do should have the type <code>&amp;mut String</code>.</p><p>In the tables below, assume the following variable types:</p><ul><li><code>c</code> holds a <code>char</code> value</li><li><code>r</code> holds a <code>std::ops::Range</code></li><li><code>s</code> and <code>t</code> hold <code>&amp;str</code> values</li><li><code>u</code>, <code>v</code>, and <code>w</code> hold <code>String</code> values</li><li><code>z</code> holds a char or <code>&amp;str</code></li></ul><p>Everywhere <code>c</code> is used, a literal character can be used in its place. Everywhere <code>s</code> and <code>t</code> are used, a literal string can be used in its place.</p><p>Here are operations on the <code>str</code> type:</p><table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody><tr><td>create</td><td><code>&quot;text in double quotes&quot;</code></td></tr><tr><td>concatenate to <code>&amp;str</code></td><td>cannot be done</td></tr><tr><td>get substring</td><td><code>s[start..end]</code> (1)</td></tr><tr><td>get iterator over Unicode characters</td><td><code>s.chars()</code></td></tr><tr><td>get <code>char</code> at index</td><td><code>s.chars().nth(index)</code> (2)</td></tr><tr><td>determine if contains</td><td><code>s.contains(z)</code></td></tr><tr><td>determine if ends with</td><td><code>s.ends_with(z)</code></td></tr><tr><td>determine if starts with</td><td><code>s.starts_with(z)</code></td></tr><tr><td>get substring</td><td><code>s.get(r)</code> (3)</td></tr><tr><td>get length</td><td><code>s.len()</code></td></tr><tr><td>get iterator over lines</td><td><code>s.lines()</code></td></tr><tr><td>parse into another type such as specific number type</td><td><code>let v = s.parse::&lt;T&gt;()</code> (4)</td></tr><tr><td>create <code>String</code> that repeat n times</td><td><code>s.repeat(n)</code></td></tr><tr><td>replace all occurrences of z1 with z2</td><td><code>s.replace(z1, z2)</code></td></tr><tr><td>replace first n occurrences of z1 with z2</td><td><code>s.replacen(z1, z2, n)</code></td></tr><tr><td>split on a character</td><td><code>s.split(c)</code> returns an iterator (5)</td></tr><tr><td>split at index</td><td><code>s.split_at(n)</code> returns tuple</td></tr><tr><td>split on any amounts of whitespace</td><td><code>s.split_whitespace()</code></td></tr><tr><td>remove prefix</td><td><code>s.strip_prefix(z)</code> returns <code>Option</code></td></tr><tr><td>remove suffix</td><td><code>s.strip_suffix(z)</code> returns <code>Option</code></td></tr><tr><td>convert <code>&amp;str</code> to <code>String</code></td><td><code>s.to_string()</code></td></tr><tr><td>get lowercase <code>String</code></td><td><code>s.to_lowercase()</code></td></tr><tr><td>get uppercase <code>String</code></td><td><code>s.to_uppercase()</code></td></tr><tr><td>get slice with leading and trailing whitespace removed</td><td><code>s.trim()</code></td></tr><tr><td>get slice with trailing whitespace removed</td><td><code>s.trim_end()</code></td></tr><tr><td>get slice with leading whitespace removed</td><td><code>s.trim_start()</code></td></tr></tbody></table><ol><li><code>start</code> is inclusive and <code>end</code> is exclusive.</li><li>The <code>chars</code> method can be used to iterate over the characters in a string. The <code>nth</code> method returns a <code>Option</code> object because the string may be shorter than the index. To get the <code>char</code> from it, use one of the approaches below.</li><li>This returns an <code>Option</code> object rather than panic on bad indexes.</li><li>The <code>::&lt;T&gt;</code> syntax is called &quot;turbofish&quot;.</li><li>Call the <code>collect</code> method on this iterator to get a <code>Vec&lt;&amp;str&gt;</code>.</li></ol><p>Many <code>String</code> methods operate on byte indexes. This works for strings that only contain ASCII characters, but is dangerous for things that contain multi-byte Unicode characters. Methods on the <code>str</code> type are better for working with Unicode characters.</p><p>Here are operations on the <code>String</code> type. Note that methods that modify the value require the <code>String</code> to be mutable (<code>mut</code>).</p><table><thead><tr><th>Operation</th><th>Syntax</th></tr></thead><tbody><tr><td>create empty</td><td><code>String::new()</code></td></tr><tr><td>create from <code>&amp;str</code> #1</td><td><code>String::from(s)</code></td></tr><tr><td>create from <code>&amp;str</code> #2</td><td><code>s.to_string()</code></td></tr><tr><td>create from multiple <code>&amp;str</code> #1</td><td><code>let u = [s, t].concat();</code></td></tr><tr><td>create from multiple <code>&amp;str</code> #2</td><td><code>let u = format!(&quot;{}{}&quot;, s, t);</code></td></tr><tr><td>create from <code>String</code> and <code>&amp;str</code> (1)</td><td><code>let u = v + s;</code></td></tr><tr><td>create from multiple <code>String</code> values (2)</td><td><code>let u = v + &amp;w;</code></td></tr><tr><td>get <code>&amp;str</code> without copying</td><td><code>let s = &amp;t;</code></td></tr><tr><td>append character</td><td><code>u.push(c)</code></td></tr><tr><td>append <code>&amp;str</code></td><td><code>u += s;</code></td></tr><tr><td>append <code>String</code></td><td><code>u += v;</code></td></tr><tr><td>append <code>&amp;str</code></td><td><code>u.push_str(s)</code></td></tr><tr><td>get substring</td><td>same as for <code>&amp;str</code></td></tr><tr><td>get substring from index to end</td><td><code>s[start..]</code></td></tr><tr><td>get substring from beginning to index</td><td><code>s[..end]</code></td></tr><tr><td>get substring where end is inclusive</td><td><code>u[start.. =end]</code></td></tr><tr><td>get <code>char</code> at index</td><td><code>&amp;u.chars().nth(index)</code></td></tr><tr><td>get length</td><td><code>u.len()</code></td></tr><tr><td>remove and return last character</td><td><code>u.pop()</code></td></tr></tbody></table><ol><li>The <code>String</code> <code>u</code> here must be first.</li><li>All <code>String</code> values on the right of <code>=</code> after the first must be preceded by <code>&amp;</code> which converts it to a <code>&amp;str</code>.</li></ol><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> my_string <span class="token operator">=</span> <span class="token string">"Santa 🎅 🎄"</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> letter <span class="token operator">=</span> <span class="token operator">&amp;</span>my_string<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nth</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Approach #1</span><br><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=</span> letter <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"letter is {}"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Approach #2</span><br><span class="token keyword">match</span> letter <span class="token punctuation">{</span><br>    <span class="token class-name">Some</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"letter is {}"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ignores when string is shorter</span><br><span class="token punctuation">}</span></code></pre><p>Here's a function that returns the first word in a string that might contain non-ASCII Unicode characters:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> letter<span class="token punctuation">)</span> <span class="token keyword">in</span> s<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> letter <span class="token operator">==</span> <span class="token char string">' '</span> <span class="token punctuation">{</span><br>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    s<br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"foo bar baz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span><br><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"onelongword"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// onelongword</span><br><span class="token punctuation">}</span></code></pre><p>In many programming languages strings are immutable. To make a change you create a new string and assign it back to the same variable. In Rust the <code>&amp;mut str</code> type can be used for this. If it is desirable to modify a string in place, perhaps for performance reasons, the <code>mut String</code> type can be used instead. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token string">"first"</span><span class="token punctuation">;</span><br>s1 <span class="token operator">=</span> <span class="token string">"second"</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> <span class="token keyword">mut</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>s2<span class="token punctuation">.</span><span class="token function">replace_range</span><span class="token punctuation">(</span><span class="token punctuation">..</span><span class="token punctuation">,</span> <span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>When a <code>String</code> reference is passed to a function that expects a <code>&amp;str</code> it is automatically coerced to that type. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span></code></pre><h3 id="vectors">Vectors</h3><table><thead><tr><th>Operation</th><th>Syntax</th></tr></thead><tbody><tr><td>create empty</td><td><code>Vec::new()</code></td></tr></tbody></table><p>TODO: Finish this.</p><h3 id="sets">Sets</h3><p>To use the <code>HashSet</code> type by ony its name:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashSet</span><span class="token punctuation">;</span></code></pre><p>Here is an example of creating and using a <code>HashSet</code> containing <code>String</code> elements:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// Element type is inferred from what is inserted.</span><br><span class="token keyword">let</span> <span class="token keyword">mut</span> colors <span class="token operator">=</span> <span class="token class-name">HashSet</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>colors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>colors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>colors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"colors = {:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"color count = {:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"contains green? = {:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"contains orange? = {:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"orange"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br><br>colors<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"after removing green, colors = {:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">for</span> color <span class="token keyword">in</span> <span class="token operator">&amp;</span>colors <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of creating and using a <code>HashSet</code> containing <code>struct</code> elements:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug, Eq, Hash, PartialEq)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Dog</span> <span class="token punctuation">{</span><br>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br>    breed<span class="token punctuation">:</span> <span class="token class-name">String</span><br><span class="token punctuation">}</span><br><span class="token keyword">impl</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> breed<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Dog</span> <span class="token punctuation">{</span><br>            name<span class="token punctuation">:</span> name<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>            breed<span class="token punctuation">:</span> breed<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">let</span> <span class="token keyword">mut</span> dogs <span class="token operator">=</span> <span class="token class-name">HashSet</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Maisey"</span><span class="token punctuation">,</span> <span class="token string">"Treeing Walker Coonhound"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Ramsay"</span><span class="token punctuation">,</span> <span class="token string">"Native American Indian Dog"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Oscar"</span><span class="token punctuation">,</span> <span class="token string">"German Shorthaired Pointer"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">,</span> <span class="token string">"Whippet"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"dogs = {:#?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">for</span> dog <span class="token keyword">in</span> <span class="token operator">&amp;</span>dogs <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> dog<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">let</span> comet <span class="token operator">=</span> <span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">,</span> <span class="token string">"Whippet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> spot <span class="token operator">=</span> <span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Spot"</span><span class="token punctuation">,</span> <span class="token string">"Beagle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"contains Comet? = {:?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>comet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"contains Spot? = {:?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spot<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre><h3 id="maps">Maps</h3><p>To use the <code>HashMap</code> type by ony its name:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span></code></pre><p>Here is an example of creating and using a <code>HashMap</code> with <code>String</code> keys and <code>i32</code> values:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// Key and value types are inferred from what is inserted.</span><br><span class="token keyword">let</span> <span class="token keyword">mut</span> days_in_month <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>days_in_month<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"January"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>days_in_month<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"February"</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>days_in_month<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"March"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>days_in_month<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"April"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"daysInMonth = {:#?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"entries = {:?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"days in March = {:?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"March"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>days_in_month<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"February"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"entries = {:?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"days in February = {:?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"February"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> month <span class="token operator">=</span> <span class="token string">"April"</span><span class="token punctuation">;</span><br><span class="token keyword">match</span> days_in_month<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token class-name">Some</span><span class="token punctuation">(</span>days<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"There are {} days in {}."</span><span class="token punctuation">,</span> days<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"No data found for {}."</span><span class="token punctuation">,</span> month<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">for</span> <span class="token punctuation">(</span>month<span class="token punctuation">,</span> days<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token operator">&amp;</span>days_in_month <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"There are {} days in {}."</span><span class="token punctuation">,</span> days<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of creating and using a <code>HashMap</code> with <code>String</code> keys and <code>struct</code> values:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug, Eq, Hash, PartialEq)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Dog</span> <span class="token punctuation">{</span><br>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br>    breed<span class="token punctuation">:</span> <span class="token class-name">String</span><br><span class="token punctuation">}</span><br><span class="token keyword">impl</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> breed<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Dog</span> <span class="token punctuation">{</span><br>            name<span class="token punctuation">:</span> name<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>            breed<span class="token punctuation">:</span> breed<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Key and value types are inferred from what is inserted.</span><br><span class="token keyword">let</span> <span class="token keyword">mut</span> dogs <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// This function must be a closure so it can access dogs.</span><br><span class="token keyword">let</span> <span class="token keyword">mut</span> add_dog <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> breed<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span><br>    dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> breed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token function">add_dog</span><span class="token punctuation">(</span><span class="token string">"Maisey"</span><span class="token punctuation">,</span> <span class="token string">"Treeing Walker Coonhound"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">add_dog</span><span class="token punctuation">(</span><span class="token string">"Ramsay"</span><span class="token punctuation">,</span> <span class="token string">"Native American Indian Dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">add_dog</span><span class="token punctuation">(</span><span class="token string">"Oscar"</span><span class="token punctuation">,</span> <span class="token string">"German Shorthaired Pointer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">add_dog</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">,</span> <span class="token string">"Whippet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"dogs = {:#?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"entries = {:?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Comet = {:#?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>dogs<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"entries = {:?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><br><br><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">"Oscar"</span><span class="token punctuation">;</span><br><span class="token keyword">match</span> dogs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token class-name">Some</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"found {:#?}."</span><span class="token punctuation">,</span> dog<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"No dog named {} found."</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">for</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> dog<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token operator">&amp;</span>dogs <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} is a {}."</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> dog<span class="token punctuation">.</span>breed<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="slices">Slices</h2><p>A slice is a reference to a contiguous subset of a collection. This is what a <code>&amp;str</code> value represents. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"abcdefgh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Note the &amp; which says we are getting a</span><br><span class="token comment">// "reference" to a portion of the string.</span><br><span class="token keyword">let</span> sub <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "def"</span></code></pre><p>Many kinds of collections, including Array and Vector, support obtaining slices of their elements.</p><p>The following table shows all the syntax variations of ranges:</p><table><thead><tr><th>Syntax</th><th>Meaning</th></tr></thead><tbody><tr><td><code>s..e</code></td><td>s to e-1</td></tr><tr><td><code>s..=e</code></td><td>s to e</td></tr><tr><td><code>s..</code></td><td>s to end</td></tr><tr><td><code>..e</code></td><td>0 to e-1</td></tr><tr><td><code>..=e</code></td><td>0 to e</td></tr></tbody></table><h2 id="conditional-logic">Conditional Logic</h2><p><code>if</code> expressions are the most common way to implement conditional logic. The condition is not surrounded by parentheses. where blocks require surrounding curly brackets. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"hot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> temperature <span class="token operator">&lt;</span> <span class="token number">40</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"cold"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"tolerable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The expression can be assigned to a variable. Newlines are not required, so this can be written on a single line. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span> <span class="token string">"red"</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"blue"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Other ways to implement conditional logic include <code>if let</code> and <code>match</code> expressions which use pattern matching to extract a value. These were shown in the early &quot;Error Handling&quot; section.</p><p><code>match</code> expressions can be used to match on any kind of value. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> month <span class="token operator">=</span> <span class="token string">"February"</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> holiday <span class="token operator">=</span> <span class="token keyword">match</span> month <span class="token punctuation">{</span><br>    <span class="token string">"January"</span> <span class="token operator">=></span> <span class="token string">"New Year's Day"</span><span class="token punctuation">,</span><br>    <span class="token string">"February"</span> <span class="token operator">=></span> <span class="token string">"Valentine's Day"</span><span class="token punctuation">,</span><br>    <span class="token string">"July"</span> <span class="token operator">=></span> <span class="token string">"Independence Day"</span><span class="token punctuation">,</span><br>    <span class="token string">"October"</span> <span class="token operator">=></span> <span class="token string">"Halloween"</span><span class="token punctuation">,</span><br>    <span class="token string">"November"</span> <span class="token operator">=></span> <span class="token string">"Thanksgiving"</span><span class="token punctuation">,</span><br>    <span class="token string">"December"</span> <span class="token operator">=></span> <span class="token string">"Christmas"</span><span class="token punctuation">,</span><br>    _ <span class="token operator">=></span> <span class="token string">"unknown"</span> <span class="token comment">// underscore matches an other value</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The holiday in {} is {}."</span><span class="token punctuation">,</span> month<span class="token punctuation">,</span> holiday<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The part of each match on the left side of <code>=&gt;</code> is called a &quot;match arm&quot;. It can list multiple values separated by <code>|</code> characters. It can also specify a numeric range.</p><p>The part on the right side of <code>=&gt;</code> can be an expression or a block.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">get_points</span><span class="token punctuation">(</span>rank<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">i8</span> <span class="token punctuation">{</span><br>    <span class="token keyword">match</span> rank <span class="token punctuation">{</span><br>        <span class="token string">"Jack"</span> <span class="token operator">|</span> <span class="token string">"Queen"</span> <span class="token operator">|</span> <span class="token string">"King"</span> <span class="token operator">=></span> <span class="token number">10</span><span class="token punctuation">,</span><br>        <span class="token string">"Ace"</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> <span class="token keyword">match</span> rank<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">i8</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>              <span class="token class-name">Ok</span><span class="token punctuation">(</span>points<span class="token punctuation">)</span> <span class="token operator">=></span> points<span class="token punctuation">,</span><br>              <span class="token class-name">Err</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token number">0</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> cards <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"7"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span> <span class="token string">"Ace"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"bad"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> rank <span class="token keyword">in</span> <span class="token operator">&amp;</span>cards <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Points for {} is {}."</span><span class="token punctuation">,</span> rank<span class="token punctuation">,</span> <span class="token function">get_points</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> category <span class="token operator">=</span> <span class="token keyword">match</span> age <span class="token punctuation">{</span><br>        <span class="token comment">// The ranges cannot overlap and</span><br>        <span class="token comment">// must use "..=" rather than "..".</span><br>        <span class="token number">0</span><span class="token punctuation">..=</span><span class="token number">2</span> <span class="token operator">=></span> <span class="token string">"toddler"</span><span class="token punctuation">,</span><br>        <span class="token number">3</span><span class="token punctuation">..=</span><span class="token number">12</span> <span class="token operator">=></span> <span class="token string">"child"</span><span class="token punctuation">,</span><br>        <span class="token number">13</span><span class="token punctuation">..=</span><span class="token number">19</span> <span class="token operator">=></span> <span class="token string">"teen"</span><span class="token punctuation">,</span><br>        <span class="token number">20</span><span class="token punctuation">..=</span><span class="token number">59</span> <span class="token operator">=></span> <span class="token string">"adult"</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> <span class="token string">"senior"</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} is a {}."</span><span class="token punctuation">,</span> age<span class="token punctuation">,</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Rust does not support the ternary operator (<code>? :</code>) found in many other programming languages. Since <code>if</code> forms an expression that has a value, the following can be written to simulate a ternary:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">const</span> color <span class="token operator">=</span> <span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span> <span class="token string">"red"</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"blue"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>It is possible to write a macro to mimic this, but it doesn't reduce the expression much. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token macro property">macro_rules!</span> tern <span class="token punctuation">{</span><br>    <span class="token punctuation">(</span><span class="token variable">$cond</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">expr</span> <span class="token operator">=></span> <span class="token variable">$true_expr</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">expr</span><span class="token punctuation">,</span> <span class="token variable">$false_expr</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">expr</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token variable">$cond</span> <span class="token punctuation">{</span><br>            <span class="token variable">$true_expr</span><br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>            <span class="token variable">$false_expr</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> temperature <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token macro property">tern!</span><span class="token punctuation">(</span>temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token operator">=></span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blue</span><br><span class="token punctuation">}</span></code></pre><h2 id="standard-io"><a name="standard-io">Standard IO</a></h2><p>The <code>std::io</code> namespace supports many input/output operations. The members <code>stdin</code> and <code>stdout</code> are functions that return objects with methods for operating on the actual <code>stdio</code> and <code>stdout</code> streams.</p><p>The <code>stdin</code> methods like <code>read_line</code> and <code>stdout</code> methods like <code>write</code> and <code>flush</code> return a <code>Result</code> enum value.</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// The Write trait is required in order to use the flush method.</span><br><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span></span><span class="token punctuation">{</span>stdin<span class="token punctuation">,</span> stdout<span class="token punctuation">,</span> <span class="token class-name">Write</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> buffer <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">loop</span> <span class="token punctuation">{</span><br>        <span class="token macro property">print!</span><span class="token punctuation">(</span><span class="token string">"Command: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">stdout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buffer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        buffer<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// removes newline from end of buffer</span><br><br>        <span class="token keyword">if</span> buffer <span class="token operator">==</span> <span class="token string">"quit"</span> <span class="token punctuation">{</span><br>            <span class="token keyword">break</span><span class="token punctuation">;</span><br>     <span class="token punctuation">}</span><br><br>      <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"You entered {}."</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>      buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prepares to reuse buffer</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here is a modified version of the code above that uses the <code>text_io</code> crate: To use this, add the following to the dependency <code>text_io = &quot;0.1.8&quot;</code> in Cargo.toml. It also adds a <code>print_flush</code> function to simplify writing to <code>stdout</code> without including a newline.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token class-name">Write</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">use</span> <span class="token namespace">text_io<span class="token punctuation">::</span></span>read<span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">print_flush</span><span class="token punctuation">(</span>text<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> <span class="token keyword">mut</span> stdout <span class="token operator">=</span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token function">stdout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  stdout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  stdout<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">loop</span> <span class="token punctuation">{</span><br>    <span class="token function">print_flush</span><span class="token punctuation">(</span><span class="token string">"Command: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> command<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token macro property">read!</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reads until newline and omits it</span><br>    <span class="token keyword">if</span> command <span class="token operator">==</span> <span class="token string">"quit"</span> <span class="token punctuation">{</span><br>      <span class="token keyword">break</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"You entered {}."</span><span class="token punctuation">,</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="iteration-(looping)">Iteration (Looping)</h2><p>Rust supports the following looping expressions:</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>loop</code></td><td>infinite loop that can be exited with a <code>break</code></td></tr><tr><td><code>while</code></td><td>top-tested loop that repeats as long as an expression evaluates to <code>true</code></td></tr><tr><td><code>while let</code></td><td>like <code>while</code>, but repeats as long as a pattern match succeeds</td></tr><tr><td><code>for</code></td><td>for looping over an iterator</td></tr></tbody></table><p>For an example using <code>loop</code>, see the <a href="#standard-io">Standard IO</a> section.</p><p>TODO: Do something with the following example code.</p><p>Here's an example of using a <code>while</code> loop:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">while</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} is odd"</span><span class="token punctuation">,</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>A <code>while let</code> loop is useful when iterating over repeated calls to a function that might fail. The example below uses the <code>futures</code> crate which requires adding the dependency <code>futures = &quot;0.3.8&quot;</code> to <code>Cargo.toml</code>. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">futures<span class="token punctuation">::</span>executor<span class="token punctuation">::</span></span>block_on<span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">rand<span class="token punctuation">::</span></span><span class="token class-name">Rng</span><span class="token punctuation">;</span><br><br><span class="token comment">// Pretend this function makes a REST call that could possibly fail.</span><br><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token keyword">i8</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token keyword">str</span><span class="token operator">></span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> <span class="token keyword">mut</span> rng <span class="token operator">=</span> <span class="token namespace">rand<span class="token punctuation">::</span></span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> n <span class="token operator">=</span> rng<span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number from 1 to 10</span><br>  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"get_data: n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">7</span> <span class="token punctuation">{</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token string">"failed"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Here is an approach for processing the result of a single call.</span><br>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">block_on</span><span class="token punctuation">(</span><span class="token function">get_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">match</span> result <span class="token punctuation">{</span><br>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in single call, n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">Err</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"get_data error: {}"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Here is an approach for processing calls in a loop</span><br>    <span class="token comment">// that continues until an Err is returned.</span><br>    <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">block_on</span><span class="token punctuation">(</span><span class="token function">get_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in while let, n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>A <code>for</code> loop is used to iterate over any kind of iterator. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// We can use range notation to iterate over a range of numbers</span><br>    <span class="token comment">// where the first number inclusive and the last is exclusive.</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">4</span> <span class="token punctuation">{</span> <span class="token comment">// 1, 2, and 3</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 1: n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token comment">// Adding = before the second number makes the range inclusive.</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..=</span><span class="token number">4</span> <span class="token punctuation">{</span> <span class="token comment">// 1, 2, 3, and 4</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 2: n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Iterating over the items in a tuple is not supported,</span><br>    <span class="token comment">// but we can iterate over the items in an array.</span><br>    <span class="token keyword">let</span> num_arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> num_arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 3: n = {:?}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// The iter_mut method allows items to be mutated during iteration.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> mut_num_arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token comment">// Double all the numbers during iteration.</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> mut_num_arr<span class="token punctuation">.</span><span class="token function">iter_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token operator">*</span>n <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> mut_num_arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 4: {:?}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Another approach is to create a new array of modified values</span><br>    <span class="token comment">// using the array map method that is considered experimental</span><br>    <span class="token comment">// and only available in nightly builds as of 12/13/20.</span><br>    <span class="token comment">//let new_numbers = numbers.map(|n| n * 2);</span><br><br>    <span class="token comment">// We can call the map method on an iterator</span><br>    <span class="token comment">// to create a new iterator over doubled numbers.</span><br>    <span class="token keyword">let</span> new_iter <span class="token operator">=</span> mut_num_arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>n<span class="token closure-punctuation punctuation">|</span></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> new_iter <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 5: {:?}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// We can iterate over the items in a vector.</span><br>    <span class="token keyword">let</span> num_vec <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> num_vec<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 3: n = {:?}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Let's look at one more iteration example that requires specifying lifetimes. The function <code>longest</code> is passed a reference to an array of strings. There are three lifetimes to consider, that of the array, that of the elements inside it, and that of the return value. Rust wants to know that the array elements will live as long as the return value since one of them will be returned. We must specify that with lifetime annotations (<code>'a</code> below).</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">longest</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">{</span><br>    strings<br>        <span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>acc<span class="token punctuation">,</span> s<span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">if</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> acc<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> s <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> acc <span class="token punctuation">}</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">let</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token string">"cherry"</span><span class="token punctuation">,</span> <span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">longest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"longest is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="iterators">Iterators</h2><p>Many Rust methods return a <code>std::iter::Iterator</code> that can be used to iterate over the elements of a collection. This type supports methods in the following non-exhaustive list:</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>all(predFn)</code></td><td>returns <code>bool</code> indicating if <code>predFn</code> returns true for all elements</td></tr><tr><td><code>any(predFn)</code></td><td>returns <code>bool</code> indicating if <code>predFn</code> returns true for any elements</td></tr><tr><td><code>chain(iter2)</code></td><td>returns <code>Iterator</code> that iterates over combined elements</td></tr><tr><td><code>collect()</code></td><td>returns a <code>std::vec::Vec</code> containing all the elements</td></tr><tr><td><code>count()</code></td><td>returns number of elements in <code>Iterator</code>, consuming it</td></tr><tr><td><code>enumerate()</code></td><td>returns <code>Iterator</code> over tuples of indexes and elements</td></tr><tr><td><code>filter(predFn)</code></td><td>returns <code>Iterator</code> over elements for which <code>predFn</code> returns true</td></tr><tr><td><code>fold(fn)</code></td><td>returns result of combining elements into a single value</td></tr><tr><td><code>last()</code></td><td>returns last element in <code>Iterator</code>, consuming it</td></tr><tr><td><code>map(fn)</code></td><td>returns <code>Iterator</code> over results of calling a function on each element</td></tr><tr><td><code>max()</code></td><td>returns <code>Option</code> that wraps the largest element</td></tr><tr><td><code>max_by(fn)</code></td><td>returns <code>Option</code> that wraps the largest result based on passing pairs of elements to a function</td></tr><tr><td><code>max_by_key(fn)</code></td><td>returns <code>Option</code> that wraps the largest result of passing each element to a function</td></tr><tr><td><code>min()</code></td><td>returns <code>Option</code> that wraps the smallest element</td></tr><tr><td><code>min_by(fn)</code></td><td>returns <code>Option</code> that wraps the smallest result based on passing pairs of elements to a function</td></tr><tr><td><code>min_by_key(fn)</code></td><td>returns <code>Option</code> that wraps the smallest result of passing each element to a function</td></tr><tr><td><code>nth(n)</code></td><td>returns the nth element</td></tr><tr><td><code>partition(predFn)</code></td><td>returns two collections containing elements for which a function returns true or false</td></tr><tr><td><code>position(predFn)</code></td><td>returns the first element for which a function returns true</td></tr><tr><td><code>product()</code></td><td>returns the product of number values</td></tr><tr><td><code>rev()</code></td><td>returns an iterate that iterates in the reverse order</td></tr><tr><td><code>skip(n)</code></td><td>returns an <code>Iterator</code> that begins after n elements</td></tr><tr><td><code>skip_while(predFn)</code></td><td>returns an <code>Iterator</code> that begins at the first element for which a function returns false</td></tr><tr><td><code>sum()</code></td><td>returns the sum of number values</td></tr><tr><td><code>take(n)</code></td><td>returns an <code>Iterator</code> that stops after the first n elements</td></tr><tr><td><code>take_while(predFn)</code></td><td>returns an <code>Iterator</code> that stops at the last element for which a function returns true</td></tr><tr><td><code>zip()</code></td><td>returns an <code>Iterator</code> over <code>Option</code> objects that wrap corresponding elements from two <code>Iterators</code></td></tr></tbody></table><p>Here is an example of using the <code>fold</code> method:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> sum <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>acc<span class="token punctuation">,</span> n<span class="token closure-punctuation punctuation">|</span></span> acc <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// For this use of fold we can use the sum method instead.</span><br><span class="token keyword">let</span> sum <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here is an example of using the <code>filter</code> method.</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// This is a predicate function that is by the filter method.</span><br><span class="token comment">// It must take a reference to a item in an Iterator.</span><br><span class="token comment">// In this case the item type is &amp;str,</span><br><span class="token comment">// so the parameter must have the type &amp;&amp;str.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">is_short</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><br>    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">5</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> months <span class="token operator">=</span> <span class="token string">"January|February|March|April|May|June|July|August"</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This passes a closure to the filter method.</span><br>    <span class="token keyword">let</span> short_names<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token operator">></span> <span class="token operator">=</span> months<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token char string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>m<span class="token closure-punctuation punctuation">|</span></span> m<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"shorts = {:?}"</span><span class="token punctuation">,</span> short_names<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This passes a function to the filter method.</span><br>    <span class="token keyword">let</span> short_names<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token operator">></span> <span class="token operator">=</span> months<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token char string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>is_short<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"shorts = {:?}"</span><span class="token punctuation">,</span> short_names<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of using the <code>map</code> method:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> iter <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>n<span class="token closure-punctuation punctuation">|</span></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// doubles each number</span><br><span class="token keyword">for</span> n <span class="token keyword">in</span> iter <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// We cannot create an array from an iterator,</span><br><span class="token comment">// but we can create a Vector.</span><br><span class="token keyword">let</span> v1 <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> iter <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>n<span class="token closure-punctuation punctuation">|</span></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> v2<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here is an example of using the <code>zip</code> method:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> <span class="token keyword">mut</span> iter <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">zip</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">None</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="functions">Functions</h2><p>Functions are defined using the <code>fn</code> keyword, followed by a name, parameter list, return type, and body. Functions that do not return anything omit the return type rather than specify a type like <code>void</code> as is done in some other languages.</p><p>A <code>return</code> statement returns the value of an expression. If the last statement is not terminated by a semicolon, its value is returned. This means that <code>return my_result;</code> is equivalent to <code>my_result</code>.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">average</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> sum<span class="token punctuation">:</span> <span class="token keyword">f64</span> <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">f64</span> <span class="token comment">// return value</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">greet</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, {}!"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> numbers<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"average = {}"</span><span class="token punctuation">,</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Function parameters that are strings that are not mutated by the function should almost always have the type <code>&amp;str</code>. This allows many string representations to be passed in including literal strings, <code>&amp;str</code> values, and <code>&amp;String</code> values.</p><p>TODO: Try to write a generic version of the average function TODO: that works on any numeric type. But see TODO: <a href="https://users.rust-lang.org/t/passing-generic-vector-of-numbers/52486/7">https://users.rust-lang.org/t/passing-generic-vector-of-numbers/52486/7</a>.</p><p>Functions are accessible by default within the same source file, but they are private by default when defined in a different source file. For functions that should be visible outside the source file that defines them, add the <code>pub</code> keyword before the <code>fn</code> keyword.</p><p>Named functions in Rust are not closures. They do not capture variables from their surrounding environment. However, anonymous functions assigned to variables are closures. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> a <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> inner <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span> <span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span><br>        a <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span> <span class="token comment">// a is visible since we are in a closure</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Rust does not support writing functions that accept a variable number of arguments (variadic). They can instead be passed in an array. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// This takes an array of strings and returns one of them.</span><br><span class="token comment">// Lifetimes must be specified, but why?</span><br><span class="token keyword">fn</span> <span class="token function-definition function">longest</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">{</span><br>    strings<br>        <span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>acc<span class="token punctuation">,</span> s<span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">if</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> acc<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> s <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> acc <span class="token punctuation">}</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token string">"cherry"</span><span class="token punctuation">,</span> <span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">longest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"longest is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="operators">Operators</h2><p>Rust supports most of the common operators found in other programming languages.</p><p>The <code>std::ops</code> namespace defines overloadable operators. For example, we can define what it means to add and subtract to <code>Point2D</code> objects by implementing the <code>Add</code> and <code>Sub</code> traits defined in <code>std::ops</code>.</p><p>The operators that can be implemented for custom types include:</p><ul><li>arithmetic: <code>+</code>, <code>+=</code>, <code>-</code>, <code>-=</code>, <code>_</code>, <code>_=</code>, <code>/</code>, <code>/=</code></li><li>bit shift: <code>&lt;&lt;</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;=</code></li><li>bitwise: <code>&amp;</code>, <code>&amp;=</code>, <code>|</code>, <code>|=</code>, <code>^</code>, and <code>^=</code></li><li>deref: <code>\*</code> for getting and setting a value</li><li>functions: <code>()</code> call operator in three forms</li><li>index: <code>[]</code> operator to get and set an element</li><li>logical: <code>!</code> not, but <code>&amp;&amp;</code> and <code>||</code> cannot be defined</li><li>mod: <code>%</code> and <code>%=</code></li><li>negate: <code>-</code> (unary)</li><li>range: <code>..</code> and <code>..=</code></li></ul><h2 id="ranges">Ranges</h2><p>The <code>std::ops</code> namespace defines the range types</p><table><thead><tr><th>Range Type</th><th>Meaning</th></tr></thead><tbody><tr><td><code>Range</code></td><td>start inclusive to end exclusive</td></tr><tr><td><code>RangeFrom</code></td><td>start inclusive and above</td></tr><tr><td><code>RangeFull</code></td><td>zero and above</td></tr><tr><td><code>RangeInclusive</code></td><td>start inclusive to end inclusive</td></tr><tr><td><code>RangeTo</code></td><td>zero to end exclusive</td></tr><tr><td><code>RangeToInclusive</code></td><td>start inclusive to end inclusive</td></tr></tbody></table><p>These are distinct types and there is not a provided range type that encompasses all of them.</p><p>Objects of these types are regular values that can be assigned to variables, be members of structs, be passed to functions, and be returned from functions.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Range</span><span class="token punctuation">,</span> <span class="token class-name">RangeInclusive</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">print_range</span><span class="token punctuation">(</span>r<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Range</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"range = {:?}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">print_range_inclusive</span><span class="token punctuation">(</span>r<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">RangeInclusive</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"range = {:?}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> r1 <span class="token operator">=</span> a<span class="token punctuation">..</span>b<span class="token punctuation">;</span><br>    <span class="token function">print_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// range = 3..7</span><br>    <span class="token comment">// The Range contains method requires a ref to a number,</span><br>    <span class="token comment">// so even literal values must be passed by reference.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br><br>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> a<span class="token punctuation">..=</span>b<span class="token punctuation">;</span><br>    <span class="token function">print_range_inclusive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// range = 3..=7</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> r2 <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="structs">Structs</h2><p>A struct defines a type that is a set of related fields and methods, similar to a class in other languages. The <code>struct</code> keyword only defines fields. The <code>impl</code> keyword adds instance and static methods to a struct. Struct names are used to create instances. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>        x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>        y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token comment">// comma after last field is optional</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>        <span class="token comment">// Instance method (use of self is similar to Python)</span><br>        <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>            <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// Static method</span><br>        <span class="token keyword">fn</span> <span class="token function-definition function">distance_between</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>            <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>            <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>            <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d1 = {}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d2 = {}"</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>In general it's best for struct fields to not have reference types. This makes the lifetime of the field value match that of the struct which simplifies its usage by removing the need to specify lifetime annotations. For example, struct fields with a string value should almost always use the type <code>String</code> instead of <code>&amp;str</code> or <code>&amp;String</code>.</p><p>To allow structs to be printed for debugging purposes, add the following above their definition: <code>#[derive(Debug)]</code>. Then print using the <code>:?</code> (single line) or <code>:#?</code> (multi-line) format specifier. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p1 = {:?}"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p2 = {:#?}"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This outputs the following:</p><pre class="language-text"><code class="language-text">p1 = Point2D { x: 3.0, y: 4.0 }<br>p2 = Point2D {<br>    x: 3.0,<br>    y: 4.0,<br>}</code></pre><p>Structs are not cloneable, copyable, or printable by default. Being copyable allows instances to be passed by value (copy) instead of by reference. These features add compile time, so Rust requires implementing them on a case-by-case basis. The easiest way to implement these features is the proceed a struct definition with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Clone, Copy, Debug)]</span></code></pre><p>A <code>struct</code> can be empty, containing no fields. This is useful for implementing groups of functionality that do not require fields.</p><p>Structs and their fields are accessible by default within the same source file, but they are private by default when defined in a different source file. For structs that should be visible outside the source file that defines them, add the <code>pub</code> keyword to both the <code>struct</code> and the fields to be exposed.</p><p>A <code>struct</code> can include the fields of another <code>struct</code> of the same type using the <code>..</code> syntax. This can only appear at the end of the list of values. It only supplies values that were not specified. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point3D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    z<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> p4 <span class="token operator">=</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{</span> z<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">..</span>p3 <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// uses p3.x and p3.y, but not p3.z</span></code></pre><p>A &quot;tuple struct&quot; gives a name to a tuple. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">RGB</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> <span class="token constant">CORNFLOWER_BLUE</span><span class="token punctuation">:</span> <span class="token constant">RGB</span> <span class="token operator">=</span> <span class="token constant">RGB</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">149</span><span class="token punctuation">,</span> <span class="token number">237</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token constant">REBECCA_PURPLE</span><span class="token punctuation">:</span> <span class="token constant">RGB</span> <span class="token operator">=</span> <span class="token constant">RGB</span><span class="token punctuation">(</span><span class="token number">0x66</span><span class="token punctuation">,</span> <span class="token number">0x33</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token constant">CORNFLOWER_BLUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RGB(100, 149, 237)</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token constant">REBECCA_PURPLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RGB(102, 51, 153)</span></code></pre><p>Structs cannot inherit from (extend) other structs, but they can nest other structs (composition).</p><h2 id="type-aliases">Type Aliases</h2><p>Aliases for types can be defined using the <code>type</code> keyword. These can be used anywhere a type can be specified. For example, we can define an alias for a function signature:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// This is a type alias for a function signature.</span><br><span class="token keyword">type</span> <span class="token class-name">PointFn</span> <span class="token operator">=</span> <span class="token keyword">fn</span> <span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> input<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">rotate</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> angle<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> cos <span class="token operator">=</span> angle<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> sin <span class="token operator">=</span> angle<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> x <span class="token operator">=</span> pt<span class="token punctuation">.</span>x <span class="token operator">*</span> cos <span class="token operator">-</span> pt<span class="token punctuation">.</span>y <span class="token operator">*</span> sin<span class="token punctuation">;</span><br>    <span class="token keyword">let</span> y <span class="token operator">=</span> pt<span class="token punctuation">.</span>x <span class="token operator">*</span> sin <span class="token operator">+</span> pt<span class="token punctuation">.</span>y <span class="token operator">*</span> cos<span class="token punctuation">;</span><br>    <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">translate_x</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> dx<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> pt<span class="token punctuation">.</span>x <span class="token operator">+</span> dx<span class="token punctuation">,</span> <span class="token punctuation">..</span><span class="token operator">*</span>pt <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">translate_y</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> dy<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> y<span class="token punctuation">:</span> pt<span class="token punctuation">.</span>x <span class="token operator">+</span> dy<span class="token punctuation">,</span> <span class="token punctuation">..</span><span class="token operator">*</span>pt <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// The type of the second parameter is the type alias defined above.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">operate</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> function<span class="token punctuation">:</span> <span class="token class-name">PointFn</span><span class="token punctuation">,</span> input<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token function">function</span><span class="token punctuation">(</span>pt<span class="token punctuation">,</span> input<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> translate_x<span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> translate_y<span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> pi <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token namespace">consts<span class="token punctuation">::</span></span><span class="token constant">PI</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> rotate<span class="token punctuation">,</span> pi <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="traits">Traits</h2><p>A trait describes an interface that any type can implement. Often they are implemented for struts, but they can also be implemented for other types like tuples and even for primitive types like <code>bool</code>.</p><p>Traits can be generic, including type parameters.</p><p>Trait functions can provide default implementations that are used by implementing types that do not override them.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>        x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>        y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">trait</span> <span class="token class-name">Distance</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">{</span><br>        <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">T</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">impl</span> <span class="token class-name">Distance</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span> <span class="token keyword">for</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>        <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>            <span class="token keyword">let</span> dx <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">-</span> other<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>            <span class="token keyword">let</span> dy <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">-</span> other<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>            <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"distance is {}"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Traits can specify other traits that must also be implemented by any structs that implement them. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">HockeyPlayer</span><span class="token punctuation">:</span> <span class="token class-name">Athlete</span> <span class="token operator">+</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Describe functions unique to hockey players here.</span><br><span class="token punctuation">}</span></code></pre><p>Now any <code>struct</code> that implements <code>HockeyPlayer</code> must also implement <code>Athlete</code> and <code>Person</code>.</p><p>It is possible for a type to implement multiple traits that describe the same constants and methods. Calling them requires do so in a form that makes it clear which is desired. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">trait</span> <span class="token class-name">First</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> <span class="token constant">SOME_CONST</span><span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in foo for trait First"</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">trait</span> <span class="token class-name">Second</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> <span class="token constant">SOME_CONST</span><span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in some_method for trait Second"</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">First</span> <span class="token keyword">for</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// using default method implementation</span><br><span class="token keyword">impl</span> <span class="token class-name">Second</span> <span class="token keyword">for</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// using default method implementation</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">//println!("{}", bool::SOME_CONST); // error; multiple `VALUE` found</span><br>    <span class="token comment">//println!("{}", First::SOME_CONST); // error; type annotations needed</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> <span class="token keyword">as</span> <span class="token class-name">One</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token constant">SOME_CONST</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> <span class="token keyword">as</span> <span class="token class-name">Two</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token constant">SOME_CONST</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br><br>    <span class="token comment">//true.some_method(); // error; multiple applicable items in scope</span><br>    <span class="token comment">// Using a "fully-qualified function call addresses this.</span><br>    <span class="token comment">// Normal function calls are really syntactic sugar for this form.</span><br>    <span class="token comment">// The compiler converts them to this form.</span><br>    <span class="token class-name">One</span><span class="token punctuation">::</span><span class="token function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br>    <span class="token class-name">Two</span><span class="token punctuation">::</span><span class="token function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br><span class="token punctuation">}</span></code></pre><p>The <a href="#attributes">Attributes</a> section describes the built-in traits that can be derived (automatically implemented). Additional built-in traits that must be manually implemented are described in the following table. &quot;Marker traits&quot; are used to indicate a property of a type without defining any methods and are indicated in the table below with &quot;marker&quot; in the Methods column.</p><table><thead><tr><th>Trait Name</th><th>Description</th><th>Methods</th></tr></thead><tbody><tr><td><code>AsRef</code></td><td></td><td></td></tr><tr><td><code>Borrow</code></td><td></td><td></td></tr><tr><td><code>Clone</code>*</td><td>adds ability to explicitly copy an object using the <code>clone</code> method</td><td></td></tr><tr><td><code>Copy</code>*</td><td>adds ability to implicitly copy an object in assignment or pass by value</td><td>marker</td></tr><tr><td><code>Debug</code>*</td><td>adds ability to output a value for debugging using <code>{:?}</code> and <code>{:#?}</code> in a format string</td><td></td></tr><tr><td><code>Default</code>*</td><td>adds a <code>default</code> static method for getting an empty or default instance of a type</td><td></td></tr><tr><td><code>Deref</code></td><td></td><td></td></tr><tr><td><code>DerefMut</code></td><td></td><td></td></tr><tr><td><code>Display</code></td><td>adds a <code>fmt</code> method that formats a value for output<br>to be seen by a user rather than a developer</td><td></td></tr><tr><td><code>Drop</code></td><td></td><td></td></tr><tr><td><code>Eq</code>*</td><td>adds ability to compare instances using <code>==</code> and <code>!=</code></td><td></td></tr><tr><td><code>Extend</code></td><td></td><td></td></tr><tr><td><code>Fn</code></td><td></td><td></td></tr><tr><td><code>FnMut</code></td><td></td><td></td></tr><tr><td><code>FnOnce</code></td><td></td><td></td></tr><tr><td><code>From</code></td><td></td><td></td></tr><tr><td><code>FromStr</code></td><td></td><td></td></tr><tr><td><code>Hash</code>*</td><td>adds a <code>hash</code> method for computing the hash value of an instance (1)</td><td></td></tr><tr><td><code>Into</code></td><td></td><td></td></tr><tr><td><code>IntoIterator</code></td><td></td><td></td></tr><tr><td><code>Iterator</code></td><td></td><td></td></tr><tr><td><code>Ord</code>*</td><td>adds ability to compare instances using <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, and <code>&gt;</code> operators</td><td></td></tr><tr><td><code>PartialEq</code>*</td><td>like <code>Eq</code>, but for types where some instances are not equal to themselves (2)</td><td></td></tr><tr><td><code>PartialOrd</code>*</td><td>like <code>Ord</code>, but for types where some instances cannot be logically compared to others (3)</td><td></td></tr><tr><td><code>Read</code></td><td></td><td></td></tr><tr><td><code>Send</code></td><td></td><td>marker</td></tr><tr><td><code>Sized</code></td><td></td><td>marker</td></tr><tr><td><code>Sync</code></td><td></td><td>marker</td></tr><tr><td><code>ToString</code></td><td>adds a <code>to_string</code> method</td><td></td></tr><tr><td><code>Unpin</code></td><td></td><td>marker</td></tr><tr><td><code>Write</code></td><td></td><td></td></tr></tbody></table><p>TODO: Finish adding descriptions and methods in the table above.</p><ol><li>Traits with &quot;*&quot; after their name can be automatically implemented using the <code>derive</code> attribute.</li><li>The <code>hash</code> method is used by the <code>HashMap</code> and <code>HashSet</code> collections.</li><li>This means values are not necessarily reflexive. For example, the number value <code>NaN</code> is not equal to itself.</li><li>For example, the number value <code>NaN</code> is not less than, equal to, or greater than zero.</li></ol><p>TODO: Finish adding descriptions in this table.</p><h2 id="modules">Modules</h2><p>A module defines a collection of values like constants, functions, and structs.</p><p>To gain access to the values in a module that is not defined in the same source file, use the <code>mod</code> statement. Values in the <code>std::prelude</code> module are automatically made available. A list of these values can be found <a href="https://doc.rust-lang.org/std/prelude/" rel="noopener" target="_blank">here</a> and include <code>Box</code>, <code>Option</code>, <code>Result</code>, <code>String</code>, and <code>Vec</code>. Other libraries can also define a <code>prelude</code> module, but the values it defines are not automatically imported. TODO: Do they just provide an easier way to gain access to selected submodule values?</p><p>A module can be defined in many places:</p><ol><li>inside a source file that uses it</li><li>in a file whose name is the module name</li><li>in multiple files within a directory whose name is the module name</li><li>in the Rust standard library</li><li>in a dependency declared in the <code>Cargo.toml</code> file</li></ol><p>By default, all members of a module are private. To make a member accessible outside the module, add the <code>pub</code> keyword at the beginning of its definition.</p><p>When a module is defined inside a source file, it is typically only used by code in that file. This is useful for teaching Rust concepts, but is not often used in practice. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">points</span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>        <span class="token keyword">pub</span> x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>        <span class="token keyword">pub</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token comment">// comma after last field is optional</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>        <span class="token comment">// Instance method</span><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>            <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// Static method</span><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_between</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>            <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>            <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>            <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">use</span> <span class="token namespace">points<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d1 = {}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d2 = {}"</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Moving the module definition into a separate file de-clutters the source file that uses it and enables using the module in many source files.</p><p>Here is the same code, split into two files. First up is the file <code>src/points.rs</code>:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    <span class="token keyword">pub</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token comment">// comma after last field is optional</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Instance method</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Static method</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_between</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>        <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>        <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>In addition to its use in defining a module inside a source file, the <code>mod</code> keyword is used to gain access to modules defined outside. The statement <code>mod name;</code> is equivalent to <code>mod name { include!(&quot;main.rs&quot;); }</code> where <code>main.rs</code> is the file that contains the module definition (determined by the compiler).</p><p>The <code>use</code> statement binds a full path to a new name for easier access. For example, <code>use A::B::C</code> enables using <code>C</code> with just that name instead of its fully qualified name.</p><p>The file <code>src/main.rs</code> below uses the <code>points</code> module defined above.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">points</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">points<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d1 = {}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d2 = {}"</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>This approach works well for small modules. For large modules it is sometimes desirable to split their definition across multiple source files. Each <code>.rs</code> defines a module and placing them in directories creates sub-modules. A <code>.rs</code> file can use the <code>mod</code> and <code>use</code> statements to gain access to the functionality in multiple other modules and re-export the functionality as its own.</p><p>The old way of doing this was to create a directory with the name of the module, place the files that define the module functionality inside it, and create the file <code>mod.rs</code> inside the directory that imports all functionality to be exposed from those files and re-exports it.</p><p>The new way is similar, but a <code>.rs</code> file with the name of the module is created instead of <code>mod.rs</code> and this is placed in the same directory as the module directory.</p><p>Here is the previous code using this approach. We'll add a function to the module that is defined in a different source file than the one that defines the <code>Point2D</code> struct.</p><p>The file <code>src/points/types.rs</code> can be identical to the file <code>src/points.rs</code> above. It defines the <code>Point2D</code> struct fields and methods.</p><p>The file <code>src/points/functions.rs</code> defines the function <code>distance</code> which returns the distance between two <code>Point2D</code> objects. Note that this is a plain function, not an instance or static method.</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// The super keyword enables finding a module</span><br><span class="token comment">// (types in this case) in the same directory.</span><br><span class="token keyword">use</span> <span class="token keyword">super</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>types<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>    <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>    <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>The file <code>src/points.rs</code> ties it all together.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">functions</span><span class="token punctuation">;</span><br><span class="token keyword">mod</span> <span class="token module-declaration namespace">types</span><span class="token punctuation">;</span><br><span class="token keyword">pub</span> <span class="token keyword">use</span> <span class="token namespace">functions<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span><br><span class="token keyword">pub</span> <span class="token keyword">use</span> <span class="token namespace">types<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span></code></pre><p>The file <code>src/main.rs</code> below demonstrates using all the features of the <code>points</code> module.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">points</span><span class="token punctuation">;</span><br><span class="token comment">// Note how a single "use" statement can simplify</span><br><span class="token comment">// access to multiple values from a module.</span><br><span class="token keyword">use</span> <span class="token namespace">points<span class="token punctuation">::</span></span><span class="token punctuation">{</span>distance<span class="token punctuation">,</span> <span class="token class-name">Point2D</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d1 = {}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d2 = {}"</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d3 <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d3 = {}"</span><span class="token punctuation">,</span> d3<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Modules can be nested to further segregate the defined names.</p><h2 id="crates">Crates</h2><p>A crate is a collection of modules.</p><h2 id="futures">Futures</h2><p>TODO: Add this section.</p><h2 id="threads">Threads</h2><p>TODO: Add this section.</p><h2 id="standard-library">Standard Library</h2><h2 id="webassembly"><a name="webassembly">WebAssembly</a></h2><p>Tools for compiling Rust code to WebAssembly include <a href="https://rustwasm.github.io/wasm-pack/" rel="noopener" target="_blank">wasm-pack</a> and <a href="https://www.secondstate.io/articles/ssvmup/" rel="noopener" target="_blank">ssvmup</a> The last update to wasm-pack was on February 7, 2020, so this project may be abandoned. The ssvmup tool was inspired by wasm-pack and has explicit support for Deno.</p><p>To compile a <code>.rs</code> file to WebAssembly:</p><ol><li><p>Install ssvmup by entering the following command (one time only):</p><pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://raw.githubusercontent.com/second-state/ssvmup/master/installer/init.sh -sSf <span class="token operator">|</span> <span class="token function">sh</span></code></pre></li><li><p>Create a new Rust library (referred to as a &quot;crate&quot;) by entering <code>cargo new --lib my-crate</code></p></li><li><p><code>cd my-crate</code></p></li><li><p>Edit <code>src/lib.rs</code> and add code there. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">wasm_bindgen<span class="token punctuation">::</span>prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[wasm_bindgen]</span><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">factorial</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u64</span> <span class="token punctuation">{</span><br>    <span class="token keyword">match</span> x <span class="token punctuation">{</span><br>        <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Edit the generated <code>Cargo.toml</code> file which is similar to a Node.js <code>package.json</code> file. For example:</p><pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">package</span><span class="token punctuation">]</span><br><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"my-crate"</span><br><span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">"0.1.0"</span><br><span class="token key property">authors</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"R. Mark Volkmann &lt;me@gmail.com>"</span><span class="token punctuation">]</span><br><span class="token key property">edition</span> <span class="token punctuation">=</span> <span class="token string">"2018"</span><br><span class="token key property">description</span> <span class="token punctuation">=</span> <span class="token string">"sample project using ssvmup"</span><br><span class="token key property">license</span> <span class="token punctuation">=</span> <span class="token string">"MIT/Apache-2.0"</span><br><span class="token comment">#repository = "https://github.com/mvolkmann/my-crate"</span><br><br><span class="token punctuation">[</span><span class="token table class-name">lib</span><span class="token punctuation">]</span><br><span class="token key property">crate-type</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"cdylib"</span><span class="token punctuation">]</span><br><br><span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span><br><span class="token key property">wasm-bindgen</span> <span class="token punctuation">=</span> <span class="token string">"=0.2.61"</span></code></pre></li><li><p>Enter <code>ssvmup build --target deno</code> This creates a <code>pkg</code> directory containing <code>package.json</code>, a <code>.wasm</code> file, and a <code>.js</code> file that reads the <code>.wasm</code> file and prepares it for use in JavaScript code.</p></li><li><p>Copy the generated <code>pkg</code> directory to the directory containing the Deno code that wishes to use it.</p></li><li><p>Import the exported functions with a line like the following:</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>factorial<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./pkg/my_crate.js'</span><span class="token punctuation">;</span></code></pre></li><li><p>Call the imported functions.</p><pre class="language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4n</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "n" suffix makes it BitInt</span></code></pre></li></ol></article>