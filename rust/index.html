<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Rust</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#why-use-rust">Why use Rust</a></li><li><a href="#why-use-another-programming-language">Why use another programming language</a></li><li><a href="#installing">Installing</a></li><li><a href="#learning-resources">Learning Resources</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#online-playground">Online Playground</a></li><li><a href="#compiling-and-running">Compiling and Running</a></li><li><a href="#vs-code">VS Code</a></li><li><a href="#toml">TOML</a></li><li><a href="#cargo">Cargo</a></li><li><a href="#formatting-code">Formatting Code</a></li><li><a href="#naming-conventions">Naming Conventions</a></li><li><a href="#syntax-highlights">Syntax Highlights</a></li><li><a href="#comments">Comments</a></li><li><a href="#attributes">Attributes</a></li><li><a href="#formatted-print">Formatted Print</a></li><li><a href="#variables">Variables</a></li><li><a href="#ownership-model">Ownership Model</a></li><li><a href="#lifetimes">Lifetimes</a></li><li><a href="#enums">Enums</a></li><li><a href="#error-handling">Error Handling</a></li><li><a href="#built-in-scalar-types">Built-in Scalar Types</a></li><li><a href="#generics">Generics</a></li><li><a href="#built-in-compound-types">Built-in Compound Types</a></li><li><a href="#collections">Collections</a><ol><li><a href="#strings">Strings</a></li><li><a href="#vectors">Vectors</a></li><li><a href="#sets">Sets</a></li><li><a href="#maps">Maps</a></li></ol></li><li><a href="#slices">Slices</a></li><li><a href="#conditional-logic">Conditional Logic</a></li><li><a href="#iteration-(looping)">Iteration (Looping)</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#regular-expressions">Regular Expressions</a></li><li><a href="#functions">Functions</a></li><li><a href="#operators">Operators</a></li><li><a href="#ranges">Ranges</a></li><li><a href="#structs">Structs</a></li><li><a href="#dereference">Dereference</a></li><li><a href="#type-aliases">Type Aliases</a></li><li><a href="#traits">Traits</a></li><li><a href="#macros">Macros</a></li><li><a href="#standard-io">Standard IO</a></li><li><a href="#file-io">File IO</a></li><li><a href="#command-line-arguments">Command-line Arguments</a></li><li><a href="#modules">Modules</a></li><li><a href="#crates">Crates</a></li><li><a href="#creating-and-using-a-library">Creating and Using a Library</a></li><li><a href="#cross-compiling">Cross-compiling</a></li><li><a href="#smart-pointers">Smart Pointers</a></li><li><a href="#futures">Futures</a></li><li><a href="#threads">Threads</a></li><li><a href="#standard-library">Standard Library</a></li><li><a href="#sending-http-requests">Sending HTTP Requests</a></li><li><a href="#webassembly">WebAssembly</a></li></ol></nav></aside><article><p><img alt="Rust logo" style="width: 20%" src="/blog/assets/rust-logo.png" title="Rust logo"> <img alt="Rust mascot" style="width: 30%" src="/blog/assets/rustacean-ferris-crab.png" title="Rust mascot, Ferris the crab"></p><h2 id="overview">Overview</h2><p><a href="https://www.rust-lang.org/" rel="noopener" target="_blank">Rust</a> is a programming language &quot;empowering everyone to build reliable and efficient software.&quot;</p><p>Features of Rust include:</p><ul><li>performance on par with C/C++</li><li>memory-efficiency</li><li>rich, static type system with type inference</li><li>ownership model to guarantee memory-safety and thread-safety</li><li>targets <a href="https://llvm.org" rel="noopener" target="_blank">LLVM</a><br>Rust programs Runs on a wide variety of platforms targeted by LLVM.</li><li>ability to call and be called by C/C++ (but calling C is easier)</li><li>functional<br>Functions can be stored in variables, passed to functions, and returned from functions.</li><li>somewhat object-oriented<br>Structs can have fields and methods (like classes). these can be private or public (encapsulation). Structs can implement traits (like interfaces). Traits can be used as types (achieves polymorphism). Structs can have fields whose types are other structs (composition), but they cannot inherit from other structs.</li></ul><p>Rust was created at Mozilla by Graydon Hoare, with contributions from Dave Herman, Brendan Eich, and others. It was formally announced in 2010. Rust has been self-hosted (implemented in itself) since 2011. Version 1.0 was released in May 2015. A new point release is made every six weeks.</p><p>From <a href="https://doc.rust-lang.org/edition-guide/editions/" rel="noopener" target="_blank">rust-lang.org</a>, &quot;Every two or three years, we'll be producing a new edition of Rust. Each edition brings together the features that have landed into a clear package, with fully updated documentation and tooling.&quot;</p><p>Rust developers are referred to as &quot;Rustaceans&quot; which was derived from the word &quot;crustaceans&quot;. Rust mascot is Ferris the crab, a crustacean. The name is fitting because ferrous metals are subject to rust. Images of Ferris can be found at <a href="https://rustacean.net/" rel="noopener" target="_blank">rustacean.net</a>.</p><h2 id="why-use-rust">Why use Rust</h2><p><strong>Performance:</strong></p><p>The best way to get software performance is to use a &quot;systems&quot; language like C, C++, or Rust. One reason these languages are fast is because they do not provide automatic garbage collection which is slow and can run at unpredictable times. Systems languages also allow control over whether data is on the stack (faster) or on the heap (slower).</p><p><strong>Safety:</strong></p><p>Software written in systems languages typically must take great care to avoid memory and threading issues. Memory issues include dangling pointers (accessing memory after it has been freed), memory leaks (failing to free memory that is no longer needed), and double frees (freeing memory more than once). These result in unpredictable behavior. Threading issues include race conditions where the order in which code runs is unpredictable, resulting in somewhat random results. Rust addresses both of these issues, resulting in code that is less likely to contain bugs.</p><p><strong>Immutable by default:</strong></p><p>A large source of software errors involves incorrect assumptions about where data is modified. Making variables immutable by default and requiring explicit indication of functions that are allowed to modify data significantly reduces these errors.</p><p><strong>Ownership model:</strong></p><p>Manual garbage collection, where developers are responsibly for allocating and freeing memory, is error prone. Rust uses an ownership model where code is explicit about the single scope that currently owns each piece of data. unless ownership is transferred to another scope, when that scope ends the data can be safely freed because no other scope can possibly be using the data.</p><p><strong>Zero-Cost Abstractions:</strong></p><p>Rust strives for zero-cost abstractions characterized by this quote from Bjarne Stroustrup, the creator of C++: &quot;What you don't use, you don't pay for. And further: What you do use, you couldn't hand code any better.&quot; Rust supports many abstractions that make code more clear, but are optimized by the compiler so there is little to no impact on performance or the amount of machine code that is generated. One example is the use of generic functions that are compiled to separate versions for each concrete type used with them which eliminates the need for runtime dynamic dispatch (referred to as &quot;monomorphism&quot;).</p><p><strong>Control over number sizes:</strong></p><p>One way to achieve performance in computationally intensive tasks is to store collections of numbers in contiguous memory for fast access and control the number of bytes used by each number. Rust supports a wide variety of number types for integer and floating point values of specific sizes.</p><p><strong>WebAssembly:</strong></p><p>WebAssembly (abbreviated WASM) is an instruction format for a virtual machine that is supported by modern web browsers (currently Chrome, Edge, Firefox, and Safari). This is typically much faster than equivalent code written in JavaScript. Code from many programming languages can be compiled to WASM. Currently full support is only available for C, C++, and Rust. Experimental support is available for C#, Go, Java, Kotlin, Python, Swift, TypeScript, and a few other less commonly used languages. In order to run WASM code in a web browser, the runtime of the source language must be included. Rust is a great choice for targeting WASM because it has a very small runtime compared to options like Python, so it downloads faster.</p><p>Systems languages tend to be more complex that non-systems languages, requiring more time to learn and more time to write software in them. Rust is no exception. But many developers choose to use Rust in spite of this in order to gain the benefits described above. On the positive side, the Rust compiler catches many errors that would only be discovered at runtime with other systems languages. The Rust compiler also provides very detailed error messages that include suggestions on how to correct the errors.</p><h2 id="why-use-another-programming-language">Why use another programming language</h2><p><strong>Performance:</strong></p><p>If programming languages that provided automatic memory management (such as JavaScript/TypeScript, Python, and Go) are fast enough for the target application, and garbage collection pauses are not an issue, the effort required to use Rust is hard to justify. For many developers, this is the case for everything they write.</p><p><strong>Learning Curve:</strong></p><p>The learning curve for Rust is quite high. It may be too much effort to bring an entire team up to speed on using it. Just learning how to use strings in Rust is a challenge. Developers must constantly decide whether values or references should be passed to functions. They must think about whether values have sizes that are known at compile-time. And generics are used heavily (for example, in error handling), and often generic types are nested.</p><p><strong>Processor target:</strong></p><p>If the target platform uses a processor type that is not a target of LLVM, Rust cannot currently produce code that will run on it.</p><h2 id="installing">Installing</h2><p>Rust is installed using the <a href="" rel="noopener" target="_blank">rustup</a> tool. This enables having multiple versions of Rust installed and switching between them.</p><p>To install rustup in macOS, install <a href="" rel="noopener" target="_blank">homebrew</a> and then enter <code>brew install rustup</code>. &quot;Command Line Tools for Xcode&quot; must also be installed from <a href="https://developer.apple.com/downloads/more" rel="noopener" target="_blank">developer.apple.com</a> which requires a free Apple ID.</p><p>To install rustup in Linux (or macOS), enter the following command:</p><pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="token operator">|</span> <span class="token function">sh</span></code></pre><p>To install rustup in Windows, use <a href="https://chocolatey.org/" rel="noopener" target="_blank">Chocolately</a> or <a href="https://scoop.sh/" rel="noopener" target="_blank">Scoop</a>.</p><p>For more details, see <a href="https://forge.rust-lang.org/infra/other-installation-methods.html" rel="noopener" target="_blank">Other Rust Installation Methods</a>.</p><p>After installing rustup, enter <code>rustup-init</code>. This installs many toolchain items including <code>cargo</code> (build/run tool), <code>clippy</code> (linter), <code>rust-docs</code> (documentation), <code>rust-std</code> (standard library), <code>rustc</code> (compiler), and <code>rustfmt</code> (code formatter). It also configures the use of Rust in the bash and zsh shells. When using the fish shell, add the following in <code>.config/fish/config.fish</code>:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">set</span> -x <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span> <span class="token environment constant">$HOME</span>/.cargo/bin</code></pre><p>Verify installation by entering <code>rustc --version</code>.</p><p>Once installed, to update the version of Rust enter <code>rustup update</code>.</p><h2 id="learning-resources">Learning Resources</h2><p>Resources are learning Rust include:</p><ul><li><p><code>rustup doc</code> command</p><ul><li>displays local documentation installed along with Rust in the default web browser</li><li>can read even when offline</li><li>includes<ul><li>API documentation</li><li>&quot;The Rust Programming Language&quot; book</li><li>&quot;Rust by Example&quot; book</li><li>&quot;The Rust Reference&quot; book which is more detailed than &quot;The Rust Programming Language&quot; book</li><li>&quot;The Cargo Book&quot; book</li><li>and much more</li></ul></li></ul></li><li><p><a href="https://www.rust-lang.org/" rel="noopener" target="_blank">Rust website</a></p></li><li><p><a href="https://doc.rust-lang.org/book/" rel="noopener" target="_blank">The Rust Programming Language</a> book</p><ul><li>free, open source book</li><li>can purchase a print copy from No Starch Press</li></ul></li><li><p><a href="https://doc.rust-lang.org/stable/reference/" rel="noopener" target="_blank">The Rust Reference</a></p><ul><li>&quot;the primary reference for the Rust programming language&quot;</li></ul></li><li><p><a href="https://rust-lang-nursery.github.io/rust-cookbook/" rel="noopener" target="_blank">Rust Cookbook</a></p><ul><li>&quot;collection of simple examples that demonstrate good practices to accomplish common programming tasks&quot;</li></ul></li><li><p><a href="https://doc.rust-lang.org/stable/rust-by-example/" rel="noopener" target="_blank">Rust by Example</a></p><ul><li>free, online set of examples in many categories</li></ul></li><li><p><a href="https://doc.rust-lang.org/std/index.html" rel="noopener" target="_blank">Rust Standard Library</a> API documentation</p></li><li><p><a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/" rel="noopener" target="_blank">Programming Rust</a> book</p><ul><li>from O'Reilly</li></ul></li><li><p><a href="https://www.manning.com/livevideo/rust-in-motion?a_aid=cnichols&a_bid=6a993c2e" rel="noopener" target="_blank">Rust in Motion</a> video course</p><ul><li>from Manning</li></ul></li><li><p><a href="https://www.youtube.com/watch?v=Az3jBd4xdF4&list=PLLqEtX6ql2EyPAZ1M2_C0GgVd4A-_L4_5" rel="noopener" target="_blank">Doug Milford Rust Tutorial series</a> YouTube videos</p></li><li><p><a href="https://www.youtube.com/watch?v=WnWGO-tLtLA&t=2s" rel="noopener" target="_blank">Jon Gjengset Crust of Rust</a> YouTube videos</p></li><li><p><a href="https://www.youtube.com/watch?v=WnWGO-tLtLA&t=2s" rel="noopener" target="_blank">Ryan Levick Introduction to Rust</a> YouTube videos</p></li><li><p><a href="https://github.com/rust-lang/rustlings" rel="noopener" target="_blank">Rustlings</a></p><ul><li>&quot;contains small exercises to get you used to reading and writing Rust code&quot;</li></ul></li><li><p><a href="https://exercism.io/tracks/rust" rel="noopener" target="_blank">exercism Rust track</a></p><ul><li>&quot;Code practice and mentorship for everyone&quot;</li><li>&quot;exercises across 52 languages&quot;</li></ul></li><li><p><a href="https://github.com/ctjhoa/rust-learning" rel="noopener" target="_blank">rust-learning</a></p><ul><li>&quot;A bunch of links to blog posts, articles, videos, etc for learning Rust.&quot;</li></ul></li></ul><h2 id="terminology">Terminology</h2><ul><li><a href="#cargo">Cargo</a><ul><li>a command-line utility for building and running Rust programs</li></ul></li><li><a href="#crates">crate</a><ul><li>a tree of modules</li><li>two types, binary (bin) or library (lib)</li></ul></li><li><a href="#enums">enum</a><ul><li>a named type whose values come from a list of named variants</li><li>in Rust, these variants can have associated data</li><li>a key feature of Rust error handling</li></ul></li><li>generic<ul><li>a parameterized type that enables storing and using multiple types of data</li></ul></li><li>lifetime<ul><li>time period during which a variable can be access, starting when it is created and ending when it is freed (a.k.a dropped)</li><li>often associated with the scope of a particular code block</li></ul></li><li><a href="#macros">macro</a><ul><li>a function-like construct whose name ends in <code>!</code> and generates code at compile-time</li></ul></li><li><a href="#modules">module</a><ul><li>set of related values such as constants and functions</li></ul></li><li>package<ul><li><code>cargo</code> feature for building, testing, and sharing crates</li><li>set of related crates described by a <code>Cargo.toml</code> file;</li><li>contains any number of binaries and 0 or 1 library</li></ul></li><li>panic<ul><li>represents an unrecoverable error that causes a program to terminate, print a stack trace, and print an error message</li></ul></li><li><a href="#structs">struct</a><ul><li>a named collection of fields similar to a class in other languages</li><li>can have associated functions and methods</li></ul></li><li><a href="#traits">trait</a><ul><li>a named collection of constants, function signatures, and optional default implementations</li><li>similar to interfaces in other languages</li></ul></li><li><a href="#toml">TOML</a><ul><li>a configuration file format used by Cargo</li><li>stands for Tom's Obvious, Minimal Language</li></ul></li></ul><h2 id="online-playground">Online Playground</h2><p>To try Rust code online, browse the <a href="https://play.rust-lang.org/" rel="noopener" target="_blank">Rust Playground</a>. This includes access to the top 100 most downloaded crates (libraries) from <a href="https://crates.io/" rel="noopener" target="_blank">crates.io</a> and crates from the <a href="https://rust-lang-nursery.github.io/rust-cookbook/" rel="noopener" target="_blank">Rust Cookbook</a>.</p><p><img alt="Rust Playground" style="width: 100%" src="/blog/assets/rust-playground.png" title="Rust Playground"></p><p>All of the code must be entered in a single editor pane, simulating all of it being in a single file.</p><p>Press the ellipsis after the &quot;RUN&quot; button to open a popup with the following options:</p><ul><li>&quot;Run&quot; to build and run the code (<code>cargo run</code>)</li><li>&quot;Build&quot; to only build the code (<code>cargo build</code>)</li><li>&quot;Test&quot; to build the code and run the tests (<code>cargo test</code>)<br>Tests must be preceded by <code>#[test]</code> and no <code>main</code> function can be present.</li><li>&quot;ASM&quot; to build the code and show the generated assembly code</li><li>&quot;LLVM IR&quot; to build the code and show the generated LLVM intermediate representation (IR)</li><li>&quot;MIR&quot; to build the code and show the generated mid-level intermediate representation (MIR)</li><li>&quot;WASM&quot; to build a WebAssembly module for use in web browsers</li></ul><p>The &quot;RUN&quot; button will change to the last selected option so it can be re-executed by pressing the button.</p><p>Press the &quot;DEBUG&quot; button to open a popup for choosing between &quot;Debug&quot; and &quot;Release&quot; build modes.</p><p>Press the &quot;STABLE&quot; button to open a popup for choosing a Rust version which can be &quot;Stable channel&quot; (default), &quot;Beta channel&quot;, or &quot;Nightly channel&quot;. The button text changes to indicate the selected version.</p><p>Press the ellipsis after the version button to open a popup with the following options:</p><ul><li>&quot;Edition&quot; sets the Rust edition to 2018 (default) or 2015</li><li>&quot;Backtrace&quot; to disable (default) or enable display of backtraces when a panic occurs<br>Enabling this slows performance a bit.</li></ul><p>Press the &quot;SHARE&quot; button to open a panel on the right side containing the following links:</p><ul><li>&quot;Permalink to the playground&quot; changes the URL to one which will recall the current code, set to run with the current version of Rust.</li><li>&quot;Direct link to the gist&quot; navigates to the URL of the GitHub Gist where the code is stored. The code can be viewed, but not executed from here.</li><li>&quot;Embed code in link&quot; changes the URL to one which includes a base 64 encoded copy of the code as a query parameter. This is only appropriate for small code samples due to URL length limits.</li><li>&quot;Open a new thread in the Rust user forum&quot; does what the link implies, making it easy to ask questions about a code sample. Use this frequently while learning!</li><li>&quot;Open an issue on the Rust GitHub repository&quot; makes it easy to report a bug in Rust.</li></ul><p>Press the &quot;TOOLS&quot; button to open a popup with the following options:</p><ul><li>&quot;Rustfmt&quot; formats the code using the <code>rustfmt</code> tool.</li><li>&quot;Clippy&quot; runs the Clippy linter on the code.</li><li>&quot;Miri&quot; runs the program using the <a href="https://github.com/rust-lang/miri" rel="noopener" target="_blank">Miri interpreter</a> which is an experimental interpreter for Rust's mid-level intermediate representation (MIR). It can detect some bugs not detected by pressing the &quot;RUN&quot; button.</li><li>&quot;Expand macros&quot; displays the code in the right panel with all the macro calls expanded in order to see what they actually do. For example, try this with a <code>main</code> function that just calls the <code>println!</code> macro to print &quot;Hello&quot;. You would never want to write this code yourself.</li></ul><p>Press the &quot;CONFIG&quot; button to open a popup with the following options:</p><ul><li>&quot;Style&quot; to switch between &quot;SIMPLE&quot; (no line numbers) and &quot;ADVANCED&quot; (line numbers)</li><li>&quot;Keybinding&quot; to choose between keybindings supported by the <a href="https://github.com/ajaxorg/ace" rel="noopener" target="_blank">Ace</a> (Cloud9) editor<br>These include ace, emacs, sublime, vim, and vscode.</li><li>&quot;Theme&quot; to choose from 30+ themes including cobalt, github, solarized light, solarized dark</li><li>&quot;Pair Characters&quot; to automatically insert closing <code>)</code>, <code>}</code>, and <code>]</code> characters after <code>(</code>, <code>{</code>, and <code>[</code> characters</li><li>&quot;Orientation&quot; to arrange panes horizontally, vertically, or automatically choose based on window size</li><li>and advanced options to control generated assembly code</li></ul><p>There doesn't seem to be a way to select a font for the code.</p><p>Configuration options are saved in browser Local Storage so they can be applied to future sessions. The most recently entered code is also saved in Local Storage, but previously entered code is not.</p><h2 id="compiling-and-running">Compiling and Running</h2><p>Rust source files have a <code>.rs</code> file extension.</p><p>To compile a Rust source file that defines a <code>main</code> function, creating an executable with the same name and no file extension, and run it:</p><ul><li>open a terminal (or Windows Command Prompt),</li><li>cd to the directory containing the <code>.rs</code> file</li><li>enter <code>rustc name.rs</code></li><li>in macOS or Linux, enter <code>./name</code></li><li>in Windows, enter <code>name</code></li></ul><p>For example, the following is a Rust Hello World program:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Note that calls to names that end in <code>!</code> (like <code>println!</code>) are calls to a <a href="#macros">macro</a> rather than a function.</p><p>Typically the <code>rustc</code> command is not used directly. Instead the <code>cargo</code> command, described in the <a href="#cargo">Cargo</a> section, is used to run <code>rustc</code> and the resulting executable.</p><h2 id="vs-code">VS Code</h2><p>If using VS Code to edit Rust code, install the Rust extension which adds:</p><ul><li>syntax highlighting</li><li>code completion</li><li>code formatting</li><li>type documentation on hover</li><li>linting with error indicators with ability to apply suggestions</li><li>code snippets</li><li>rename refactoring</li><li>debugging</li><li>build tasks</li></ul><p>Add the following in <code>settings.json</code>:</p><pre class="language-json"><code class="language-json">  <span class="token property">"[rust]"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"rust-lang.rust"</span><span class="token punctuation">,</span><br>    <span class="token property">"editor.insertSpaces"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>    <span class="token property">"editor.tabSize"</span><span class="token operator">:</span> <span class="token number">4</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>Note that this extension only works if the opened folder contains a <code>Cargo.toml</code> file. See the <a href="#cargo">Cargo</a> section for details on creating this.</p><h2 id="toml"><a name="toml">TOML</a></h2><p><a href="https://github.com/toml-lang/toml" rel="noopener" target="_blank">TOML</a> is a configuration file format that maps to a hash table. The Rust Cargo tool uses this for its <code>cargo.toml</code> configuration file.</p><p>Each key/value pair is described by a line with the syntax <code>key = value</code>. Keys are not surrounded by any delimiters. Supported value data types include string, integer, float, boolean, datetime, array (ordered list of values), and table (collection of key/value pairs). String values are surrounded by double quotes. Datetime values have the format <code>yyyy-mm-ddThh:mm:ss</code>. The time portion can be omitted or be followed by a time zone (<code>Z</code> for UTC or <code>+hh:mm</code> for an offset). Array elements are surrounded by square brackets and separated by commas.</p><p>Comments begin with the <code>#</code> character and extend to the end of the line.</p><p>Sections and sub-sections are indicated by lines containing a name enclosed in square brackets. Think of these like keys whose values are objects.</p><h2 id="cargo"><a name="cargo">Cargo</a></h2><p>The <code>cargo</code> command is a CLI tool that is installed with Rust. While using it is not required, it is highly recommended.</p><p>For help, enter <code>cargo --help</code> or just <code>cargo</code>.</p><p>The following table describes the <code>cargo</code> subcommands:</p><table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody><tr><td><code>bench</code></td><td>runs benchmarks for the current project</td></tr><tr><td><code>build</code></td><td>builds current project in the <code>target</code> directory</td></tr><tr><td><code>check</code></td><td>verifies current project builds without errors,<br>without generating code</td></tr><tr><td><code>clean</code></td><td>deletes <code>target</code> directory</td></tr><tr><td><code>clippy</code></td><td>checks current project for errors using the Clippy linter</td></tr><tr><td><code>doc</code></td><td>generates documentation for the current project</td></tr><tr><td><code>init</code></td><td>creates a Rust project in the current directory</td></tr><tr><td><code>install</code></td><td>installs an executable, by default in <code>~/.cargo/bin</code></td></tr><tr><td><code>new</code></td><td>creates a Rust project in a new subdirectory</td></tr><tr><td><code>publish</code></td><td>publishes the crate to the <a href="https://crates.io" rel="noopener" target="_blank">crates.io</a> registry</td></tr><tr><td><code>run</code> or <code>r</code></td><td>builds and runs current project</td></tr><tr><td><code>search</code></td><td>searches the <a href="https://crates.io" rel="noopener" target="_blank">crates.io</a> registry for crates</td></tr><tr><td><code>test</code> or <code>t</code></td><td>runs tests in the current project</td></tr><tr><td><code>uninstall</code></td><td>removes the executable, by default from <code>~/.cargo/bin</code></td></tr><tr><td><code>update</code></td><td>updates dependencies in the <code>Cargo.lock</code> file</td></tr></tbody></table><p>The <code>cargo new</code> command creates a new directory containing a Rust project that is initialized as a new Git repository. It contains a <code>Cargo.toml</code> configuration file that specifies the project name, version, authors, the Rust edition to use, and a list of project dependencies. The created directory also contains a <code>src</code> directory containing a single file. When the <code>--lib</code> switch is not included, the file is <code>main.rs</code> file which is a simple hello world program. When the <code>--lib</code> switch is included, the file is <code>lib.rs</code> file that contains a simple unit test.</p><p>The <code>cargo run</code> command builds and runs the project. It also downloads dependencies listed in the <code>Cargo.toml</code> file, and their dependencies recursively. This can be slow, so the speed of this command varies greatly depending on whether any new dependencies have been added since the last time it was run.</p><p>To pass command-line arguments to the program, specify them after <code>--</code>. For example, <code>cargo run -- arg1 arg2 ...</code></p><p>To watch project files for changes and automatically run a <code>cargo</code> command when they do, enter <code>cargo install cargo-watch</code> one time and then enter <code>cargo watch -x <i>subcommand</i></code>. If the <code>-x</code> option is omitted, the subcommand defaults to <code>check</code>, not <code>run</code>. Typically you will want the subcommand to be <code>run</code>.</p><p>The <code>cargo build</code> command creates an executable in the <code>target/debug</code> directory. To create an optimized, production build, enter <code>cargo build --release</code> which creates an executable in the <code>target/release</code> directory.</p><h2 id="formatting-code">Formatting Code</h2><p>The most popular code formatting tool for Rust is <a href="" rel="noopener" target="_blank">rustfmt</a>. The <code>rustup</code> tool installs this by default.</p><p>To run it on all <code>.rs</code> files in the current directory, enter <code>cargo fmt</code> or <code>rustfmt *.rs</code>.</p><h2 id="naming-conventions">Naming Conventions</h2><p>In general, names of types use PascalCase and names of values use snake_case.</p><table><thead><tr><th>Item</th><th>Naming Convention</th></tr></thead><tbody><tr><td>constants</td><td>SCREAMING_SNAKE_CASE</td></tr><tr><td>constructor functions</td><td>snake_case</td></tr><tr><td>crates</td><td>snake_case or kebab-case</td></tr><tr><td>crate features</td><td>no convention</td></tr><tr><td>enums</td><td>PascalCase</td></tr><tr><td>enums variants</td><td>PascalCase</td></tr><tr><td>file names</td><td>snake_case or kebab-case</td></tr><tr><td>functions</td><td>snake_case</td></tr><tr><td>lifetimes</td><td>'lowercase</td></tr><tr><td>macros</td><td>snake_case!</td></tr><tr><td>methods</td><td>snake_case</td></tr><tr><td>modules</td><td>snake_case</td></tr><tr><td>statics</td><td>SCREAMING_SNAKE_CASE</td></tr><tr><td>structs</td><td>PascalCase</td></tr><tr><td>traits</td><td>PascalCase</td></tr><tr><td>type parameters (generics)</td><td>PascalCase, but usually one letter</td></tr><tr><td>type aliases</td><td>PascalCase</td></tr><tr><td>variables</td><td>snake_case</td></tr></tbody></table><p>The compiler outputs warnings when these naming conventions are not followed.</p><h2 id="syntax-highlights">Syntax Highlights</h2><ul><li>The preferred indentation is four spaces.</li><li>Statements must terminated by a semicolon.</li><li>Strings are delimited by double quotes.</li><li>Single characters are delimited by single quotes.</li><li>Items (like functions and struct members) are made public using the <code>pub</code> keyword.</li><li>The dot (<code>.</code>) character is used to access struct fields and call instance methods.</li><li>The double colon (<code>::</code>) is used as a namespace separator (borrowed from C++) and to call static methods.</li><li>Conditions for conditional logic and iteration are not surrounded by any delimiter (no parentheses).</li><li>Statements associated with conditional logic and iteration must be in blocks surrounded by curly brackets.</li><li>Named functions are declared with the <code>fn</code> keyword.</li><li>Function return types follow the parameter list and <code>-&gt;</code>.</li><li>Functions that return nothing omit <code>-&gt;</code> and return type.</li><li>Most statements are also expressions and evaluate to a value, including <code>if</code> and <code>match</code> statements.</li><li>If the last expression in a function does not end with a semicolon, its value is returned.</li><li>There is no null type or value. Instead the <code>Option</code> enum <code>None</code> variant used.</li></ul><h2 id="comments">Comments</h2><p>Rust supports regular comments and &quot;doc comments&quot;.</p><table><thead><tr><th>Syntax</th><th>Usage</th></tr></thead><tbody><tr><td><code>//</code></td><td>extends to end of current line</td></tr><tr><td><code>/* ... */</code></td><td>can span multiple lines</td></tr><tr><td><code>///</code></td><td>doc comment preceding the item it describes</td></tr><tr><td><code>//!</code></td><td>doc comment inside the item it describes</td></tr></tbody></table><p>&quot;Doc comments&quot; are included in HTML documentation that is generated by entering <code>cargo doc</code>. This creates the directory <code>target/doc/{crate-name}</code> and writes HTML for the documentation there. To generate the documentation and open it in the default browser, enter <code>cargo doc --open</code>. Optionally add the <code>--no-deps</code> flag to avoid building documentation for crate dependencies.</p><p>Doc comments optionally include sections with titles that begin with <code>#</code>. Common sections include:</p><ul><li><p><code># Examples</code></p><p>This section provides code examples in Markdown fences. It is especially useful to demonstrate calls to functions and methods. For library crates (not for binary crates) this code is run along with other test code by the <code>cargo test</code> and <code>rustdoc --test</code> commands.</p></li><li><p><code># Errors</code></p><p>This section describes any errors that can be returned by the code in a <code>Result</code> enum.</p></li><li><p><code># Panics</code></p><p>This section describes scenarios that can cause the code to panic.</p></li><li><p><code># Safety</code></p><p>For functions marked as <code>unsafe</code>, this section explains why. It also describes what callers must do to use it safely.</p></li></ul><p>For example:</p><ol><li><p>Create a project by entering <code>cargo new math --lib</code>.</p></li><li><p>Edit the file <code>src/lib.rs</code> and replace its content the following:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">/// # Examples</span><br><span class="token comment">///</span><br><span class="token comment">/// ```</span><br><span class="token comment">/// let numbers = vec![1.0, 2.0, 3.0, 4.0];</span><br><span class="token comment">/// assert_eq!(doc_test2::average(&amp;numbers), 2.5);</span><br><span class="token comment">/// ```</span><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">average</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> sum<span class="token punctuation">:</span> <span class="token keyword">f64</span> <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">f64</span> <span class="token comment">// return value</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Run the doc comment examples as tests by entering <code>cargo test</code>.</p></li></ol><h2 id="attributes"><a name="attributes">Attributes</a></h2><p>Rust attributes are like &quot;decorators&quot; in other programming languages. They annotate an item in order to change its behavior. An attribute can be specified immediately before an item with the syntax <code>#[attr]</code> or inside the item with the syntax <code>#![attr]</code>. When used at the top level, <code>#![attr]</code> specifies a crate-wide attribute.</p><p>The following table summarizes commonly used built-in attributes.</p><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td><code>allow(warning1, warning2, ...)</code></td><td>suppress specified linting rule warnings</td></tr><tr><td><code>derive(trait1, trait2, ...)</code></td><td>automatically implement a list of traits on a <code>struct</code></td></tr><tr><td><code>doc</code></td><td>provides an alternate way to specify and format doc comments</td></tr><tr><td><code>should_panic</code></td><td>indicates that a test function is expected to panic</td></tr><tr><td><code>test</code></td><td>indicates that a function is a test</td></tr></tbody></table><p>For a list of linting rules that produce warnings, see <a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html" rel="noopener" target="_blank">Warn-by-default lints</a>. Examples include <code>dead_code</code>, <code>unreachable_code</code>, <code>unused_assignment</code>, <code>unused_imports</code>, and <code>unused_variables</code>. These warnings can be disabled using <code>allow</code> attributes.</p><p>The <a href="#trait-table">table of provided traits</a> in the &quot;Traits&quot; section indicates those can be automatically implemented using the <code>derive</code> attribute. For more detail, see <a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html" rel="noopener" target="_blank">Derive</a>.</p><p>For more built-in attributes, see the list at <a href="https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index" rel="noopener" target="_blank">Attributes</a>.</p><p>Custom attributes are implemented by defining <a href="https://doc.rust-lang.org/book/ch19-06-macros.html#attribute-like-macros" rel="noopener" target="_blank">attribute-like macros</a>.</p><h2 id="formatted-print">Formatted Print</h2><p>The <code>std::fmt</code> namespace defines macros that format text.</p><table><thead><tr><th>Macro Name</th><th>Description</th></tr></thead><tbody><tr><td><code>format!</code></td><td>writes to a <code>String</code></td></tr><tr><td><code>print!</code></td><td>writes to stdout</td></tr><tr><td><code>println!</code></td><td>same as <code>print!</code>, but adds a newline</td></tr><tr><td><code>eprint!</code></td><td>writes to stderr</td></tr><tr><td><code>eprintln!</code></td><td>same as <code>eprint!</code>, but adds a newline</td></tr></tbody></table><p>All of these macros take a formatting string followed by zero or more expressions whose values are substituted into the formatting string where occurrences of <code>{}</code> appear. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} is {}."</span><span class="token punctuation">,</span> <span class="token string">"Rust"</span><span class="token punctuation">,</span> <span class="token string">"interesting"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Rust is interesting.</span></code></pre><p>To print a representation of a value for debugging purposes on a single line, use <code>{:?}</code>. To print each field of a struct on separate lines, use <code>{:#?}</code>. Custom structs must implement the <code>Debug</code> trait in order to use these. This is done by adding the line <code>#[derive(Debug)]</code> before their definitions.</p><p>The following table summarizes the supported format arguments that can appear inside the curly brackets.</p><table><thead><tr><th>Format Argument</th><th>Description</th></tr></thead><tbody><tr><td><code>{}</code></td><td>prints display value of next argument</td></tr><tr><td><code>{:?}</code></td><td>debugging output on single line</td></tr><tr><td><code>{:#?}</code></td><td>debugging output on multiple lines</td></tr><tr><td><code>{n}</code></td><td>prints the argument at index n (zero-based)</td></tr><tr><td><code>{name}</code></td><td>prints the value with a given name</td></tr><tr><td><code>{:.n}</code></td><td>prints a number with <code>n</code> decimal places</td></tr><tr><td><code>{:.*}</code></td><td>prints a number with number of decimal places specified in value list</td></tr><tr><td><code>{:#X}</code></td><td>prints number as uppercase hexadecimal</td></tr><tr><td><code>{:#x}</code></td><td>prints number as lowercase hexadecimal</td></tr><tr><td><code>{:&lt;n}</code></td><td>print left justified in a width of n</td></tr><tr><td><code>{:&gt;n}</code></td><td>print right justified in a width of n</td></tr><tr><td><code>{:^n}</code></td><td>print centered in a width of n</td></tr></tbody></table><p>Here are some examples:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} {}"</span><span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6, 9</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{2} {1}"</span><span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6, 9</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{double} {triple}"</span><span class="token punctuation">,</span> double <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> triple <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6 9</span><br><br><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:#?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Point2D {</span><br><span class="token comment">//     x: 1.0,</span><br><span class="token comment">//     y: 2.0,</span><br><span class="token comment">// }</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{1} {0} {2} {1}"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// green red blue green</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><br>    <span class="token string">"{red} {green} {blue}"</span><span class="token punctuation">,</span><br>    blue<span class="token operator">=</span><span class="token string">"00F"</span><span class="token punctuation">,</span> green<span class="token operator">=</span><span class="token string">"0F0"</span><span class="token punctuation">,</span> red<span class="token operator">=</span><span class="token string">"F00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// F00 0F0 00F</span><br><br><span class="token keyword">let</span> pi <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token namespace">consts<span class="token punctuation">::</span></span><span class="token constant">PI</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:.4}"</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3.1416</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:.*}"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3.1416</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:#X}"</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0xF</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:#x}"</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0xf</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"A{:&lt;5}Z"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A123  Z</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"A{:>5}Z"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A  123Z</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"A{:^5}Z"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A 123 Z</span></code></pre><p>Here is an example of customizing the way a struct is formatted as a string:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>fmt<span class="token punctuation">;</span><br><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Display</span> <span class="token keyword">for</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Using "self" as the name of the first parameter makes this a method.</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">fmt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> formatter<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Formatter</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Result</span> <span class="token punctuation">{</span><br>        <span class="token macro property">write!</span><span class="token punctuation">(</span>formatter<span class="token punctuation">,</span> <span class="token string">"(x:{}, y:{})"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.2</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">3.4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (x:1.2, y:3.4)</span><br><span class="token punctuation">}</span></code></pre><p>For more formatting options, see <a href="https://doc.rust-lang.org/std/fmt/" rel="noopener" target="_blank">std::fmt</a>.</p><h2 id="variables">Variables</h2><p>Rust variables are immutable by default. For variables that hold non-primitive values such as arrays, tuples, and structs, even their elements/fields cannot be mutated.</p><p>The <code>mut</code> keyword marks a variable as mutable. For variables that hold non-primitive values such as arrays, tuples, and structs, the variable can be changed to point to a different value and their elements/fields can be mutated.</p><p>A variable declaration has the syntax <code>let[ mut] name[: type][ = value];</code> where optional parts are surrounded by square brackets. The colon and type can be omitted if the desired type can be inferred from the value. A value must be assigned before the variable is referenced. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p<span class="token punctuation">:</span> <span class="token class-name">Point2D</span> <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// can assign in declaration</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p = {:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><br>    <span class="token keyword">let</span> p<span class="token punctuation">:</span> <span class="token class-name">Point2D</span><span class="token punctuation">;</span><br>    p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// can assign after declaration</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p = {:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br>    <span class="token comment">//p = Point2D { x: 1.2, y: 3.4 }; // cannot change value</span><br>    <span class="token comment">//p.x = 5.6; // cannot change a field in current value</span><br><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p = {:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br>    p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.2</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">3.4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// can change value</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p = {:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.2, y: 3.4 }</span><br>    p<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5.6</span><span class="token punctuation">;</span> <span class="token comment">// can change a field in current value</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p = {:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 5.6, y: 3.4 }</span><br><span class="token punctuation">}</span></code></pre><p>There are five ways to declare a variable.</p><table><thead><tr><th>Syntax</th><th>Meaning</th></tr></thead><tbody><tr><td><code>let name: type = value;</code></td><td>immutable variable that must be assigned a value<br>before it is used and is thereafter immutable</td></tr><tr><td><code>let mut name: type = value;</code></td><td>mutable variable that must be assigned a value<br>before it is used and can be modified</td></tr><tr><td><code>const name: type = value;</code></td><td>constant that must be assigned a compile-time expression when it is declared, not the result of a function call</td></tr><tr><td><code>static name: type = value;</code></td><td>immutable variable that lives for the duration of the program</td></tr><tr><td><code>static mut name: type = value;</code></td><td>mutable variable that lives for the duration of the program;<br>can only access in <code>unsafe</code> blocks and functions</td></tr></tbody></table><p>Variables defined with <code>static</code> are given a fixed location in memory and all references refer to the value at that location. Their lifetime is <code>'static</code> which is the duration of the program.</p><p>Variables defined with <code>const</code> do not have a location in memory. The compiler substitutes their value where all references appear, so the variable doesn't exist at runtime. In that sense they do not have a lifetime.</p><p>Rather than inferring a type based on the assigned value, <code>const</code> and <code>static</code> declarations must be explicitly typed. One rationale is that because their scope can extend to the entire crate, it is better to be explicit about the desired type.</p><p>Constants can be defined using either <code>const</code> or <code>static</code>. Using <code>static</code> is preferred for values that are larger than a pointer. This is because the value of a <code>const</code> variable is copied everywhere it is used, unlike the value of a <code>static</code> variable that is shared. A consequence of this is that static values cannot be assigned to variables unless their type implements the <code>Copy</code> trait because doing so requires copying. Note that all the scalar types like <code>bool</code>, <code>char</code>, <code>i32</code>, and <code>f64</code> implement the <code>Copy</code> trait.</p><p>Here are examples of using these:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Color</span> <span class="token punctuation">{</span><br>    r<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">,</span><br>    g<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">,</span><br>    b<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><br><span class="token keyword">const</span> <span class="token constant">PURPLE_C</span><span class="token punctuation">:</span> <span class="token class-name">Color</span> <span class="token operator">=</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> r<span class="token punctuation">:</span> <span class="token number">255</span><span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">255</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">static</span> <span class="token constant">PURPLE_S</span><span class="token punctuation">:</span> <span class="token class-name">Color</span> <span class="token operator">=</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> r<span class="token punctuation">:</span> <span class="token number">255</span><span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">255</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">static</span> <span class="token keyword">mut</span> <span class="token constant">SIZE</span><span class="token punctuation">:</span> <span class="token keyword">u8</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"PURPLE_C = {:?}"</span><span class="token punctuation">,</span> <span class="token constant">PURPLE_C</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"PURPLE_S = {:?}"</span><span class="token punctuation">,</span> <span class="token constant">PURPLE_S</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token constant">PURPLE_C</span><span class="token punctuation">;</span><br>    <span class="token comment">//let v = PURPLE_S; // cannot move out of static item</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"v = {:?}"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token constant">SIZE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>        <span class="token function">change_it</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">use_it</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">change_it</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token constant">SIZE</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">use_it</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token constant">SIZE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><br><span class="token punctuation">}</span></code></pre><p>To print the type of a variable for debugging purposes, define the following function and pass a reference to it:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">print_type</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token namespace">std<span class="token punctuation">::</span>any<span class="token punctuation">::</span></span><span class="token function">type_name</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>Rust allows variables to be re-declared with a different type in the same block. This is referred to as &quot;shadowing&quot;. Sometimes this is preferred over coming up with multiple names for the same concept. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> command <span class="token operator">=</span> <span class="token string">"order 3 tacos"</span><span class="token punctuation">;</span> <span class="token comment">// &amp;str</span><br><span class="token comment">// The str split_whitespace method returns an Iterator.</span><br><span class="token comment">// The Iterator nth method returns an Option.</span><br><span class="token keyword">let</span> quantity <span class="token operator">=</span> command<span class="token punctuation">.</span><span class="token function">split_whitespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nth</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &amp;str</span><br><span class="token comment">// The str parse method returns an Option.</span><br><span class="token keyword">let</span> quantity <span class="token operator">=</span> quantity<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i32</span><br><span class="token keyword">if</span> quantity <span class="token operator">></span> <span class="token number">2</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"You must be very hungry!"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Perhaps you don't really like tacos."</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><h2 id="ownership-model">Ownership Model</h2><p>Memory management in Rust is handled by following these rules, referred to as the ownership model:</p><ol><li>Each value is referred to by a variable that is its owner.</li><li>Each value has one owner at a time, but the owner can change over its lifetime.</li><li>When the owner variable goes out of the scope, the value is dropped (freed).</li></ol><p>The ownership model provides the following benefits:</p><ul><li>Runtime speed is achieved by eliminating the need for a garbage collector (GC).</li><li>Performance is more predictable because there are no GC pauses.</li><li>Memory access is safer since there is no possibility of null pointer accesses or dangling pointer accesses (accessing memory that has already been freed).</li><li>Parallel and concurrent processing is safer because there is no possibility of data races causing unpredictable interactions between threads.</li></ul><p>Variable values are stored either in the stack or the heap. Accessing stack data is faster, but data on the heap can grow and shrink and it can live beyond the scope that created it.</p><p>Variable values whose sizes are known at compile time are stored on the stack. This includes booleans (<code>bool</code> type), single characters (<code>char</code> type), numbers, tuples, arrays, and structs. Variable values of all other types are stored in the heap. This includes:</p><ul><li>strings (<code>&amp;str</code> and <code>String</code>)</li><li>collections from the <code>std::collections</code> namespace which defines sequences (<code>Vec</code>, <code>VecDeque</code>, and <code>LinkedList</code>), sets (<code>HashSet</code> and <code>BTreeSet</code>), and maps (<code>HashMap</code> and <code>BTreeMap</code>).</li></ul><p>Values of these types can be stored on the heap by using the <code>Box</code> type. This is typically done in order to have a fixed size way to refer to a value that does not have a fixed size. An example is returning an error struct whose specific type is selected at run time based on the kind of error that occurs. Another example is a recursive type such as linked list.</p><p>Note that sometimes Rust stores <code>&amp;str</code> values on the stack but you cannot control that, so it's best to think of them as always being on the heap.</p><p>All code blocks are delimited by a pair of curly brackets and create a new scope. Each new scope can add data to the stack that is freed when that scope exits. Many keywords have an associated block, including <code>fn</code>, <code>if</code>, <code>loop</code>, <code>for</code>, and <code>while</code>.</p><p>The <code>Drop</code> trait can be implemented for any type to specify code to execute (in the <code>drop</code> method) when data of a specific type is dropped.</p><p>While it is not typically called directly, <code>std::mem::drop</code> is a function that can be called to explicitly free the memory owned by a variable before it goes out of scope.</p><p>The following table summarizes the options for passing an argument to a function.</p><table><thead><tr><th>Goal</th><th>Syntax</th></tr></thead><tbody><tr><td>transfer ownership</td><td><code>name</code></td></tr><tr><td>borrow immutably</td><td><code>&amp;name</code></td></tr><tr><td>borrow mutably</td><td><code>&amp;mut name</code></td></tr></tbody></table><p>Here are some examples that demonstrate ownership inside a single function:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Because a is a scalar type (fixed size) that implements the Copy trait,</span><br>    <span class="token comment">// this makes a copy of a and assigns that to b</span><br>    <span class="token comment">// rather than moving ownership from a to b.</span><br>    <span class="token comment">// Both a and b can then be used.</span><br>    <span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a = {}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"b = {}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><br>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Because c is on the heap and String does not implement</span><br>    <span class="token comment">// the Copy trait, this moves ownership from c to d</span><br>    <span class="token comment">// and c can no longer be used.</span><br>    <span class="token keyword">let</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span><br><br>    <span class="token comment">//println!("c = {}", c); // error "value borrowed here after move"</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d = {}"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test</span><br><br>    <span class="token comment">// The Copy trait requires also implementing the Clone trait.</span><br>    <span class="token comment">// We could implement these traits manually, but that is more work.</span><br>    <span class="token attribute attr-name">#[derive(Clone, Copy, Debug)]</span><br>    <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>        x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>        y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Since we implemented the Copy trait on the Point2D type,</span><br>    <span class="token comment">// this makes a copy of e and assigns it to f.</span><br>    <span class="token comment">// If we hadn't implemented the Copy trait,</span><br>    <span class="token comment">// this would move ownership from e to f.</span><br>    <span class="token keyword">let</span> f <span class="token operator">=</span> e<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><br>    <span class="token comment">// This works because we implemented the Copy trait.</span><br>    <span class="token comment">// If we hadn't, we would get the error "value borrowed here after move".</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"e = {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Ownership of a value can be &quot;borrowed&quot; by any number of variables by getting a reference to a value. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"e = {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><br><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span> <span class="token comment">// an immutable borrow</span><br><span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span> <span class="token comment">// another immutable borrow</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"f={:?}, g={:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Any type that acts like a pointer to another type (ex. <code>&amp;variable</code> and smart pointers like <code>Box</code>, <code>Rc</code>, and <code>Arc</code>) can be dereferenced to get the value to which it points. This can be done with the <code>*</code> operator. Automatic dereferencing is performed by the dot operator which is used to access a field or method of a type. Finally, automatic dereferencing occurs when a reference type is passed to a function or macro. This is why we were able to print <code>f</code> above without specifying <code>*f</code>, but that also works. Automatic dereferencing makes code less &quot;noisy&quot; than it would otherwise be.</p><p>Borrowing does not transfer (also referred to as &quot;move&quot;) ownership. A borrowed variable can go out of scope without freeing the memory associated with the original variable.</p><p>When a value is mutable and ownership is borrowed, the compiler will report an error if the value is mutated after the borrow is created and before its last use. This is because references expect the data they reference to remain the same. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> e <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span> <span class="token comment">// f borrows a reference rather than taking ownership</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br><br><span class="token comment">// f is used after the next line which mutates e, so we get</span><br><span class="token comment">// the error "cannot assign to `e.x` because it is borrowed".</span><br>e<span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">3.0</span><span class="token punctuation">;</span><br><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Often a borrow only needs to read a value (referred to as an &quot;immutable borrow&quot;) and any number of these can be created. A mutable borrow allows changing a mutable value through the borrowed variable. But a mutable borrow can only be created when there will be no uses of already created immutable borrows until after the last use of the mutable one. Also, only one mutable borrow of a given variable can be active at a time. The original variable cannot be accessed again until after the last access of the borrowed variable. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> ref1 <span class="token operator">=</span> <span class="token operator">&amp;</span>pt<span class="token punctuation">;</span> <span class="token comment">// immutable reference</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ref1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><br>    <span class="token comment">// Can create and use any number of additional immutable references.</span><br>    <span class="token keyword">let</span> ref2 <span class="token operator">=</span> <span class="token operator">&amp;</span>pt<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ref2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><br>    <span class="token comment">// Can use earlier immutable references again.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ref1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br><br>    <span class="token comment">// Can create and use a mutable reference.</span><br>    <span class="token keyword">let</span> ref3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> pt<span class="token punctuation">;</span><br>    ref3<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ref3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 3.0, y: 2.0 }</span><br><br>    <span class="token comment">// Can't use immutable references created before a mutable reference,</span><br>    <span class="token comment">// even if the mutable reference isn't used to mutate the value.</span><br>    <span class="token comment">//println!("{:?}", ref1);</span><br><br>    <span class="token comment">// Can create and use new immutable references because</span><br>    <span class="token comment">// we are finished with the mutable reference at this point.</span><br>    <span class="token keyword">let</span> ref4 <span class="token operator">=</span> <span class="token operator">&amp;</span>pt<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ref4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 3.0, y: 2.0 }</span><br><span class="token punctuation">}</span></code></pre><p>An alternative to borrowing is to clone data, but doing this is often unnecessarily inefficient. To clone a value, call its <code>clone</code> method which is available for all types that implement the <code>Clone</code> trait. A large number of built-in types implement this including <code>String</code>, arrays, tuples, <code>Vec</code>, <code>HashMap</code>, and <code>HashSet</code>. To enable cloning a struct, implement the <code>Clone</code> trait by adding the <code>#[derive(Clone)]</code> attribute before it.</p><p>When variables whose values are on the stack are passed to functions, the functions are given copies. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><span class="token punctuation">}</span></code></pre><p>When variables (not references) of types that do not implement the <code>Copy</code> trait are passed to functions, copies are not made and ownership is transferred. When the function exits, the data is freed. The calling function can then no longer use variables that were passed in. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Clone, Copy, Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">take_point</span><span class="token punctuation">(</span>p<span class="token punctuation">:</span> <span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p = {:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">take_vector</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"v = {:?}"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">take_point</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token comment">// We can still use pt because ownership was not transferred.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"pt = {:?}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token function">take_vector</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error "borrow of moved value: `numbers`"</span><br>    <span class="token comment">// We cannot still use numbers because ownership was transferred.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"numbers = {:?}"</span><span class="token punctuation">,</span> numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// value borrowed here after move</span><br><span class="token punctuation">}</span></code></pre><p>We can fix the error above by changing the function to return the parameter which returns ownership. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">take_vector</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"v = {:?}"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    v<br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> new_numbers <span class="token operator">=</span> <span class="token function">take_vector</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"new_numbers = {:?}"</span><span class="token punctuation">,</span> new_numbers<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>When references to variables are passed to functions, ownership is borrowed rather than being transferred. When the function exits, the value is not freed and the calling function can continue using it. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// We could pass the i32 argument by reference,</span><br><span class="token comment">// but there is no benefit in doing that.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span></code></pre><p>To allow a function to modify data passed to it by reference, pass and receive mutable references. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token operator">*</span>i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br>    s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">" more"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// on stack</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// on heap</span><br>    <span class="token comment">// Even though i and s are mutable, the arguments to</span><br>    <span class="token comment">// my_function below only need to be marked as mutable</span><br>    <span class="token comment">// if that function requires them to be mutable.</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test more"</span><br><span class="token punctuation">}</span></code></pre><p>A function can create a value and return it. This transfers ownership to the caller rather than freeing the data when the function exits. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">get_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span><br>    <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">get_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 0.0, y: 0.0 }</span><br><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test</span><br><span class="token punctuation">}</span></code></pre><p>Early we said that memory for values allocated in a scope is freed when the scope exits. However, there is an exception to this when ownership is transferred outside the block. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> a<span class="token punctuation">;</span> <span class="token comment">// set once inside the block that follows</span><br><br>    <span class="token punctuation">{</span><br>        <span class="token comment">// Allocate inside block.</span><br>        <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// Move ownership to "a" which lives outside this block.</span><br>        a <span class="token operator">=</span> b<span class="token punctuation">;</span><br><br>        <span class="token comment">// If the previous line is changed to</span><br>        <span class="token comment">// a = &amp;b;</span><br>        <span class="token comment">// we get the error "`b` does not live long enough"</span><br>        <span class="token comment">// because a will no longer get ownership</span><br>        <span class="token comment">// and b will be freed at the end of the block.</span><br><br>        <span class="token comment">// Memory for b is not freed when this block exits</span><br>        <span class="token comment">// because b no longer owns it.</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// "a" can be used here because its lifetime has yet not ended.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Closures are anonymous functions that capture values in their environment. Their parameter list is written between vertical bars which must be present even if there are no parameters. Closures are described in more detail later. Here is a similar ownership example using a closure:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// This variable must be initialized in order to access it in the closure.</span><br>    <span class="token comment">// Since it is then modified in the closure, it must be mutable.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> a <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This variable must be `mut` because it captures and mutates</span><br>    <span class="token comment">// the mutable variable "a" in its environment.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> inner <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span> <span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        a <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// Moves ownership from b to a.</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example that concisely summarizes the ownership options when passing a value to a function:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">take</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in take pt = {:?}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">take_and_return</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in take_and_return pt = {:?}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    pt <span class="token comment">// returns ownership to caller</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">borrow_immutably</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">//pt.x = 3.0; // can't mutate</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in borrow_immutably pt = {:?}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">borrow_mutably</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    pt<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span> <span class="token comment">// can mutate</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in borrow_mutably pt = {:?}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">take</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token comment">// Can't use pt after ownership was transferred.</span><br>    <span class="token comment">//println!("after take, pt = {:?}", pt);</span><br><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    pt <span class="token operator">=</span> <span class="token function">take_and_return</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"after take_and_return, pt = {:?}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">borrow_immutably</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"after borrow_immutably, pt = {:?}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">borrow_mutably</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"after borrow_mutably, pt = {:?}"</span><span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="lifetimes">Lifetimes</h2><p>Lifetimes ensure that memory does not get freed before a reference to it can use it.</p><p>Lifetime annotations only apply to references. All reference parameters and reference return types have a lifetime, but the Rust compiler automatically determines them in most cases. When it cannot, you must explicitly specify them. This is typically only needed when there are multiple reference parameters and more than one of them can be returned. Usually the same lifetime is used on all of the reference parameters AND on the return reference type.</p><p>Lifetime annotations used in function signatures are declared by listing them in angle brackets just like generic types. They are distinguish from generic types by beginning with a single quote. Uses of lifetime annotations appear in reference types after the <code>&amp;</code> and before type names. Their names are typically a single letter such as &quot;a&quot;. Lifetime annotations only serve to indicate which items in a function signature have the same lifetime (or at least as long as another), not an actual duration.</p><p>The following example illustrates a case where lifetime annotations are required:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// The function signature below results in a "missing lifetime specifier" error</span><br><span class="token comment">// The compiler says "explicit lifetime required"</span><br><span class="token comment">// for s1, s2, and the return type.</span><br><span class="token comment">// When more than one reference is passed to a function AND</span><br><span class="token comment">// one of them can be returned, Rust requires lifetime specifiers.</span><br><span class="token comment">//fn get_greater(s1: &amp;str, s2: &amp;str) -> &amp;str {</span><br><br><span class="token comment">// The next function signature includes lifetime specifiers.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">get_greater</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">,</span> s2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> s1 <span class="token operator">></span> s2 <span class="token punctuation">{</span><br>        s1<br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        s2<br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">get_surprise</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token function">get_greater</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"no soup for you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token function">get_surprise</span><span class="token punctuation">(</span><span class="token string">"soup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// soup</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token function">get_surprise</span><span class="token punctuation">(</span><span class="token string">"bread"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no soup for you</span><br><span class="token punctuation">}</span></code></pre><p>The name <code>static</code> is a reserved lifetime name. It is the lifetime of <code>const</code> and <code>static</code> values which live for the duration of the program.</p><p>To use more than one lifetime specifier in a function signature, list them after the function name inside angle brackets separated by commas. For example, <code>fn my_function&lt;'a, 'b&gt;(...)</code>.</p><p>To specify that lifetime <code>b</code> is at least as long as lifetime <code>a</code>, use <code>fn my_function&lt;'a, 'b: 'a&gt;(...)</code>.</p><h2 id="enums"><a name="enums">Enums</a></h2><p>Enums specify a list of allowed values referred to as &quot;variants&quot;. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[allow(dead_code)]</span> <span class="token comment">// suppresses warning about not using all the variants</span><br><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">enum</span> <span class="token type-definition class-name">PrimaryColor</span> <span class="token punctuation">{</span> <span class="token class-name">Red</span><span class="token punctuation">,</span> <span class="token class-name">Green</span><span class="token punctuation">,</span> <span class="token class-name">Blue</span> <span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">process_color</span><span class="token punctuation">(</span>color<span class="token punctuation">:</span> <span class="token class-name">PrimaryColor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"color = {:?}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Green</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> color<span class="token punctuation">:</span> <span class="token class-name">PrimaryColor</span> <span class="token operator">=</span> <span class="token class-name">PrimaryColor</span><span class="token punctuation">::</span><span class="token class-name">Green</span><span class="token punctuation">;</span><br>    <span class="token function">process_color</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Match expressions are similar to <code>switch</code> statements in other languages, but they evaluate to a value. Instead of <code>case</code> statements inside a <code>switch</code> they have &quot;match arms&quot;. There must be a match arm for every possible value of the expression being matched (exhaustive). For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[allow(dead_code)]</span><br><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">enum</span> <span class="token type-definition class-name">PrimaryColor</span> <span class="token punctuation">{</span> <span class="token class-name">Red</span><span class="token punctuation">,</span> <span class="token class-name">Green</span><span class="token punctuation">,</span> <span class="token class-name">Blue</span> <span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">use</span> <span class="token class-name">PrimaryColor</span><span class="token punctuation">::</span><span class="token operator">*</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token class-name">Red</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// If a match arm for any PrimaryColor variant was missing</span><br>    <span class="token comment">// we would get a "non-exhaustive patterns" error.</span><br>    <span class="token keyword">let</span> item <span class="token operator">=</span> <span class="token keyword">match</span> color <span class="token punctuation">{</span><br>        <span class="token class-name">Red</span> <span class="token operator">=></span> <span class="token string">"stop sign"</span><span class="token punctuation">,</span><br>        <span class="token class-name">Green</span> <span class="token operator">=></span> <span class="token string">"grass"</span><span class="token punctuation">,</span><br>        <span class="token class-name">Blue</span> <span class="token operator">=></span> <span class="token string">"sky"</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"item = {}"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// stop sign</span><br><br>    <span class="token keyword">let</span> item <span class="token operator">=</span> <span class="token keyword">match</span> color <span class="token punctuation">{</span><br>        <span class="token class-name">Blue</span> <span class="token operator">=></span> <span class="token string">"sky"</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> <span class="token string">"unknown"</span> <span class="token comment">// wildcard handling all other values</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"item = {}"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// unknown</span><br><span class="token punctuation">}</span></code></pre><p>The <a href="#error-handling">Error Handling</a> section describes the <code>Option</code> and <code>Result</code> enums that are provided by the standard library. These contain variants that hold data, which is something that enums in most other programming languages cannot do. The <code>Option&lt;T&gt;</code> enum defines the variants <code>Some(T)</code> and <code>None</code>. The <code>Result&lt;T, E&gt;</code> enum defines the variants <code>Ok(T)</code> and <code>Err&lt;E&gt;</code>.</p><p>Enum variants can hold many kinds of values. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>fmt<span class="token punctuation">::</span></span><span class="token class-name">Debug</span><span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">enum</span> <span class="token type-definition class-name">Demo</span> <span class="token punctuation">{</span><br>    <span class="token class-name">Empty</span><span class="token punctuation">,</span><br>    <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token class-name">TupleLike</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token class-name">StructLike</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">use</span> <span class="token class-name">Demo</span><span class="token punctuation">::</span><span class="token operator">*</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> <span class="token class-name">Empty</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d3 <span class="token operator">=</span> <span class="token class-name">TupleLike</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d4 <span class="token operator">=</span> <span class="token class-name">StructLike</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1.2</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">3.4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}, {:?}, {:?}, {:?}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">,</span> d2<span class="token punctuation">,</span> d3<span class="token punctuation">,</span> d4<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="error-handling"><a name="error-handling">Error Handling</a></h2><p>Rust does not support throwing and catching exceptions like many other programming languages. Instead, functions that can fail typically return the enum type <code>Option</code> or <code>Result</code>.</p><p>The <code>Option</code> enum has two values, <code>Some</code> which wraps a value and <code>None</code> which doesn't. For example, a function that takes a vector and returns the first element that matches some criteria could return <code>Some</code> wrapping the element, or <code>None</code> if no match is found. This is similar to the <code>Maybe</code> monad in Haskell.</p><p>The <code>Result</code> enum also has two values, <code>Ok</code> which wraps a value and <code>Err</code> which wraps an error description. For example, a function that reads all the text in a file could return <code>Ok</code> wrapping the text, or <code>Err</code> wrapping a description of why reading the file failed. This is similar to the <code>Either</code> monad in Haskell.</p><p>There are many ways to handle values from these enum types.</p><ol><li><p>Use a <code>match</code> statement.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">MathError</span> <span class="token punctuation">{</span><br>    <span class="token class-name">DivisionByZero</span> <span class="token comment">// used by divide2</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Demonstrates returning a Option enum.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">divide1</span><span class="token punctuation">(</span>numerator<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> denominator<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> denominator <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token punctuation">{</span><br>        <span class="token class-name">None</span> <span class="token comment">// means there is no result, but doesn't explain why</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Some</span><span class="token punctuation">(</span>numerator <span class="token operator">/</span> denominator<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Demonstrates returning a Result enum.</span><br><span class="token comment">// Commented lines below show an alternative way</span><br><span class="token comment">// to describe the error using a string.</span><br><span class="token comment">//const DIV_BY_ZERO: &amp;str = "divide by zero";</span><br><span class="token keyword">fn</span> <span class="token function-definition function">divide2</span><span class="token punctuation">(</span>numerator<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> denominator<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token class-name">MathError</span><span class="token operator">></span> <span class="token punctuation">{</span><br><span class="token comment">//fn divide2(numerator: f64, denominator: f64) -> Result&lt;f64, &amp;'static str> {</span><br>    <span class="token keyword">if</span> denominator <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token class-name">MathError</span><span class="token punctuation">::</span><span class="token class-name">DivisionByZero</span><span class="token punctuation">)</span><br>        <span class="token comment">//Err(DIV_BY_ZERO)</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>numerator <span class="token operator">/</span> denominator<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">match</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// returns an Option enum</span><br>        <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"divide by zero"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">Some</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:.2}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">match</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// returns a Result enum</span><br>        <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token comment">//Err(msg) => println!("{}", msg),</span><br>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {:.2}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Use <code>if let</code> statement.</p><p>We can replace the <code>match</code> statements in the previous example with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// With this approach we lose the detail in the Err variant.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Use the <code>unwrap</code>, <code>unwrap_or</code>, <code>unwrap_or_default</code>, or <code>unwrap_or_else</code> method.</p><p>These extract the value from an <code>Option</code> or <code>Result</code> enum.</p><p>If the value is a <code>Some</code> or <code>Ok</code>, these succeed.</p><p>If the value is a <code>None</code> or <code>Err</code>:</p><ul><li><code>unwrap</code> panics, exiting the program</li><li><code>unwrap_or</code> uses a specified value</li><li><code>unwrap_or_default</code> uses the default value for the type</li><li><code>unwrap_or_else</code> executes a closure passed to it to compute the value to use</li></ul><p>If the value is <code>Err</code> and the <code>unwrap</code> method is used, the message it wraps will be output.</p><p>We can replace the <code>match</code> and <code>if let</code> statements above with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// When d is zero this uses infinity for the value.</span><br><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token namespace">std<span class="token punctuation">::</span></span><span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token constant">INFINITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Use the <code>expect</code> method.</p><p>This is nearly the same as the <code>unwrap</code> method. The only difference is that a custom error message can be supplied. We can replace the lines above with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"division failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"division failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Use the <code>?</code> operator which is shorthand for the <code>try!</code> macro.</p><p>If the value is a <code>Some</code> or <code>Ok</code> then it is unwrapped and returned. If the value is a <code>None</code> or <code>Err</code> then it is passed through the <code>from</code> function (defined in the standard library <code>From</code> trait) in order to convert it to the return type of the function, and that is returned to the caller. The function in which this operator is used must declare the proper return type and return a value of that type. This allows the caller to handle errors, similar to re-throwing an exception in other programming languages.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">divide2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Uses of <code>?</code> can be chained in the same statement. For example, suppose the function <code>alpha</code> returns a <code>Result</code> whose wrapped value is an object with a method <code>beta</code> that returns a <code>Result</code> whose wrapped value is an object with a method <code>gamma</code> that returns a <code>Result</code>. We can get the value of this call sequences with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">alpha</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">beta</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">gamma</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span></code></pre><p>In functions that call multiple other functions that return <code>Result</code> instances with different types of errors and wish to return them to callers, consider adding <code>?</code> after those calls and making the return type <code>Result&lt;SomeOkType, Box&lt;dyn error::Error&gt;&gt;</code>. The <code>dyn</code> keyword performs dynamic dispatch to allow a value of any type that implements a given trait. In this case the errors that can be returned (<code>std::io::Error</code> and <code>std::num::ParseIntError</code>) all implement the <code>std::error::Error</code> trait. Because they don't all have the same size, they must wrapped in a <code>Box</code> which does have a fixed size. For example, from the Rustlings exercise <code>errorsn.rs</code>:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">read_and_validate</span><span class="token punctuation">(</span><br>    b<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">dyn</span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">BufRead</span><span class="token punctuation">,</span><br><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">PositiveNonzeroInteger</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token namespace">std<span class="token punctuation">::</span>error<span class="token punctuation">::</span></span><span class="token class-name">Error</span><span class="token operator">>></span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> line <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    b<span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> line<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span> <span class="token comment">// can return Err(std::io::Error)</span><br>    <span class="token keyword">let</span> num<span class="token punctuation">:</span> <span class="token keyword">i64</span> <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span> <span class="token comment">// can return Err(std::num::ParseIntError)</span><br>    <span class="token comment">// If</span><br>    <span class="token keyword">let</span> answer <span class="token operator">=</span> <span class="token class-name">PositiveNonzeroInteger</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br>    <span class="token class-name">Ok</span><span class="token punctuation">(</span>answer<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre></li></ol><h2 id="built-in-scalar-types">Built-in Scalar Types</h2><p>Rust defines many scalar (primitive) types which can be categories as boolean, character, integer (6 kinds), or floating point (2 kinds).</p><p>The boolean type name is <code>bool</code>. Its only values are <code>true</code> and <code>false</code>.</p><p>The character type name is <code>char</code>. Literal values are surrounded by single quotes. Its values are Unicode values that each occupy four bytes regardless of whether four bytes are actually needed to represent them. This gives the values a known size at compile time.</p><p>The signed integer type names are <code>i{n}</code> where <code>{n}</code> is the number of bits which can be 8, 16, 32, 64, 128, or <code>size</code>. The <code>isize</code> type matches either <code>i32</code> or <code>i64</code> depending on the processor architecture. The default type for literal integers is <code>i32</code> regardless of the processor.</p><p>The unsigned integer types are the same, but start with <code>u</code> instead of <code>i</code>.</p><p>Literal number values can end with these type names to make their type explicit. For example, the value 19 can be specified to be an unsigned, 8-bit integer by writing <code>19u8</code>.</p><p>Literal integer values can use the underscore character to separate thousands, millions, and so on. For example, the population of the U.S. in 2020 was approximately 330_676_544.</p><p>Hex values begin with <code>0x</code>, octal values begin with <code>0o</code>, and binary values begin with <code>0b</code>.</p><p>The floating point type names are <code>f{n}</code> where <code>{n}</code> is 32 or 64. The default type for literal floats is <code>f64</code> regardless of the processor. Literal floating point values must include a decimal point to avoid being treated as integer values, but it is acceptable to have no digits after the decimal point. This means that <code>123.</code> is treated the same as <code>123.0</code>.</p><p>The &quot;unit type&quot; represents not having a value, like <code>void</code> in other languages. It can be thought of as an enum with a single variant which is written as <code>()</code>. It is the return value of functions that do not return a value. It is what the <code>Result</code> enum <code>Ok</code> variant wraps when there is nothing to return. It can follow the <code>=&gt;</code> in a <code>match</code> arm to take no action.</p><p>Rust allows adding methods to any type, even built-in types. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">trait</span> <span class="token class-name">Days</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">days_from_now</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Days</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token keyword">for</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">days_from_now</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">match</span> <span class="token keyword">self</span> <span class="token punctuation">{</span><br>            <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=></span> <span class="token string">"yesterday"</span><span class="token punctuation">,</span><br>            <span class="token number">0</span> <span class="token operator">=></span> <span class="token string">"today"</span><span class="token punctuation">,</span><br>            <span class="token number">1</span> <span class="token operator">=></span> <span class="token string">"tomorrow"</span><span class="token punctuation">,</span><br>            _ <span class="token operator">=></span> <span class="token keyword">if</span> <span class="token keyword">self</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token string">"future"</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"past"</span> <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><span class="token punctuation">;</span><br>        s<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> days<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> days<span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yesterday</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// today</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tomorrow</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// future</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// past</span><br><span class="token punctuation">}</span></code></pre><p>Here is another way to implement this that works on values of any type that implements the traits <code>Eq</code>, <code>Ord</code>, and <code>From&lt;i8&gt;</code> which all the number types do:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token punctuation">{</span> <span class="token class-name">Eq</span><span class="token punctuation">,</span> <span class="token class-name">Ord</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">trait</span> <span class="token class-name">Days</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">days_from_now</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token keyword">str</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Eq</span> <span class="token operator">+</span> <span class="token class-name">Ord</span> <span class="token operator">+</span> <span class="token class-name">From</span><span class="token operator">&lt;</span><span class="token keyword">i8</span><span class="token operator">>></span> <span class="token class-name">Days</span> <span class="token keyword">for</span> <span class="token class-name">T</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">days_from_now</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token keyword">str</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token keyword">self</span> <span class="token operator">==</span> <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token string">"today"</span><br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">self</span> <span class="token operator">==</span> <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token string">"yesterday"</span><br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">self</span> <span class="token operator">==</span> <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token string">"tomorrow"</span><br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">self</span> <span class="token operator">></span> <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token string">"future"</span><br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>            <span class="token string">"past"</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> days<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> days<span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yesterday</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// today</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tomorrow</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// future</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// past</span><br><span class="token punctuation">}</span></code></pre><p>The <a href="#macros">Macros</a> section shows one more approach.</p><h2 id="generics">Generics</h2><p>Rust makes heavy use of generic types. They enable implementing functions, structs, and traits that operate on various types of data instead of only specific types.</p><p>Generic types are declared inside angle brackets. They can specify one or more traits that must be implemented by concrete types in order to use them in place of the type parameters. The sections on functions, structs, and traits contain many examples of using generic types.</p><h2 id="built-in-compound-types">Built-in Compound Types</h2><p>Rust defines two compound (non-primitive) types which are tuple and array. These are distinct from the collection types that are described later.</p><p>A tuple is a fixed-length list of values that can be of different types. The maximum length is 12. The syntax for a tuple type is <code>(type1, type2, ...)</code>. The syntax for a tuple value is <code>(value1, value2, ...)</code>. Individual values can be accessed by index or destructuring. It is not possible to iterate over the elements of a tuple.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> <span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> <span class="token punctuation">..</span><span class="token punctuation">)</span> <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// .. means to ignore the remaining values</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} {}"</span><span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 2</span></code></pre><p>An array is a fixed-length list of values that have the same type. The syntax for an array type is <code>[type; length]</code>. The syntax for an array value is <code>[value1, value2, ...]</code>. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// inferred type is [i32; 4]</span><br><span class="token keyword">let</span> <span class="token punctuation">[</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> <span class="token punctuation">..</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// .. means to ignore the remaining values</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} {}"</span><span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 2</span><br><br><span class="token keyword">let</span> rgb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// A Rust string is a "compound collection", covered later.</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"rgb = {:?}"</span><span class="token punctuation">,</span> rgb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "green", "blue"]</span><br><br><span class="token keyword">let</span> sevens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// same as [7, 7, 7, 7, 7]</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"sevens = {:?}"</span><span class="token punctuation">,</span> sevens<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [7, 7, 7, 7, 7]</span></code></pre><p>Elements of an array can be accessed using square brackets and zero-based indexes. For example, <code>rgb[1]</code> is &quot;green&quot;.</p><p>Rust provides the <code>Vec</code> (vector) type for creating variable-length lists of values that have the same type. These can be used in place of arrays when the number of values varies. Operating on an array or <code>Vec</code> often requires obtaining an <a href="#iterators"><code>Iterator</code></a>. For example, that is where the methods <code>map</code>, <code>filter</code>, and <code>fold</code> are found.</p><h2 id="collections">Collections</h2><p>Rust defines many kinds of collections that hold a variable number of values. These include strings and collections in the <code>std::collections</code> namespace.</p><p>The <code>std::collections</code> namespace defines the following sequence types:</p><ul><li><code>Vec</code>: a resizable, ordered array of values of the same type where items can be efficiently adding and removing items at the end</li><li><code>VecDeque</code>: like a <code>Vec</code>, but items can also be efficiently adding and removing items at the beginning</li><li><code>LinkedList</code>: like a <code>VecDeque</code>, but can be efficiently split which enables efficiently adding and removing items in the middle</li></ul><p>The <code>std::collections</code> namespace defines the following map types:</p><ul><li><code>HashMap</code>: a collection of key/value pairs with efficient value lookup by key where keys and values can be any type</li><li><code>BTreeMap</code>: like a <code>HashMap</code>, but sorted by key enabling efficient retrieval of values corresponding to the smallest key, largest key, closest key that is smaller or larger than some key value, or range of keys</li></ul><p>The <code>std::collections</code> namespace defines the following set types:</p><ul><li><code>HashSet</code>: a collection of unique values with efficient determination of whether a given value is a member</li><li><code>BTreeSet</code>: similar to storing only the keys in a <code>BTreeMap</code></li></ul><p>The <code>std::collections</code> namespace defines one more collection type that doesn't fall into the previous categories:</p><ul><li><code>BinaryHeap</code>: implements a priority queue where only the highest priority item is accessible</li></ul><h3 id="strings"><a name="strings">Strings</a></h3><p>Strings are collections of UTF-8 encoded characters stored as a <code>Vec</code> of <code>u8</code> byte values. Literal values are surrounded by double quotes. Strings are more difficult to work with in Rust than in other languages. Rust trades simplicity here for better performance, memory management, and concurrency.</p><p>There are two kinds of strings in Rust. The language defines the &quot;string slice&quot; type <code>&amp;str</code> and the standard library defines the <code>String</code> type. A <code>&amp;str</code> value is a reference (or pointer) to data that includes the length of the string and a pointer to where the character data is stored, which can be on the stack or the heap. A <code>String</code> value is a &lt;% aTargetBlank &quot;#smart-pointers&quot;, &quot;smart pointer&quot; %&gt; that holds a pointer to the character data on the heap, a length, and a capacity. The capacity is the length to which the character data can grow before additional space must be allocated (handled automatically). A <code>&amp;str</code> value can be a view into the characters of <code>String</code>, sharing its character data.</p><p>While one reason to choose the <code>String</code> type over the <code>&amp;str</code> type is so the length can change, the most common reason is so a variable can &quot;own&quot; it. Values of type <code>&amp;str</code> cannot be owned by a variable.</p><p>Literal characters (just one) are surrounded by single quotes and have the type <code>char</code>. Literal strings (zero or more characters) are surrounded by double quotes and have the type <code>&amp;str</code>.</p><p>Here is a summary of the types that can be used to represent strings:</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>str</code></td><td>rarely used directly</td></tr><tr><td><code>&amp;str</code></td><td>reference to an immutable string slice; commonly used</td></tr><tr><td><code>&amp;mut str</code></td><td>rarely user; some <code>str</code> methods use it</td></tr><tr><td><code>String</code></td><td>immutable if declared with <code>let</code>; mutable with <code>let mut</code>; commonly used</td></tr><tr><td><code>&amp;String</code></td><td>reference to an immutable string; typically <code>&amp;str</code> is used instead</td></tr><tr><td><code>&amp;mut String</code></td><td>reference to a mutable string; commonly used</td></tr></tbody></table><p>So the string types most frequently used are <code>&amp;str</code>, <code>String</code>, and <code>&amp;mut String</code>.</p><p>To get a <code>&amp;str</code> from a <code>String</code> in the variable <code>s</code>, use <code>&amp;s</code> or <code>s.as_str()</code> which are equivalent.</p><p>To get a <code>String</code> from a <code>&amp;str</code> in the variable <code>s</code>, use <code>s.to_string()</code>, <code>String::from(s)</code>, or <code>s.to_owned()</code> which are equivalent. Actually, <code>to_string</code> calls <code>String::from</code> which calls <code>to_owned</code>. These calls are inlined so they all have the same performance.</p><p>When a <code>String</code> reference is passed to a function that expects a <code>&amp;str</code> it is automatically coerced to that type. This is because <code>String</code> implements the <code>Deref</code> trait with a <code>Target</code> of <code>str</code>. For more on this, see the <a href="#smart-pointers">Smart Pointers</a> section. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ownership is not transferred</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span></code></pre><p>To create a <code>String</code> from multiple values of types that implement the <code>Display</code> trait, use <code>format!(fmt_string, v1, v2, ...)</code>.</p><p>Here are examples of declaring, creating, and passing various kinds of strings:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">demo</span><span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> s2<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> s3<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">,</span> s4<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 = {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// one</span><br>  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s2 = {}"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// two</span><br>  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s3 = {}"</span><span class="token punctuation">,</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// three</span><br>  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s4 = {}"</span><span class="token punctuation">,</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// four alpha</span><br>  <span class="token comment">//s3.push_str(" beta"); // error: cannot borrow `*s3` as mutable</span><br>  s4<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">" beta"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// only s4 can be mutated</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token string">"one"</span><span class="token punctuation">;</span> <span class="token comment">// type is inferred as &amp;str</span><br>    <span class="token keyword">let</span> s2<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token string">"two"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> s3<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s4<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token string">"four"</span><span class="token punctuation">.</span><span class="token function">to_owned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    s4<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">" alpha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token function">demo</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s3<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"main: s1 = {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// one</span><br>    <span class="token comment">//println!("main: s2 = {}", s2); // error: borrow of moved value</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"main: s3 = {}"</span><span class="token punctuation">,</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// three</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"main: s4 = {}"</span><span class="token punctuation">,</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// four alpha beta</span><br><span class="token punctuation">}</span></code></pre><p>Typically variables and parameters for strings that do not require mutation should use the type <code>&amp;str</code> and those that do should use the type <code>&amp;mut String</code>.</p><p>In the tables below, assume the following variable types:</p><ul><li><code>c</code> holds a <code>char</code> value</li><li><code>r</code> holds a <code>std::ops::Range</code> value</li><li><code>s</code> and <code>t</code> hold <code>&amp;str</code> values</li><li><code>u</code>, <code>v</code>, and <code>w</code> hold <code>String</code> values</li><li><code>z</code> holds a <code>char</code> or <code>&amp;str</code> value</li></ul><p>Everywhere <code>c</code> is used, a literal character can be used in its place. Everywhere <code>s</code> and <code>t</code> are used, a literal string can be used in their place.</p><p>Here are operations on the <code>str</code> type:</p><table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody><tr><td>create</td><td><code>&quot;text in double quotes&quot;</code></td></tr><tr><td>get substring</td><td><code>s[start..end]</code> (1)</td></tr><tr><td>get iterator over Unicode characters</td><td><code>s.chars()</code></td></tr><tr><td>get <code>char</code> at index</td><td><code>s.chars().nth(index)</code> (2)</td></tr><tr><td>determine if contains</td><td><code>s.contains(z)</code></td></tr><tr><td>determine if ends with</td><td><code>s.ends_with(z)</code></td></tr><tr><td>determine if starts with</td><td><code>s.starts_with(z)</code></td></tr><tr><td>get substring</td><td><code>s.get(r)</code> (3)</td></tr><tr><td>get length</td><td><code>s.len()</code></td></tr><tr><td>get iterator over lines</td><td><code>s.lines()</code></td></tr><tr><td>parse into another type such as specific number type</td><td><code>let v = s.parse::&lt;T&gt;()</code> (4)</td></tr><tr><td>create <code>String</code> that repeat n times</td><td><code>s.repeat(n)</code></td></tr><tr><td>replace all occurrences of z1 with z2</td><td><code>s.replace(z1, z2)</code></td></tr><tr><td>replace first n occurrences of z1 with z2</td><td><code>s.replacen(z1, z2, n)</code></td></tr><tr><td>split on a character</td><td><code>s.split(c)</code> returns an iterator (5)</td></tr><tr><td>split on a character n times (last contains rest)</td><td><code>s.splitn(n, c)</code> returns an iterator</td></tr><tr><td>split at index</td><td><code>s.split_at(n)</code> returns tuple</td></tr><tr><td>split on any amounts of whitespace</td><td><code>s.split_whitespace()</code></td></tr><tr><td>remove prefix</td><td><code>s.strip_prefix(z)</code> returns <code>Option</code></td></tr><tr><td>remove suffix</td><td><code>s.strip_suffix(z)</code> returns <code>Option</code></td></tr><tr><td>convert <code>&amp;str</code> to <code>String</code></td><td><code>s.to_string()</code></td></tr><tr><td>convert <code>&amp;str</code> to <code>String</code></td><td><code>String::from(s)</code></td></tr><tr><td>convert <code>&amp;str</code> to <code>String</code></td><td><code>s.to_owned()</code></td></tr><tr><td>get lowercase <code>String</code></td><td><code>s.to_lowercase()</code></td></tr><tr><td>get uppercase <code>String</code></td><td><code>s.to_uppercase()</code></td></tr><tr><td>get <code>&amp;str</code> with leading and trailing whitespace removed</td><td><code>s.trim()</code></td></tr><tr><td>get <code>&amp;str</code> with trailing whitespace removed</td><td><code>s.trim_end()</code></td></tr><tr><td>get <code>&amp;str</code> with leading whitespace removed</td><td><code>s.trim_start()</code></td></tr></tbody></table><ol><li><code>start</code> is inclusive and <code>end</code> is exclusive.</li><li>The <code>chars</code> method can be used to iterate over the characters in a string. The <code>nth</code> method returns a <code>Option</code> object because the string may be shorter than the index. See the <a href="#error-handling">Error Handling</a> section for ways to get the <code>char</code> from it.</li><li>This returns an <code>Option</code> object rather than panic on bad indexes.</li><li>The <code>::&lt;T&gt;</code> syntax is called &quot;turbofish&quot;.</li><li>The <code>collect</code> method can be called on this iterator to get a <code>Vec&lt;&amp;str&gt;</code>.</li></ol><p>Many <code>String</code> methods operate on byte indexes. This works for strings that only contain ASCII characters, but is error-prone for strings that contain multi-byte Unicode characters. Methods on the <code>str</code> type are better for working with Unicode characters.</p><p>Here are operations on the <code>String</code> type. Note that methods that modify the value require the <code>String</code> to be mutable (<code>mut</code>).</p><table><thead><tr><th>Operation</th><th>Syntax</th></tr></thead><tbody><tr><td>create empty</td><td><code>String::new()</code></td></tr><tr><td>create from <code>&amp;str</code> #1</td><td><code>String::from(s)</code></td></tr><tr><td>create from <code>&amp;str</code> #2</td><td><code>s.to_string()</code></td></tr><tr><td>create from multiple <code>&amp;str</code> #1</td><td><code>let u = [s, t].concat();</code></td></tr><tr><td>create from multiple <code>&amp;str</code> #2</td><td><code>let u = format!(&quot;{}{}&quot;, s, t);</code></td></tr><tr><td>create from <code>String</code> and <code>&amp;str</code> (1)</td><td><code>let u = v + s;</code></td></tr><tr><td>create from multiple <code>String</code> values (2)</td><td><code>let u = v + &amp;w;</code></td></tr><tr><td>get <code>&amp;str</code> without copying</td><td><code>let s = &amp;t;</code></td></tr><tr><td>get <code>&amp;str</code> without copying</td><td><code>let s = t.as_str();</code></td></tr><tr><td>append <code>char</code></td><td><code>u.push(c)</code></td></tr><tr><td>append <code>&amp;str</code></td><td><code>u += s;</code></td></tr><tr><td>append <code>&amp;str</code></td><td><code>u.push_str(s)</code></td></tr><tr><td>append <code>String</code></td><td><code>u += v;</code></td></tr><tr><td>insert <code>char</code></td><td><code>u.insert(index, c)</code></td></tr><tr><td>insert <code>&amp;str</code></td><td><code>u.insert_str(v, s)</code></td></tr><tr><td>get substring</td><td><code>s.get(r)</code> same as for <code>&amp;str</code></td></tr><tr><td>get substring from index to end</td><td><code>s[start..]</code></td></tr><tr><td>get substring from beginning to index</td><td><code>s[..end]</code></td></tr><tr><td>get substring where end is exclusive</td><td><code>u[start..end]</code></td></tr><tr><td>get substring where end is inclusive</td><td><code>u[start..=end]</code></td></tr><tr><td>get <code>char</code> at index</td><td><code>&amp;u.chars().nth(index)</code></td></tr><tr><td>get length</td><td><code>u.len()</code></td></tr><tr><td>remove and return last character</td><td><code>u.pop()</code></td></tr></tbody></table><ol><li>The <code>String</code> <code>v</code> here must precede the <code>&amp;str</code> s.</li><li>All <code>String</code> values on the right of <code>=</code> after the first must be preceded by <code>&amp;</code> which converts them to <code>&amp;str</code>.</li></ol><p>Here's an example of working with Unicode characters:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> my_string <span class="token operator">=</span> <span class="token string">"Santa 🎅 🎄"</span><span class="token punctuation">;</span><br><span class="token comment">// Get the Santa emoji character.</span><br><span class="token keyword">let</span> letter <span class="token operator">=</span> <span class="token operator">&amp;</span>my_string<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nth</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Approach #1</span><br><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=</span> letter <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"letter is {}"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🎅</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Approach #2</span><br><span class="token keyword">match</span> letter <span class="token punctuation">{</span><br>    <span class="token class-name">Some</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"letter is {}"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 🎅</span><br>    <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ignores when string is shorter</span><br><span class="token punctuation">}</span></code></pre><p>Here's a function that returns the first word in a string that might contain non-ASCII Unicode characters:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span><br>    <span class="token comment">// The chars method returns an iterator.</span><br>    <span class="token comment">// The enumerate method on the iterator returns a new iterator over</span><br>    <span class="token comment">// tuples of indexes and values in the iterator on which it is called.</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> letter<span class="token punctuation">)</span> <span class="token keyword">in</span> s<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> letter <span class="token operator">==</span> <span class="token char string">' '</span> <span class="token punctuation">{</span><br>            <span class="token comment">// Return all the characters up to,</span><br>            <span class="token comment">// but not including the space.</span><br>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    s<br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"foo bar baz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span><br><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"onelongword"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// onelongword</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// empty string</span><br><span class="token punctuation">}</span></code></pre><p>In many programming languages strings are immutable. To make a change you create a new string and assign it back to the same variable. In Rust the <code>&amp;mut str</code> type can be used for this. If it is desirable to modify a string in place, perhaps for performance reasons, the <code>mut String</code> type can be used instead. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token string">"first"</span><span class="token punctuation">;</span><br>s1 <span class="token operator">=</span> <span class="token string">"second"</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> <span class="token keyword">mut</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>s2<span class="token punctuation">.</span><span class="token function">replace_range</span><span class="token punctuation">(</span><span class="token punctuation">..</span><span class="token punctuation">,</span> <span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// range .. is the entire string</span></code></pre><h3 id="vectors">Vectors</h3><p>A vector is represented by the <code>Vec</code> generic type. It is a smart pointer that holds a pointer to the data on the heap, a length, and a capacity. The capacity is the length to which the data can grow before additional space must be allocated (handled automatically).</p><p>Here is a summary of commonly used <code>Vec</code> methods:</p><table><thead><tr><th>Operation</th><th>Syntax</th></tr></thead><tbody><tr><td>create empty</td><td><code>Vec::new()</code></td></tr><tr><td>create empty with capacity</td><td><code>Vec::with_capacity(capacity)</code></td></tr><tr><td>create with items</td><td><code>vec![item1, item2, ...]</code> (1)</td></tr><tr><td>append other</td><td><code>v.append(&amp;other_vector)</code></td></tr><tr><td>search for index of value when sorted</td><td><code>v.binary_search(value)</code></td></tr><tr><td>remove all items</td><td><code>v.clear()</code></td></tr><tr><td>determine if contains value</td><td><code>v.contains(value)</code></td></tr><tr><td>remove consecutive repeated items</td><td><code>v.dedup()</code></td></tr><tr><td>remove consecutive repeated items</td><td><code>v.dedup_by(fn)</code> (2)</td></tr><tr><td>remove consecutive repeated items</td><td><code>v.dedup_by_key(fn)</code> (3)</td></tr><tr><td>get first value</td><td><code>v.first()</code></td></tr><tr><td>insert at index</td><td><code>v.insert(index, value)</code></td></tr><tr><td>determine if empty</td><td><code>v.is_empty()</code></td></tr><tr><td>get iterator</td><td><code>v.iter()</code></td></tr><tr><td>get iterator that allows mutating</td><td><code>v.iter_mut()</code></td></tr><tr><td>get last value</td><td><code>v.last()</code></td></tr><tr><td>get length</td><td><code>v.len()</code></td></tr><tr><td>remove and return last item</td><td><code>v.pop()</code></td></tr><tr><td>add to end</td><td><code>v.push(value)</code></td></tr><tr><td>remove and return item at index</td><td><code>v.remove(index)</code></td></tr><tr><td>remove item with value</td><td><code>v.remove_item(index)</code></td></tr><tr><td>reverse in place</td><td><code>v.reverse()</code></td></tr><tr><td>sort in place</td><td><code>v.sort()</code></td></tr><tr><td>sort in place</td><td><code>v.sort_by(fn)</code> (2)</td></tr><tr><td>sort in place</td><td><code>v.sort_by_key(fn)</code> (3)</td></tr><tr><td>replace items</td><td><code>v.splice(range, iter)</code> (4)</td></tr><tr><td>swap items at indexes</td><td><code>v.swap(index1, index2)</code></td></tr></tbody></table><ol><li><code>vec!</code> is a macro, not a method.</li><li><code>fn</code> is passed two values and returns a <code>bool</code> indicating if the first should be removed.</li><li><code>fn</code> is passed a value and returns a computed value to be used for comparison.</li><li><code>range</code> specifies indexes to remove and <code>iter</code> specifies items to insert in their place.</li></ol><p>Also see the <a href="#iterators">Iterator</a> methods that include <code>filter</code>, <code>map</code>, <code>fold</code> (like <code>reduce</code> in JavaScript), <code>min</code>, <code>max</code>, <code>sum</code>, <code>product</code>, and more.</p><p>Here is an example of creating and operating on a vector:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">for</span> score <span class="token keyword">in</span> <span class="token operator">&amp;</span>scores <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> grade <span class="token operator">=</span> <span class="token keyword">match</span> score <span class="token punctuation">{</span><br>            <span class="token number">90</span><span class="token punctuation">..=</span><span class="token number">100</span> <span class="token operator">=></span> <span class="token char string">'A'</span><span class="token punctuation">,</span><br>            <span class="token number">80</span><span class="token punctuation">..=</span><span class="token number">89</span> <span class="token operator">=></span> <span class="token char string">'B'</span><span class="token punctuation">,</span><br>            <span class="token number">70</span><span class="token punctuation">..=</span><span class="token number">79</span> <span class="token operator">=></span> <span class="token char string">'C'</span><span class="token punctuation">,</span><br>            <span class="token number">60</span><span class="token punctuation">..=</span><span class="token number">69</span> <span class="token operator">=></span> <span class="token char string">'D'</span><span class="token punctuation">,</span><br>            _ <span class="token operator">=></span> <span class="token char string">'F'</span><span class="token punctuation">,</span><br>        <span class="token punctuation">}</span><span class="token punctuation">;</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">let</span> total<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> average <span class="token operator">=</span> total <span class="token keyword">as</span> <span class="token keyword">f32</span> <span class="token operator">/</span> total <span class="token keyword">as</span> <span class="token keyword">f32</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"average = {:.1}"</span><span class="token punctuation">,</span> average<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>When a <code>Vec</code> reference is passed to a function that expects a slice reference it is automatically coerced to that type. This is because <code>Vec&lt;T&gt;</code> implements the <code>Deref</code> trait with a <code>Target</code> of <code>[T]</code>. For more on this, see the <a href="#smart-pointers">Smart Pointers</a> section. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">average_i32</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f32</span> <span class="token punctuation">{</span><br>    numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">f32</span> <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">f32</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Print average of all scores.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"average = {:.1}"</span><span class="token punctuation">,</span> <span class="token function">average_i32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>scores<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 86.2</span><br><br>    <span class="token comment">// Print average of all scores except the first.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"average = {:.1}"</span><span class="token punctuation">,</span> <span class="token function">average_i32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>scores<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 91.7</span><br><span class="token punctuation">}</span></code></pre><p>Writing functions that operate on any numeric type is tricky, but it can be done. This involves using the <a href="https://crates.io/crates/num" rel="noopener" target="_blank">num</a> crate. Add this as a dependency in <code>Cargo.toml</code> with a line like <code>num = &quot;0.3.1&quot;</code>.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">num</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">AddAssign</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">num<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Num</span><span class="token punctuation">,</span> <span class="token class-name">ToPrimitive</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">// T can be any type that implements the traits</span><br><span class="token comment">// AddAssign, Copy, Num, and ToPrimitive.</span><br><span class="token comment">// The built-in primitive number types like i32, u8, and f32</span><br><span class="token comment">// all implement the AddAssign and Copy traits.</span><br><span class="token comment">// The num crate adds implementations of</span><br><span class="token comment">// Num and ToPrimitive to those same types.</span><br><span class="token comment">// So T can be any built-in numeric type.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">average</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">AddAssign</span> <span class="token operator">+</span> <span class="token class-name">Copy</span> <span class="token operator">+</span> <span class="token class-name">Num</span> <span class="token operator">+</span> <span class="token class-name">ToPrimitive</span><span class="token operator">></span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token class-name">T</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f32</span> <span class="token punctuation">{</span><br>    <span class="token comment">// The Num trait requires also implementing the Zero trait</span><br>    <span class="token comment">// which defines the zero function.</span><br>    <span class="token comment">// That returns the zero value for the wrapped primitive type.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> sum <span class="token operator">=</span> <span class="token class-name">T</span><span class="token punctuation">::</span><span class="token function">zero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> numbers <span class="token punctuation">{</span><br>        sum <span class="token operator">+=</span> <span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token comment">// requires implementing the AddAssign trait</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">let</span> numerator <span class="token operator">=</span> sum<span class="token punctuation">.</span><span class="token function">to_f32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    numerator <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">f32</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">//let scores = vec![70, 90, 85, 100];</span><br>    <span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">70.1</span><span class="token punctuation">,</span> <span class="token number">90.2</span><span class="token punctuation">,</span> <span class="token number">85.3</span><span class="token punctuation">,</span> <span class="token number">99.4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Print average of all scores.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"average = {:.1}"</span><span class="token punctuation">,</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>scores<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 86.2</span><br><br>    <span class="token comment">// Print average of all scores except the first.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"average = {:.1}"</span><span class="token punctuation">,</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>scores<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 91.7</span><br><span class="token punctuation">}</span></code></pre><h3 id="sets">Sets</h3><p>A set is a collection of unique values.</p><p>The <code>std::collections</code> namespace defines the <code>HashSet</code> generic type.</p><p>Here is a summary of commonly used <code>HashSet</code> methods:</p><table><thead><tr><th>Operation</th><th>Syntax</th></tr></thead><tbody><tr><td>create empty</td><td><code>let set = HashSet::new()</code></td></tr><tr><td>remove all items</td><td><code>set.clear()</code></td></tr><tr><td>determine if an item is present</td><td><code>set.contains(item)</code></td></tr><tr><td>get iterator over items not in another set</td><td><code>set1.difference(set2)</code></td></tr><tr><td>get a reference to an item with a given value</td><td><code>set.get(value)</code></td></tr><tr><td>insert an item</td><td><code>set.insert(item)</code> (1)</td></tr><tr><td>get iterator over common items in two sets</td><td><code>set1.intersection(set2)</code></td></tr><tr><td>determine if empty</td><td><code>set.is_empty()</code></td></tr><tr><td>determine if a subset of another set</td><td><code>set1.is_subset(set2)</code></td></tr><tr><td>determine if a superset of another set</td><td><code>set1.is_superset(set2)</code></td></tr><tr><td>get iterator over all items</td><td><code>set.iter()</code></td></tr><tr><td>get number of items (length)</td><td><code>set.len()</code></td></tr><tr><td>remove a value</td><td><code>set.remove(value)</code></td></tr><tr><td>remove elements that do not match a predicate</td><td><code>set.retain(pred_fn)</code> (2)</td></tr><tr><td>get iterator over unique items in two sets</td><td><code>set1.union(set2)</code></td></tr></tbody></table><ol><li>returns a <code>bool</code> indicating if the item was added; <code>false</code> if already present</li><li>modifies in place</li></ol><p>Here is an example of creating and using a <code>HashSet</code> containing <code>String</code> elements. Using the <code>String</code> type rather than <code>&amp;str</code> allows the <code>HashSet</code> to own the values so they have the same lifetime as the <code>HashSet</code> which is generally desirable.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashSet</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Element type is inferred from what is inserted.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> colors <span class="token operator">=</span> <span class="token class-name">HashSet</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    colors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    colors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    colors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {"red", "green", "blue"}</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"orange"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br><br>    colors<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {"blue", "red"}</span><br><br>    <span class="token keyword">for</span> color <span class="token keyword">in</span> <span class="token operator">&amp;</span>colors <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blue then red</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of creating and using a <code>HashSet</code> containing <code>struct</code> elements:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashSet</span><span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[derive(Debug, Eq, Hash, PartialEq)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Dog</span> <span class="token punctuation">{</span><br>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br>    breed<span class="token punctuation">:</span> <span class="token class-name">String</span><br><span class="token punctuation">}</span><br><span class="token keyword">impl</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span><br>    <span class="token comment">// This is a constructor function where</span><br>    <span class="token comment">// the name "new" is used by convention.</span><br>    <span class="token comment">// The type "Self" here refers to "Dog".</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> breed<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>            name<span class="token punctuation">:</span> name<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>            breed<span class="token punctuation">:</span> breed<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> dogs <span class="token operator">=</span> <span class="token class-name">HashSet</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Maisey"</span><span class="token punctuation">,</span> <span class="token string">"Treeing Walker Coonhound"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Ramsay"</span><span class="token punctuation">,</span> <span class="token string">"Native American Indian Dog"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Oscar"</span><span class="token punctuation">,</span> <span class="token string">"German Shorthaired Pointer"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">,</span> <span class="token string">"Whippet"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"dogs = {:#?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">for</span> dog <span class="token keyword">in</span> <span class="token operator">&amp;</span>dogs <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> dog<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">let</span> comet <span class="token operator">=</span> <span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">,</span> <span class="token string">"Whippet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> spot <span class="token operator">=</span> <span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Spot"</span><span class="token punctuation">,</span> <span class="token string">"Beagle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>comet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spot<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br><span class="token punctuation">}</span></code></pre><h3 id="maps">Maps</h3><p>Maps are collections of key/value pairs. Keys can be any type, but they must all be the same type. The same is true for values.</p><p>The <code>std::collections</code> namespace defines the <code>HashMap</code> generic type.</p><p>Here is a summary of commonly used <code>HashMap</code> methods:</p><table><thead><tr><th>Operation</th><th>Syntax</th></tr></thead><tbody><tr><td>create empty</td><td><code>let map = HashMap::new()</code></td></tr><tr><td>remove all items</td><td><code>map.clear()</code></td></tr><tr><td>determine if a key is present</td><td><code>set.contains_key(key)</code></td></tr><tr><td>get value associated with a key</td><td><code>map.get(key)</code> (1)</td></tr><tr><td>get mutable value associated with a key</td><td><code>map.get_mut(key)</code> (1)</td></tr><tr><td>insert key/value pair</td><td><code>map.insert(key, value)</code> (2)</td></tr><tr><td>determine if empty</td><td><code>map.is_empty()</code></td></tr><tr><td>get iterator over key/value pairs as tuples</td><td><code>map.iter()</code></td></tr><tr><td>get mutable iterator over key/value pairs as tuples</td><td><code>map.iter_mut()</code></td></tr><tr><td>get iterator over keys</td><td><code>map.keys()</code></td></tr><tr><td>get number of key/value pairs (length)</td><td><code>map.len()</code></td></tr><tr><td>remove a key/value pair</td><td><code>map.remove(key)</code> (2)</td></tr><tr><td>remove key/value pairs that do not match a predicate</td><td><code>map.retain(pred_fn)</code> (3)</td></tr><tr><td>get iterator over values</td><td><code>map.values()</code></td></tr><tr><td>get iterator over mutable values</td><td><code>map.values_mut()</code></td></tr></tbody></table><ol><li>returns an <code>Option</code></li><li>returns <code>Some(old_value)</code> if key was already present and <code>None</code> otherwise</li><li>modifies in place</li></ol><p>Here is an example of creating and using a <code>HashMap</code> containing <code>String</code> keys and <code>i32</code> values. Using the <code>String</code> type for keys rather than <code>&amp;str</code> allows the <code>HashMap</code> to own the values so they have the same lifetime as the <code>HashMap</code> which is generally desirable.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">get_shortest_v1</span><span class="token punctuation">(</span>months<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">i8</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> shortest<span class="token punctuation">:</span> <span class="token keyword">i8</span> <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token keyword">i8</span><span class="token punctuation">::</span><span class="token constant">MAX</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> name<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">None</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>val<span class="token punctuation">)</span> <span class="token keyword">in</span> months <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> val <span class="token operator">&lt;</span> shortest <span class="token punctuation">{</span><br>            name <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><br>            shortest <span class="token operator">=</span> val<span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    name<br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">get_shortest_v2</span><span class="token punctuation">(</span>months<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">i8</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token operator">></span> <span class="token punctuation">{</span><br>      <span class="token comment">// The HashMap iter method returns</span><br>      <span class="token comment">// an iterator over (key, value) tuples.</span><br>      months<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token comment">// The Iter min_by_key method is passed a closure and returns</span><br>        <span class="token comment">// an Option that wraps the smallest value returned by the closure.</span><br>        <span class="token comment">// The closure is passed each tuple, one at a time,</span><br>        <span class="token comment">// and returns the value to be compared.</span><br>        <span class="token comment">// In this case it is the second element in the tuple (at index 1).</span><br>        <span class="token punctuation">.</span><span class="token function">min_by_key</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>p<span class="token closure-punctuation punctuation">|</span></span> p<span class="token number">.1</span><span class="token punctuation">)</span><br>        <span class="token comment">// The Option map is called on an Option of one type</span><br>        <span class="token comment">// and returns an Option of another.</span><br>        <span class="token comment">// In this case it is called on an Option wrapping a (key, value) tuple</span><br>        <span class="token comment">// and returns an Option wrapping just the key (at index 0).</span><br>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>p<span class="token closure-punctuation punctuation">|</span></span> p<span class="token number">.0</span><span class="token punctuation">.</span><span class="token function">as_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> days_in_month<span class="token punctuation">:</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">i8</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    days_in_month<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"January"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    days_in_month<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"February"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    days_in_month<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"March"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    days_in_month<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"April"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"daysInMonth = {:#?}"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>days_in_month<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>month<span class="token punctuation">,</span> days<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token operator">&amp;</span>days_in_month <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"There are {} days in {}."</span><span class="token punctuation">,</span> days<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"entries = {:?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"days in March = {:?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"March"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// get_shortest_v1 and get_shortest_v2 return the same value.</span><br>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>shortest<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">get_shortest_v1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>days_in_month<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"shortest = {}"</span><span class="token punctuation">,</span> shortest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// February</span><br>    <span class="token punctuation">}</span><br><br>    days_in_month<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"February"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"entries = {:?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"days in February = {:?}"</span><span class="token punctuation">,</span> days_in_month<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"February"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> month <span class="token operator">=</span> <span class="token string">"April"</span><span class="token punctuation">;</span><br>    <span class="token keyword">match</span> days_in_month<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Some</span><span class="token punctuation">(</span>days<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"There are {} days in {}."</span><span class="token punctuation">,</span> days<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"No data found for {}."</span><span class="token punctuation">,</span> month<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of creating and using a <code>HashMap</code> with <code>String</code> keys and <code>struct</code> values:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[derive(Debug, Eq, Hash, PartialEq)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Dog</span> <span class="token punctuation">{</span><br>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br>    breed<span class="token punctuation">:</span> <span class="token class-name">String</span><br><span class="token punctuation">}</span><br><span class="token keyword">impl</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> breed<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>            name<span class="token punctuation">:</span> name<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>            breed<span class="token punctuation">:</span> breed<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Key and value types are inferred from what is inserted.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> dogs <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This function must be a closure so it can access dogs.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> add_dog <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> breed<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span><br>        dogs<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> breed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token function">add_dog</span><span class="token punctuation">(</span><span class="token string">"Maisey"</span><span class="token punctuation">,</span> <span class="token string">"Treeing Walker Coonhound"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">add_dog</span><span class="token punctuation">(</span><span class="token string">"Ramsay"</span><span class="token punctuation">,</span> <span class="token string">"Native American Indian Dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">add_dog</span><span class="token punctuation">(</span><span class="token string">"Oscar"</span><span class="token punctuation">,</span> <span class="token string">"German Shorthaired Pointer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">add_dog</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">,</span> <span class="token string">"Whippet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"dogs = {:#?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"entries = {:?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Comet = {:#?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    dogs<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"Comet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"entries = {:?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><br><br>    <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">"Oscar"</span><span class="token punctuation">;</span><br>    <span class="token keyword">match</span> dogs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Some</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"found {:#?}."</span><span class="token punctuation">,</span> dog<span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"No dog named {} found."</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> dog<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token operator">&amp;</span>dogs <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} is a {}."</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> dog<span class="token punctuation">.</span>breed<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="slices">Slices</h2><p>A slice is a reference to a contiguous subset of a collection that is represented by pointer and a length. They are often created using a range. This is what a <code>&amp;str</code> value represents. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"abcdefgh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Note the &amp; which says we are getting a</span><br><span class="token comment">// "reference" to a portion of the string.</span><br><span class="token keyword">let</span> sub <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "def"</span></code></pre><p>Many kinds of collections, including arrays and vectors, support obtaining slices of their items.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"></code></pre><p>Mutable slices allow their items to be mutated. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Create a vector of &amp;str values.</span><br>    <span class="token keyword">let</span> original <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"purple"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Create a vector of String values from original.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> colors <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>c<span class="token closure-punctuation punctuation">|</span></span> c<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Change a subset of the colors to uppercase.</span><br>    <span class="token keyword">let</span> subset <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> colors<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..=</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> color <span class="token keyword">in</span> subset <span class="token punctuation">{</span><br>        color<span class="token punctuation">.</span><span class="token function">make_ascii_uppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "ORANGE", "YELLOW", "GREEN", "blue", "purple"]</span><br><span class="token punctuation">}</span></code></pre><p>For details on the syntax for specifying ranges, see <a href="#ranges">Ranges</a>.</p><h2 id="conditional-logic">Conditional Logic</h2><p>The most common way to implement conditional logic is with an <code>if</code> expressions. The condition is not surrounded by parentheses and code to be executed must be surrounded curly brackets, even if there is only one statement or expression. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"hot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> temperature <span class="token operator">&lt;</span> <span class="token number">40</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"cold"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"tolerable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>An <code>if</code> expression can be assigned to a variable and newlines are not required. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span> <span class="token string">"red"</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"blue"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Other ways to implement conditional logic include <code>if let</code> and <code>match</code> expressions which use pattern matching to extract a value. These were shown in the <a href="#error-handling">Error Handling</a> section.</p><p>A <code>match</code> expression can match the following kinds of values: boolean, integer, &amp;str, String, and enum. These must be exhaustive, meaning that they account for every possible value of the expression being matched. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> month <span class="token operator">=</span> <span class="token string">"February"</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> holiday <span class="token operator">=</span> <span class="token keyword">match</span> month <span class="token punctuation">{</span><br>    <span class="token string">"January"</span> <span class="token operator">=></span> <span class="token string">"New Year's Day"</span><span class="token punctuation">,</span><br>    <span class="token string">"February"</span> <span class="token operator">=></span> <span class="token string">"Valentine's Day"</span><span class="token punctuation">,</span><br>    <span class="token string">"July"</span> <span class="token operator">=></span> <span class="token string">"Independence Day"</span><span class="token punctuation">,</span><br>    <span class="token string">"October"</span> <span class="token operator">=></span> <span class="token string">"Halloween"</span><span class="token punctuation">,</span><br>    <span class="token string">"November"</span> <span class="token operator">=></span> <span class="token string">"Thanksgiving"</span><span class="token punctuation">,</span><br>    <span class="token string">"December"</span> <span class="token operator">=></span> <span class="token string">"Christmas"</span><span class="token punctuation">,</span><br>    _ <span class="token operator">=></span> <span class="token string">"unknown"</span> <span class="token comment">// underscore matches any other value</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The holiday in {} is {}."</span><span class="token punctuation">,</span> month<span class="token punctuation">,</span> holiday<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The lines containing <code>=&gt;</code> are referred to as &quot;match arms&quot;. They can match a single pattern or multiple patterns separated by <code>|</code> characters. Patterns can be literal values of the types <code>bool</code>, <code>char</code>, <code>&amp;str</code>, non-negative integer, wildcard (<code>_</code>), tuple of these types, array of these types, inclusive range (<code>m..=n</code>, not <code>m..n</code>), enum variant, or struct. There are a few more less commonly used patterns that are supported. For details, see <a href="https://doc.rust-lang.org/reference/patterns.html" rel="noopener" target="_blank">Patterns</a>.</p><p>The part on the right side of <code>=&gt;</code> can be an expression or a block.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">get_points</span><span class="token punctuation">(</span>rank<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">i8</span> <span class="token punctuation">{</span><br>    <span class="token keyword">match</span> rank <span class="token punctuation">{</span><br>        <span class="token string">"Jack"</span> <span class="token operator">|</span> <span class="token string">"Queen"</span> <span class="token operator">|</span> <span class="token string">"King"</span> <span class="token operator">=></span> <span class="token number">10</span><span class="token punctuation">,</span><br>        <span class="token string">"Ace"</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> <span class="token keyword">match</span> rank<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">i8</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>              <span class="token class-name">Ok</span><span class="token punctuation">(</span>points<span class="token punctuation">)</span> <span class="token operator">=></span> points<span class="token punctuation">,</span><br>              <span class="token class-name">Err</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token number">0</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> cards <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"7"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span> <span class="token string">"Ace"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"bad"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> rank <span class="token keyword">in</span> <span class="token operator">&amp;</span>cards <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Points for {} is {}."</span><span class="token punctuation">,</span> rank<span class="token punctuation">,</span> <span class="token function">get_points</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> category <span class="token operator">=</span> <span class="token keyword">match</span> age <span class="token punctuation">{</span><br>        <span class="token comment">// The ranges cannot overlap and</span><br>        <span class="token comment">// must use "..=" rather than "..".</span><br>        <span class="token number">0</span><span class="token punctuation">..=</span><span class="token number">2</span> <span class="token operator">=></span> <span class="token string">"toddler"</span><span class="token punctuation">,</span><br>        <span class="token number">3</span><span class="token punctuation">..=</span><span class="token number">12</span> <span class="token operator">=></span> <span class="token string">"child"</span><span class="token punctuation">,</span><br>        <span class="token number">13</span><span class="token punctuation">..=</span><span class="token number">19</span> <span class="token operator">=></span> <span class="token string">"teen"</span><span class="token punctuation">,</span><br>        <span class="token number">20</span><span class="token punctuation">..=</span><span class="token number">59</span> <span class="token operator">=></span> <span class="token string">"adult"</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> <span class="token string">"senior"</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} is a {}."</span><span class="token punctuation">,</span> age<span class="token punctuation">,</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>A &quot;match guard&quot; adds an <code>if</code> expression to a match pattern. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">i32</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Suppose the numbers are supposed to be between 1 and 10 inclusive</span><br>    <span class="token comment">// and we want to know whether each is even, odd,</span><br>    <span class="token comment">// or invalid because it is outside that range.</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> numbers <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> describe <span class="token operator">=</span> <span class="token keyword">match</span> n <span class="token punctuation">{</span><br>            <span class="token number">1</span><span class="token punctuation">..=</span><span class="token number">10</span> <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=></span> <span class="token string">"even"</span><span class="token punctuation">,</span><br>            <span class="token number">1</span><span class="token punctuation">..=</span><span class="token number">10</span> <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">=></span> <span class="token string">"odd"</span><span class="token punctuation">,</span><br>            _ <span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">=></span> <span class="token string">"too high"</span><span class="token punctuation">,</span><br>            _ <span class="token operator">=></span> <span class="token string">"negative"</span> <span class="token comment">// only other possibility</span><br>        <span class="token punctuation">}</span><span class="token punctuation">;</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"n is {}"</span><span class="token punctuation">,</span> describe<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// odd, even, negative, too high</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Structs can be matched, but</span><br>    <span class="token comment">// floating point values cannot be used in match patterns.</span><br>    <span class="token comment">// This is why the Point2D struct here uses integer values.</span><br>    <span class="token keyword">let</span> describe <span class="token operator">=</span> <span class="token keyword">match</span> pt <span class="token punctuation">{</span><br>        <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=></span> <span class="token string">"origin"</span><span class="token punctuation">,</span><br>        <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> _<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=></span> <span class="token string">"x-axis"</span><span class="token punctuation">,</span><br>        <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> _ <span class="token punctuation">}</span> <span class="token operator">=></span> <span class="token string">"y-axis"</span><span class="token punctuation">,</span><br>        <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">=></span> <span class="token string">"1st quadrant"</span><span class="token punctuation">,</span><br>        <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">=></span> <span class="token string">"2nd quadrant"</span><span class="token punctuation">,</span><br>        <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">=></span> <span class="token string">"3rd quadrant"</span><span class="token punctuation">,</span><br>        <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">=></span> <span class="token string">"4th quadrant"</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> <span class="token string">"impossible"</span> <span class="token comment">// doesn't know about conditions are exhaustive</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> describe<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4th quadrant</span><br><span class="token punctuation">}</span></code></pre><p>Rust does not support the ternary operator (<code>? :</code>) found in many other programming languages. Since <code>if</code> expressions have a value, the following can be written to simulate a ternary:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">const</span> color <span class="token operator">=</span> <span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span> <span class="token string">"red"</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"blue"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>It is possible to write a macro to mimic this, but it doesn't reduce the expression much. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token macro property">macro_rules!</span> tern <span class="token punctuation">{</span><br>    <span class="token punctuation">(</span><span class="token variable">$cond</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">expr</span> <span class="token operator">=></span> <span class="token variable">$true_expr</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">expr</span><span class="token punctuation">,</span> <span class="token variable">$false_expr</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">expr</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token variable">$cond</span> <span class="token punctuation">{</span><br>            <span class="token variable">$true_expr</span><br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>            <span class="token variable">$false_expr</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> temperature <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token macro property">tern!</span><span class="token punctuation">(</span>temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token operator">=></span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blue</span><br><span class="token punctuation">}</span></code></pre><h2 id="iteration-(looping)">Iteration (Looping)</h2><p>Rust supports the following looping expressions:</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>loop</code></td><td>infinite loop that can be exited with a <code>break</code></td></tr><tr><td><code>while</code></td><td>top-tested loop that repeats as long as an expression evaluates to <code>true</code></td></tr><tr><td><code>while let</code></td><td>like <code>while</code>, but repeats as long as a pattern match succeeds</td></tr><tr><td><code>for</code></td><td>for looping over an iterator</td></tr></tbody></table><p>See the <a href="#standard-io">Standard IO</a> section for an example using <code>loop</code>. While not commonly used, the <code>break</code> keyword can be followed by an expression whose value becomes the value of the <code>loop</code> expression.</p><p>Here's an example of using a <code>while</code> loop:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Item</span> <span class="token punctuation">{</span><br>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br>    price<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token comment">// in cents</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> items<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Item</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><br>        <span class="token class-name">Item</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"milk"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">289</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>        <span class="token class-name">Item</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"bread"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">349</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>        <span class="token class-name">Item</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"orange juice"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">479</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>        <span class="token class-name">Item</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"cheese"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">399</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>        <span class="token class-name">Item</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"cereal"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">379</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    <span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> len <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> wallet <span class="token operator">=</span> <span class="token number">1200</span><span class="token punctuation">;</span> <span class="token comment">// $12</span><br><br>    <span class="token comment">// Buy items until there isn't enough left in the wallet.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>    <span class="token keyword">while</span> index <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> wallet <span class="token operator">>=</span> items<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>price <span class="token punctuation">{</span><br>      wallet <span class="token operator">-=</span> items<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>price<span class="token punctuation">;</span><br>      <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"bought {}"</span><span class="token punctuation">,</span> items<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// milk, bread, and orange juice</span><br>      index <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Here is a somewhat nicer approach using a for loop:</span><br>    <span class="token comment">/*<br>    for item in items {<br>        if wallet &lt; item.price { break; }<br>        wallet -= item.price;<br>        println!("bought {}", item.name); // milk, bread, and orange juice<br>    }<br>    */</span><br><span class="token punctuation">}</span></code></pre><p>A <code>while let</code> loop is useful when iterating over repeated calls to a function that might fail. The example below uses the <code>futures</code> crate which requires adding the dependency <code>futures = &quot;0.3.8&quot;</code> to <code>Cargo.toml</code>. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">futures<span class="token punctuation">::</span>executor<span class="token punctuation">::</span></span>block_on<span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">rand<span class="token punctuation">::</span></span><span class="token class-name">Rng</span><span class="token punctuation">;</span><br><br><span class="token comment">// Pretend this function makes a REST call that could possibly fail.</span><br><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token keyword">i8</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token keyword">str</span><span class="token operator">></span> <span class="token punctuation">{</span><br>  <span class="token comment">// rng stands for "random number generator".</span><br>  <span class="token keyword">let</span> <span class="token keyword">mut</span> rng <span class="token operator">=</span> <span class="token namespace">rand<span class="token punctuation">::</span></span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> n <span class="token operator">=</span> rng<span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number from 1 to 10</span><br>  <span class="token comment">// Fail if n is greater than 7.</span><br>  <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">7</span> <span class="token punctuation">{</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token string">"failed"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Here is an approach for processing the result of a single call.</span><br>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">block_on</span><span class="token punctuation">(</span><span class="token function">get_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">match</span> result <span class="token punctuation">{</span><br>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in single call, n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">Err</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"error: {}"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Here is an approach for processing calls in a loop</span><br>    <span class="token comment">// that continues until an Err is returned.</span><br>    <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">block_on</span><span class="token punctuation">(</span><span class="token function">get_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in while let, n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>A <code>for</code> loop is used to iterate over any kind of iterator. It can operate on an explicitly obtained iterator or it can obtain an iterator from any type that implements the <code>IntoIterator</code> trait. Collection types such as <code>Range</code>, <code>HashMap</code>, <code>HashSet</code>, and <code>Vec</code> implement this, but arrays and tuples do not. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// We can use range notation to iterate over a range of numbers</span><br>    <span class="token comment">// where the first number inclusive and the last is exclusive.</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">4</span> <span class="token punctuation">{</span> <span class="token comment">// 1, 2, and 3</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 1: n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token comment">// Adding = before the second number makes the range inclusive.</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..=</span><span class="token number">4</span> <span class="token punctuation">{</span> <span class="token comment">// 1, 2, 3, and 4</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 2: n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Iterating over the items in a tuple is not supported, but we</span><br>    <span class="token comment">// can iterate over the items in an array using the "iter" method.</span><br>    <span class="token keyword">let</span> num_arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> num_arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 3: n = {:?}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// The iter_mut method allows items to be mutated during iteration.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> num_arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token comment">// Double all the numbers during iteration.</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> num_arr<span class="token punctuation">.</span><span class="token function">iter_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token operator">*</span>n <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> num_arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 4: {:?}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// values are doubled</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Another approach is to create a new array of modified values</span><br>    <span class="token comment">// using the array map method that is considered experimental</span><br>    <span class="token comment">// and only available in nightly builds as of 12/13/20.</span><br>    <span class="token comment">//let new_numbers = numbers.map(|n| n * 2);</span><br><br>    <span class="token comment">// We can call the map method on an iterator</span><br>    <span class="token comment">// to create a new iterator over doubled numbers.</span><br>    <span class="token keyword">let</span> new_iter <span class="token operator">=</span> num_arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>n<span class="token closure-punctuation punctuation">|</span></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> new_iter <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 5: {:?}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// values are doubled</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// We can iterate over the items in a vector</span><br>    <span class="token comment">// without calling the "iter" method.</span><br>    <span class="token keyword">let</span> num_vec <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> num_vec <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"loop 6: n = {:?}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Let's look at one more iteration example that requires specifying lifetimes. The function <code>longest</code> is passed a reference to an array of strings. There are three lifetimes to consider, that of the array, that of the items inside it, and that of the return value. Rust wants to know that the array items will live as long as the return value since one of them will be returned. We must specify that with lifetime annotations (<code>'a</code> below).</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">longest</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">{</span><br>    strings<br>        <span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>acc<span class="token punctuation">,</span> s<span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">if</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> acc<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> s <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> acc <span class="token punctuation">}</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token string">"cherry"</span><span class="token punctuation">,</span> <span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">longest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"longest is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// banana</span><br><span class="token punctuation">}</span></code></pre><h2 id="iterators"><a name="iterators">Iterators</a></h2><p>TODO: Continue review from here.</p><p>Many Rust methods return a <code>std::iter::Iterator</code> that can be used to iterate over the elements of a collection. Iterators are lazy, meaning that they do not pre-compute the values they will return. This type supports methods in the following non-exhaustive list:</p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>all(pred_fn)</code></td><td>returns <code>bool</code> indicating if <code>pred_fn</code> returns true for all items</td></tr><tr><td><code>any(pred_fn)</code></td><td>returns <code>bool</code> indicating if <code>pred_fn</code> returns true for any items</td></tr><tr><td><code>chain(iter2)</code></td><td>returns <code>Iterator</code> that iterates over combined items</td></tr><tr><td><code>collect()</code></td><td>returns a <code>std::vec::Vec</code> containing all the items</td></tr><tr><td><code>count()</code></td><td>returns number of items in <code>Iterator</code>, consuming it</td></tr><tr><td><code>enumerate()</code></td><td>returns <code>Iterator</code> over tuples of indexes and items</td></tr><tr><td><code>filter(pred_fn)</code></td><td>returns <code>Iterator</code> over items for which <code>pred_fn</code> returns true</td></tr><tr><td><code>fold(fn)</code></td><td>returns result of combining items into a single value</td></tr><tr><td><code>last()</code></td><td>returns last item in <code>Iterator</code>, consuming it</td></tr><tr><td><code>map(fn)</code></td><td>returns <code>Iterator</code> over results of calling a function on each item</td></tr><tr><td><code>max()</code></td><td>returns <code>Option</code> that wraps the largest item</td></tr><tr><td><code>max_by(fn)</code></td><td>returns <code>Option</code> that wraps the largest result based on passing pairs of items to a function</td></tr><tr><td><code>max_by_key(fn)</code></td><td>returns <code>Option</code> that wraps the largest result of passing each item to a function</td></tr><tr><td><code>min()</code></td><td>returns <code>Option</code> that wraps the smallest item</td></tr><tr><td><code>min_by(fn)</code></td><td>returns <code>Option</code> that wraps the smallest result based on passing pairs of items to a function</td></tr><tr><td><code>min_by_key(fn)</code></td><td>returns <code>Option</code> that wraps the smallest result of passing each item to a function</td></tr><tr><td><code>next()</code></td><td>returns <code>Option</code> that wraps the next item</td></tr><tr><td><code>nth(n)</code></td><td>returns the nth item</td></tr><tr><td><code>partition(pred_fn)</code></td><td>returns two collections containing items for which a function returns true or false</td></tr><tr><td><code>position(pred_fn)</code></td><td>returns the first item for which a function returns true</td></tr><tr><td><code>product()</code></td><td>returns the product of number values</td></tr><tr><td><code>rev()</code></td><td>returns an iterate that iterates in the reverse order</td></tr><tr><td><code>skip(n)</code></td><td>returns an <code>Iterator</code> that begins after n items</td></tr><tr><td><code>skip_while(pred_fn)</code></td><td>returns an <code>Iterator</code> that begins at the first item for which a function returns false</td></tr><tr><td><code>sum()</code></td><td>returns the sum of number values</td></tr><tr><td><code>take(n)</code></td><td>returns an <code>Iterator</code> that stops after the first n items</td></tr><tr><td><code>take_while(pred_fn)</code></td><td>returns an <code>Iterator</code> that stops at the last item for which a function returns true</td></tr><tr><td><code>zip()</code></td><td>returns an <code>Iterator</code> over <code>Option</code> objects that wrap corresponding items from two <code>Iterators</code></td></tr></tbody></table><p>Here is an example of using the <code>next</code> method:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> iter <span class="token operator">=</span> colors<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">match</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Some</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// red</span><br>        <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"no more colors"</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yellow</span><br>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blue</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>We can also obtain a mutable iterator so the underlying collection can be modify while iterating over it. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">for</span> color <span class="token keyword">in</span> colors<span class="token punctuation">.</span><span class="token function">iter_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        color<span class="token punctuation">.</span><span class="token function">make_ascii_uppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["RED", "YELLOW", "BLUE"]</span><br><br>    <span class="token comment">// If we wanted to create a new vector rather than modify one in place ...</span><br>    <span class="token comment">//let new_colors: Vec&lt;String> =</span><br>    <span class="token comment">//    colors.iter().map(|s| s.to_uppercase()).collect();</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of using the <code>fold</code> method which is like <code>reduce</code> in some other programming languages:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> sum <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>acc<span class="token punctuation">,</span> n<span class="token closure-punctuation punctuation">|</span></span> acc <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// For this use of fold we can use the sum method instead.</span><br><span class="token keyword">let</span> sum <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here is an example of using the <code>filter</code> method.</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// This is a predicate function that is by the filter method.</span><br><span class="token comment">// It must take a reference to a item in an Iterator.</span><br><span class="token comment">// In this case the item type is &amp;str,</span><br><span class="token comment">// so the parameter must have the type &amp;&amp;str.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">is_short</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><br>    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">5</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> months <span class="token operator">=</span> <span class="token string">"January|February|March|April|May|June|July|August"</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This passes a closure to the filter method.</span><br>    <span class="token keyword">let</span> short_names<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token operator">></span> <span class="token operator">=</span> months<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token char string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>m<span class="token closure-punctuation punctuation">|</span></span> m<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"shorts = {:?}"</span><span class="token punctuation">,</span> short_names<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// This passes a function to the filter method.</span><br>    <span class="token keyword">let</span> short_names<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token operator">></span> <span class="token operator">=</span> months<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token char string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>is_short<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"shorts = {:?}"</span><span class="token punctuation">,</span> short_names<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of using the <code>map</code> method:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> iter <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>n<span class="token closure-punctuation punctuation">|</span></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// doubles each number</span><br><span class="token keyword">for</span> n <span class="token keyword">in</span> iter <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// We cannot create an array from an iterator,</span><br><span class="token comment">// but we can create a Vector.</span><br><span class="token keyword">let</span> v1 <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> iter <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>n<span class="token closure-punctuation punctuation">|</span></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> v2<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here is an example of using the <code>zip</code> method:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> <span class="token keyword">mut</span> iter <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">zip</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">None</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here is an example of using the <code>take</code> method to get a certain number of initial values from an iterator:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Student</span> <span class="token punctuation">{</span><br>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br>    scores<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">f32</span><span class="token operator">></span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> scores<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">f32</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>            name<span class="token punctuation">:</span> name<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>            scores<span class="token punctuation">:</span> scores<span class="token punctuation">.</span><span class="token function">to_vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">average</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">f32</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f32</span> <span class="token punctuation">{</span><br>    numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">f32</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">f32</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// This is mutable because the sort_by method sorts it in place.</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> students<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Student</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><br>        <span class="token class-name">Student</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">90.0</span><span class="token punctuation">,</span> <span class="token number">75.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">Student</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Betty"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">85.0</span><span class="token punctuation">,</span> <span class="token number">95.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">Student</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Claire"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">70.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">,</span> <span class="token number">75.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">Student</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Dina"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">95.0</span><span class="token punctuation">,</span> <span class="token number">100.0</span><span class="token punctuation">,</span> <span class="token number">90.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token class-name">Student</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Elaine"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">75.0</span><span class="token punctuation">,</span> <span class="token number">90.0</span><span class="token punctuation">,</span> <span class="token number">100.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Sort the students in descending order by their average scores.</span><br>    students<span class="token punctuation">.</span><span class="token function">sort_by</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>a<span class="token punctuation">,</span> b<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> a_avg <span class="token operator">=</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">.</span>scores<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">let</span> b_avg <span class="token operator">=</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">.</span>scores<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        b_avg<span class="token punctuation">.</span><span class="token function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a_avg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Print the names of the top 3 students.</span><br>    <span class="token keyword">for</span> student <span class="token keyword">in</span> students<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> student<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="regular-expressions">Regular Expressions</h2><p>Regular expressions for string pattern matching are not directly supported. Instead an external crate such as <a href="https://crates.io/crates/regex" rel="noopener" target="_blank">regex</a> must be used. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">regex<span class="token punctuation">::</span></span><span class="token class-name">Regex</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Determine if a string matches a regular expression.</span><br>    <span class="token comment">// Match 'h' or 's' followed by 1 to 3 digits.</span><br>    <span class="token keyword">let</span> re <span class="token operator">=</span> <span class="token class-name">Regex</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">r"[hs]\d{1,3}"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"The host is h19 and the switch is s257."</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> re<span class="token punctuation">.</span><span class="token function">is_match</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"matched"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"mismatch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Get text matching capture groups.</span><br>    <span class="token comment">//let re = Regex::new(r"([hs]\d{1,3})").unwrap();</span><br>    <span class="token keyword">for</span> cap <span class="token keyword">in</span> re<span class="token punctuation">.</span><span class="token function">captures_iter</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token operator">&amp;</span>cap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// h19 and s257</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Split a string on a regular expression</span><br>    <span class="token comment">// and collect the pieces into a vector.</span><br>    <span class="token keyword">let</span> pieces<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token operator">></span> <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"pieces = {:?}"</span><span class="token punctuation">,</span> pieces<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Split a string on a regular expression</span><br>    <span class="token comment">// and iterate over the pieces.</span><br>    <span class="token keyword">let</span> piece_iter <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> piece <span class="token keyword">in</span> piece_iter <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"piece = {}"</span><span class="token punctuation">,</span> piece<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="functions">Functions</h2><p>Functions are defined using the <code>fn</code> keyword, followed by a name, parameter list, return type, and body. Functions that do not return anything omit the return type rather than specify a type like <code>void</code> as is done in some other languages. Functions that might fail should return a <code>Result</code> enum to allow callers to handle errors. See the &quot;Error Handling&quot; section for details.</p><p>A <code>return</code> statement returns the value of an expression. If the last statement is not terminated by a semicolon, its value is returned. This means that <code>return my_result;</code> is equivalent to <code>my_result</code>.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">average</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> sum<span class="token punctuation">:</span> <span class="token keyword">f64</span> <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">f64</span> <span class="token comment">// return value</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">greet</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, {}!"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> numbers<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"average = {}"</span><span class="token punctuation">,</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The documentation for the <code>Copy</code> trait says that values of types that implement it &quot;can be duplicated by simply copying bits&quot;. When such a value is passed to a function, rather than passing a reference, a copy is created and ownership of the original value is not transferred. All primitive types such as <code>bool</code>, <code>char</code>, <code>i32</code>, and <code>f64</code> implement <code>Copy</code>. However, structs and collection types like tuple, array, <code>Vec</code>, <code>HashMap</code>, and <code>HashMap</code> do not. You can choose to implement the <code>Copy</code> trait for custom structs if all their fields also implement it.</p><p>Function parameters of non-Copy types typically use reference types. This is because usually the function wants to borrow their values rather than take ownership. If the caller uses a variable to pass a non-Copy value, and the function takes ownership, the caller loses ownership and can no longer use the variable unless the function returns it.</p><p>Function return values typically have non-reference types. This is because usually the function creates the value and wants to transfer ownership to the caller. If a function creates a value and returns a reference to it, the code will not compile because the value goes out of scope and is dropped.</p><p>Function parameters that are strings that are not mutated by the function should almost always have the type <code>&amp;str</code>. This allows many string representations to be passed in including literal strings, <code>&amp;str</code> values, and <code>&amp;String</code> values. Functions that create and return strings have the return type <code>String</code> so ownership can be transferred to the caller.</p><p>Functions are accessible by default within the same source file, but they are private by default when defined in a different source file. For functions that should be visible outside the source file that defines them, add the <code>pub</code> keyword before the <code>fn</code> keyword.</p><p>Named functions in Rust are not closures. They do not capture variables from their surrounding environment. However, anonymous functions assigned to variables are closures. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> a <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> inner <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span> <span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span><br>        a <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span> <span class="token comment">// a is visible since we are in a closure</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Rust does not support writing functions that accept a variable number of arguments (variadic). They can instead be passed in an array. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// This takes an array of strings and returns one of them.</span><br><span class="token comment">// Lifetimes must be specified, but why?</span><br><span class="token keyword">fn</span> <span class="token function-definition function">longest</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">{</span><br>    strings<br>        <span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>acc<span class="token punctuation">,</span> s<span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">if</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> acc<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> s <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> acc <span class="token punctuation">}</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token string">"cherry"</span><span class="token punctuation">,</span> <span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">longest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"longest is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="operators">Operators</h2><p>Rust supports most of the common operators found in other programming languages.</p><p>The <code>std::ops</code> namespace defines overloadable operators. For example, we can define what it means to add and subtract to <code>Point2D</code> objects by implementing the <code>Add</code> and <code>Sub</code> traits defined in <code>std::ops</code>.</p><p>The operators that can be implemented for custom types include:</p><ul><li>arithmetic: <code>+</code>, <code>+=</code>, <code>-</code>, <code>-=</code>, <code>_</code>, <code>_=</code>, <code>/</code>, <code>/=</code></li><li>bit shift: <code>&lt;&lt;</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;=</code></li><li>bitwise: <code>&amp;</code>, <code>&amp;=</code>, <code>|</code>, <code>|=</code>, <code>^</code>, and <code>^=</code></li><li>deref: <code>\*</code> for getting and setting a value</li><li>functions: <code>()</code> call operator in three forms</li><li>index: <code>[]</code> operator to get and set an element</li><li>logical: <code>!</code> not, but <code>&amp;&amp;</code> and <code>||</code> cannot be defined</li><li>mod: <code>%</code> and <code>%=</code></li><li>negate: <code>-</code> (unary)</li><li>range: <code>..</code> and <code>..=</code></li></ul><h2 id="ranges"><a name="ranges">Ranges</a></h2><p>The <code>std::ops</code> namespace defines the range types</p><table><thead><tr><th>Range Type</th><th>Meaning</th><th>Syntax</th></tr></thead><tbody><tr><td><code>RangeFull</code></td><td>all items</td><td><code>..</code></td></tr><tr><td><code>Range</code></td><td>start inclusive to end exclusive</td><td><code>s..e</code></td></tr><tr><td><code>RangeInclusive</code></td><td>start inclusive to end inclusive</td><td><code>s..=e</code></td></tr><tr><td><code>RangeFrom</code></td><td>start inclusive and above</td><td><code>s..</code></td></tr><tr><td><code>RangeTo</code></td><td>zero to end exclusive</td><td><code>..e</code></td></tr><tr><td><code>RangeToInclusive</code></td><td>zero to end inclusive</td><td><code>..=e</code></td></tr></tbody></table><p>These are distinct types and there is not a provided range type that encompasses all of them.</p><p>Objects of these types are regular values that can be assigned to variables, be members of structs, be passed to functions, and be returned from functions.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Range</span><span class="token punctuation">,</span> <span class="token class-name">RangeInclusive</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">print_range</span><span class="token punctuation">(</span>r<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Range</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"range = {:?}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">print_range_inclusive</span><span class="token punctuation">(</span>r<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">RangeInclusive</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"range = {:?}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> r1 <span class="token operator">=</span> a<span class="token punctuation">..</span>b<span class="token punctuation">;</span><br>    <span class="token function">print_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// range = 3..7</span><br>    <span class="token comment">// The Range contains method requires a ref to a number,</span><br>    <span class="token comment">// so even literal values must be passed by reference.</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br><br>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> a<span class="token punctuation">..=</span>b<span class="token punctuation">;</span><br>    <span class="token function">print_range_inclusive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// range = 3..=7</span><br>    <span class="token keyword">for</span> n <span class="token keyword">in</span> r2 <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"n = {}"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="structs"><a name="structs">Structs</a></h2><p>A struct defines a type that is a set of related fields and methods, similar to a class in other languages.</p><p>The <code>struct</code> keyword only defines a set of fields. When there a no fields, it is referred to as a &quot;unit struct&quot;. These are used to implement groups of related functionality that have no state.</p><p>The <code>impl</code> keyword adds associated functions (like class or static methods in other languages) and methods (like instance methods in other languages) to a struct. The first parameter of methods must be named &quot;self&quot;. Any <code>fn</code> definition with no parameters or a first parameter with a name other than &quot;self&quot; is an &quot;associated function&quot; rather than a method. Associated functions are called with <code>StructName::function_name(arguments)</code>. Methods are called with <code>instance_variable.method_name(arguments)</code>.</p><p>In an <code>impl</code> block the type <code>Self</code> refers to the associated struct type. Using <code>Self</code> in place of the struct name enables renaming the struct without needing to change uses of the name inside the <code>impl</code> block.</p><p>Instances of a struct can be created using its name. It is also common to define an associated function named &quot;new&quot; (by convention) that creates an instance that is initialized in a specific way (like a constructor in other languages).</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token comment">// comma after last field is optional</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token comment">// The new function can have parameters.</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>      <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Instance method (use of self is similar to Python)</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Static method</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">distance_between</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>        <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>        <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> origin <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"origin = {:?}"</span><span class="token punctuation">,</span> origin<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d1 = {}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d2 = {}"</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>In general it's best for struct fields to not have reference types. This makes the lifetime of the field value match that of the struct which simplifies its usage by removing the need to specify lifetime annotations. For example, struct fields with a string value should almost always use the type <code>String</code> instead of <code>&amp;str</code> or <code>&amp;String</code>.</p><p>To allow structs to be printed for debugging purposes, add the following above their definition: <code>#[derive(Debug)]</code>. Then print using the <code>:?</code> (single line) or <code>:#?</code> (multi-line) format specifier. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p1 = {:?}"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p2 = {:#?}"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This outputs the following:</p><pre class="language-text"><code class="language-text">p1 = Point2D { x: 3.0, y: 4.0 }<br>p2 = Point2D {<br>    x: 3.0,<br>    y: 4.0,<br>}</code></pre><p>Structs are not cloneable, copyable, or printable by default. Being copyable allows instances to be passed by value (copy) instead of by reference. These features add compile time, so Rust requires implementing them on a case-by-case basis. The easiest way to implement these features is the proceed a struct definition with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Clone, Copy, Debug)]</span></code></pre><p>Structs and their fields are accessible by default within the same source file, but they are private by default when defined in a different source file. For structs that should be visible outside the source file that defines them, add the <code>pub</code> keyword to both the <code>struct</code> and the fields to be exposed.</p><p>A <code>struct</code> can include the fields of another <code>struct</code> of the same type using the <code>..</code> syntax. This can only appear at the end of the list of values. It only supplies values that were not specified. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point3D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    z<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> p4 <span class="token operator">=</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{</span> z<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">..</span>p3 <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// uses p3.x and p3.y, but not p3.z</span></code></pre><p>Note that it wouldn't make sense to allow including the fields of multiple structs because struct fields are never optional. Each struct being included would contain all the fields.</p><p>A &quot;tuple struct&quot; gives a name to a tuple. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">RGB</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> <span class="token constant">CORNFLOWER_BLUE</span><span class="token punctuation">:</span> <span class="token constant">RGB</span> <span class="token operator">=</span> <span class="token constant">RGB</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">149</span><span class="token punctuation">,</span> <span class="token number">237</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token constant">REBECCA_PURPLE</span><span class="token punctuation">:</span> <span class="token constant">RGB</span> <span class="token operator">=</span> <span class="token constant">RGB</span><span class="token punctuation">(</span><span class="token number">0x66</span><span class="token punctuation">,</span> <span class="token number">0x33</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token constant">CORNFLOWER_BLUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RGB(100, 149, 237)</span><br><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token constant">REBECCA_PURPLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RGB(102, 51, 153)</span></code></pre><p>Structs cannot inherit from (extend) other structs, but they can nest other structs (composition).</p><p>The <code>impl</code> keyword can be used multiple times on the same struct. Typically it's best to define all the methods of a struct in one place. The following example shows using <code>impl</code> in three places to define methods on the same struct.</p><p><code>geometry.rs</code></p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    <span class="token keyword">pub</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_from_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p><code>more.rs</code></p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token keyword">super</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>geometry<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">translate_x</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> dx<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> dx<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">scoot</span><span class="token punctuation">(</span>p<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    p<span class="token punctuation">.</span><span class="token function">translate_x</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p><code>main.rs</code></p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">geometry</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">geometry<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">mod</span> <span class="token module-declaration namespace">more</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">demo</span><span class="token punctuation">(</span>p<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>        <span class="token keyword">fn</span> <span class="token function-definition function">translate_y</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> dy<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> dy<span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><br>    p<span class="token punctuation">.</span><span class="token function">translate_y</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"distance = {}"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">distance_from_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// The translate_x method is defined in geometry.rs.</span><br>    p<span class="token punctuation">.</span><span class="token function">translate_x</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// The scoot function is defined in more.rs.</span><br>    <span class="token comment">// Just because p is mutable doesn't mean</span><br>    <span class="token comment">// that all references to it are mutable.</span><br>    <span class="token comment">// The scoot function requires a mutable reference</span><br>    <span class="token comment">// and we must specify that when passing a reference.</span><br>    <span class="token namespace">more<span class="token punctuation">::</span></span><span class="token function">scoot</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token function">demo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// The translate_y method is defined in the demo function above.</span><br>    p<span class="token punctuation">.</span><span class="token function">translate_y</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 4.0, y: 5.0 }</span><br><span class="token punctuation">}</span></code></pre><p>Structs can use generic types. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Wrapper</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    value<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token class-name">Wrapper</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Wrapper</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>TODO: Make the example above more compelling.</p><h2 id="dereference">Dereference</h2><p>The dereference operator is used to get the value of a reference. It isn't needed very often. This is because unlike in most programming languages that support references (or pointers), Rust does not require different syntax for accessing fields and methods based on whether an instance or a reference is used. It supplies &quot;automatic referencing and dereferencing&quot; in field access and method calls for types that implement the <code>Deref</code> trait. This includes the <code>String</code> and <code>Vec</code> types. In the case of method calls, it automatically adds <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> based on the method declaration of the <code>self</code> type.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><br>        <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token operator">&amp;&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token number">0.0</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p_ref <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p_ref<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1; same syntax with reference</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p_ref<span class="token punctuation">.</span><span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false; same syntax with reference</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example where dereference is needed:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// Implementing the PartialEq and PartialOrd traits</span><br><span class="token comment">// enables comparing instances.</span><br><span class="token attribute attr-name">#[derive(Debug, PartialEq, PartialOrd)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> <span class="token constant">ORIGIN</span><span class="token punctuation">:</span> <span class="token class-name">Point2D</span> <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">is_origin</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><br>    <span class="token comment">// We could just check whether x and y are zero,</span><br>    <span class="token comment">// but then we wouldn't need to dereference pt.</span><br>    <span class="token comment">//pt.x == 0.0 &amp;&amp; pt.y == 0.0</span><br><br>    <span class="token comment">// We can't compare a Point2D reference to a Point2D,</span><br>    <span class="token comment">// but we can dereference pt to get the Point2D instance</span><br>    <span class="token comment">// it references and then compare that to ORIGIN.</span><br>    <span class="token operator">*</span>pt <span class="token operator">==</span> <span class="token constant">ORIGIN</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p equal q? {}"</span><span class="token punctuation">,</span> p <span class="token operator">==</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p is origin? {:?}"</span><span class="token punctuation">,</span> <span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"q is origin? {:?}"</span><span class="token punctuation">,</span> <span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br><span class="token punctuation">}</span></code></pre><h2 id="type-aliases">Type Aliases</h2><p>Aliases for types can be defined using the <code>type</code> keyword. These can be used anywhere a type can be specified. For example, we can define an alias for a function signature:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// This is a type alias for a function signature.</span><br><span class="token keyword">type</span> <span class="token class-name">PointFn</span> <span class="token operator">=</span> <span class="token keyword">fn</span> <span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> input<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">rotate</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> angle<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> cos <span class="token operator">=</span> angle<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> sin <span class="token operator">=</span> angle<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> x <span class="token operator">=</span> pt<span class="token punctuation">.</span>x <span class="token operator">*</span> cos <span class="token operator">-</span> pt<span class="token punctuation">.</span>y <span class="token operator">*</span> sin<span class="token punctuation">;</span><br>    <span class="token keyword">let</span> y <span class="token operator">=</span> pt<span class="token punctuation">.</span>x <span class="token operator">*</span> sin <span class="token operator">+</span> pt<span class="token punctuation">.</span>y <span class="token operator">*</span> cos<span class="token punctuation">;</span><br>    <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">translate_x</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> dx<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> pt<span class="token punctuation">.</span>x <span class="token operator">+</span> dx<span class="token punctuation">,</span> <span class="token punctuation">..</span><span class="token operator">*</span>pt <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">translate_y</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> dy<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> y<span class="token punctuation">:</span> pt<span class="token punctuation">.</span>x <span class="token operator">+</span> dy<span class="token punctuation">,</span> <span class="token punctuation">..</span><span class="token operator">*</span>pt <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// The type of the second parameter is the type alias defined above.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">operate</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> function<span class="token punctuation">:</span> <span class="token class-name">PointFn</span><span class="token punctuation">,</span> input<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token function">function</span><span class="token punctuation">(</span>pt<span class="token punctuation">,</span> input<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> translate_x<span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> translate_y<span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> pi <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token namespace">consts<span class="token punctuation">::</span></span><span class="token constant">PI</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> rotate<span class="token punctuation">,</span> pi <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="traits"><a name="traits">Traits</a></h2><p>A trait describes an interface that any type can implement. This can include any number of functions and methods. The first parameter of methods must be named &quot;self&quot;. Any <code>fn</code> definition that does not is an &quot;associated function&quot; rather than a method.</p><p>The first parameter of a method can be written as <code>self</code> (takes ownership or copies), <code>&amp;self</code> (borrows immutably; most common), or <code>&amp;mut self</code> (borrows mutably). These are shorthand for <code>self: Self</code>, <code>self: &amp;Self</code>, <code>self: &amp;mut Self</code>. In first case, if the type implements the <code>Copy</code> trait then the value is copied. Otherwise ownership is transferred to the method.</p><p>Often traits are implemented for structs, but they can also be implemented for tuples and primitive types like <code>bool</code>.</p><p>A trait function can be described by providing only its signature, requiring implementing structs to define the body. It can also provide a default implementation that is used by implementing types that do not override it.</p><p>Traits can be generic, including type parameters.</p><p>Many functions provided by the standard library are implementations of traits. When looking at documentation for a type consider that some methods may only be described in the documentation for traits that are implemented for the type.</p><p>Here is an example of a custom trait named <code>Distance</code> that is implemented for the custom type <code>Point2D</code>. We saw in the <a href="#structs">Structs</a> section that we can add methods to a struct without defining a trait. Using a trait useful when it is desireable to implement the same set of functions and methods on many types. The trait can then be used as a parameter or return type, enabling any type that implements the trait can be used. This is how Rust achieves polymorphism.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">trait</span> <span class="token class-name">Distance</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token comment">// The type Self here refers to the implementing type.</span><br>    <span class="token comment">// In the example below, that is the Point2D struct.</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">T</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Distance</span><span class="token operator">&lt;</span><span class="token keyword">f64</span><span class="token operator">></span> <span class="token keyword">for</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> dx <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">-</span> other<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>        <span class="token keyword">let</span> dy <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">-</span> other<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>        <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"distance is {}"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Traits can specify other traits that must also be implemented by any types that implement them. These are referred to as &quot;supertraits&quot;. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">HockeyPlayer</span><span class="token punctuation">:</span> <span class="token class-name">Athlete</span> <span class="token operator">+</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Describe functions unique to hockey players here.</span><br><span class="token punctuation">}</span></code></pre><p>Now any <code>struct</code> that implements <code>HockeyPlayer</code> must also implement <code>Athlete</code> and <code>Person</code>.</p><p>It is possible for a type to implement multiple traits that describe the same constants and methods. Calling them requires do so in a form that makes it clear which is desired. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">trait</span> <span class="token class-name">First</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> <span class="token constant">SOME_CONST</span><span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in foo for trait First"</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">trait</span> <span class="token class-name">Second</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> <span class="token constant">SOME_CONST</span><span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"in some_method for trait Second"</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">First</span> <span class="token keyword">for</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// using default method implementation</span><br><span class="token keyword">impl</span> <span class="token class-name">Second</span> <span class="token keyword">for</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// using default method implementation</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">//println!("{}", bool::SOME_CONST); // error; multiple `VALUE` found</span><br>    <span class="token comment">//println!("{}", First::SOME_CONST); // error; type annotations needed</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> <span class="token keyword">as</span> <span class="token class-name">One</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token constant">SOME_CONST</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> <span class="token keyword">as</span> <span class="token class-name">Two</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token constant">SOME_CONST</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br><br>    <span class="token comment">//true.some_method(); // error; multiple applicable items in scope</span><br>    <span class="token comment">// Using a "fully-qualified function call addresses this.</span><br>    <span class="token comment">// Normal function calls are really syntactic sugar for this form.</span><br>    <span class="token comment">// The compiler converts them to this form.</span><br>    <span class="token class-name">One</span><span class="token punctuation">::</span><span class="token function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br>    <span class="token class-name">Two</span><span class="token punctuation">::</span><span class="token function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br><span class="token punctuation">}</span></code></pre><p><a name="trait-table"></a> The following table summarizes the built-in traits. Those that can be derived (automatically implemented) using the <code>#[derive(trait1, trait2, ...)]</code> syntax are indicted in the &quot;Notes&quot; column. &quot;Marker traits&quot; are used to indicate a property of a type without defining any methods and are also indicated in the &quot;Notes&quot; column. Other traits must be manually implemented.</p><table><thead><tr><th>Trait Name</th><th>Description</th><th>Notes</th></tr></thead><tbody><tr><td><code>AsRef</code></td><td>defines an <code>as_ref</code> method that converts one reference type to another</td><td></td></tr><tr><td><code>Borrow</code></td><td>allows a type to be borrowed as a different type (ex. <code>String</code> borrowed as <code>str</code>)</td><td></td></tr><tr><td><code>Clone</code></td><td>defines a <code>clone</code> method that explicitly copies an object</td><td>derivable</td></tr><tr><td><code>Copy</code></td><td>marks a type whose instances can be implicitly copied by assignment or passing by value</td><td>derivable, marker</td></tr><tr><td><code>Debug</code></td><td>outputs a value for debugging using <code>{:?}</code> and <code>{:#?}</code> in a format string</td><td>derivable</td></tr><tr><td><code>Default</code></td><td>defines a <code>default</code> static method for getting a default instance of a type</td><td>derivable</td></tr><tr><td><code>Deref</code></td><td>allows smart pointers to be used like immutable references to the data to which they point</td><td></td></tr><tr><td><code>DerefMut</code></td><td>allows smart pointers to be used like mutable references to the data to which they point</td><td></td></tr><tr><td><code>Display</code></td><td>defines a <code>fmt</code> method that formats a value for output<br>to be seen by a user rather than a developer</td><td></td></tr><tr><td><code>Drop</code></td><td>defines a <code>drop</code> method that is called when a value is dropped, typically to free resources</td><td></td></tr><tr><td><code>Eq</code></td><td>compares instances using <code>==</code> and <code>!=</code></td><td>derivable</td></tr><tr><td><code>Extend</code></td><td>defines an <code>extend</code> method that adds items to a collection</td><td></td></tr><tr><td><code>Fn</code></td><td>type of a closure that borrows values from its environment immutably</td><td></td></tr><tr><td><code>FnMut</code></td><td>type of a closure that borrows values from its environment mutably</td><td></td></tr><tr><td><code>FnOnce</code></td><td>type of a closure that takes ownership of values from its environment; can only be called once</td><td></td></tr><tr><td><code>From</code></td><td>defines a <code>from</code> static method that converts one value type to another; ex. <code>String::from</code></td><td></td></tr><tr><td><code>FromStr</code></td><td>defines a <code>from_str</code> static method that converts a <code>&amp;str</code> value to the implementing type</td><td></td></tr><tr><td><code>Hash</code></td><td>adds a <code>hash</code> method for computing the hash value of an instance (1)</td><td>derivable</td></tr><tr><td><code>Into</code></td><td>opposite of <code>From</code> and automatically implement when that is implemented</td><td></td></tr><tr><td><code>IntoIterator</code></td><td>automatically converts a value to an iterator over the data in the value</td><td></td></tr><tr><td><code>Iterator</code></td><td>defines the <code>next</code> method for iterating over the data in a value</td><td></td></tr><tr><td><code>Ord</code></td><td>compares instances using <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, and <code>&gt;</code> operators</td><td>derivable</td></tr><tr><td><code>PartialEq</code></td><td>like <code>Eq</code>, but for types where some instances are not equal to themselves (2)</td><td>derivable</td></tr><tr><td><code>PartialOrd</code></td><td>like <code>Ord</code>, but for types where some instances cannot be logically compared to others (3)</td><td>derivable</td></tr><tr><td><code>Read</code></td><td>defines the <code>read</code> method which reads the receiver value into an array of bytes (4)</td><td></td></tr><tr><td><code>Send</code></td><td>marks a type whose instance ownership can be transferred from one thread to another</td><td>marker</td></tr><tr><td><code>Sized</code></td><td>marks a type whose instance sizes are known a compile time</td><td>marker</td></tr><tr><td><code>Sync</code></td><td>marks a type whose instance references can be shared between threads</td><td>marker</td></tr><tr><td><code>ToString</code></td><td>adds a <code>to_string</code> method</td><td></td></tr><tr><td><code>Unpin</code></td><td>marks a type whose instances can be moved after being pinned to a memory location</td><td>marker</td></tr><tr><td><code>Write</code></td><td>defines the <code>write</code> method which writes data from an array of bytes into the receiver</td><td></td></tr></tbody></table><ol><li>The <code>hash</code> method is used by the <code>HashMap</code> and <code>HashSet</code> collections.</li><li>This means values are not necessarily reflexive. For example, the number value <code>NaN</code> is not equal to itself.</li><li>For example, the number value <code>NaN</code> is not less than, equal to, or greater than zero.</li><li>The term &quot;receiver&quot; refers to the value to the left of the dot.</li></ol><p>Here is an example of implementing some of the built-in traits for a custom struct:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>cmp<span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>default<span class="token punctuation">::</span></span><span class="token class-name">Default</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Add</span><span class="token punctuation">,</span> <span class="token class-name">AddAssign</span><span class="token punctuation">,</span> <span class="token class-name">Sub</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">// Deriving the "Default" trait adds a "default" function</span><br><span class="token comment">// that returns an instance of the struct where all the fields</span><br><span class="token comment">// are set to their default value, 0 in this case.</span><br><span class="token attribute attr-name">#[derive(Clone, Copy, Debug, Default)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Color</span> <span class="token punctuation">{</span><br>    r<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">,</span><br>    g<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">,</span><br>    b<span class="token punctuation">:</span> <span class="token keyword">u8</span><br><span class="token punctuation">}</span><br><br><span class="token comment">/*<br>// We could manually implement the "Default" trait as follows<br>// which is useful for fields to have non-default values.<br>impl Default for Color {<br>    fn default() -> Self {<br>        Self {<br>            r: 0,<br>            g: 0,<br>            b: 0<br>        }<br>    }<br>}<br>*/</span><br><br><span class="token comment">// Implementing the "Add" trait enables using</span><br><span class="token comment">// the "+" operator to add "Color" instances.</span><br><span class="token keyword">impl</span> <span class="token class-name">Add</span> <span class="token keyword">for</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span><br>    <span class="token constant">TODO</span><span class="token punctuation">:</span> <span class="token class-name">Describe</span> the <span class="token keyword">use</span> of <span class="token string">"type"</span> inside an <span class="token string">"impl"</span> <span class="token macro property">block!</span><br>    <span class="token keyword">type</span> <span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token keyword">Self</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">fn</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>            r<span class="token punctuation">:</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>r <span class="token operator">+</span> other<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span><br>            g<span class="token punctuation">:</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>g <span class="token operator">+</span> other<span class="token punctuation">.</span>g<span class="token punctuation">)</span><span class="token punctuation">,</span><br>            b<span class="token punctuation">:</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>b <span class="token operator">+</span> other<span class="token punctuation">.</span>b<span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Implementing the "AddAssign" trait enables using</span><br><span class="token comment">// the "+=" operator to add a "Color" instance to a receiver "Color".</span><br><span class="token keyword">impl</span> <span class="token class-name">AddAssign</span> <span class="token keyword">for</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">add_assign</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">self</span><span class="token punctuation">.</span>r <span class="token operator">=</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>r <span class="token operator">+</span> other<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">self</span><span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>g <span class="token operator">+</span> other<span class="token punctuation">.</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">self</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>b <span class="token operator">+</span> other<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Implementing the "Sub" trait enables using</span><br><span class="token comment">// the "-" operator to subtract "Color" instances.</span><br><span class="token keyword">impl</span> <span class="token class-name">Sub</span> <span class="token keyword">for</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span><br>    <span class="token keyword">type</span> <span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token keyword">Self</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">fn</span> <span class="token function-definition function">sub</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span> <span class="token punctuation">{</span><br>            r<span class="token punctuation">:</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>r <span class="token operator">-</span> other<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span><br>            g<span class="token punctuation">:</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>g <span class="token operator">-</span> other<span class="token punctuation">.</span>g<span class="token punctuation">)</span><span class="token punctuation">,</span><br>            b<span class="token punctuation">:</span> <span class="token namespace">cmp<span class="token punctuation">::</span></span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>b <span class="token operator">-</span> other<span class="token punctuation">.</span>b<span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Implementing the "SubAssign" trait to enable using the "-=" operator</span><br><span class="token comment">// would be similar to implementing the "AddAssign" trait.</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> red <span class="token operator">=</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> r<span class="token punctuation">:</span> <span class="token number">255</span><span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> blue <span class="token operator">=</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> r<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">255</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> purple <span class="token operator">=</span> red <span class="token operator">+</span> blue<span class="token punctuation">;</span> <span class="token comment">// can add colors</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"purple = {:?}"</span><span class="token punctuation">,</span> purple<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Color { r: 255, g: 0, b: 255 }</span><br><br>    <span class="token keyword">let</span> blue <span class="token operator">=</span> purple <span class="token operator">-</span> red<span class="token punctuation">;</span> <span class="token comment">// can subtract colors</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"blue = {:?}"</span><span class="token punctuation">,</span> blue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Color { r: 0, g: 0, b: 255 }</span><br><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> color <span class="token operator">=</span> <span class="token class-name">Color</span><span class="token punctuation">::</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    color <span class="token operator">+=</span> red<span class="token punctuation">;</span> <span class="token comment">// can add a Color to the one on the left side</span><br>    color <span class="token operator">+=</span> blue<span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"color = {:?}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Color { r: 255, g: 0, b: 255 }</span><br><span class="token punctuation">}</span></code></pre><h2 id="macros"><a name="macros">Macros</a></h2><p>Macros are like functions that:</p><ul><li>name names that end in <code>!</code></li><li>generate code at compile-time</li><li>can take a variable number of arguments</li></ul><p>To define a macro ... TODO: Finish this</p><p>Back in the &quot;Built-in Scalar Types&quot; we included examples of adding methods to built-in types. This can also be accomplished with macros as shown here:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">trait</span> <span class="token class-name">Days</span> <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">days_from_now</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token macro property">macro_rules!</span> implement_days <span class="token punctuation">{</span><br>    <span class="token punctuation">(</span><span class="token variable">$t</span><span class="token punctuation">:</span> ty<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token keyword">impl</span> <span class="token class-name">Days</span> <span class="token keyword">for</span> <span class="token variable">$t</span> <span class="token punctuation">{</span><br>            <span class="token keyword">fn</span> <span class="token function-definition function">days_from_now</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span><br>                <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">match</span> <span class="token keyword">self</span> <span class="token punctuation">{</span><br>                    <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=></span> <span class="token string">"yesterday"</span><span class="token punctuation">,</span><br>                    <span class="token number">0</span> <span class="token operator">=></span> <span class="token string">"today"</span><span class="token punctuation">,</span><br>                    <span class="token number">1</span> <span class="token operator">=></span> <span class="token string">"tomorrow"</span><span class="token punctuation">,</span><br>                    _ <span class="token operator">=></span> <span class="token punctuation">{</span><br>                        <span class="token keyword">if</span> <span class="token keyword">self</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span><br>                            <span class="token string">"future"</span><br>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>                            <span class="token string">"past"</span><br>                        <span class="token punctuation">}</span><br>                    <span class="token punctuation">}</span><br>                <span class="token punctuation">}</span><span class="token punctuation">;</span><br>                s<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token macro property">implement_days!</span> <span class="token punctuation">{</span><span class="token keyword">i8</span><span class="token punctuation">}</span><br><span class="token macro property">implement_days!</span> <span class="token punctuation">{</span><span class="token keyword">i16</span><span class="token punctuation">}</span><br><span class="token macro property">implement_days!</span> <span class="token punctuation">{</span><span class="token keyword">i32</span><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> d8<span class="token punctuation">:</span> <span class="token keyword">i8</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d16<span class="token punctuation">:</span> <span class="token keyword">i16</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> d8<span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tomorrow</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> d16<span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yesterday</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token function">days_from_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// today</span><br><span class="token punctuation">}</span></code></pre><p>Another option is allow multiple types to be passed into the macro. To this, change the first line inside the macro to the following:</p><pre class="language-rust"><code class="language-rust">    <span class="token punctuation">(</span>$<span class="token punctuation">(</span><span class="token variable">$t</span><span class="token punctuation">:</span> ty<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        $<span class="token punctuation">(</span></code></pre><p>Add the line <code>)*</code> after the end of the <code>impl</code> block. Call the new version of the macro as follows:</p><pre class="language-rust"><code class="language-rust"><span class="token macro property">implement_days!</span> <span class="token punctuation">{</span> <span class="token keyword">i8</span><span class="token punctuation">,</span> <span class="token keyword">i16</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i64</span><span class="token punctuation">,</span> <span class="token keyword">i128</span> <span class="token punctuation">}</span></code></pre><h2 id="standard-io"><a name="standard-io">Standard IO</a></h2><p>The <code>std::io</code> namespace supports many input/output operations. The members <code>stdin</code> and <code>stdout</code> are functions that return objects with methods for operating on the <code>stdio</code> and <code>stdout</code> streams.</p><p>The <code>stdin</code> methods like <code>read_line</code> and <code>stdout</code> methods like <code>write</code> and <code>flush</code> return a <code>Result</code> enum value. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// The Write trait must be in scope in order to use the flush method.</span><br><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span></span><span class="token punctuation">{</span>stdin<span class="token punctuation">,</span> stdout<span class="token punctuation">,</span> <span class="token class-name">Write</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> buffer <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">loop</span> <span class="token punctuation">{</span><br>        <span class="token comment">// Output a prompt.</span><br>        <span class="token macro property">print!</span><span class="token punctuation">(</span><span class="token string">"Command: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token comment">// Flush stdio without writing a newline character.</span><br>        <span class="token function">stdout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buffer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        buffer<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// removes newline from end of buffer</span><br><br>        <span class="token keyword">if</span> buffer <span class="token operator">==</span> <span class="token string">"quit"</span> <span class="token punctuation">{</span><br>            <span class="token keyword">break</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"You entered {}."</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prepares to reuse buffer</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here is a modified version of the code above that uses the <code>text_io</code> crate: To use this, add the dependency <code>text_io = &quot;0.1.8&quot;</code> in the <code>Cargo.toml</code> file. This also adds a <code>print</code> function to simplify writing to <code>stdout</code> without including a newline.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token class-name">Write</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">use</span> <span class="token namespace">text_io<span class="token punctuation">::</span></span>read<span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">print</span><span class="token punctuation">(</span>text<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> <span class="token keyword">mut</span> stdout <span class="token operator">=</span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token function">stdout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  stdout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  stdout<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">loop</span> <span class="token punctuation">{</span><br>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Command: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> command<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token macro property">read!</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reads until newline and omits it</span><br>    <span class="token keyword">if</span> command <span class="token operator">==</span> <span class="token string">"quit"</span> <span class="token punctuation">{</span><br>      <span class="token keyword">break</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"You entered {}."</span><span class="token punctuation">,</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="file-io">File IO</h2><p>The <code>std::fs</code> and <code>std::io</code> modules enable reading and writing from files. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>fs<span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>io<span class="token punctuation">;</span><br><span class="token comment">// The following is required to gain access to the</span><br><span class="token comment">// lines and write methods.</span><br><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span>prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">write_file</span><span class="token punctuation">(</span>path<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token comment">// To write entire file from one string ...</span><br>    <span class="token comment">//let mut f = fs::File::create(path)?;</span><br>    <span class="token comment">//f.write_all(b"Hello\nWorld\n")</span><br><br>    <span class="token comment">// To write one line at a time ...</span><br>    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token namespace">fs<span class="token punctuation">::</span></span><span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> writer <span class="token operator">=</span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">BufWriter</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token comment">// The write method takes a byte slice</span><br>    <span class="token comment">// and returns the number of bytes written.</span><br>    <span class="token comment">// This shows two ways to create a byte slice from a string.</span><br>    writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">b"Hello\n"</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br>    writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"World\n"</span><span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br>    <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">read_file</span><span class="token punctuation">(</span>path<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token comment">// To read entire file into a string ...</span><br>    <span class="token comment">//let content = fs::read_to_string(path)?;</span><br>    <span class="token comment">//println!("content = {}", content);</span><br><br>    <span class="token comment">// To read one line at a time ...</span><br>    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token namespace">fs<span class="token punctuation">::</span></span><span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> reader <span class="token operator">=</span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">BufReader</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> line <span class="token keyword">in</span> reader<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"line = {}"</span><span class="token punctuation">,</span> line<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token string">"demo.txt"</span><span class="token punctuation">;</span><br>    <span class="token function">write_file</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span><br>    <span class="token function">read_file</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>To read and write JSON files, consider using <a href="https://github.com/serde-rs/json" rel="noopener" target="_blank">Serde JSON</a>. This requires adding the following dependencies in <code>cargo.toml</code>:</p><pre class="language-toml"><code class="language-toml"><span class="token key property">serde</span> <span class="token punctuation">=</span> <span class="token punctuation">{</span> <span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">"1.0.118"</span><span class="token punctuation">,</span> <span class="token key property">features</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"derive"</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><br><span class="token key property">serde_json</span> <span class="token punctuation">=</span> <span class="token string">"1.0.60"</span></code></pre><p>The &quot;features&quot; option above is required to use features in a library that are &quot;feature-gated&quot;. In the case of the <code>serde</code> library, we need things provided by the &quot;derive&quot; feature. Some libraries use this approach to optimize compile times and the generated binary size when optional parts of the library are not needed.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">serde<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Deserialize</span><span class="token punctuation">,</span> <span class="token class-name">Serialize</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> serde_json<span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[derive(Deserialize, Serialize, Debug)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Dog</span> <span class="token punctuation">{</span><br>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br>    breed<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> dogs <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    dogs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Dog</span> <span class="token punctuation">{</span><br>        name<span class="token punctuation">:</span> <span class="token string">"Comet"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        breed<span class="token punctuation">:</span> <span class="token string">"Whippet"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> json <span class="token operator">=</span> <span class="token namespace">serde_json<span class="token punctuation">::</span></span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dogs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"json = {}"</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> dogs<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Dog</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token namespace">serde_json<span class="token punctuation">::</span></span><span class="token function">from_str</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>json<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"dogs = {:#?}"</span><span class="token punctuation">,</span> dogs<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="command-line-arguments">Command-line Arguments</h2><p>To pass command-line arguments to the program, specify them after <code>--</code>. For example, <code>cargo run -- arg1 arg2 ...</code> The arguments are available in <code>std::env::args</code>. The following can be used to get the command-line arguments in a vector where the first item is the path the executable and the remaining items are the actual arguments.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> args<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Command-line arguments can represent options that affect what an application does. A crate like <a href="https://crates.io/crates/clap" rel="noopener" target="_blank">clap</a> can be used to simplify parsing of the options and provide help.</p><p>The <code>clap</code> crate supports many features including:</p><ul><li>generated help viewed with <code>--help</code> (not with <code>-h</code>)</li><li>getting the version with <code>--version</code> or <code>-V</code> (not with <code>-v</code>) specified in the code or obtained from the <code>Cargo.toml</code> file</li><li>positional arguments</li><li>optional named arguments with no value, also known as &quot;flags&quot; (ex. <code>--quiet</code>)</li><li>named arguments with values, also known as &quot;options&quot; (ex. <code>--color yellow</code>)</li><li>arguments with default values</li><li>defining when an argument is allowed or required (see the <code>Arg</code> methods <code>required_if</code>, <code>required_ifs</code>, <code>required_unless</code>, <code>required_unless_all</code>, and <code>required_unless_one</code>)</li><li>specifying options with YAML (but a benefit of specifying them in code is that an IDE can detect and report errors)</li><li>colored error messages</li><li>non-string option values (ex. <code>bool</code>, <code>i32</code>, or <code>f64</code>)</li><li>custom value validation</li><li>and more</li></ul><p>Named arguments can have short (ex. <code>-q</code>) and long (ex. <code>--quiet</code>) forms. Flags can be combined, so <code>-a -b -c</code> is the same as <code>-abc</code>.</p><p>Each argument must have a name that uses to retrieve its value. This typically matches its long name, but is required because positional options are not required to have a long or short name.</p><p>For example, consider an app that accepts:</p><ul><li>a positional argument with a type of <code>u8</code> that specifies a size</li><li>an optional flag that causes output to be minimized</li><li>a required option that supplies a color name</li></ul><p>To get help on the app, enter <code>cargo run -- --help</code> or build the app with <code>cargo build</code> and enter <code>./target/debug/clap-demo --help</code>.</p><p>To run the app, enter <code>cargo run -- 19 --color yellow -q</code> or build the app with <code>cargo build</code> and enter <code>./target/debug/clap-demo -- 19 --color yellow -q</code>.</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// The following attribute enables using macros defined in the clap crate.</span><br><span class="token attribute attr-name">#[macro_use]</span><br><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">clap</span><span class="token punctuation">;</span><br><br><span class="token keyword">use</span> <span class="token namespace">clap<span class="token punctuation">::</span></span><span class="token class-name">Arg</span><span class="token punctuation">;</span><br><span class="token comment">// Use the following line instead if the alternate approach below is selected.</span><br><span class="token comment">//use clap::{App, Arg};</span><br><br><span class="token comment">// This is a custom validator function that</span><br><span class="token comment">// is passed to the `validator` method below.</span><br><span class="token keyword">fn</span> <span class="token function-definition function">validate_color</span><span class="token punctuation">(</span>color<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> color <span class="token operator">==</span> <span class="token string">"white"</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token string">"white is not a valid choice"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Alternate approach, not getting values from Cargo.toml file:</span><br>    <span class="token comment">// let matches = App::new("clap-demo) // next line preferred</span><br>    <span class="token comment">// let matches = App::new(crate_name!()) // gets from Cargo.toml</span><br>    <span class="token comment">//     .about("This demonstrates the use of clap.") // next line preferred</span><br>    <span class="token comment">//     .about(crate_description!()) // gets from Cargo.toml</span><br>    <span class="token comment">//     .author("R. Mark Volkmann") // next line preferred</span><br>    <span class="token comment">//     .author(crate_authors!()) // gets from Cargo.toml</span><br>    <span class="token comment">//     .version("1.0") // next line preferred</span><br>    <span class="token comment">//     .version(crate_version!()) // gets from Cargo.toml</span><br><br>    <span class="token comment">// Preferred approach, getting all possible values from Cargo.toml file:</span><br>    <span class="token comment">// The `app_from_crate!` macro combines</span><br>    <span class="token comment">// the use of all the macros used above.</span><br>    <span class="token keyword">let</span> matches <span class="token operator">=</span> <span class="token macro property">app_from_crate!</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">.</span><span class="token function">before_help</span><span class="token punctuation">(</span><span class="token string">"Welcome to my demo!"</span><span class="token punctuation">)</span> <span class="token comment">// optional; rarely used</span><br>        <span class="token punctuation">.</span><span class="token function">after_help</span><span class="token punctuation">(</span><span class="token string">"Have fun!"</span><span class="token punctuation">)</span> <span class="token comment">// optional; rarely used</span><br><br>        <span class="token comment">// Good usage strings are generated automatically,</span><br>        <span class="token comment">// but they can be overridden as follows.</span><br>        <span class="token comment">//.usage("overridden usage text")</span><br><br>        <span class="token comment">// This is a named argument that doesn't have a value (a "flag")</span><br>        <span class="token comment">// and is either present or not.</span><br>        <span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span><br>            <span class="token class-name">Arg</span><span class="token punctuation">::</span><span class="token function">with_name</span><span class="token punctuation">(</span><span class="token string">"quiet"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">long</span><span class="token punctuation">(</span><span class="token string">"quiet"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">short</span><span class="token punctuation">(</span><span class="token string">"q"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">help</span><span class="token punctuation">(</span><span class="token string">"minimizes output"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token punctuation">)</span><br><br>        <span class="token comment">// This is a named argument that has a value (an "option").</span><br>        <span class="token comment">// The name can be separated from the value with a space or `=`.</span><br>        <span class="token comment">// For example, `--color yellow` or `--color=yellow`.</span><br>        <span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span><br>            <span class="token class-name">Arg</span><span class="token punctuation">::</span><span class="token function">with_name</span><span class="token punctuation">(</span><span class="token string">"color"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">long</span><span class="token punctuation">(</span><span class="token string">"color"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">short</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">takes_value</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// makes this an "option"</span><br>                <span class="token punctuation">.</span><span class="token function">default_value</span><span class="token punctuation">(</span><span class="token string">"black"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">value_name</span><span class="token punctuation">(</span><span class="token string">"COLOR"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">help</span><span class="token punctuation">(</span><span class="token string">"your favorite color"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">validator</span><span class="token punctuation">(</span>validate_color<span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token punctuation">)</span><br><br>        <span class="token comment">// This argument is positional (an "arg").</span><br>        <span class="token comment">// Positional arguments can come before or after named arguments.</span><br>        <span class="token comment">// Their order is the order in which they are defined</span><br>        <span class="token comment">// unless the `index` method is called.</span><br>        <span class="token comment">// This specifies the position and is only used on positional arguments.</span><br>        <span class="token comment">// When this is done, `takes_value` defaults to `true`.</span><br>        <span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span><br>            <span class="token class-name">Arg</span><span class="token punctuation">::</span><span class="token function">with_name</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">takes_value</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">help</span><span class="token punctuation">(</span><span class="token string">"how big?"</span><span class="token punctuation">)</span><br>                <span class="token punctuation">.</span><span class="token function">required</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token punctuation">)</span><br><br>        <span class="token punctuation">.</span><span class="token function">get_matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// parses the command-line arguments</span><br><br>    <span class="token comment">// The `value_of` method returns an `Option` enum, with</span><br>    <span class="token comment">// `Some` wrapping the value or `None` when not present.</span><br>    <span class="token comment">// We can safely call unwrap instead of unwrap_or</span><br>    <span class="token comment">// (which supplies a value to use in case of parsing error)</span><br>    <span class="token comment">// for required options.</span><br>    <span class="token comment">// In this case, `color` is not required and has a default value.</span><br>    <span class="token keyword">let</span> color <span class="token operator">=</span> matches<span class="token punctuation">.</span><span class="token function">value_of</span><span class="token punctuation">(</span><span class="token string">"color"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Values are always strings, but clap provides</span><br>    <span class="token comment">// a macro to convert them to other types.</span><br>    <span class="token keyword">let</span> size <span class="token operator">=</span> <span class="token macro property">value_t_or_exit!</span><span class="token punctuation">(</span>matches<span class="token punctuation">,</span> <span class="token string">"size"</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// The `is_present` method checks whether a flag is present.</span><br>    <span class="token keyword">if</span> matches<span class="token punctuation">.</span><span class="token function">is_present</span><span class="token punctuation">(</span><span class="token string">"quiet"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} {}"</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"You ordered size {} in {}."</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="modules"><a name="modules">Modules</a></h2><p>A module defines a collection of values like constants, functions, and structs.</p><p>To gain access to the values in a module that is not defined in the same source file, use the <code>mod</code> statement. Values in the <code>std::prelude</code> module are automatically made available. A list of these values can be found <a href="https://doc.rust-lang.org/std/prelude/" rel="noopener" target="_blank">here</a> and include <code>Box</code>, <code>Option</code>, <code>Result</code>, <code>String</code>, and <code>Vec</code>. Other libraries can also define a <code>prelude</code> module, but the values it defines are not automatically imported. TODO: Do they just provide an easier way to gain access to selected submodule values?</p><p>A module can be defined in many places:</p><ol><li>inside a source file that uses it</li><li>in a file whose name is the module name</li><li>in multiple files within a directory whose name is the module name</li><li>in the Rust standard library</li><li>in a dependency declared in the <code>Cargo.toml</code> file</li></ol><p>By default, all members of a module are private. To make a member accessible outside the module, add the <code>pub</code> keyword at the beginning of its definition.</p><p>When a module is defined inside a source file, it is typically only used by code in that file. This is useful for teaching Rust concepts, but is not often used in practice. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">points</span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>        <span class="token keyword">pub</span> x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>        <span class="token keyword">pub</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token comment">// comma after last field is optional</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>        <span class="token comment">// Instance method</span><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>            <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// Static method</span><br>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_between</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>            <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>            <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>            <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">use</span> <span class="token namespace">points<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d1 = {}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d2 = {}"</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Moving the module definition into a separate file de-clutters the source file that uses it and enables using the module in many source files.</p><p>Here is the same code, split into two files. First up is the file <code>src/points.rs</code>:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    <span class="token keyword">pub</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token comment">// comma after last field is optional</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Instance method</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Static method</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_between</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>        <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>        <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>In addition to its use in defining a module inside a source file, the <code>mod</code> keyword is used to gain access to modules defined outside. The statement <code>mod name;</code> is equivalent to <code>mod name { include!(&quot;main.rs&quot;); }</code> where <code>main.rs</code> is the file that contains the module definition (determined by the compiler).</p><p>The <code>use</code> statement binds a full path to a new name for easier access. For example, <code>use A::B::C</code> enables using <code>C</code> with just that name instead of its fully qualified name. This is also referred to as bringing <code>C</code> into scope.</p><p>When bringing functions into scope it is idiomatic to just specify the path to their parent module in a <code>use</code> statement and use that to refer to the function (<code>ParentModule::fnName</code>). This makes it apparent when looking a calls to the functions that they are not defined locally.</p><p>When bringing other items like structs and enums into scope it is idiomatic to specify their full paths in a <code>use</code> statement and then refer to them using only their name. However, this approach doesn't work if multiple items are needed from different modules and they have the same name. In that case either bring their parent modules into scope and use those to disambiguate references or use the <code>as</code> keyword in the <code>use</code> statement to assign aliases to the names. For example, <code>use math::dimension3::Point as Point3D</code>.</p><p>The file <code>src/main.rs</code> below uses the <code>points</code> module defined above.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">points</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">points<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d1 = {}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d2 = {}"</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>This approach works well for small modules. For large modules it is sometimes desirable to split their definition across multiple source files. Each <code>.rs</code> defines a module and placing them in directories creates sub-modules. A <code>.rs</code> file can use the <code>mod</code> and <code>use</code> statements to gain access to the functionality in multiple other modules and re-export the functionality as its own.</p><p>The old way of doing this was to create a directory with the name of the module, place the files that define the module functionality inside it, and create the file <code>mod.rs</code> inside the directory that imports all functionality to be exposed from those files and re-exports it.</p><p>The new way is similar, but a <code>.rs</code> file with the name of the module is created instead of <code>mod.rs</code> and this is placed in the same directory as the module directory.</p><p>Here is the previous code using this approach. We'll add a function to the module that is defined in a different source file than the one that defines the <code>Point2D</code> struct.</p><p>The file <code>src/points/types.rs</code> can be identical to the file <code>src/points.rs</code> above. It defines the <code>Point2D</code> struct fields and methods.</p><p>The file <code>src/points/functions.rs</code> defines the function <code>distance</code> which returns the distance between two <code>Point2D</code> objects. Note that this is a plain function, not an instance or static method.</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// The super keyword enables finding a module</span><br><span class="token comment">// (types in this case) in the same directory.</span><br><span class="token keyword">use</span> <span class="token keyword">super</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>types<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point2D</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>    <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>    <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>The file <code>src/points.rs</code> ties it all together.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">functions</span><span class="token punctuation">;</span><br><span class="token keyword">mod</span> <span class="token module-declaration namespace">types</span><span class="token punctuation">;</span><br><span class="token keyword">pub</span> <span class="token keyword">use</span> <span class="token namespace">functions<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span><br><span class="token keyword">pub</span> <span class="token keyword">use</span> <span class="token namespace">types<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span></code></pre><p>The file <code>src/main.rs</code> below demonstrates using all the features of the <code>points</code> module.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">points</span><span class="token punctuation">;</span><br><span class="token comment">// Note how a single "use" statement can simplify</span><br><span class="token comment">// access to multiple values from a module.</span><br><span class="token keyword">use</span> <span class="token namespace">points<span class="token punctuation">::</span></span><span class="token punctuation">{</span>distance<span class="token punctuation">,</span> <span class="token class-name">Point2D</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d1 = {}"</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d2 <span class="token operator">=</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d2 = {}"</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> d3 <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"d3 = {}"</span><span class="token punctuation">,</span> d3<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Modules can be nested to further segregate the defined names.</p><h2 id="crates"><a name="crates">Crates</a></h2><p>A crate is a tree of modules. There are two kinds of traits. Binary (bin) crates produce an executable. Library (lib) crates provide code used by other crates.</p><p>The most popular source of open source crates is <a href="https://crates.io/" rel="noopener" target="_blank">crates.io</a>. Commonly used crates found here include:</p><ul><li><a href="https://crates.io/crates/actix-web" rel="noopener" target="_blank">actix-web</a> - web framework</li><li><a href="https://crates.io/crates/chrono" rel="noopener" target="_blank">chrono</a> - date and time library</li><li><a href="https://crates.io/crates/clap" rel="noopener" target="_blank">clap</a> - command-line argument parser</li><li><a href="https://crates.io/crates/futures" rel="noopener" target="_blank">log</a> - &quot;An implementation of futures and streams featuring zero allocations, composability, and iterator-like interfaces.</li><li><a href="https://crates.io/crates/hyper" rel="noopener" target="_blank">log</a> - HTTP client library</li><li><a href="https://crates.io/crates/log" rel="noopener" target="_blank">log</a> - logging API</li><li><a href="https://crates.io/crates/num-traits" rel="noopener" target="_blank">log</a> - generic mathematics</li><li><a href="https://crates.io/crates/rand" rel="noopener" target="_blank">rand</a> - random number generation</li><li><a href="https://crates.io/crates/rayon" rel="noopener" target="_blank">rayon</a> - &quot;data-parallelism library&quot;</li><li><a href="https://crates.io/crates/reqwest" rel="noopener" target="_blank">reqwest</a> - HTTP client</li><li><a href="https://crates.io/crates/rocket" rel="noopener" target="_blank">rocket</a> - web framework</li><li><a href="https://crates.io/crates/serde" rel="noopener" target="_blank">serde</a> - data structure serialization, including JSON</li><li><a href="https://crates.io/crates/tokio" rel="noopener" target="_blank">tokio</a> - &quot;An event-driven, non-blocking I/O platform for writing asynchronous I/O backed applications.&quot;</li></ul><h2 id="creating-and-using-a-library">Creating and Using a Library</h2><p>To create a library project, enter <code>cargo new {name} --lib</code></p><p>To demonstrate, let's create a library for operating on 2D points.</p><ol><li><p>Create the library directory structure by entering <code>cargo new geometry2d --lib</code></p></li><li><p>Enter <code>cd geometry2d</code></p></li><li><p>Create <code>src/geometry2d.rs</code> containing the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token keyword">pub</span> x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br>    <span class="token keyword">pub</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Instance method (use of self is similar to Python)</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Static method</span><br>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">distance_between</span><span class="token punctuation">(</span>pt1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> pt2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">f64</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> dx <span class="token operator">=</span> pt1<span class="token punctuation">.</span>x <span class="token operator">-</span> pt2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>        <span class="token keyword">let</span> dy <span class="token operator">=</span> pt1<span class="token punctuation">.</span>y <span class="token operator">-</span> pt2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>        <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Modify <code>src/lib.rs</code> to contain the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">geometry2d</span><span class="token punctuation">;</span><br><br><span class="token comment">// Expose the Point2D struct as a root item.</span><br><span class="token keyword">pub</span> <span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>geometry2d<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[cfg(test)]</span><br><span class="token keyword">mod</span> <span class="token module-declaration namespace">tests</span> <span class="token punctuation">{</span><br>    <span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>geometry2d<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br>    <span class="token attribute attr-name">#[test]</span><br>    <span class="token comment">// To skip a test, add: #[ignore]</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">distance_between</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> origin <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>        <span class="token keyword">let</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>origin<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token attribute attr-name">#[test]</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">distance_to</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">let</span> origin <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>        <span class="token keyword">let</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>origin<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Run the tests by entering <code>cargo test</code></p></li><li><p>Build the library by entering <code>cargo build</code></p></li><li><p>Go back up a directory by entering <code>cd ..</code></p></li><li><p>Create the directory structure for an application that will use the library by entering <code>cargo new geometry2d-app</code></p></li><li><p>Enter <code>cd geometry2d-app</code></p></li><li><p>Modify <code>Cargo.toml</code> to contain the following dependency:</p><pre class="language-toml"><code class="language-toml"><span class="token key property">geometry2d</span> <span class="token punctuation">=</span> <span class="token punctuation">{</span> <span class="token key property">path</span> <span class="token punctuation">=</span> <span class="token string">"../geometry2d"</span> <span class="token punctuation">}</span></code></pre></li><li><p>Modify <code>src/main.rs</code> to contain the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">geometry2d</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">geometry2d<span class="token punctuation">::</span></span><span class="token class-name">Point2D</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> origin <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> pt <span class="token operator">=</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token class-name">Point2D</span><span class="token punctuation">::</span><span class="token function">distance_between</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>origin<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> origin<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Run the app by entering <code>cargo run</code></p></li></ol><h2 id="cross-compiling">Cross-compiling</h2><p>Rust can build executables for platforms other than the host platform. For example, follow these steps to build a Windows executable when not running on a Windows machine:</p><ol><li>One time, install mingw-w64. In macOS this can be done by installing Homebrew and entering <code>brew install mingw-w64</code></li><li>One time, enter <code>rustup target add x86_64-pc-windows-gnu</code></li><li>One time, enter <code>rustup toolchain install stable-x86_64-pc-windows-gnu</code></li><li><code>cd</code> to the application root directory.</li><li>Enter <code>cargo build --target x86_64-pc-windows-gnu --release</code></li></ol><p>This creates the executable file in the <code>target/x86_64-pc-windows-gnu/release</code> directory with the same name as the project and a <code>.exe</code> file extension.</p><h2 id="smart-pointers"><a name="smart-pointers">Smart Pointers</a></h2><p>Smart pointers are an alternative to references. Each is implemented by a struct that holds metadata and has methods that implement its features. Many are defined in the standard library and developers can implement new ones.</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>String</code></td><td>owns <code>str</code> data, holds <code>capacity</code> and <code>length</code> metadata, and provides methods to operate on the data</td></tr><tr><td><code>Vec&lt;T&gt;</code></td><td>similar to <code>String</code>, but the data elements can be any specified type</td></tr><tr><td><code>Box&lt;T&gt;</code></td><td>a pointer stored on the stack to data on the heap</td></tr><tr><td><code>Rc&lt;T&gt;</code></td><td>stands for &quot;reference counting&quot;; enables multiple owners</td></tr><tr><td><code>Arc&lt;T&gt;</code></td><td>stands for &quot;atomically reference counting&quot;; enables multiple owners across multiple threads</td></tr><tr><td><code>Cell&lt;T&gt;</code></td><td>enables having multiple mutable references to a value within a single thread (1)</td></tr><tr><td><code>RefCell&lt;T&gt;</code></td><td>similar to <code>Cell</code>, but holds references to values instead of values</td></tr><tr><td><code>Ref&lt;T&gt;</code></td><td>used with a <code>RefCell</code> to enforce immutable borrowing rules at runtime</td></tr><tr><td><code>RefMut&lt;T&gt;</code></td><td>used with a <code>RefCell</code> to enforce mutable borrowing rules at runtime</td></tr></tbody></table><ol><li>This supports &quot;interior mutability&quot; which is described below.</li></ol><p>Smart pointers must implement the <code>std::ops::Deref</code> and <code>Drop</code> traits. The <code>Deref</code> trait requires a single method, <code>deref</code>, that is used by the dereference operator <code>*</code>. The <code>Drop</code> trait requires a single method, <code>drop</code>, that is called automatically when an object from an implementing struct goes out of scope. It can define what should happen in addition to freeing memory, including freeing resources like file handles and network connections.</p><p>Rust provides &quot;deref coercion&quot; which automatically converts a reference to any value that implements the <code>Deref</code> trait to a reference to the value returned by the <code>deref</code> method. This enables passing references or smart pointers to functions that take a reference. No additional uses of the <code>&amp;</code> or <code>*</code> operators are required. This is why references to <code>String</code> values can be passed to functions that take a <code>&amp;str</code>.</p><p>It is possible to drop (free) a value that implements the <code>Drop</code> trait before it goes out of scope. This is done by passing the value to the prelude function <code>std::mem::drop</code> rather than calling the <code>drop</code> method.</p><p>A <code>Box</code> smart pointer lives on the stack and holds a pointer to data on the heap. It is useful in three scenarios:</p><ol><li>A value that implements a given trait should be owned, but the value can be any type that implements the trait (ex. <code>Box&lt;dyn Error&gt;</code>).</li><li>Ownership of a large value should be transferred without copying the data.</li><li>The size of some data cannot be known at compile time, but it must be used in a context that requires a fixed size (ex. a recursive type such as linked-list or tree)</li></ol><p>An <code>Rc</code> smart pointer holds a reference count that starts at one, is incremented each time it is cloned (by calling <code>Rc::clone(&amp;my_rc)</code>), and is decremented when the original or a clone goes out of scope. The value they refer to is not dropped until the reference count goes to zero. This smart pointer is useful when it is not possible to know at compile-time which scope that uses the data will be the last to do so.</p><p>&quot;Interior mutability&quot; is the ability to modify data inside an immutable object. Normally Rust does not allow this, but the <code>RefCell</code> smart pointer enables it. Often <code>RefCell</code> is used in combination with <code>Rc</code>.</p><p>The <code>Rc</code> smart pointer can hold both strong (owning) and weak (not owning) references. Instances are dropped when the number of strong references goes to zero, but not when the number of weak references goes to zero. This distinction is useful in situations like representing a tree where parent nodes have strong references to children, but children have a weak reference to their parent. The result is that dropping a parent also drops its children (unless there are other strong references to them), but dropping a child does not drop its parent.</p><p>Smart pointers are needed to implement data structures such as linked lists, trees, and graphs. The standard library provides <code>std::collections::LinkedList</code>, but it does not provide structs that implement trees and graphs. TODO: Try implementing a graph with Node and Edge structs.</p><h2 id="futures">Futures</h2><p>TODO: Add this section.</p><h2 id="threads">Threads</h2><p>Rust has built-in support for threads. <a href="https://crates.io/crates/tokio" rel="noopener" target="_blank">tokio</a> is a popular crate that makes implementing asynchronous code even easier.</p><p>Features supported by Tokio include:</p><ul><li>TCP</li><li>UDP</li><li>Unix sockets</li><li>timers</li><li>spawning threads</li><li>communication between threads using channels</li><li>streams</li><li>sync utilities</li><li>scheduling</li><li>and more</li></ul><p>Here is a very basic example of using <code>tokio</code>. It assumes the following dependency line has been added in the <code>Cargo.toml</code> file.</p><pre class="language-toml"><code class="language-toml"><span class="token key property">tokio</span> <span class="token punctuation">=</span> <span class="token punctuation">{</span> <span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">"1.0.1"</span><span class="token punctuation">,</span> <span class="token key property">features</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"full"</span><span class="token punctuation">]</span> <span class="token punctuation">}</span></code></pre><p>Tokio supports a large number of features. The resulting binary size for a program can be reduced by including only the features being used instead of &quot;full&quot;.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> <span class="token namespace">tokio<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token punctuation">{</span>sleep<span class="token punctuation">,</span> <span class="token class-name">Sleep</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function-definition function">sleep_ms</span><span class="token punctuation">(</span>ms<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Sleep</span> <span class="token punctuation">{</span><br>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token attribute attr-name">#[tokio::main]</span><br><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token comment">//sleep(Duration::from_millis(1000)).await;</span><br>    <span class="token function">sleep_ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>TODO: Add this section. TODO: Add an example that uses multiple threads. TODO: Add an example that uses channels to communicate between threads.</p><h2 id="standard-library">Standard Library</h2><p>The <a href="https://doc.rust-lang.org/std/index.html" rel="noopener" target="_blank">Rust Standard Library</a> is relatively small. Often commonly needed functionality is instead found in the collection of crates at <a href="https://crates.io/" rel="noopener" target="_blank">crates.io</a>.</p><h2 id="sending-http-requests">Sending HTTP Requests</h2><p>The <a href="https://crates.io/crates/reqwest" rel="noopener" target="_blank">reqwest</a> crate is a popular option for sending HTTP requests. Here is an example of using it along with <a href="https://crates.io/crates/tokio" rel="noopener" target="_blank">tokio</a> for asynchronous calls and <a href="https://crates.io/crates/serde" rel="noopener" target="_blank">serde</a> for data structure deserialization.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">reqwest</span><span class="token punctuation">;</span><br><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">tokio</span><span class="token punctuation">;</span><br><br><span class="token keyword">use</span> <span class="token namespace">serde<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Deserialize</span><span class="token punctuation">,</span> <span class="token class-name">Serialize</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> serde_json<span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[derive(Deserialize, Serialize, Debug)]</span><br><span class="token attribute attr-name">#[serde(rename_all = <span class="token string">"camelCase"</span>)]</span><br><span class="token keyword">struct</span> <span class="token type-definition class-name">Todo</span> <span class="token punctuation">{</span><br>    user_id<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span><br>    id<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span><br>    title<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><br>    completed<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// std::error::Error is a trait, not a type.</span><br><span class="token comment">// Adding the `dyn` keyword before it means the error can be</span><br><span class="token comment">// described by any type of value that implements that trait.</span><br><span class="token comment">// The error value must have known size at compile time.</span><br><span class="token comment">// Since any value of a type that implements the trait can be used,</span><br><span class="token comment">// that size is not known.</span><br><span class="token comment">// But the compiler does know the size of a `Box`</span><br><span class="token comment">// which is what it is used to wrap the error value.</span><br><span class="token attribute attr-name">#[tokio::main]</span><br><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token namespace">std<span class="token punctuation">::</span>error<span class="token punctuation">::</span></span><span class="token class-name">Error</span><span class="token operator">>></span> <span class="token punctuation">{</span><br>    <span class="token comment">//let url = "https://jsonplaceholder.typicode.com/todos/3";</span><br>    <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token string">"https://jsonplaceholder.typicode.com/todos"</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token namespace">reqwest<span class="token punctuation">::</span></span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token operator">?</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> json <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"json = {}"</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">//let todo: Todo = serde_json::from_str(&amp;json).unwrap();</span><br>    <span class="token keyword">let</span> todos<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Todo</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token namespace">serde_json<span class="token punctuation">::</span></span><span class="token function">from_str</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>json<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">//println!("todo = {:?}", todo);</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"todos = {:#?}"</span><span class="token punctuation">,</span> todos<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><h2 id="webassembly"><a name="webassembly">WebAssembly</a></h2><p>Tools for compiling Rust code to WebAssembly include <a href="https://rustwasm.github.io/wasm-pack/" rel="noopener" target="_blank">wasm-pack</a> and <a href="https://www.secondstate.io/articles/ssvmup/" rel="noopener" target="_blank">ssvmup</a> The last update to wasm-pack was on February 7, 2020, so this project may be abandoned. The ssvmup tool was inspired by wasm-pack and has explicit support for Deno.</p><p>To compile a <code>.rs</code> file to WebAssembly:</p><ol><li><p>Install ssvmup by entering the following command (one time only):</p><pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://raw.githubusercontent.com/second-state/ssvmup/master/installer/init.sh -sSf <span class="token operator">|</span> <span class="token function">sh</span></code></pre></li><li><p>Create a new Rust library (referred to as a &quot;crate&quot;) by entering <code>cargo new --lib my-crate</code></p></li><li><p><code>cd my-crate</code></p></li><li><p>Edit <code>src/lib.rs</code> and add code there. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">wasm_bindgen<span class="token punctuation">::</span>prelude<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[wasm_bindgen]</span><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">factorial</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u64</span> <span class="token punctuation">{</span><br>    <span class="token keyword">match</span> x <span class="token punctuation">{</span><br>        <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Edit the generated <code>Cargo.toml</code> file which is similar to a Node.js <code>package.json</code> file. For example:</p><pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">package</span><span class="token punctuation">]</span><br><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"my-crate"</span><br><span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">"0.1.0"</span><br><span class="token key property">authors</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"R. Mark Volkmann &lt;me@gmail.com>"</span><span class="token punctuation">]</span><br><span class="token key property">edition</span> <span class="token punctuation">=</span> <span class="token string">"2018"</span><br><span class="token key property">description</span> <span class="token punctuation">=</span> <span class="token string">"sample project using ssvmup"</span><br><span class="token key property">license</span> <span class="token punctuation">=</span> <span class="token string">"MIT/Apache-2.0"</span><br><span class="token comment">#repository = "https://github.com/mvolkmann/my-crate"</span><br><br><span class="token punctuation">[</span><span class="token table class-name">lib</span><span class="token punctuation">]</span><br><span class="token key property">crate-type</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"cdylib"</span><span class="token punctuation">]</span><br><br><span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span><br><span class="token key property">wasm-bindgen</span> <span class="token punctuation">=</span> <span class="token string">"=0.2.61"</span></code></pre></li><li><p>Enter <code>ssvmup build --target deno</code> This creates a <code>pkg</code> directory containing <code>package.json</code>, a <code>.wasm</code> file, and a <code>.js</code> file that reads the <code>.wasm</code> file and prepares it for use in JavaScript code.</p></li><li><p>Copy the generated <code>pkg</code> directory to the directory containing the Deno code that wishes to use it.</p></li><li><p>Import the exported functions with a line like the following:</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>factorial<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./pkg/my_crate.js'</span><span class="token punctuation">;</span></code></pre></li><li><p>Call the imported functions.</p><pre class="language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4n</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "n" suffix makes it BitInt</span></code></pre></li></ol></article>