<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Rust</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#why-use-rust">Why use Rust</a></li><li><a href="#installing">Installing</a></li><li><a href="#online-playground">Online Playground</a></li><li><a href="#compiling-and-running">Compiling and Running</a></li><li><a href="#vs-code">VS Code</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#toml-syntax">TOML Syntax</a></li><li><a href="#cargo">Cargo</a></li><li><a href="#formatting-code">Formatting Code</a></li><li><a href="#naming-conventions">Naming Conventions</a></li><li><a href="#syntax-details">Syntax Details</a></li><li><a href="#comments">Comments</a></li><li><a href="#formatted-print">Formatted Print</a></li><li><a href="#variables">Variables</a></li><li><a href="#ownership-model">Ownership Model</a></li><li><a href="#dereference">Dereference</a></li><li><a href="#lifetimes">Lifetimes</a></li><li><a href="#built-in-scalar-types">Built-in Scalar Types</a></li><li><a href="#built-in-compound-types">Built-in Compound Types</a></li><li><a href="#operators">Operators</a></li><li><a href="#collections">Collections</a></li><li><a href="#strings">Strings</a></li><li><a href="#std%3A%3Acollections">std::collections</a><ol><li><a href="#vectors">Vectors</a></li></ol></li><li><a href="#conditional-logic">Conditional Logic</a></li><li><a href="#iteration">Iteration</a></li><li><a href="#functions">Functions</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#custom-types">Custom Types</a></li><li><a href="#modules">Modules</a></li><li><a href="#imports">Imports</a></li><li><a href="#standard-library">Standard Library</a></li><li><a href="#webassembly">WebAssembly</a></li></ol></nav></aside><article><p><img alt="Deno logo" style="width: 20%" src="/blog/assets/rust-logo.png" title="Rust logo"></p><h2 id="overview">Overview</h2><p><a href="https://www.rust-lang.org/" rel="noopener" target="_blank">Rust</a> is a programming language for building reliable and efficient software.</p><p>Features of Rust include:</p><ul><li>fast</li><li>memory-efficient</li><li>rich, static type system with type inference</li><li>ownership model to guarantee memory-safety and thread-safety</li></ul><h2 id="why-use-rust">Why use Rust</h2><p>Performance:</p><p>The best way to get software performance is to use a &quot;systems&quot; language like C, C++, or Rust. One reason these languages are fast is because they do not provide automatic garbage collection that is slow and can run at unpredictable times. Systems languages also allow control over whether data is on the stack or on the heap.</p><p>Safety:</p><p>Software written in systems languages typically must take great care to avoid memory and threading issues. Memory issues include accessing memory after it has been freed, resulting in unpredictable behavior. Threading issues include race conditions where the order in which code runs is unpredictable, resulting in unpredictable results. Rust addresses both of these issues, resulting in code that is less likely to contain bugs.</p><p>Immutable by default:</p><p>A large source of errors in any software involves incorrect assumptions about where data is modified. Making variables immutable by default and requiring explicit indication of functions that are allowed to modify data significantly reduces these errors.</p><p>Control over number sizes:</p><p>One way to achieve performance in computationally intensive tasks is to store collections of numbers in contiguous memory for fast access and control the number of bytes used by each number.</p><p>Ownership model:</p><p>Manual garbage collection is error prone. Rust uses an &quot;ownership model&quot; where code is explicit about the single scope that owns each piece of data. When that scope ends, the data can be safely freed because no other scope can possibly be using the data.</p><p>Systems languages tend to be more complex that non-systems languages, requiring more time to learn and more time to write software in them. Rust is no exception. But some developers choose to use Rust in spite of this in order to gain the benefits described above. On the positive side, the Rust compiler catches many errors that would only be discovered at runtime with other systems languages. The Rust compiler also provides very detailed error messages that include suggestions on how to correct the errors.</p><h2 id="installing">Installing</h2><p>Rust is installed using the <a href="" rel="noopener" target="_blank">rustup</a> tool.</p><p>To install rustup in macOS, install <a href="" rel="noopener" target="_blank">homebrew</a> and then enter <code>brew install rustup</code>.</p><p>To install rustup in Linux (or macOS), enter the following command:</p><pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="token operator">|</span> <span class="token function">sh</span></code></pre><p>To install rustup in Windows, use <a href="https://chocolatey.org/" rel="noopener" target="_blank">Chocolately</a> or <a href="https://scoop.sh/" rel="noopener" target="_blank">Scoop</a>.</p><p>After installing rustup, enter <code>rustup-init</code>. This configures the use of Rust in the bash and zsh shells. When using the fish shell, add the following in <code>.config/fish/config.fish</code>:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">set</span> -x <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span> <span class="token environment constant">$HOME</span>/.cargo/bin</code></pre><p>Verify installation by entering <code>rustc --version</code>.</p><h2 id="online-playground">Online Playground</h2><p>To try Rust code online, browse the <a href="https://play.rust-lang.org/" rel="noopener" target="_blank">Rust Playground</a>. This includes access to the top 100 most downloaded crates from <a href="https://crates.io/" rel="noopener" target="_blank">crates.io</a> and crates from the <a href="https://rust-lang-nursery.github.io/rust-cookbook/" rel="noopener" target="_blank">Rust Cookbook</a>.</p><p><img alt="Rust Playground" style="width: 100%" src="/blog/assets/rust-playground.png" title="Rust Playground"></p><p>Press the ellipsis after the &quot;RUN&quot; button to open a popup with the following options:</p><ul><li>&quot;Run&quot; to build and run the code (<code>cargo run</code>)</li><li>&quot;Build&quot; to only build the code (<code>cargo build</code>)</li><li>&quot;Test&quot; to build the code and run the tests (<code>cargo test</code>)<br>Tests must be preceded by <code>#[test]</code> and no <code>main</code> function can be present.</li><li>&quot;ASM&quot; to build the code and show the generated assembly code</li><li>&quot;LLVM IR&quot; to build the code and show the generated LLVM intermediate representation (IR)</li><li>&quot;MIR&quot; to build the code and show the generated mid-level intermediate representation (MIR)</li><li>&quot;WASM&quot; to build a WebAssembly module for use in web browsers</li></ul><p>The &quot;RUN&quot; button will change to the last selected option so it can be re-executed by pressing the button.</p><p>Press the &quot;DEBUG&quot; button to open a popup for choosing between &quot;Debug&quot; and &quot;Release&quot; built modes.</p><p>Press the &quot;NIGHTLY&quot; button to open a popup for choosing a Rust version which can be &quot;Stable channel&quot; (default), &quot;Beta channel&quot;, or &quot;Nightly channel&quot;. The button text changes to indicate the selected version.</p><p>Press the ellipsis after the version button to open a popup with the following options:</p><ul><li>&quot;Edition&quot; sets the Rust edition to 2018 (default) or 2015</li><li>&quot;Backtrace&quot; to disable (default) or enable display of backtraces when a panic occurs<br>Enabling this slows performance a bit.</li></ul><p>Press the &quot;SHARE&quot; button to open a panel on the right side containing the following links:</p><ul><li>&quot;Permalink to the playground&quot; changes the URL to one which will recall the current code set to run with the current version of Rust.</li><li>&quot;Direct link to the gist&quot; navigates to the URL of the GitHub Gist where the code is stored. The code cannot be executed from here.</li><li>&quot;Embed code in link&quot; changes the URL to one which includes a base 64 encoded copy of the code as a query parameter. This is only appropriate for small code samples due to URL length limits.</li><li>&quot;Open a new thread in the Rust user forum&quot; does what the link implies, making it easy to ask questions about a code sample.</li><li>&quot;Open an issue on the Rust GitHub repository&quot; makes it easy to report a bug in Rust.</li></ul><p>Press the &quot;TOOLS&quot; button to open a popup with the following options:</p><ul><li>&quot;Rustfmt&quot; formats the code using the <code>rustfmt</code> tool.</li><li>&quot;Clippy&quot; runs the Clippy linter on the code.</li><li>&quot;Miri&quot; runs the program using the <a href="https://github.com/rust-lang/miri" rel="noopener" target="_blank">Miri interpreter</a> which is an experimental interpreter for Rust's mid-level intermediate representation (MIR). which detects some bugs not detected by press the &quot;RUN&quot; button?</li><li>&quot;Expand macros&quot; displays the code in the right panel with all the macro calls expanded in order to see what they actually do.</li></ul><p>Press the &quot;CONFIG&quot; button to open a popup with the following options:</p><ul><li>&quot;Style&quot; to switch between &quot;SIMPLE&quot; (no line numbers) and &quot;ADVANCED&quot; (line numbers)</li><li>&quot;Keybinding&quot; to choose between keybindings supported by the <a href="https://github.com/ajaxorg/ace" rel="noopener" target="_blank">Ace</a> (Cloud9) editor<br>These include ace, emacs, sublime, vim, and vscode.</li><li>&quot;Theme&quot; to choose from 30+ themes including cobalt, github, solarized light, solarized dark</li><li>&quot;Pair Characters&quot; to automatically insert closing <code>)</code>, <code>}</code>, and <code>]</code> character after <code>(</code>, <code>{</code>, and <code>[</code> characters</li><li>&quot;Orientation&quot; to arrange panes horizontally, vertically, or automatically choose based on window size</li><li>and advanced options to control generated assembly code</li></ul><p>There doesn't seem to be a way to select a font for the code.</p><p>Configuration options are saved in browser Local Storage so they can be applied to future sessions. The most recently entered code is also saved in Local Storage, but previously entered code is not.</p><h2 id="compiling-and-running">Compiling and Running</h2><p>Rust source files have a <code>.rs</code> file extension.</p><p>To compile a Rust source file, creating an executable with the same name and no file extension, and run it:</p><ul><li>open a terminal (or Windows Command Prompt),</li><li>cd to the directory containing a <code>.rs</code> file that defines a <code>main</code> function</li><li>enter <code>rustc name.rs</code></li><li>in macOS or Linux, enter <code>./name</code></li><li>in Windows, enter <code>name</code></li></ul><p>For example, the following is a Rust Hello World program:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>See the &quot;Cargo&quot; section for an alternative way to compile and run a Rust program.</p><h2 id="vs-code">VS Code</h2><p>Install the Rust extension which adds:</p><ul><li>syntax highlighting</li><li>code completion</li><li>code formatting</li><li>type documentation on hover</li><li>linting with error indicators with ability to apply suggestions</li><li>code snippets</li><li>rename refactoring</li><li>debugging</li><li>build tasks</li></ul><p>TODO: This extension seems to do nothing!</p><h2 id="terminology">Terminology</h2><p><code>cargo</code>: a command-line utility described later crate: a binary (executable) or a library module: a set of related values such as constants and functions package: a set of related crates described by a <code>Cargo.toml</code> file TOML: a configuration file format; stands for Tom's Obvious, Minimal Language</p><h2 id="toml-syntax">TOML Syntax</h2><p><a href="https://github.com/toml-lang/toml" rel="noopener" target="_blank">TOML</a> is a configuration file format that maps to a hash table.</p><p>Each key/value pair is described by a line with the syntax <code>key = value</code>. Keys are not surrounded by any delimiters. Supported value data types include string, integer, float, boolean, datetime, array (ordered list of values), and table (collection of key/value pairs). String values are surrounded by double quotes. Datetime values have the format <code>yyyy-mm-ddThh:mm:ss</code>. The time portion can be omitted and it can be followed by a time zone (<code>Z</code> for UTC or <code>+hh:mm</code> for an offset). Array elements are surrounded by square brackets and separated by commas.</p><p>Comments begin with <code>#</code> character and extend to the end of the line.</p><p>Sections and sub-sections are indicated by lines containing a name enclosed in square brackets. Think of these like keys whose values are objects.</p><h2 id="cargo">Cargo</h2><p>The <code>cargo</code> command is a CLI tool that is installed with Rust. While using it is not required, it is highly recommended. For help, enter <code>cargo --help</code> or just <code>cargo</code>.</p><p>The following table describes the <code>cargo</code> subcommands:</p><table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody><tr><td><code>bench</code></td><td>runs benchmarks for the current project</td></tr><tr><td><code>build</code></td><td>builds current project in the <code>target</code> directory</td></tr><tr><td><code>check</code></td><td>verifies current project builds without errors,<br>without generating code</td></tr><tr><td><code>clean</code></td><td>deletes <code>target</code> directory</td></tr><tr><td><code>clippy</code></td><td>checks current project for errors using the Clippy linter</td></tr><tr><td><code>doc</code></td><td>generates documentation for the current project</td></tr><tr><td><code>init</code></td><td>creates a Rust project in the current directory</td></tr><tr><td><code>install</code></td><td>installs an executable in <code>~/.cargo/bin</code> by default</td></tr><tr><td><code>new</code></td><td>creates a Rust project in a new subdirectory</td></tr><tr><td><code>publish</code></td><td>publishes package to the registry</td></tr><tr><td><code>run</code> or <code>r</code></td><td>runs current project</td></tr><tr><td><code>search</code></td><td>searches registry for crates</td></tr><tr><td><code>test</code> or <code>t</code></td><td>runs tests in the current project</td></tr><tr><td><code>uninstall</code></td><td>removes executable from <code>~/.cargo/bin</code> by default</td></tr><tr><td><code>update</code></td><td>updates dependencies in <code>Cargo.lock</code></td></tr></tbody></table><h2 id="formatting-code">Formatting Code</h2><p>The most popular code formatting tool for Rust is <a href="" rel="noopener" target="_blank">rustfmt</a>. To install this, enter <code>cargo install rustfmt</code>. TODO: Is this installed by default by rustup?</p><p>To run it on all <code>.rs</code> files in the current directory, enter <code>rustfmt *.rs</code>.</p><h2 id="naming-conventions">Naming Conventions</h2><p>In general, names of &quot;types&quot; use PascalCase and names of &quot;value&quot; use snake_case.</p><table><thead><tr><th>Item</th><th>Naming Convention</th></tr></thead><tbody><tr><td>constants</td><td>SCREAMING_SNAKE_CASE</td></tr><tr><td>constructors</td><td>snake_case</td></tr><tr><td>crates</td><td>snake_case or kebab-case</td></tr><tr><td>enums</td><td>PascalCase</td></tr><tr><td>enums values</td><td>PascalCase</td></tr><tr><td>features</td><td>no convention</td></tr><tr><td>enums</td><td>PascalCase</td></tr><tr><td>file names</td><td>snake_case or kebab-case</td></tr><tr><td>functions</td><td>snake_case</td></tr><tr><td>lifetimes</td><td>'lowercase</td></tr><tr><td>macros</td><td>snake_case!</td></tr><tr><td>methods</td><td>snake_case</td></tr><tr><td>modules</td><td>snake_case</td></tr><tr><td>statics</td><td>SCREAMING_SNAKE_CASE</td></tr><tr><td>structs</td><td>PascalCase</td></tr><tr><td>traits</td><td>PascalCase</td></tr><tr><td>type parameters</td><td>PascalCase, but usually one letter</td></tr><tr><td>types</td><td>PascalCase</td></tr><tr><td>variables</td><td>snake_case</td></tr></tbody></table><h2 id="syntax-details">Syntax Details</h2><p>The dot (<code>.</code>) character is used to access struct fields and call instance methods.</p><p>The double colon (<code>::</code>) is used as a namespace separator (borrowed from C++) and to call static methods.</p><h2 id="comments">Comments</h2><p>Rust supports many comment syntaxes. &quot;Doc comments&quot; are included in generated HTML documentation that is generated by entering <code>cargo doc</code>. TODO: How do you generate it?</p><table><thead><tr><th>Syntax</th><th>Usage</th></tr></thead><tbody><tr><td><code>//</code></td><td>extends to end of current line</td></tr><tr><td><code>/* ... */</code></td><td>can span multiple lines</td></tr><tr><td><code>///</code></td><td>doc comment preceding the item it describes</td></tr><tr><td><code>//!</code></td><td>doc comment inside the item it describes</td></tr></tbody></table><p>Code inside doc comments that is surrounded by &quot;fences&quot; is run by the <code>rustdoc --test</code> command. For example:</p><ol><li><p>Create a project by entering <code>cargo new doc_test</code>.</p></li><li><p>Add the file <code>src/math.rs</code> containing the following:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">/// ```</span><br><span class="token comment">/// assert_eq!(math::average(vec![1.0, 2.0, 3.0, 4.0]), 2.5);</span><br><span class="token comment">/// ```</span><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">average</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>f64<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> f64 <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> sum<span class="token punctuation">:</span> f64 <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f64 <span class="token comment">// return value</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Compile this to a library by entering <code>rustc --crate-type lib src/math.rs</code> This is needed because doc tests are only run on library crates.</p></li><li><p>Run the doc tests by entering <code>rustdoc -L . --test src/math.rs</code></p></li><li><p>To call the <code>average</code> function from another source file, modify <code>src/main.js</code> to match the following:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">mod</span> math<span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> avg <span class="token operator">=</span> math<span class="token punctuation">::</span><span class="token function">average</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"average = {}"</span><span class="token punctuation">,</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre></li><li><p>To run this, enter <code>cargo run</code></p></li></ol><p>TODO: Are all names that end with <code>!</code> macros?</p><h2 id="formatted-print">Formatted Print</h2><p>The <code>std::fmt</code> namespace defines macros that format text.</p><table><thead><tr><th>Macro Name</th><th>Description</th></tr></thead><tbody><tr><td><code>format!</code></td><td>writes to a <code>String</code></td></tr><tr><td><code>print!</code></td><td>writes to stdout</td></tr><tr><td><code>println!</code></td><td>same as <code>print!</code>, but adds a newline</td></tr><tr><td><code>eprint!</code></td><td>writes to stderr</td></tr><tr><td><code>eprintln!</code></td><td>same as <code>eprint!</code>, but adds a newline</td></tr></tbody></table><p>All of these macros take a formatting string followed by zero or more expressions whose values are substituted into the formatting string where occurrences of <code>{}</code> appear. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{} is {}."</span><span class="token punctuation">,</span> <span class="token string">"Rust"</span><span class="token punctuation">,</span> <span class="token string">"interesting"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Rust is interesting.</span></code></pre><p>The curly brackets can contain indexes which allow the expression values to be inserted in a different order and be inserted more than once. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{1} {0} {2} {1}"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// green red blue green</span></code></pre><h2 id="variables">Variables</h2><p>Variables are immutable by default. For variables that hold non-primitive values, even their fields cannot be mutated.</p><p>The <code>mut</code> keyword marks a variable as mutable.</p><p>A variable declaration has the syntax <code>let name: type = value;</code> where the value is optional. However, a value must be assigned before the variable is referenced. The colon and the type can be omitted if it can be inferred from the value.</p><p>There are four ways to declare a &quot;variable&quot;.</p><table><thead><tr><th>Syntax</th><th>Meaning</th></tr></thead><tbody><tr><td><code>let name: type = value</code></td><td>immutable variable that must be assigned a value<br>before it is used and is thereafter immutable</td></tr><tr><td><code>let mut name: type = value</code></td><td>mutable variable that must be assigned a value<br>before it is used, but can be modified</td></tr><tr><td><code>const name: type = value</code></td><td>constant that must be assigned a value when it is declared</td></tr><tr><td><code>static name: type = value</code></td><td>immutable variable that lives for the duration of the program; typically <code>const</code> is preferred</td></tr><tr><td><code>static mut name: type = value</code></td><td>mutable variable that lives for the duration of the program;<br>can only mutate in <code>unsafe</code> functions</td></tr></tbody></table><p>Note that <code>const</code> declarations must be explicitly typed. They do not infer a type based on the assigned value.</p><p>TODO: Are statics a way to share data across functions, TODO: even those defined in separate files, without passing it?</p><h2 id="ownership-model">Ownership Model</h2><p>The Rust ownership model provides the following benefits:</p><ul><li>runtime speed achieved by eliminating the need for a garbage collector (GC)</li><li>more predictable performance since there are no GC pauses</li><li>safer memory access since there is no possibility of null pointer accesses or dangling pointer accesses (accessing memory that has already been freed)</li><li>safer parallel and concurrent processing since there is no possibility of data races causing unpredictable interactions between threads</li></ul><p>Memory management is handled by following these rules:</p><ol><li>Each value is referred to by a variable that is its owner.</li><li>Each value has one owner at a time, the owner can change over its lifetime.</li><li>When the owner goes out of the scope, the value is dropped.</li></ol><p>Variable values are stored either in the stack or the heap. Accessing stack data is faster, but data on the heap can grow and shrink and it can live beyond the scope that created it.</p><p>Variable values whose sizes are known at compile time are stored on the stack. This includes booleans (<code>bool</code> type), single characters (<code>char</code> type), numbers, tuples, and arrays. Variable values of all other types are stored in the heap. This includes:</p><ul><li>strings (<code>&amp;str</code> and <code>String</code>)</li><li>structs, even those that only contain fields with types that have a known size</li><li>collections from the <code>std::collections</code> namespace which defines sequences (<code>Vec</code>, <code>VecDeque</code>, and <code>LinkedList</code>), sets (<code>HashSet</code> and <code>BTreeSet</code>), and maps (<code>HashMap</code> and <code>BTreeMap</code>).</li></ul><p>A value of these types can be stored on the heap by using the <code>Box</code> type. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> heap_int<span class="token punctuation">:</span> Box<span class="token operator">&lt;</span>i32<span class="token operator">></span> <span class="token operator">=</span> Box<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Note: Sometimes Rust stores <code>&amp;str</code> values on the stack but you cannot control that, so it's best to think of them as always being on the heap.</p><p>All code blocks are delimited by a pair of curly brackets and create a new scope. Each new scope can add data to the stack that is freed when that scope exits. Many keywords have an associated block, including <code>fn</code>, <code>if</code>, <code>loop</code>, <code>for</code>, and <code>while</code>.</p><p>Here are some examples that demonstrate ownership inside a single function:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  <span class="token comment">// Because a is a scalar type (fixed size),</span><br>  <span class="token comment">// this makes a copy of a and assigns that to b</span><br>  <span class="token comment">// rather than moving ownership from a to b.</span><br>  <span class="token comment">// Both a and b can then be used.</span><br>  <span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"b = {}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a = {}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><br>  <span class="token keyword">let</span> c <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// Because c is on the heap and does not implement the Copy trait,</span><br>  <span class="token comment">// this moves ownership from c to d.</span><br>  <span class="token comment">// c can no longer be used.</span><br>  <span class="token keyword">let</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"d = {}"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test</span><br>  <span class="token comment">//println!("c = {}", c); // error "value borrowed here after move"</span><br><br>  <span class="token comment">// The Copy trait requires also implementing the Clone trait.</span><br>  <span class="token comment">// We can also implement these traits manually, but that is more work.</span><br>  <span class="token attribute attr-name">#[derive(Clone, Copy, Debug)]</span><br>  <span class="token keyword">struct</span> Point2D <span class="token punctuation">{</span><br>      x<span class="token punctuation">:</span> f64<span class="token punctuation">,</span><br>      y<span class="token punctuation">:</span> f64<br>  <span class="token punctuation">}</span><br>  <span class="token keyword">let</span> e <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token comment">// If the struct implements the Copy trait, as we have done above,</span><br>  <span class="token comment">// a copy is made.  Otherwise this moves ownership from e to f.</span><br>  <span class="token keyword">let</span> f <span class="token operator">=</span> e<span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br>  <span class="token comment">// This fails if ownership has been moved from e to f.</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"e = {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error "value borrowed here after move"</span><br><span class="token punctuation">}</span></code></pre><p>Ownership of a value can also be &quot;borrowed&quot;. For example:</p><pre class="language-rust"><code class="language-rust">  <span class="token keyword">let</span> e <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"e = {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 1.0, y: 2.0 }</span></code></pre><p>When a value is mutable and ownership is borrowed, Rust will flag an error if the value is mutated after ownership is borrowed and before the last use of the borrow. This is because references expect the data they reference to remain the same. For example:</p><pre class="language-rust"><code class="language-rust">  <span class="token keyword">let</span> <span class="token keyword">mut</span> e <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span> <span class="token comment">// f borrows a reference rather than taking ownership</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span><br>  <span class="token comment">// If f is used after this, the next line triggers the error</span><br>  <span class="token comment">// "cannot assign to `e.x` because it is borrowed".</span><br>  e<span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">3.0</span><span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"e = {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point2D { x: 4.0, y: 2.0 }</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"f = {:?}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// triggers error on mutation above</span></code></pre><p>An alternative is to clone data instead of borrowing a reference, but doing this is often unnecessarily inefficient. To clone a value whose type implements the <code>Clone</code> trait, call the <code>clone</code> method on it. For example, <code>let f = e.clone();</code></p><p>When stack variables are passed to functions, the functions are given copies. This is true even if the parameters are declared to be mutable. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">my_function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br><span class="token punctuation">}</span></code></pre><p>When heap variables (not references) are passed to functions, copies are not made and ownership is transferred. When the function exits, the data is freed. The calling function can no longer use the variable that was passed in. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// Note that it is preferable to use &amp;str instead of String here</span><br><span class="token comment">// unless we need a mutable String as demonstrated below.</span><br><span class="token comment">// However, we want to demonstrate using an argument value</span><br><span class="token comment">// that is definitely in the heap.</span><br><span class="token keyword">fn</span> <span class="token function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error "borrow of moved value: `s`"</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// triggers error above</span><br><span class="token punctuation">}</span></code></pre><p>When references to stack or heap variables are passed to functions, ownership is borrowed by the function and is returned to the calling function when the function completes. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// We could pass the i32 argument by reference,</span><br><span class="token comment">// but there is no benefit in doing that.</span><br><span class="token keyword">fn</span> <span class="token function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span></code></pre><p>To allow a function to modify data passed to it by reference, pass and receive mutable references. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">my_function</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> i32<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token operator">*</span>i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br>    s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">" more"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// on stack</span><br>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// on heap</span><br>    <span class="token comment">// Even though i and s are mutable, the arguments to</span><br>    <span class="token comment">// my_function below do not need to be marked as mutable</span><br>    <span class="token comment">// unless that function requires them to be mutable.</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test more"</span><br><span class="token punctuation">}</span></code></pre><h2 id="dereference">Dereference</h2><p>The dereference operator is used to get the value of a reference. It isn't needed very often. This is because unlike in most programming languages that support references (or pointers), Rust does not require different syntax for accessing fields and methods based on whether an instance or a reference is used. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> Point2D <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> f64<span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> f64<br><span class="token punctuation">}</span><br><br><span class="token keyword">impl</span> Point2D <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token punctuation">{</span><br>        <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token operator">&amp;&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token number">0.0</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> p_ref <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p_ref<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> p_ref<span class="token punctuation">.</span><span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example where dereference is needed:</p><pre class="language-rust"><code class="language-rust"><span class="token comment">// Implementing the PartialEq and PartialOrd traits</span><br><span class="token comment">// enables comparing instances.</span><br><span class="token attribute attr-name">#[derive(Debug, PartialEq, PartialOrd)]</span><br><span class="token keyword">struct</span> Point2D <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> f64<span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> f64<br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> ORIGIN<span class="token punctuation">:</span> Point2D <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">fn</span> <span class="token function">is_origin</span><span class="token punctuation">(</span>pt<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Point2D<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token punctuation">{</span><br>    <span class="token comment">// We could just check whether x and y are zero,</span><br>    <span class="token comment">// but then we wouldn't need to dereference pt.</span><br>    <span class="token comment">//pt.x == 0.0 &amp;&amp; pt.y == 0.0</span><br><br>    <span class="token comment">// We can't compare a Point2D reference to a Point2D,</span><br>    <span class="token comment">// but we can dereference pt to get the Point2D instance</span><br>    <span class="token comment">// it references and then compare that to ORIGIN.</span><br>    <span class="token operator">*</span>pt <span class="token operator">==</span> ORIGIN<br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> p <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> q <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"p equal q? {}"</span><span class="token punctuation">,</span> p <span class="token operator">==</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"p is origin? {:?}"</span><span class="token punctuation">,</span> <span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"q is origin? {:?}"</span><span class="token punctuation">,</span> <span class="token function">is_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br><span class="token punctuation">}</span></code></pre><h2 id="lifetimes">Lifetimes</h2><p>Lifetimes ensure that memory does not get freed before a reference to it can use it. This is only a concern in functions that take two or more references and return one of them.</p><p>All reference parameters and reference return types have a lifetime, but the Rust compiler automatically determines them in most cases. When it cannot, you must explicitly specify them. This is typically only needed when reference parameters can be returned. Usually the same lifetime is used on all of them AND on the return reference type.</p><p>Lifetimes are specified appear before type names are are composed of a single quote followed by a name which is typically a single letter such as &quot;a&quot;. They only serve to indicate which items in a function signature have the same lifetime, not an actual duration.</p><p>The following code illustrates potential errors that lifetime checking prevents.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">a</span><span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>String <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> s2 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token function">b</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// This function signature results in</span><br><span class="token comment">// "explicit lifetime required" errors for s1 and s2.</span><br><span class="token comment">// and a "missing lifetime specifier" error on the return type.</span><br><span class="token comment">// This is because when more than one reference is passed to a function</span><br><span class="token comment">// AND one of them can be returned, Rust requires lifetime specifiers.</span><br><span class="token comment">//fn b(s1: &amp;String, s2: &amp;String) -> &amp;String {</span><br><br><span class="token comment">// This function signature includes lifetime specifiers.</span><br><span class="token comment">// Now we get an error on the call to function b above</span><br><span class="token comment">// because it might return the value of the local variable s2</span><br><span class="token comment">// which is freed when function a exits.</span><br><span class="token comment">// "s2" would not be available in the caller ("main" in this case).</span><br><span class="token keyword">fn</span> b<span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> String<span class="token punctuation">,</span> s2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> String<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> String <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> s1 <span class="token operator">></span> s2 <span class="token punctuation">{</span><br>    s1<br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    s2<br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> s1 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"greatest is {}"</span><span class="token punctuation">,</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>To use more than one lifetime specifier in a function signature, list them after the function name inside angle brackets separated by commas. For example, <code>fn my_function&lt;'a, 'b&gt;(...)</code>.</p><p>To specify that lifetime <code>b</code> is at least as long as lifetime <code>a</code>, use <code>fn my_function&lt;'a, 'b: 'a&gt;(...)</code>.</p><h2 id="built-in-scalar-types">Built-in Scalar Types</h2><p>Rust defines four scalar (primitive) types which are boolean, character, integer, and floating point.</p><p>The boolean type name is <code>bool</code>. Its only values are <code>true</code> and <code>false</code>.</p><p>The character type name is <code>char</code>. Literal values are surrounded by single quotes. Its values are Unicode values of up to four bytes. TODO: Does every character use all four bytes?</p><p>The signed integer type names are <code>i{n}</code> where <code>{n}</code> is the number of bits which can be 8, 16, 32, 64, 128 or <code>size</code> which corresponds to either 32 or 64 depending on the processor architecture. The default type for literal integers is <code>i32</code> regardless of the processor.</p><p>Literal integer values can use the underscore character to separate thousands, millions, and so on. For example, the population of the U.S. in 2020 was approximately 330_676_544. Hex values begin with <code>0x</code>, octal values begin with <code>0o</code>, and binary values begin with <code>0b</code>.</p><p>The unsigned integer types are the same, but start with <code>u</code> instead of <code>i</code>.</p><p>Floating point type names are <code>f{n}</code> where <code>{n}</code> is 32 or 64. The default type for literal floats is <code>f64</code> regardless of the processor. Literal floating point values must include a decimal point to avoid being treated as integer values.</p><h2 id="built-in-compound-types">Built-in Compound Types</h2><p>Rust defines two compound (non-primitive) types which are tuple and array. These are distinct from the collection types that are described later.</p><p>A tuple is a fixed-length list of values that can be of different types. The syntax for a tuple type is <code>(type1, type2, ...)</code>. The syntax for a tuple value is <code>(value1, value2, ...)</code>. Individual values can be accessed by index or destructuring.</p><p>For example:</p><pre class="language-rust"><code class="language-rust">TODO<span class="token punctuation">:</span> ADD THIS</code></pre><p>An array is a fixed-length list of values that have the same type. The syntax for an array type is <code>[type, length]</code>. The syntax for an array value is <code>[value1, value2, ...]</code>. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> rgb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// A Rust string is a "compound collection", covered later.</span><br><span class="token keyword">let</span> sevens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// same as [7, 7, 7, 7, 7]</span></code></pre><p>Elements of an array can be accessed using square brackets and zero-based indexes. For example, <code>rgb[1]</code> is &quot;green&quot;.</p><p>A vector is a variable-length list of values. TODO: Do they all have the same type?</p><h2 id="operators">Operators</h2><p>Rust supports common operators including:</p><ul><li>arithmetic: <code>+</code>, <code>-</code>, <code>\*</code>, <code>/</code>, <code>%</code> (mod)</li></ul><h2 id="collections">Collections</h2><p>Rust defines many kinds of collections that hold a variable number of values. These include strings and collections in the <code>std::collections</code> namespace.</p><h2 id="strings">Strings</h2><p>Strings are collections of UTF-8 encoded characters. Literal values are surrounded by double quotes. Strings are more difficult to work with in Rust than in other languages. Rust trades simplicity here for better performance, concurrency, memory management.</p><p>There are two kinds of strings in Rust. The language defines the &quot;string slice&quot; type <code>&amp;str</code> and the standard library defines the <code>String</code> type. A <code>&amp;str</code> value has a fixed length and its data can be stored on the stack or in the heap. Variables of this type hold a reference to the data wherever it lives. A <code>String</code> value has a variable length and is stored in the heap.</p><p>Literal strings (zero or more characters) are surrounded by double quotes and have the type <code>&amp;str</code>. Literal characters (just one) are surrounded by single quotes and have the type <code>char</code>.</p><p>In the table below, assume the variable <code>c</code> holds a <code>char</code> value, the variables <code>s</code> and <code>t</code> hold <code>&amp;str</code> values, and the variables <code>u</code>, <code>v</code>, and <code>w</code> hold <code>String</code> values. Everywhere <code>c</code> is used, a literal character can be used in its place. Everywhere <code>s</code> and <code>t</code> are used, a literal string can be used in its place.</p><table><thead><tr><th>Operation</th><th>Syntax</th></tr></thead><tbody><tr><td>create <code>&amp;str</code></td><td><code>&quot;text in double quotes&quot;</code></td></tr><tr><td>create <code>String</code> #1</td><td><code>String::from(s)</code></td></tr><tr><td>create <code>String</code> #2</td><td><code>s.to_string()</code></td></tr><tr><td>create empty <code>String</code></td><td><code>String::new()</code></td></tr><tr><td>create <code>String</code> from multiple <code>&amp;str</code> #1</td><td><code>let u = [s, t].concat();</code></td></tr><tr><td>create <code>String</code> from multiple <code>&amp;str</code> #2</td><td><code>let u = format!(&quot;{}{}&quot;, s, t);</code></td></tr><tr><td>create <code>String</code> from <code>String</code> and <code>&amp;str</code> (1)</td><td><code>let u = v + s;</code></td></tr><tr><td>create <code>String</code> from multiple <code>String</code> values (2)</td><td><code>let u = v + &amp;w;</code></td></tr><tr><td>convert <code>&amp;str</code> to <code>String</code></td><td><code>s.to_string()</code></td></tr><tr><td>convert <code>String</code> to <code>&amp;str</code> without copying</td><td><code>let s = &amp;t;</code></td></tr><tr><td>concatenate to <code>&amp;str</code></td><td>cannot be done</td></tr><tr><td>concatenate to <code>&amp;str</code> to <code>String</code></td><td><code>u += s;</code></td></tr><tr><td>concatenate to <code>String</code> to <code>String</code></td><td><code>u += v;</code></td></tr><tr><td>concatenate to <code>char</code> to <code>String</code> (3)</td><td><code>u.push(c);</code></td></tr><tr><td>concatenate to <code>&amp;str</code> to <code>String</code> (3)</td><td><code>u.push_str(s);</code></td></tr><tr><td>get substring of <code>&amp;str</code></td><td><code>s[start..end]</code> (4)</td></tr><tr><td>get substring of <code>String</code></td><td>same as for <code>&amp;str</code></td></tr><tr><td>get substring from index to end</td><td><code>s[start..]</code></td></tr><tr><td>get substring from beginning to index</td><td><code>s[..end]</code></td></tr><tr><td>get substring where end is inclusive</td><td><code>u[start.. =end]</code></td></tr><tr><td>get <code>char</code> at index from <code>&amp;str</code></td><td><code>s.chars().nth(index)</code> (5)</td></tr><tr><td>get <code>char</code> at index from <code>String</code></td><td><code>&amp;u.chars().nth(index)</code></td></tr></tbody></table><ol><li>The <code>String</code> <code>u</code> here must be first.</li><li>All <code>String</code> values on the right of <code>=</code> after the first must be preceded by <code>&amp;</code> which converts it to a <code>&amp;str</code>.</li><li>The <code>String</code> <code>u</code> must be mutable.</li><li><code>start</code> is inclusive and <code>end</code> is exclusive.</li><li>The <code>chars</code> method can be used to iterate over the characters in a string. The <code>nth</code> method returns a <code>Option</code> object because the string may be shorter than the index. To get the <code>char</code> from it, use one of the approaches below.</li></ol><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> char5 <span class="token operator">=</span> <span class="token operator">&amp;</span>myString<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nth</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Approach #1</span><br><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=</span> char5 <span class="token punctuation">{</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"5th char is {}"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Approach #2</span><br><span class="token keyword">match</span> char5 <span class="token punctuation">{</span><br>  <span class="token function">Some</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"5th char is {}"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  None <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ignores when string is shorter</span><br><span class="token punctuation">}</span></code></pre><p>In many programming languages strings are immutable. To make a change you create a new string and assign it back to the same variable. In Rust the <code>&amp;mut str</code> type can be used for this. If it is desirable to modify a string in place, perhaps for performance reasons, the <code>mut String</code> type can be used instead. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token string">"first"</span><span class="token punctuation">;</span><br>s1 <span class="token operator">=</span> <span class="token string">"second"</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> <span class="token keyword">mut</span> s2 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>s2<span class="token punctuation">.</span><span class="token function">replace_range</span><span class="token punctuation">(</span><span class="token punctuation">..</span><span class="token punctuation">,</span> <span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>When a <code>String</code> reference is passed to a function that expects a <code>&amp;str</code> it is automatically coerced to that type. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">my_function</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "test"</span><br><span class="token punctuation">}</span></code></pre><h2 id="std%3A%3Acollections"><code>std::collections</code></h2><p>The <code>std::collections</code> namespace defines the following sequence types:</p><ul><li><code>Vec</code>: a resizable, ordered array of any kind of value where items can be efficiently added at the end</li><li><code>VecDeque</code>: like a <code>Vec</code>, but items can also be efficiently added at the beginning</li><li><code>LinkedList</code>: like a <code>Vec</code>, but it they can be efficiently split and appended</li></ul><p>The <code>std::collections</code> namespace defines the following map types:</p><ul><li><code>HashMap</code>: a collection of key/value pairs with efficient value lookup by key where keys and values can be any kind of value</li><li><code>BTreeMap</code>: like a <code>HashMap</code>, but sorted by key enabling efficient retrieval of values corresponding to the smallest key, largest key, closest key that is smaller or larger than some key value, or range of keys</li></ul><p>The <code>std::collections</code> namespace defines the following set types:</p><ul><li><p><code>HashSet</code>: a collection of values with efficient determination of whether a given value is a member</p></li><li><p><code>BTreeSet</code>: similar to storing only the keys in a <code>HashMap</code></p></li><li><p><code>BinaryHeap</code>: implements a priority queue where only the highest priority item is accessible</p></li></ul><h3 id="vectors">Vectors</h3><table><thead><tr><th>Operation</th><th>Syntax</th></tr></thead><tbody><tr><td>create empty</td><td><code>Vec::new()</code></td></tr></tbody></table><h2 id="conditional-logic">Conditional Logic</h2><p><code>if</code> expressions are the most common way to implement conditional logic. The condition is not surrounded by parentheses. where blocks require surrounding curly brackets. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"hot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> temperature <span class="token operator">&lt;</span> <span class="token number">40</span> <span class="token punctuation">{</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"cold"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"tolerable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The expression can be assigned to a variable. Newlines are not required, so this can be written on a single line. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span> <span class="token string">"red"</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"blue"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Other ways to implement conditional logic include <code>if let</code> and <code>match</code> expressions which use pattern matching to extract a value. These are often used in conjunction with <code>Option</code> and <code>Result</code> enum types which can be the result type of functions that can fail.</p><p>Here is an example of using the <code>Option</code> type whose possible values are <code>Some(value)</code> and <code>None</code>. This is similar to the <code>Maybe</code> monad in Haskell.</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">divide</span><span class="token punctuation">(</span>numerator<span class="token punctuation">:</span> f64<span class="token punctuation">,</span> denominator<span class="token punctuation">:</span> f64<span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>f64<span class="token operator">></span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> denominator <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token punctuation">{</span><br>    None <span class="token comment">// means there is no result, but doesn't explain why</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token function">Some</span><span class="token punctuation">(</span>numerator <span class="token operator">/</span> denominator<span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">.</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">match</span> <span class="token function">divide</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    None <span class="token operator">=></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"divide by zero"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">Some</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:.2}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here is an example of using the <code>Result</code> type whose possible values are <code>Ok(value)</code> and <code>Err(why)</code>. It differs from the <code>Option</code> type in that it can express why a function failed. This is similar to the <code>Either</code> monad in Haskell.</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">pub</span> <span class="token keyword">enum</span> MathError <span class="token punctuation">{</span><br>  DivisionByZero<br><span class="token punctuation">}</span><br><br><span class="token comment">// Commented lines show an alternative way</span><br><span class="token comment">// to describe the error using a string.</span><br><span class="token comment">//const DIV_BY_ZERO: &amp;str = "divide by zero";</span><br><br><span class="token keyword">fn</span> <span class="token function">divide</span><span class="token punctuation">(</span>numerator<span class="token punctuation">:</span> f64<span class="token punctuation">,</span> denominator<span class="token punctuation">:</span> f64<span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>f64<span class="token punctuation">,</span> MathError<span class="token operator">></span> <span class="token punctuation">{</span><br><span class="token comment">//fn divide(numerator: f64, denominator: f64) -> Result&lt;f64, &amp;'static str> {</span><br>  <span class="token keyword">if</span> denominator <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token punctuation">{</span><br>    <span class="token function">Err</span><span class="token punctuation">(</span>MathError<span class="token punctuation">::</span>DivisionByZero<span class="token punctuation">)</span><br>    <span class="token comment">//Err(DIV_BY_ZERO)</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token function">Ok</span><span class="token punctuation">(</span>numerator <span class="token operator">/</span> denominator<span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">.</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">match</span> <span class="token function">divide</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token comment">//Err(msg) => println!("{}", msg),</span><br>    <span class="token function">Ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"result is {:.2}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token function">Ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Rust does not support the ternary operator (<code>? :</code>) found in many other programming languages. Since <code>if</code> forms an expression that has a value, the following can be written to simulate a ternary:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">const</span> color <span class="token operator">=</span> <span class="token keyword">if</span> temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">{</span> <span class="token string">"red"</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token string">"blue"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>It is possible to write a macro to mimic this, but it doesn't reduce the expression much. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token macro-rules function">macro_rules!</span> tern <span class="token punctuation">{</span><br>    <span class="token punctuation">(</span>$cond<span class="token punctuation">:</span>expr <span class="token operator">=></span> $true_expr<span class="token punctuation">:</span>expr<span class="token punctuation">,</span> $false_expr<span class="token punctuation">:</span>expr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> $cond <span class="token punctuation">{</span><br>            $true_expr<br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>            $false_expr<br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> temperature <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token function">tern!</span><span class="token punctuation">(</span>temperature <span class="token operator">></span> <span class="token number">90</span> <span class="token operator">=></span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blue</span><br><span class="token punctuation">}</span></code></pre><h2 id="iteration">Iteration</h2><h2 id="functions">Functions</h2><p>Functions are defined using the <code>fn</code> keyword, followed by a name, parameter list, return type, and body. Functions that do not return anything omit the return type rather than specify a type like <code>void</code> as is done in some other languages.</p><p>A <code>return</code> statement returns the value of an expression. If the last statement is not terminated by a semicolon, its value is returned. This means that <code>return my_result;</code> is equivalent to <code>my_result</code>.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">average</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Vec<span class="token operator">&lt;</span>f64<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> f64 <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> sum<span class="token punctuation">:</span> f64 <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  sum <span class="token operator">/</span> numbers<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f64 <span class="token comment">// return value</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, {}!"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> numbers<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>f64<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"average = {}"</span><span class="token punctuation">,</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Functions are accessible by default within the same source file, but they are private by default when defined in a different source file. For functions that should be visible outside the source file that defines them, add the <code>pub</code> keyword before the <code>fn</code> keyword.</p><h2 id="structs">Structs</h2><p>A struct defines a type that is a set of related fields and methods, similar to a class in other languages. The <code>struct</code> keyword only defines fields. The <code>impl</code> keyword adds methods to a struct. Struct names are used to create instances. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">struct</span> Point2D <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> f64<span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> f64<span class="token punctuation">,</span> <span class="token comment">// comma after last field is optional</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">impl</span> Point2D <span class="token punctuation">{</span><br>    <span class="token keyword">fn</span> <span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>Point2D<span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Point2D<span class="token punctuation">)</span> <span class="token punctuation">-></span> f64 <span class="token punctuation">{</span><br>      <span class="token keyword">let</span> dx <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">-</span> other<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>      <span class="token keyword">let</span> dy <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">-</span> other<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>      <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">let</span> p1 <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> p2 <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> d <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"distance is {}"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>To allow structs to be printed for debugging purposes, add the following above their definition: <code>#[derive(Debug)]</code>. Then print using the <code>:?</code> (single line) or <code>:#f</code> (multi-line) format specifier. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"p1 = {:?}"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"p2 = {:#?}"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This outputs the following:</p><pre class="language-text"><code class="language-text">p1 = Point2D { x: 3.0, y: 4.0 }<br>p2 = Point2D {<br>    x: 3.0,<br>    y: 4.0,<br>}</code></pre><p>Structs are not cloneable, copyable, or printable by default. Being copyable allows instances to be passed by value (copy) instead of by reference. These features add compile time, so Rust requires implementing them on a case-by-case basis. The easiest way to implement these features is the proceed a struct definition with the following:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Clone, Copy, Debug)]</span></code></pre><p>A <code>struct</code> can be empty, containing no fields. This is useful for implementing groups of functionality that do not require fields.</p><p>Structs and their fields are accessible by default within the same source file, but they are private by default when defined in a different source file. For structs that should be visible outside the source file that defines them, add the <code>pub</code> keyword to both the <code>struct</code> and the fields to be exposed.</p><p>A <code>struct</code> can include the fields of another <code>struct</code> of the same type using the <code>..</code> syntax. This can only appear at the end of the list of values. It only supplies values that were not specified. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> Point3D <span class="token punctuation">{</span><br>  x<span class="token punctuation">:</span> f64<span class="token punctuation">,</span><br>  y<span class="token punctuation">:</span> f64<span class="token punctuation">,</span><br>  z<span class="token punctuation">:</span> f64<br><span class="token punctuation">}</span><br><span class="token keyword">let</span> p3 <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> p4 <span class="token operator">=</span> Point3D <span class="token punctuation">{</span> z<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">..</span>p3 <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// uses p3.x and p3.y, but not p3.z</span></code></pre><p>A &quot;tuple struct&quot; gives a name to a tuple. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><br><span class="token keyword">struct</span> <span class="token function">RGB</span><span class="token punctuation">(</span>u8<span class="token punctuation">,</span> u8<span class="token punctuation">,</span> u8<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> CORNFLOWER_BLUE<span class="token punctuation">:</span> RGB <span class="token operator">=</span> <span class="token function">RGB</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">149</span><span class="token punctuation">,</span> <span class="token number">237</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> REBECCA_PURPLE<span class="token punctuation">:</span> RGB <span class="token operator">=</span> <span class="token function">RGB</span><span class="token punctuation">(</span><span class="token number">0x66</span><span class="token punctuation">,</span> <span class="token number">0x33</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> CORNFLOWER_BLUE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RGB(100, 149, 237)</span><br><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> REBECCA_PURPLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RGB(102, 51, 153)</span></code></pre><p>Structs cannot inherit from (extend) other structs, but they can nest other structs (composition).</p><h2 id="traits">Traits</h2><p>A trait describes an interface that structs can implement. Traits can be generic, including type parameters. Trait functions can provide default implementations that are used by implementing types that do not override them.</p><p>For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">struct</span> Point2D <span class="token punctuation">{</span><br>    x<span class="token punctuation">:</span> f64<span class="token punctuation">,</span><br>    y<span class="token punctuation">:</span> f64<span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">trait</span> Distance<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span><br>      <span class="token keyword">fn</span> <span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> T<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">impl</span> Distance<span class="token operator">&lt;</span>f64<span class="token operator">></span> <span class="token keyword">for</span> Point2D <span class="token punctuation">{</span><br>      <span class="token keyword">fn</span> <span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>Point2D<span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Point2D<span class="token punctuation">)</span> <span class="token punctuation">-></span> f64 <span class="token punctuation">{</span><br>          <span class="token keyword">let</span> dx <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">-</span> other<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>          <span class="token keyword">let</span> dy <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">-</span> other<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br>          <span class="token punctuation">(</span>dx<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span><span class="token function">powf</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>      <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">let</span> p1 <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> p2 <span class="token operator">=</span> Point2D <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">6.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">8.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> d <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">distance_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"distance is {}"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Traits can specify other traits that must also be implemented by any structs that implement them. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> HockeyPlayer<span class="token punctuation">:</span> Athlete <span class="token operator">+</span> Person <span class="token punctuation">{</span><br>  <span class="token comment">// Describe functions unique to hockey players here.</span><br><span class="token punctuation">}</span></code></pre><p>Now any <code>struct</code> that implements <code>HockeyPlayer</code> must also implement <code>Athlete</code> and <code>Person</code>.</p><h2 id="custom-types">Custom Types</h2><p>TODO: Is this different from a struct?</p><h2 id="modules">Modules</h2><p>Modules define collections of values like constants and functions. A module can be defined in three ways.</p><ol><li>Inside a source file that uses it with the <code>mod</code> keyword.</li><li>In a file whose name is the module name.</li><li>In multiple files within a directory whose name is the module name.</li></ol><p>By default, all members of a module are private. To make a member accessible outside the module, add the <code>pub</code> keyword at the beginning of its definition.</p><p>TODO: Show examples of each of these approaches.</p><p>To use a module that is defined in another file or directory, use the <code>mod</code> keyword to gain access and the <code>use</code> keyword to specify the values in it that will be used. TODO: Why are both keywords needed?</p><p>Modules can be nested to further segregate the defined names.</p><h2 id="imports">Imports</h2><h2 id="standard-library">Standard Library</h2><h2 id="webassembly"><a name="webassembly">WebAssembly</a></h2><p>Tools for compiling Rust code to WebAssembly include <a href="https://rustwasm.github.io/wasm-pack/" rel="noopener" target="_blank">wasm-pack</a> and <a href="https://www.secondstate.io/articles/ssvmup/" rel="noopener" target="_blank">ssvmup</a> The last update to wasm-pack was on February 7, 2020, so this project may be abandoned. The ssvmup tool was inspired by wasm-pack and has explicit support for Deno.</p><p>To compile a <code>.rs</code> file to WebAssembly:</p><ol><li><p>Install ssvmup by entering the following command (one time only):</p><pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://raw.githubusercontent.com/second-state/ssvmup/master/installer/init.sh -sSf <span class="token operator">|</span> <span class="token function">sh</span></code></pre></li><li><p>Create a new Rust library (referred to as a &quot;crate&quot;) by entering <code>cargo new --lib my-crate</code></p></li><li><p><code>cd my-crate</code></p></li><li><p>Edit <code>src/lib.rs</code> and add code there. For example:</p><pre class="language-rust"><code class="language-rust"><span class="token keyword">use</span> wasm_bindgen<span class="token punctuation">::</span>prelude<span class="token punctuation">::</span><span class="token operator">*</span><span class="token punctuation">;</span><br><br><span class="token attribute attr-name">#[wasm_bindgen]</span><br><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">factorial</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> u64<span class="token punctuation">)</span> <span class="token punctuation">-></span> u64 <span class="token punctuation">{</span><br>    <span class="token keyword">match</span> x <span class="token punctuation">{</span><br>        <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">,</span><br>        _ <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre></li><li><p>Edit the generated <code>Cargo.toml</code> file which is similar to a Node.js <code>package.json</code> file. For example:</p><pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">package</span><span class="token punctuation">]</span><br><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"my-crate"</span><br><span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">"0.1.0"</span><br><span class="token key property">authors</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"R. Mark Volkmann &lt;me@gmail.com>"</span><span class="token punctuation">]</span><br><span class="token key property">edition</span> <span class="token punctuation">=</span> <span class="token string">"2018"</span><br><span class="token key property">description</span> <span class="token punctuation">=</span> <span class="token string">"sample project using ssvmup"</span><br><span class="token key property">license</span> <span class="token punctuation">=</span> <span class="token string">"MIT/Apache-2.0"</span><br><span class="token comment">#repository = "https://github.com/mvolkmann/my-crate"</span><br><br><span class="token punctuation">[</span><span class="token table class-name">lib</span><span class="token punctuation">]</span><br><span class="token key property">crate-type</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"cdylib"</span><span class="token punctuation">]</span><br><br><span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span><br><span class="token key property">wasm-bindgen</span> <span class="token punctuation">=</span> <span class="token string">"=0.2.61"</span></code></pre></li><li><p>Enter <code>ssvmup build --target deno</code> This creates a <code>pkg</code> directory containing <code>package.json</code>, a <code>.wasm</code> file, and a <code>.js</code> file that reads the <code>.wasm</code> file and prepares it for use in JavaScript code.</p></li><li><p>Copy the generated <code>pkg</code> directory to the directory containing the Deno code that wishes to use it.</p></li><li><p>Import the exported functions with a line like the following:</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>factorial<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./pkg/my_crate.js'</span><span class="token punctuation">;</span></code></pre></li><li><p>Call the imported functions.</p><pre class="language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4n</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "n" suffix makes it BitInt</span></code></pre></li></ol><pre><code>
</code></pre></article>