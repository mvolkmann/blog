<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Nearley</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#installing">Installing</a></li><li><a href="#builtins">Builtins</a></li><li><a href="#grammars">Grammars</a><ol><li><a href="#creating-a-grammar">Creating a Grammar</a></li><li><a href="#compiling-a-grammar">Compiling a Grammar</a></li><li><a href="#testing-a-grammar">Testing a Grammar</a></li></ol></li><li><a href="#postprocessors">Postprocessors</a><ol><li><a href="#postprocessor-rules-for-evaluating">Postprocessor Rules for Evaluating</a></li><li><a href="#postprocessor-rules-for-ast-building">Postprocessor Rules for AST Building</a></li></ol></li><li><a href="#using-a-grammar-from-javascript-code">Using a Grammar from JavaScript Code</a></li><li><a href="#railroad-diagrams">Railroad Diagrams</a></li><li><a href="#unparsing">Unparsing</a></li><li><a href="#customizing-the-lexer">Customizing the Lexer</a></li><li><a href="#example-grammars">Example Grammars</a></li></ol></nav></aside><article><style>img {
    border: 1px solid gray;
  }</style><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://nearley.js.org?v=1.1.1" rel="noopener" target="_blank">nearley</a> is a parsing toolkit with many features.</p><ul><li>It handles all BNF grammars, including those with left recursion.</li><li>It can produce abstract syntax trees, text output, or simply validate input.</li><li>It provides a testing tool (<code>nearley-test</code>).</li><li>It provides a railroad diagram generator that creates HTML files which include SVG-based diagrams (<code>nearley-railroad</code>).</li><li>It works with many lexers including its default lexer <a href="https://github.com/no-context/moo?v=1.1.1" rel="noopener" target="_blank">Moo</a>.</li></ul><p>The nearley library:</p><ul><li>can be used in both server-side and browser JavaScript code</li><li>uses the Earley algorithm</li><li>implements right recursion optimizations</li><li>can produce random strings that match a given grammar</li><li>has editor plug-ins that provide syntax highlighting for VS Code (from Pouya Kary), Sublime Text, and Vim</li><li>has been maintained by volunteers since 2014</li></ul><h2 id="installing" tabindex="-1">Installing</h2><p>To install nearley globally so its tools can be used from the command line, enter <code>npm install -g nearley</code>.</p><p>To install nearley in a Node project, enter <code>npm install nearley</code>.</p><p>Installing nearley also installs the Moo lexer library.</p><h2 id="builtins" tabindex="-1">Builtins</h2><p>Nearley provides files that define commonly used grammar rules and functions. These are found at <a href="https://github.com/kach/nearley/tree/master/builtin" target="_blank">builtin</a>.</p><p><code>number.ne</code> defines the grammar rules:</p><ul><li><code>unsigned_int</code> matches zero or positive integers</li><li><code>int</code> matches any integer</li><li><code>unsigned_decimal</code> matches zero or positive floating point numbers</li><li><code>decimal</code> matches any floating point number</li><li><code>percentage</code> matches a decimal followed by %</li><li><code>jsonfloat</code> matches same as decimal, but adds scientific notation matching</li></ul><p><code>postprocessors.ne</code> defines the following functions that are used inside the postprocesssor code associated with grammar rules (more on this later):</p><ul><li><code>nth</code> returns the nth element from a data array</li><li><code>$</code> ???</li><li><code>delimited</code> ???</li></ul><p><code>string.ne</code> defines the grammar rules:</p><ul><li><code>dqstring</code> matches strings delimited by double quotes</li><li><code>sqstring</code> matches strings delimited by single quotes</li><li><code>btquote</code> matches strings delimited by backticks</li></ul><p><code>whitespace.ne</code> defines the grammar rules:</p><ul><li><code>_</code> matches zero or more whitespace characters.</li><li><code>__</code> matches one or more whitespace characters.</li></ul><p>To include these files in <code>.ne</code> grammar file, use the <code>@builtin</code> directive. For example, <code>@builtin &quot;whitespace.ne&quot;</code>.</p><h2 id="grammars" tabindex="-1">Grammars</h2><p>A grammar is a set of rules that define sequences of matching tokens. Each rule can optionally specify a result to produced.</p><h3 id="creating-a-grammar" tabindex="-1">Creating a Grammar</h3><p>Grammars are defined in text files with a <code>.ne</code> file extension. The first grammar rule defines the starting point. The remaining rules can appear in any order, including alphabetical.</p><p>The following is a fairly simple grammar defined in the file <code>arithmetic.ne</code>. It defines rules for arithmetic expressions that use the following operators:</p><ul><li><code>+</code> addition</li><li><code>-</code> subtraction</li><li><code>*</code> multiplication</li><li>'/' division</li></ul><p>This grammar supports standard operator precedence and using parentheses to override that.</p><pre class="language-js"><code class="language-js">@builtin <span class="token string">"number.ne"</span> # using decimal rule<br>@builtin <span class="token string">"whitespace.ne"</span> # using _ rule<br><br>start <span class="token operator">-</span><span class="token operator">></span> additive<br><br>additive<br>  <span class="token operator">-</span><span class="token operator">></span> multiplicative _ <span class="token string">"+"</span> _ additive<br>   <span class="token operator">|</span> multiplicative _ <span class="token string">"-"</span> _ additive<br>   <span class="token operator">|</span> multiplicative<br><br>multiplicative<br>  <span class="token operator">-</span><span class="token operator">></span> term _ <span class="token string">"*"</span> _ multiplicative<br>   <span class="token operator">|</span> term _ <span class="token string">"/"</span> _ multiplicative<br>   <span class="token operator">|</span> term<br><br>term<br>  <span class="token operator">-</span><span class="token operator">></span> decimal<br>   <span class="token operator">|</span> <span class="token string">"("</span> additive <span class="token string">")"</span></code></pre><h3 id="compiling-a-grammar" tabindex="-1">Compiling a Grammar</h3><p>To compile a grammar to JavaScript code, use the <code>nearleyc</code> command. For example:</p><pre class="language-bash"><code class="language-bash">nearlyc arithmetic.ne <span class="token parameter variable">-o</span> arithmetic.js</code></pre><h3 id="testing-a-grammar" tabindex="-1">Testing a Grammar</h3><p>To test a grammar with specific input, use the <code>nearley-test</code> command. For example:</p><pre class="language-bash"><code class="language-bash">nearly-test arithmetic.js <span class="token parameter variable">-i</span> <span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span>",</code></pre><p>This outputs the following nested array which represents the parse tree. For this example, each occurrence of <code>null</code> represents whitespace which is not being captured.</p><pre class="language-text"><code class="language-text">[<br>  [<br>    [<br>      [<br>        [ 2 ], null, "*", null, [<br>          [ 3 ]<br>        ]<br>      ], null, "+", null, [<br>        [<br>          [ "(", [<br>              [<br>                [ 5 ]<br>              ], null, "+", null, [<br>                [<br>                  [ 1 ]<br>                ]<br>              ]<br>            ], ")" ], null, "/", null, [<br>            [ 2 ]<br>          ]<br>        ], null, "-", null, [<br>          [<br>            [ 4 ]<br>          ]<br>        ]<br>      ]<br>    ]<br>  ]<br>]</code></pre><p>This output is not particularly helpful. It does demonstrate that our grammar is correct.</p><p>Here is an example of supplying input that does not match the grammar.</p><pre class="language-bash"><code class="language-bash">nearley-test arithmetic-default.js <span class="token parameter variable">-i</span> <span class="token string">'1 + two'</span></code></pre><p>And here is the output with some parts elided because it is quite long.</p><pre class="language-text"><code class="language-text">/usr/local/lib/node_modules/nearley/lib/nearley.js:346<br>                throw err;<br>                ^<br>Error: Syntax error at line 1 col 5:<br><br>1 1 + two<br>      ^<br>Unexpected "t". Instead, I was expecting to see one of the following:<br><br>A character matching /[ \t\n\v\f]/ based on:<br>    ...<br>A "(" based on:<br>    ...<br>A "-" based on:<br>    ...<br>A character matching /[0-9]/ based on:<br>    ...<br>  offset: 4,<br>  token: { value: 't' }</code></pre><h2 id="postprocessors" tabindex="-1">Postprocessors</h2><p>Each rule can be followed by JavaScript code that is executed when the rule is matched. The code must be delimited by <code>{%</code> and <code>%}</code>.</p><p>It must contain the name of a predefined function or a function definition (typically written as an arrow function).</p><p>The function is passed three values:</p><ul><li><code>data</code> - array containing the parsed result for each matching token</li><li><code>location</code> - zero-based index into the input string where the match began</li><li><code>reject</code> - object that can be returned to indicate that the rule should not match</li></ul><p>Typically only the first argument, <code>data</code> is used and often the name is shortened to just <code>d</code>.</p><h3 id="postprocessor-rules-for-evaluating" tabindex="-1">Postprocessor Rules for Evaluating</h3><p>Let's add postprocessing the previous grammar so that it evaluates each rule to a number. The value of the starting rule will be the value of the entire input expression.</p><pre class="language-js"><code class="language-js">@builtin <span class="token string">"number.ne"</span> # using decimal rule<br>@builtin <span class="token string">"whitespace.ne"</span> # using _ rule<br><br>start <span class="token operator">-</span><span class="token operator">></span> additive <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>additive<br>  <span class="token operator">-</span><span class="token operator">></span> multiplicative _ <span class="token string">"+"</span> _ additive <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> multiplicative _ <span class="token string">"-"</span> _ additive <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>multiplicative<br>  <span class="token operator">-</span><span class="token operator">></span> term _ <span class="token string">"*"</span> _ multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> term _ <span class="token string">"/"</span> _ multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> term <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>term<br>  <span class="token operator">-</span><span class="token operator">></span> decimal <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> <span class="token string">"("</span> additive <span class="token string">")"</span> <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> <span class="token function">Number</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><p>Running the following command:</p><pre class="language-bash"><code class="language-bash">nearly-test arithmetic.js <span class="token parameter variable">-i</span> <span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span>",</code></pre><p>outputs the expected value in an array which is <code>[ 5 ]</code>.</p><h3 id="postprocessor-rules-for-ast-building" tabindex="-1">Postprocessor Rules for AST Building</h3><p>Let's modify the postprocessing so the result is an abstract syntax tree (AST).</p><p>ASTs are trees of objects describe the results of parsing input text. They can be useful for compiling one syntax into another. For example, we could parse code written in Smalltalk and output corresponding JavaScript code.</p><p>Arbitrary JavaScript code can be included in a grammar by delimiting it with <code>@{%</code> and <code>%}</code>. Often this is used to define functions that are used in postprocessing rules. It can also be used to customize the lexer, which is the code that converts the input string into tokens that are matched by the parser rules.</p><p>The provided <code>id</code> function returns the first element from the data array. It is equivalent to <code>d =&gt; d[0]</code>.</p><pre class="language-js"><code class="language-js">@<span class="token punctuation">{</span><span class="token operator">%</span><br><span class="token keyword">function</span> <span class="token function">binaryOperation</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token punctuation">{</span><br>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">"binary operation"</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">operator</span><span class="token operator">:</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">left</span><span class="token operator">:</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">right</span><span class="token operator">:</span> data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token operator">%</span><span class="token punctuation">}</span><br><br>@builtin <span class="token string">"number.ne"</span> # using decimal rule<br>@builtin <span class="token string">"whitespace.ne"</span> # using _ rule<br><br>start <span class="token operator">-</span><span class="token operator">></span> additive <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>additive<br>  <span class="token operator">-</span><span class="token operator">></span> multiplicative _ <span class="token punctuation">[</span><span class="token operator">+</span><span class="token operator">-</span><span class="token punctuation">]</span> _ additive <span class="token punctuation">{</span><span class="token operator">%</span> binaryOperation <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>multiplicative<br>  <span class="token operator">-</span><span class="token operator">></span> term _ <span class="token punctuation">[</span><span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">]</span> _ multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> binaryOperation <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> term <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>term<br>  <span class="token operator">-</span><span class="token operator">></span> decimal <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> <span class="token string">"("</span> additive <span class="token string">")"</span> <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">data</span> <span class="token operator">=></span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><p>Running the following command:</p><pre class="language-bash"><code class="language-bash">nearly-test arithmetic.js <span class="token parameter variable">-i</span> <span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span>",</code></pre><p>outputs the following AST:</p><pre class="language-text"><code class="language-text">[<br>  {<br>    type: "binary operation",<br>    operator: "+",<br>    left: {<br>      type: "binary operation",<br>      operator: "*",<br>      left: 2,<br>      right: 3,<br>    },<br>    right: {<br>      type: "binary operation",<br>      operator: "-",<br>      left: {<br>        type: "binary operation",<br>        operator: "/",<br>        left: {<br>          type: "binary operation",<br>          operator: "+",<br>          left: 5,<br>          right: 1<br>        },<br>        right: 2<br>      }<br>      right: 4,<br>    },<br>  }<br>]</code></pre><p>The following JavaScript function takes a node from this AST and computes its result. If it is passed the root node above, it returns the expected result of <code>5</code>.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">evaluateAstNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> <span class="token punctuation">{</span>left<span class="token punctuation">,</span> operator<span class="token punctuation">,</span> right<span class="token punctuation">}</span> <span class="token operator">=</span> node<span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> left <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> left <span class="token operator">=</span> <span class="token function">evaluateAstNode</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> right <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> right <span class="token operator">=</span> <span class="token function">evaluateAstNode</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>operator<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> left <span class="token operator">-</span> right<span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> left <span class="token operator">*</span> right<span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> left <span class="token operator">/</span> right<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="using-a-grammar-from-javascript-code" tabindex="-1">Using a Grammar from JavaScript Code</h2><p>The compiled parser code can be used from a JavaScript program. This works in both server-side code and browser code.</p><p>The following example uses the previous grammar to produce an AST. It then uses the <code>evaluateAstNode</code> function above to compute the result.</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> nearley <span class="token keyword">from</span> <span class="token string">'nearley'</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> grammar <span class="token keyword">from</span> <span class="token string">'./arithmetic.js'</span><span class="token punctuation">;</span> <span class="token comment">// compiled grammar</span><br><br><span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">nearley<span class="token punctuation">.</span>Parser</span><span class="token punctuation">(</span>nearley<span class="token punctuation">.</span>Grammar<span class="token punctuation">.</span><span class="token function">fromCompiled</span><span class="token punctuation">(</span>grammar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> input <span class="token operator">=</span> <span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span><span class="token punctuation">;</span> <span class="token comment">// expect 5</span><br><br><span class="token keyword">try</span> <span class="token punctuation">{</span><br>  parser<span class="token punctuation">.</span><span class="token function">feed</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">evaluateAstNode</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span>results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="railroad-diagrams" tabindex="-1">Railroad Diagrams</h2><p>To generate a railroad diagram from a grammar, use the <code>nearley-railroad</code> command. For example, <code>nearly-railroad my-grammar.ne -o my-grammar.html</code>. To view the diagram, open the generated <code>.html</code> in any web browser.</p><p>Here is the railroad diagram for our arithmetic grammar:</p><p><img alt="nearley Railroad Diagram" style="width: 60%" src="/blog/assets/nearley-railroad-diagram.png?v=1.1.1"></p><h2 id="unparsing" tabindex="-1">Unparsing</h2><p>The <code>nearly-unparse</code> command takes a compiled grammar (<code>.js</code> file) and generates an input string that matches the grammar. Running it multiple times will produce different results.</p><p>By default it begins at the first rule, but any rule can be specified with the <code>-s</code> flag.</p><p>By default there is no limit to how deeply it will search through the rules to generate matching input. This can be quite slow. To limit the search, specify the <code>-d</code> option with a value like <code>500</code>.</p><p>For example, the following command generates matching input for our arithmetic grammar:</p><pre class="language-bash"><code class="language-bash">nearley-unparse <span class="token parameter variable">-d</span> <span class="token number">200</span> arithmetic-ast.js</code></pre><p>This produces results like the following:</p><pre class="language-text"><code class="language-text">-48.6<br>((20802.1530))<br>(((-3)))</code></pre><p>I could not get this to generate any matching input that contained an arithmetic operator. Color me unimpressed.</p><h2 id="customizing-the-lexer" tabindex="-1">Customizing the Lexer</h2><p>The nearley parser library uses the Moo lexer library by default. Installing <code>nearley</code> also installs <code>moo</code>.</p><p>Let's modify our arithmetic grammar to support single-line comments that begin with the <code>#</code> character and extend to the end of the line. This requires modifying the lexer because by default the lexer discards all newline characters. We need to consider those to know when a comment ends.</p><p>TODO: Add this example.</p><h2 id="example-grammars" tabindex="-1">Example Grammars</h2><p>Many example grammars can be found in the nearley GitHub repository. See <a href="https://github.com/kach/nearley/tree/master/examples" target="_blank">examples</a>.</p></article>