<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Nearley</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#installing">Installing</a></li><li><a href="#builtins">Builtins</a></li><li><a href="#grammars">Grammars</a><ol><li><a href="#creating-a-grammar">Creating a Grammar</a></li><li><a href="#compiling-a-grammar">Compiling a Grammar</a></li><li><a href="#testing-a-grammar">Testing a Grammar</a></li></ol></li><li><a href="#postprocessors">Postprocessors</a><ol><li><a href="#postprocessor-rules-for-evaluating">Postprocessor Rules for Evaluating</a></li><li><a href="#postprocessor-rules-for-ast-building">Postprocessor Rules for AST Building</a></li></ol></li><li><a href="#using-ebnf-modifiers">Using EBNF modifiers</a></li><li><a href="#using-a-grammar-from-javascript-code">Using a Grammar from JavaScript Code</a></li><li><a href="#railroad-diagrams">Railroad Diagrams</a></li><li><a href="#unparsing">Unparsing</a></li><li><a href="#customizing-the-lexer">Customizing the Lexer</a></li><li><a href="#unit-tests">Unit Tests</a></li><li><a href="#compiling-to-typescript">Compiling to TypeScript</a></li><li><a href="#example-grammars">Example Grammars</a></li></ol></nav></aside><article><style>img {
    border: 1px solid gray;
  }</style><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://nearley.js.org?v=1.1.1" rel="noopener" target="_blank">nearley</a> is a parsing toolkit with many features.</p><ul><li>It handles all BNF grammars, including those with left recursion.</li><li>It can produce abstract syntax trees, text output, or simply validate input.</li><li>It provides a testing tool (<code>nearley-test</code>).</li><li>It provides a railroad diagram generator that creates HTML files which include SVG-based diagrams (<code>nearley-railroad</code>).</li><li>It works with many lexers including its default lexer <a href="https://github.com/no-context/moo?v=1.1.1" rel="noopener" target="_blank">Moo</a>. The lexer converts the input string into tokens that are matched by the parser rules.</li></ul><p>The nearley library:</p><ul><li>can be used in both server-side and browser JavaScript code</li><li>uses the Earley algorithm</li><li>implements right recursion optimizations</li><li>can produce random strings that match a given grammar</li><li>has editor plug-ins that provide syntax highlighting for VS Code (from Pouya Kary), Sublime Text, and Vim</li><li>has been maintained by volunteers since 2014</li></ul><h2 id="installing" tabindex="-1">Installing</h2><p>To install nearley globally so its tools can be used from the command line, enter <code>npm install -g nearley</code>.</p><p>To install nearley in a Node project, enter <code>npm install nearley</code>.</p><p>Installing nearley also installs the Moo lexer library.</p><h2 id="builtins" tabindex="-1">Builtins</h2><p>Nearley provides files that define commonly used grammar rules and functions. These are found at <a href="https://github.com/kach/nearley/tree/master/builtin" target="_blank">builtin</a>.</p><p><code>number.ne</code> defines the grammar rules:</p><ul><li><code>unsigned_int</code> matches zero or positive integers</li><li><code>int</code> matches any integer</li><li><code>unsigned_decimal</code> matches zero or positive floating point numbers</li><li><code>decimal</code> matches any floating point number</li><li><code>percentage</code> matches a decimal followed by %</li><li><code>jsonfloat</code> matches same as decimal, but adds scientific notation matching</li></ul><p><code>postprocessors.ne</code> defines the following functions that are used inside the postprocesssor code associated with grammar rules (more on this later):</p><ul><li><code>nth</code> returns the nth element from a data array</li><li><code>$</code> ???</li><li><code>delimited</code> ???</li></ul><p><code>string.ne</code> defines the grammar rules:</p><ul><li><code>dqstring</code> matches strings delimited by double quotes</li><li><code>sqstring</code> matches strings delimited by single quotes</li><li><code>btquote</code> matches strings delimited by backticks</li></ul><p><code>whitespace.ne</code> defines the grammar rules:</p><ul><li><code>_</code> matches zero or more whitespace characters.</li><li><code>__</code> matches one or more whitespace characters.</li></ul><p>To include these files in <code>.ne</code> grammar file, use the <code>@builtin</code> directive. For example, <code>@builtin &quot;whitespace.ne&quot;</code>.</p><h2 id="grammars" tabindex="-1">Grammars</h2><p>A grammar is a set of rules that define sequences of matching tokens. Each rule can optionally specify a result to produced.</p><h3 id="creating-a-grammar" tabindex="-1">Creating a Grammar</h3><p>Grammars are defined in text files with a <code>.ne</code> file extension. The first grammar rule defines the starting point. The remaining rules can appear in any order, including alphabetical.</p><p>Grammars can contain single-line comments that begin with the <code>#</code> character and extend to the end of the line.</p><p>The following is a fairly simple grammar defined in the file <code>arithmetic.ne</code>. It defines rules for arithmetic expressions that use the following operators:</p><ul><li><code>+</code> addition</li><li><code>-</code> subtraction</li><li><code>*</code> multiplication</li><li>'/' division</li></ul><p>This grammar supports standard operator precedence and using parentheses to override that.</p><pre class="language-js"><code class="language-js">@builtin <span class="token string">"number.ne"</span> # using decimal rule<br>@builtin <span class="token string">"whitespace.ne"</span> # using _ rule<br><br>start <span class="token operator">-</span><span class="token operator">></span> additive<br><br># Note the recursive references<span class="token punctuation">.</span><br>additive<br>  <span class="token operator">-</span><span class="token operator">></span> multiplicative _ <span class="token string">"+"</span> _ additive<br>   <span class="token operator">|</span> multiplicative _ <span class="token string">"-"</span> _ additive<br>   <span class="token operator">|</span> multiplicative<br><br>multiplicative<br>  <span class="token operator">-</span><span class="token operator">></span> term _ <span class="token string">"*"</span> _ multiplicative<br>   <span class="token operator">|</span> term _ <span class="token string">"/"</span> _ multiplicative<br>   <span class="token operator">|</span> term<br><br>term<br>  <span class="token operator">-</span><span class="token operator">></span> decimal<br>   <span class="token operator">|</span> <span class="token string">"("</span> additive <span class="token string">")"</span></code></pre><p>A grammar rule cannot be named &quot;null&quot; because that is a nearley keyword that represents the absence of a match.</p><p>A grammar file can include the contents of other grammar files using the <code>@include &quot;file-path&quot;</code> directive. This allows sharing common elements between top-level grammars including lexer configurations, function defintions, and grammar rules.</p><h3 id="compiling-a-grammar" tabindex="-1">Compiling a Grammar</h3><p>To compile a grammar to JavaScript code, use the <code>nearleyc</code> command. For example:</p><pre class="language-bash"><code class="language-bash">nearlyc arithmetic.ne <span class="token parameter variable">-o</span> arithmetic.js</code></pre><h3 id="testing-a-grammar" tabindex="-1">Testing a Grammar</h3><p>To test a grammar with specific input, use the <code>nearley-test</code> command. For example:</p><pre class="language-bash"><code class="language-bash">nearly-test arithmetic.js <span class="token parameter variable">-i</span> <span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span>",</code></pre><p>This outputs the following nested array which represents the parse tree. For this example, each occurrence of <code>null</code> represents whitespace which is not being captured.</p><pre class="language-text"><code class="language-text">[<br>  [<br>    [<br>      [<br>        [ 2 ], null, "*", null, [<br>          [ 3 ]<br>        ]<br>      ], null, "+", null, [<br>        [<br>          [ "(", [<br>              [<br>                [ 5 ]<br>              ], null, "+", null, [<br>                [<br>                  [ 1 ]<br>                ]<br>              ]<br>            ], ")" ], null, "/", null, [<br>            [ 2 ]<br>          ]<br>        ], null, "-", null, [<br>          [<br>            [ 4 ]<br>          ]<br>        ]<br>      ]<br>    ]<br>  ]<br>]</code></pre><p>This output is not particularly helpful. It does demonstrate that our grammar is correct.</p><p>Here is an example of supplying input that does not match the grammar.</p><pre class="language-bash"><code class="language-bash">nearley-test arithmetic-default.js <span class="token parameter variable">-i</span> <span class="token string">'1 + two'</span></code></pre><p>And here is the output with some parts elided because it is quite long.</p><pre class="language-text"><code class="language-text">/usr/local/lib/node_modules/nearley/lib/nearley.js:346<br>                throw err;<br>                ^<br>Error: Syntax error at line 1 col 5:<br><br>1 1 + two<br>      ^<br>Unexpected "t". Instead, I was expecting to see one of the following:<br><br>A character matching /[ \t\n\v\f]/ based on:<br>    ...<br>A "(" based on:<br>    ...<br>A "-" based on:<br>    ...<br>A character matching /[0-9]/ based on:<br>    ...<br>  offset: 4,<br>  token: { value: 't' }</code></pre><h2 id="postprocessors" tabindex="-1">Postprocessors</h2><p>Each rule can be followed by JavaScript code that is executed when the rule is matched. The code must be delimited by <code>{%</code> and <code>%}</code>.</p><p>It must contain the name of a predefined function or a function definition (typically written as an arrow function).</p><p>The function is passed three values:</p><ul><li><code>data</code> - array containing the parsed result for each matching token</li><li><code>location</code> - zero-based index into the input string where the match began</li><li><code>reject</code> - object that can be returned to indicate that the rule should not match</li></ul><p>Typically only the first argument, <code>data</code> is used and often the name is shortened to just <code>d</code>.</p><h3 id="postprocessor-rules-for-evaluating" tabindex="-1">Postprocessor Rules for Evaluating</h3><p>Let's add postprocessing the previous grammar so that it evaluates each rule to a number. The value of the starting rule will be the value of the entire input expression.</p><pre class="language-js"><code class="language-js">@builtin <span class="token string">"number.ne"</span> # using decimal rule<br>@builtin <span class="token string">"whitespace.ne"</span> # using _ rule<br><br>start <span class="token operator">-</span><span class="token operator">></span> additive <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>additive<br>  <span class="token operator">-</span><span class="token operator">></span> multiplicative _ <span class="token string">"+"</span> _ additive <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> multiplicative _ <span class="token string">"-"</span> _ additive <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>multiplicative<br>  <span class="token operator">-</span><span class="token operator">></span> term _ <span class="token string">"*"</span> _ multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> term _ <span class="token string">"/"</span> _ multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> term <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>term<br>  <span class="token operator">-</span><span class="token operator">></span> decimal <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> <span class="token string">"("</span> additive <span class="token string">")"</span> <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> <span class="token function">Number</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><p>Running the following command:</p><pre class="language-bash"><code class="language-bash">nearly-test arithmetic.js <span class="token parameter variable">-i</span> <span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span>",</code></pre><p>outputs the expected value in an array which is <code>[ 5 ]</code>.</p><h3 id="postprocessor-rules-for-ast-building" tabindex="-1">Postprocessor Rules for AST Building</h3><p>Let's modify the postprocessing so the result is an abstract syntax tree (AST).</p><p>ASTs are trees of objects describe the results of parsing input text. They can be useful for compiling one syntax into another. For example, we could parse code written in Smalltalk and output corresponding JavaScript code.</p><p>Arbitrary JavaScript code can be included in a grammar by delimiting it with <code>@{%</code> and <code>%}</code>. Often this is used to define functions that are used in postprocessing rules. It can also be used to customize the lexer. Any number of these blocks can appear and they can be placed anywhere within the grammar file. There definitions will be hoisted to the top of the generated parser code regardless of where they appear in the grammar file.</p><p>The provided <code>id</code> function returns the first element from the data array. It is equivalent to <code>d =&gt; d[0]</code>.</p><pre class="language-js"><code class="language-js">@<span class="token punctuation">{</span><span class="token operator">%</span><br><span class="token keyword">function</span> <span class="token function">binaryOperation</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token punctuation">{</span><br>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">"binary operation"</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">operator</span><span class="token operator">:</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">left</span><span class="token operator">:</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">right</span><span class="token operator">:</span> data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token operator">%</span><span class="token punctuation">}</span><br><br>@builtin <span class="token string">"number.ne"</span> # using decimal rule<br>@builtin <span class="token string">"whitespace.ne"</span> # using _ rule<br><br>start <span class="token operator">-</span><span class="token operator">></span> additive <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>additive<br>  <span class="token operator">-</span><span class="token operator">></span> multiplicative _ <span class="token punctuation">[</span><span class="token operator">+</span><span class="token operator">-</span><span class="token punctuation">]</span> _ additive <span class="token punctuation">{</span><span class="token operator">%</span> binaryOperation <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>multiplicative<br>  <span class="token operator">-</span><span class="token operator">></span> term _ <span class="token punctuation">[</span><span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">]</span> _ multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> binaryOperation <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> term <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>term<br>  <span class="token operator">-</span><span class="token operator">></span> decimal <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> <span class="token string">"("</span> additive <span class="token string">")"</span> <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">data</span> <span class="token operator">=></span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><p>Running the following command:</p><pre class="language-bash"><code class="language-bash">nearly-test arithmetic.js <span class="token parameter variable">-i</span> <span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span>",</code></pre><p>outputs the following AST:</p><pre class="language-text"><code class="language-text">[<br>  {<br>    type: "binary operation",<br>    operator: "+",<br>    left: {<br>      type: "binary operation",<br>      operator: "*",<br>      left: 2,<br>      right: 3,<br>    },<br>    right: {<br>      type: "binary operation",<br>      operator: "-",<br>      left: {<br>        type: "binary operation",<br>        operator: "/",<br>        left: {<br>          type: "binary operation",<br>          operator: "+",<br>          left: 5,<br>          right: 1<br>        },<br>        right: 2<br>      }<br>      right: 4,<br>    },<br>  }<br>]</code></pre><p>The following JavaScript function takes a node from this AST and computes its result. If it is passed the root node above, it returns the expected result of <code>5</code>.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">evaluateAstNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> <span class="token punctuation">{</span>left<span class="token punctuation">,</span> operator<span class="token punctuation">,</span> right<span class="token punctuation">}</span> <span class="token operator">=</span> node<span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> left <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> left <span class="token operator">=</span> <span class="token function">evaluateAstNode</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> right <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> right <span class="token operator">=</span> <span class="token function">evaluateAstNode</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>operator<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> left <span class="token operator">-</span> right<span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> left <span class="token operator">*</span> right<span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> left <span class="token operator">/</span> right<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><h2 id="using-ebnf-modifiers" tabindex="-1">Using EBNF modifiers</h2><p>One way implement a rule that matches a repeated sequence of tokens is to use a recursive approach. Another way is to use Extended Backus-Naur Form (EBNF) modifiers which include:</p><ul><li><code>:?</code> optional (zero or one)</li><li><code>:*</code> zero or more</li><li><code>:+</code> one or more</li></ul><p>The grammar below shows both approaches with the recursive approach commented out and the corresponding EBNF approach uncommented. It matches a sequence of words separated by any amount of whitespace.</p><pre class="language-js"><code class="language-js">@builtin <span class="token string">"whitespace.ne"</span><br><br># Recursive technique<br>#words<br>#  <span class="token operator">-</span><span class="token operator">></span> word <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br>#   <span class="token operator">|</span> word __ words <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>#       <span class="token keyword">return</span> d<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">word</span> <span class="token operator">=></span> word <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>#     <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token punctuation">}</span><br><br># <span class="token constant">EBNF</span> technique<br>words <span class="token operator">-</span><span class="token operator">></span> <span class="token function">word</span> <span class="token punctuation">(</span>__ word<span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">*</span> <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> d<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">word</span> <span class="token operator">=></span> word <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token operator">%</span><span class="token punctuation">}</span><br><br># Recursive technique<br>#word<br>#  <span class="token operator">-</span><span class="token operator">></span> letter <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br>#   <span class="token operator">|</span> letter word <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token punctuation">}</span><br><br># <span class="token constant">EBNF</span> technique<br>word <span class="token operator">-</span><span class="token operator">></span> letter<span class="token operator">:</span><span class="token operator">+</span> <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token punctuation">}</span><br><br># The id <span class="token keyword">function</span> is equivalent to <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><br>letter <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token constant">A</span><span class="token operator">-</span>Za<span class="token operator">-</span>z<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><p>To test this, enter something like the following:</p><pre class="language-bash"><code class="language-bash">nearley-test ./ebnf-demo.js <span class="token parameter variable">-i</span> <span class="token string">'apple banana cherry'</span></code></pre><p>This outputs <code>[ [ 'apple', 'banana', 'cherry' ] ]</code> indicating that there was one result that is an array of the three words.</p><h2 id="using-a-grammar-from-javascript-code" tabindex="-1">Using a Grammar from JavaScript Code</h2><p>The compiled parser code can be used from a JavaScript program. This works in both server-side code and browser code.</p><p>The following example uses the previous grammar to produce an AST. It then uses the <code>evaluateAstNode</code> function above to compute the result.</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> nearley <span class="token keyword">from</span> <span class="token string">'nearley'</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> grammar <span class="token keyword">from</span> <span class="token string">'./arithmetic.js'</span><span class="token punctuation">;</span> <span class="token comment">// compiled grammar</span><br><br><span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">nearley<span class="token punctuation">.</span>Parser</span><span class="token punctuation">(</span>nearley<span class="token punctuation">.</span>Grammar<span class="token punctuation">.</span><span class="token function">fromCompiled</span><span class="token punctuation">(</span>grammar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> input <span class="token operator">=</span> <span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span><span class="token punctuation">;</span> <span class="token comment">// expect 5</span><br><br><span class="token keyword">try</span> <span class="token punctuation">{</span><br>  parser<span class="token punctuation">.</span><span class="token function">feed</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// parser.results is an array because there</span><br>  <span class="token comment">// can be more than one way to parse given input.</span><br>  <span class="token comment">// There is more than one element,</span><br>  <span class="token comment">// the grammar is considered to be ambiguous.</span><br>  <span class="token comment">// Often only the first element is of interest.</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">evaluateAstNode</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span>results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="railroad-diagrams" tabindex="-1">Railroad Diagrams</h2><p>To generate a railroad diagram from a grammar, use the <code>nearley-railroad</code> command. For example, <code>nearly-railroad my-grammar.ne -o my-grammar.html</code>. To view the diagram, open the generated <code>.html</code> in any web browser.</p><p>Here is the railroad diagram for our arithmetic grammar:</p><p><img alt="nearley Railroad Diagram" style="width: 60%" src="/blog/assets/nearley-railroad-diagram.png?v=1.1.1"></p><h2 id="unparsing" tabindex="-1">Unparsing</h2><p>The <code>nearly-unparse</code> command takes a compiled grammar (<code>.js</code> file) and generates an input string that matches the grammar. Running it multiple times will produce different results.</p><p>By default it begins at the first rule, but any rule can be specified with the <code>-s</code> flag.</p><p>By default there is no limit to how deeply it will search through the rules to generate matching input. This can be quite slow. To limit the search, specify the <code>-d</code> option with a value like <code>500</code>.</p><p>For example, the following command generates matching input for our arithmetic grammar:</p><pre class="language-bash"><code class="language-bash">nearley-unparse <span class="token parameter variable">-d</span> <span class="token number">200</span> arithmetic-ast.js</code></pre><p>This produces results like the following:</p><pre class="language-text"><code class="language-text">-48.6<br>((20802.1530))<br>(((-3)))</code></pre><p>I could not get this to generate any matching input that contained an arithmetic operator. Color me unimpressed.</p><h2 id="customizing-the-lexer" tabindex="-1">Customizing the Lexer</h2><p>Let's modify our arithmetic grammar to support single-line comments that begin with the <code>#</code> character and extend to the end of the line. This requires modifying the lexer because by default the lexer discards all newline characters. We need to consider newline characters to know when a comment ends.</p><p>Here is an example of input that includes single-line comments. Like before, evaluating this should produce the result <code>5</code>.</p><pre class="language-text"><code class="language-text"># first term<br>2 * 3 +<br># middle term<br>(5 + 1) / 2 -<br># last term<br>4</code></pre><p>The following grammar customizes the lexer. This grammar differs from previous ones we have seen in that:</p><ul><li>We don't need the builtins <code>number.ne</code> and <code>whitespace.ne</code> because the lexer takes care of those concerns.</li><li>We don't have to account for whitespace or comments in the grammar rules because the lexer removes all tokens that represent them.</li><li>The tokens defined in the lexer are referred to in the grammar with a <code>%</code> prefix.</li></ul><pre class="language-js"><code class="language-js">@<span class="token punctuation">{</span><span class="token operator">%</span><br>  <span class="token keyword">const</span> moo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'moo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">const</span> lexer <span class="token operator">=</span> moo<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>    <span class="token literal-property property">add</span><span class="token operator">:</span> <span class="token string">'+'</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">comment</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">#[^\n]*\n</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><br>    <span class="token literal-property property">divide</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">lparen</span><span class="token operator">:</span> <span class="token string">'('</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">multiply</span><span class="token operator">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">0|[1-9][0-9]*(?:.[0-9]+)?</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><br>    <span class="token literal-property property">rparen</span><span class="token operator">:</span> <span class="token string">')'</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">subtract</span><span class="token operator">:</span> <span class="token string">'-'</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">ws</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">match</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[ \n\t]+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token literal-property property">lineBreaks</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Redefine the lexer next function to skip certain tokens.</span><br>  <span class="token keyword">const</span> originalNext <span class="token operator">=</span> lexer<span class="token punctuation">.</span>next<span class="token punctuation">;</span><br>  lexer<span class="token punctuation">.</span><span class="token function-variable function">next</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">originalNext</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>token<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// end of tokens</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span>type <span class="token operator">!==</span> <span class="token string">'ws'</span> <span class="token operator">&amp;&amp;</span> token<span class="token punctuation">.</span>type <span class="token operator">!==</span> <span class="token string">'comment'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">//console.log('token =', token);</span><br>        <span class="token keyword">return</span> token<span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token operator">%</span><span class="token punctuation">}</span><br><br>@lexer lexer<br><br>start <span class="token operator">-</span><span class="token operator">></span> additive <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>additive<br>  <span class="token operator">-</span><span class="token operator">></span> multiplicative <span class="token operator">%</span>add additive <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> multiplicative <span class="token operator">%</span>subtract additive <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>multiplicative<br>  <span class="token operator">-</span><span class="token operator">></span> term <span class="token operator">%</span>multiply multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> term <span class="token operator">%</span>divide multiplicative <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> term <span class="token punctuation">{</span><span class="token operator">%</span> id <span class="token operator">%</span><span class="token punctuation">}</span><br><br>term<br>  <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">%</span>number <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> <span class="token function">Number</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token punctuation">}</span><br>   <span class="token operator">|</span> <span class="token operator">%</span>lparen additive <span class="token operator">%</span>rparen <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token parameter">d</span> <span class="token operator">=></span> <span class="token function">Number</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><h2 id="unit-tests" tabindex="-1">Unit Tests</h2><p>It's a good idea to create a suite of unit tests for each grammar that verifies that it correctly parses a collection of input strings. Here's an example that uses the <code>vitest</code> testing library.</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> nearley <span class="token keyword">from</span> <span class="token string">'nearley'</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> <span class="token punctuation">{</span>describe<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> it<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vitest'</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> compiledGrammar <span class="token keyword">from</span> <span class="token string">'./arithmetic-eval.js'</span><span class="token punctuation">;</span><br><br><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'parser'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> grammar <span class="token operator">=</span> nearley<span class="token punctuation">.</span>Grammar<span class="token punctuation">.</span><span class="token function">fromCompiled</span><span class="token punctuation">(</span>compiledGrammar<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'evaluates expression 1'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token comment">// Each test requires a new Parser instance.</span><br>    <span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">nearley<span class="token punctuation">.</span>Parser</span><span class="token punctuation">(</span>grammar<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    parser<span class="token punctuation">.</span><span class="token function">feed</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">expect</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span>results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'evaluates expression 2'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">nearley<span class="token punctuation">.</span>Parser</span><span class="token punctuation">(</span>compiledGrammar<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    parser<span class="token punctuation">.</span><span class="token function">feed</span><span class="token punctuation">(</span><span class="token string">'2 * 3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">expect</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span>results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'evaluates expression 3'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">nearley<span class="token punctuation">.</span>Parser</span><span class="token punctuation">(</span>compiledGrammar<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    parser<span class="token punctuation">.</span><span class="token function">feed</span><span class="token punctuation">(</span><span class="token string">'2 * 3 + (5 + 1) / 2 - 4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">expect</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span>results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The file above is named <code>arithmetic-eval.test.js</code>. The npm script <code>&quot;test&quot;: &quot;vitest&quot;,</code> will run all the tests fond in files whose extension is <code>.test.js</code> or <code>.test.ts</code>.</p><h2 id="compiling-to-typescript" tabindex="-1">Compiling to TypeScript</h2><p>By default the nearley compiler generates JavaScript code for the parser. To change this to TypeScript:</p><ul><li>Add the <code>@preprocessor typescript</code> directive in the grammar file.</li><li>Change references to the generatred parser file to use the <code>.ts</code> file extension instead of <code>.js</code>.</li></ul><h2 id="example-grammars" tabindex="-1">Example Grammars</h2><p>All of the example code shown above can be found in the GitHub repository <a href="https://github.com/mvolkmann/nearley-demos" target="_blank">nearley-demos</a>.</p><p>Many example grammars can be found in the nearley GitHub repository. See <a href="https://github.com/kach/nearley/tree/master/examples" target="_blank">examples</a>.</p></article>