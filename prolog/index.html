<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Prolog</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#resources">Resources</a></li><li><a href="#implementations">Implementations</a><ol><li><a href="#swi-prolog">SWI-Prolog</a></li><li><a href="#gnu-prolog">GNU Prolog</a></li><li><a href="#scryer-prolog">Scryer Prolog</a></li></ol></li><li><a href="#online-repl">Online REPL</a></li><li><a href="#exiting">Exiting</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#syntax">Syntax</a><ol><li><a href="#facts">Facts</a></li><li><a href="#rules">Rules</a></li></ol></li><li><a href="#queries">Queries</a></li><li><a href="#conjunctions">Conjunctions</a></li><li><a href="#typical-flow">Typical Flow</a></li><li><a href="#data-structures">Data Structures</a><ol><li><a href="#lists">Lists</a></li><li><a href="#pairs">Pairs</a></li><li><a href="#dicts">Dicts</a></li></ol></li><li><a href="#dynamic-predicates">Dynamic Predicates</a></li><li><a href="#input">Input</a></li><li><a href="#output">Output</a></li><li><a href="#special-characters">Special Characters</a></li><li><a href="#naming-conventions">Naming Conventions</a></li><li><a href="#operators">Operators</a></li><li><a href="#strings">Strings</a></li><li><a href="#arithmetic-functions">Arithmetic Functions</a></li><li><a href="#conditional-logic">Conditional Logic</a></li><li><a href="#iteration">Iteration</a></li><li><a href="#lists-1">Lists</a></li><li><a href="#help">Help</a></li><li><a href="#listing">Listing</a></li><li><a href="#debugging">Debugging</a></li><li><a href="#structures">Structures</a></li><li><a href="#calling-from-other-languages">Calling From Other Languages</a></li><li><a href="#efficiency">Efficiency</a></li><li><a href="#constraint-logic-programming-over-finite-domains%3A-clp(fd)">Constraint Logic Programming over Finite Domains: CLP(FD)</a></li><li><a href="#language-server">Language Server</a></li><li><a href="#libraries">Libraries</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p>Prolog is a logic-based programming language. The name is a contraction of &quot;programming in logic&quot;. It uses a declarative syntax rather than a procedural one.</p><p>A core feature of Prolog is pattern matching search with backtracking, also referred to as &quot;unification&quot;. This is the process of searching a set of facts and rules (called a database) to find values that match a given predicate. Prolog is highly optimized to handle searching large databases.</p><p>Prolog has many uses including artificial intelligence, abstract problem solving, symbolic equation solving, and more.</p><p>Prolog first appeared in 1972. It was designed by three computer scientists, Alain Colmerauer (France), Phillipe Roussel (France), and Robert Kowalski (USA/Britain).</p><p>&quot;IBM Watson is a question-answering computer system capable of answering questions posed in natural language.&quot; It is partially implemented in Prolog.</p><p>The Prolog unification process relies on the properties of <a href="https://en.wikipedia.org/wiki/Horn_clause?v=1.0.21" rel="noopener" target="_blank">Horn clauses</a>.</p><h2 id="resources" tabindex="-1">Resources</h2><ul><li><p><a href="http://www.gprolog.org?v=1.0.21" rel="noopener" target="_blank">GNU Prolog</a></p></li><li><p><a href="https://www.iso.org/standard/21413.html?v=1.0.21" rel="noopener" target="_blank">ISO Standard for Prolog</a></p></li><li><p><a href="https://www.metalevel.at/prolog?v=1.0.21" rel="noopener" target="_blank">The Power of Prolog</a> free, online book by <a href="https://www.metalevel.at?v=1.0.21" rel="noopener" target="_blank">Markus Triska</a></p></li><li><p><a href="https://link.springer.com/book/10.1007/978-3-642-55481-0?v=1.0.21" rel="noopener" target="_blank">Programming in Prolog</a> Fifth edition book by Clocksin and Mellish</p></li><li><p><a href="https://www.swi-prolog.org?v=1.0.21" rel="noopener" target="_blank">SWI-Prolog</a></p></li><li><p><a href="https://www.linuxlinks.com/excellent-free-books-learn-prolog/?v=1.0.21" rel="noopener" target="_blank">13 Excellent Free Books to Learn Prolog</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Prolog?v=1.0.21" rel="noopener" target="_blank">Wikipedia</a></p></li></ul><h2 id="implementations" tabindex="-1">Implementations</h2><p>There are many implementations of the Prolog programming language. The most popular seems to be <a href="https://www.swi-prolog.org?v=1.0.21" rel="noopener" target="_blank">SWI-Prolog</a>. Another option is <a href="http://www.gprolog.org?v=1.0.21" rel="noopener" target="_blank">GNU Prolog</a>.</p><p>Both SWI-Prolog and GNU Prolog conform to the ISO standard and both were being actively maintained as of June 2023.</p><h3 id="swi-prolog" tabindex="-1">SWI-Prolog</h3><p><img alt="SWI-Prolog logo" style="width: 20%" src="/blog/assets/swipl-logo.png?v=1.0.21" title="SWI-Prolog logo"></p><blockquote><p>SWI-Prolog offers a comprehensive free Prolog environment. Since its start in 1987, SWI-Prolog development has been driven by the needs of real world applications. SWI-Prolog is widely used in research and education as well as commercial applications.&quot;</p></blockquote><blockquote><p>Its main author is Jan Wielemaker. The name SWI is derived from Sociaal-Wetenschappelijke Informatica (&quot;Social Science Informatics&quot;), the former name of the group at the University of Amsterdam, where Wielemaker is employed.</p></blockquote><p>SWI-Prolog is implemented in a combination of C (48%) and Prolog (39%).</p><p>To install the terminal command <code>swipl</code> in macOS, enter <code>brew install swi-prolog</code></p><p>To run SWI-Prolog from a terminal, enter <code>swipl</code>.</p><h3 id="gnu-prolog" tabindex="-1">GNU Prolog</h3><p><img alt="GNU Prolog logo" style="width: 20%" src="/blog/assets/gnu-prolog-logo.png?v=1.0.21" title="GNU Prolog logo"></p><p>GNU Prolog is implemented in a combination of C (84%) and Prolog (15%).</p><p>To install the terminal command <code>gprolog</code> in macOS, enter <code>brew install gnu-prolog</code>.</p><p>To run GNU Prolog from a terminal, enter <code>gprolog</code>.</p><h3 id="scryer-prolog" tabindex="-1">Scryer Prolog</h3><p><a href="https://www.scryer.pl?v=1.0.21" rel="noopener" target="_blank">Scryer Prolog</a> &quot;is a free software ISO Prolog system intended to be an industrial strength production environment and a testbed for bleeding edge research in logic and constraint programming.&quot;</p><p>Scryer Prolog is implemented in a combination of Rust (64%) and Prolog (36%).</p><p>To install, enter the following commands:</p><pre class="language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/mthom/scryer-prolog<br><span class="token builtin class-name">cd</span> scryer-prolog<br><span class="token function">curl</span> https://sh.rustup.rs <span class="token parameter variable">-sSf</span> <span class="token operator">|</span> <span class="token function">sh</span> <span class="token comment"># if cargo is not yet installed</span><br><span class="token function">cargo</span> build <span class="token parameter variable">--release</span></code></pre><p>This creates the executable file <code>target/release/scryer-prolog</code>. Define an alias to make this easier to run.</p><h2 id="online-repl" tabindex="-1">Online REPL</h2><p>To enter and run Prolog code in a web browser, browse <a href="https://swish.swi-prolog.org?v=1.0.21" rel="noopener" target="_blank">SWISH</a>.</p><p>Enter facts and rules in the left pane. Enter a query in the lower-right pane. Press the &quot;Run!&quot; button or ctrl-return to execute the query.</p><h2 id="exiting" tabindex="-1">Exiting</h2><p>To exit from any Prolog interpreter, enter <code>halt.</code> or press ctrl-d.</p><h2 id="terminology" tabindex="-1">Terminology</h2><p>| Term | Meaning | | ----------------- | --------------------------------------------------------------- | --- | | term | the only datatype; has four subtypes listed below | | - number | integer or floating point | | - atom | identifier that represents a specific thing | | - variable | represents a value to be determined | | - compound term | specific combination of terms; more detail below | | fact | description of something that is true | | rule | relationship involving one or more unknown things (variables) | | predicate | a fact or rule | | clause | another name for a predicate | | query | asks if a clause is true or asks for satisfying variable values | | database | collection of predicates | | functor name | name of a predicate | | arity | number of predicate arguments | | functor | function name and its arity; written with a slash between | | list notation | comma-separated terms inside square brackets; ex. <code>[a, B, 7]</code> | | operator notation | terms separated by operators; ex. <code>Y = m\*X + b</code> | | unification | process of searching for variable values that satisfy a rule | | choice point | represents a choice in the search for a solution | |</p><p>A compound term is a functor name followed by an argument list. Each argument can be an atom, a variable, a destructuring of variables, or another compound term. Nested compound terms can be represented by a tree structure.</p><p>A rule can be thought of as a special kind of fact that depends on a set of other facts.</p><p>Numbers can include underscores for readability. For example, <code>1_234_567</code> makes it more clear that this number is greater than one million.</p><p>The functor for <code>foo(bar, baz)</code> is written as <code>foo/2</code>.</p><p>For more, see <a href="https://www.swi-prolog.org/pldoc/man?section=glossary?v=1.0.21" rel="noopener" target="_blank">Glossary of Terms</a>.</p><h2 id="syntax" tabindex="-1">Syntax</h2><p>Prolog programs are composed of facts, rules, and queries. All of these are terminated by a period.</p><h3 id="facts" tabindex="-1">Facts</h3><p>A fact states that some relationship is always true.</p><p>A fact is written as a functor (atom) followed by an argument list that is surrounded by parentheses. The argument list contains only atoms, not variables.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">runner</span><span class="token punctuation">(</span>mark<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% says mark is a runner</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> prolog<span class="token punctuation">)</span> <span class="token comment">% says mark likes prolog</span></code></pre><p>These are facts that say comet is a whippet and spots is a cheetah:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">whippet</span><span class="token punctuation">(</span>comet<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">cheetah</span><span class="token punctuation">(</span>spots<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h3 id="rules" tabindex="-1">Rules</h3><p>A rule is written as a head and a body separated by the &quot;if&quot; symbol <code>:-</code> and terminated by a period.</p><p>The head is a functor (atom) followed by an argument list that is surrounded by parentheses. The head syntax is similar to that of a fact, but its argument list can contain variables.</p><p>The body is a comma (means &quot;and&quot;) or semicolon (means &quot;or&quot;) separated list of goals.</p><p>The following rules state that if something is a whippet or a cheetah then it is fast.</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">fast</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">whippet</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">fast</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">cheetah</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% The previous two lines can be replaced with this.</span><br><span class="token comment">% fast(X) :- cheetah(X); whippet(X).</span></code></pre><p>A fact is a degenerate case of a rule whose body only contains <code>true</code>. For example, the following are equivalent:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> ice<span class="token operator">-</span>cream<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> ice<span class="token operator">-</span>cream<span class="token punctuation">)</span> <span class="token operator">:-</span> true<span class="token operator">.</span></code></pre><p>The following rules define what it means for two people to be siblings or sisters.</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This states that siblings must have the same father and the same mother.</span><br><span class="token function">sibling</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">father</span><span class="token punctuation">(</span>F<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">father</span><span class="token punctuation">(</span>F<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">mother</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">mother</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">sister_of</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token operator">\+</span> X <span class="token operator">=</span> Y<span class="token punctuation">,</span> <span class="token comment">% can't be sister of self</span><br>  <span class="token function">female</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">sibling</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Rules do not return values like a function, but they can set the values of their arguments.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">area</span><span class="token punctuation">(</span>circle<span class="token punctuation">,</span> Radius<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> X <span class="token operator">is</span> pi <span class="token operator">*</span> Radius<span class="token operator">^</span><span class="token number">2.</span><br><span class="token function">area</span><span class="token punctuation">(</span>square<span class="token punctuation">,</span> Side<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> X <span class="token operator">is</span> Side<span class="token operator">^</span><span class="token number">2.</span><br><span class="token function">area</span><span class="token punctuation">(</span>rectangle<span class="token punctuation">,</span> Width<span class="token punctuation">,</span> Height<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> X <span class="token operator">is</span> Width <span class="token operator">*</span> Height<span class="token operator">.</span><br><br><span class="token operator">?-</span> <span class="token function">area</span><span class="token punctuation">(</span>circle<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token number">12.566370614359172</span><span class="token operator">.</span></code></pre><p>TODO: See the version of the area rule that uses clpr in <a href="http://geometry.pl">geometry.pl</a>.</p><p>Each of the <code>area</code> rules uses the <code>is</code> keyword to assign a value to the X argument.</p><p>Rules can be recursive. See the <code>sum</code> example above.</p><h2 id="queries" tabindex="-1">Queries</h2><p>Queries test whether a clause is true or they find variable values for which the clause is true. Queries are written after the characters <code>?-</code>.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This is a query that asks whether comet is fast.</span><br><span class="token operator">?-</span> <span class="token function">fast</span><span class="token punctuation">(</span>comet<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% true</span><br><br><span class="token comment">% This is a query that asks for something that is fast.</span><br><span class="token operator">?-</span> <span class="token function">fast</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% comet</span></code></pre><p>Suppose the following facts are loaded:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> tacos<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> books<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> running<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The query <code>likes(X, running)</code> will find &quot;mark&quot;.</p><p>The query <code>likes(mark, X)</code> will find &quot;tacos&quot;, &quot;books&quot;, and &quot;running&quot; that in that order. When a query has multiple matches, as in this example, the interpreter will wait for further input.</p><p>To search for the next match, press the semicolon key. (SWI-Prolog also supports pressing the n, r, space, or tab keys to do this.)</p><p>To stop searching for matches before the last one is found, press the return key. (SWI-Prolog also supports pressing the c or a keys to do this.)</p><p>After the last match is found, a prompt for the next query will appear.</p><p>Variables can be used for any argument of a predicate. For example, the built-in predicate <code>append</code> appends two lists to create a new list.</p><p>If this were not built-in, it could be implemented as follows:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% Appending an empty list to any list gives the second list.</span><br><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Appending two lists is the same as appending</span><br><span class="token comment">% the head of the first list (H) to the result of appending</span><br><span class="token comment">% the tail of the first list (L1) to the second list (L2).</span><br><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>L1<span class="token punctuation">]</span><span class="token punctuation">,</span> L2<span class="token punctuation">,</span> <span class="token punctuation">[</span>H<span class="token operator">|</span>L3<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">append</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> L3<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Here are several examples of how <code>append</code> can be used:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% Is the result of appending two lists a given result list?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>true<span class="token operator">.</span><br><br><span class="token comment">% What is the result of appending two lists?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token comment">% What list must be appended to a given list to obtain a given result?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token comment">% What list must be prepended to a given list to obtain a given result?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><br><br><span class="token comment">% What lists can be appended to obtain a given result?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">;</span></code></pre><h2 id="conjunctions" tabindex="-1">Conjunctions</h2><p>The comma operator is used to form rules and queries where multiple goals must be met. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This rule says that mark likes females that like cycling.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token function">female</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">likes</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> cycling<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This query asks if mark loves tami AND tami loves mark.</span><br><span class="token operator">?-</span> <span class="token function">loves</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> tami<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">loves</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> mark<span class="token punctuation">)</span>`<br><br><span class="token comment">% This query searches for things that both mark and tami love.</span><br><span class="token comment">% X stands for the same value in both goals.</span><br><span class="token operator">?-</span> <span class="token function">loves</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">loves</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> X<span class="token punctuation">)</span></code></pre><h2 id="typical-flow" tabindex="-1">Typical Flow</h2><p>The typical steps to run a Prolog program are:</p><ol><li>Add facts and rules to a Prolog source file that has an extension of <code>.pl</code></li><li>Load Prolog source files into the Prolog app.</li><li>Enter queries in the Prolog app.</li></ol><p>Unfortunately Prolog and Perl use the same file extension for their source files.</p><p>To load a <code>.pl</code> file, enter <code>[file-name].</code> or <code>consult('file-name').</code> For example, to load the file <code>demo.pl</code>, <code>enter [demo].</code> Alternatively, pass a source file to the interpreter when starting it. For example, <code>swipl demo.pl</code></p><p>After modifying source files that have already been loaded, enter <code>make.</code> to reload all of them.</p><p>To enter new facts and rules in a running session:</p><ul><li>Enter <code>[user].</code> to open stdin as a pseudo file.</li><li>Enter facts and rules.</li><li>Press ctrl-d to close and load the pseudo file.</li></ul><p>It seems this can replace existing facts rather than add to them.</p><h2 id="data-structures" tabindex="-1">Data Structures</h2><p>ISO Prolog supports two data structures, lists and pairs.</p><p>SWI-Prolog also supports dicts (a.k.a dictionaries). See <a href="https://eu.swi-prolog.org/pldoc/man?section=bidicts?v=1.0.21" rel="noopener" target="_blank">Dicts: structures with named arguments</a>.</p><h3 id="lists" tabindex="-1">Lists</h3><p>TODO: Add detail here.</p><h3 id="pairs" tabindex="-1">Pairs</h3><p>A Prolog &quot;pair&quot; is a key and a value. There are two ways to write a pair, <code>k-v</code> or <code>-(k, v)</code>.</p><p>A list of pairs can be sorted using <code>keysort</code>. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">keysort</span><span class="token punctuation">(</span><span class="token punctuation">[</span>c<span class="token operator">-</span>cow<span class="token punctuation">,</span> b<span class="token operator">-</span>bear<span class="token punctuation">,</span> a<span class="token operator">-</span>apple<span class="token punctuation">]</span><span class="token punctuation">,</span> Ps<span class="token punctuation">)</span><span class="token operator">.</span><br>Ps <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token operator">-</span>apple<span class="token punctuation">,</span> b<span class="token operator">-</span>bear<span class="token punctuation">,</span> c<span class="token operator">-</span>cow<span class="token punctuation">]</span><span class="token operator">.</span></code></pre><p>TODO: Add detail here.</p><p>The following code implements rules to determine if a queen on a chess board can attach another piece.</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">queen_can_attack</span><span class="token punctuation">(</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>R<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">queen_can_attack</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">queen_can_attack</span><span class="token punctuation">(</span><span class="token punctuation">(</span>R1<span class="token punctuation">,</span> C1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>R2<span class="token punctuation">,</span> C2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">abs</span><span class="token punctuation">(</span>R1 <span class="token operator">-</span> R2<span class="token punctuation">)</span> <span class="token operator">=:=</span> <span class="token function">abs</span><span class="token punctuation">(</span>C1 <span class="token operator">-</span> C2<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>See <a href="https://eu.swi-prolog.org/pldoc/man?section=pairs?v=1.0.21" rel="noopener" target="_blank">library(pairs): Operations on key-value lists</a>.</p><h3 id="dicts" tabindex="-1">Dicts</h3><p>TODO: Add detail here.</p><h2 id="dynamic-predicates" tabindex="-1">Dynamic Predicates</h2><p>By default predicates cannot be added or deleted in a session. To enable this, run a <code>dynamic</code> query on a specific predicate. Once this is done, a predicate of that type can be added to the beginning with <code>asserta</code> or added to the end with <code>assertz</code>. And predicates of that type can be removed with the <code>retract</code> and <code>retractall</code> functions.</p><p>For example, suppose we have the file <code>likes.pl</code> containing the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% Enable adding and removing "likes" predicates that take two arguments.</span><br><span class="token operator">:-</span> <span class="token function">dynamic</span><span class="token punctuation">(</span><span class="token function">likes/2</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> books<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> running<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>A session can do the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token punctuation">[</span>likes<span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token operator">?-</span> <span class="token function">assertz</span><span class="token punctuation">(</span><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> reeces<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% adds after existing predicates</span><br><span class="token operator">?-</span> <span class="token function">retract</span><span class="token punctuation">(</span><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> books<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% removes</span><br><span class="token operator">?-</span> <span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% outputs running and reeces</span><br><br><span class="token operator">?-</span> <span class="token function">retractall</span><span class="token punctuation">(</span><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% removes everything that mark likes</span><br><span class="token operator">?-</span> <span class="token function">retractall</span><span class="token punctuation">(</span><span class="token function">likes</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% removes everything that anybody likes</span><br><span class="token operator">?-</span> <span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% outputs nothing</span></code></pre><h2 id="input" tabindex="-1">Input</h2><p>The <code>read</code> function reads a string from stdin. For example:</p><pre class="language-prolog"><code class="language-prolog">greet <span class="token operator">:-</span><br>  <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Enter your name: '</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">read</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Hello, ~w!'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Enter a name in single or double quotes followed by a period. This is an odd requirement for users! Entering 'Mark'. results in the following output: <code>Hello, Mark!</code>.</p><p>The <code>get</code> function reads a single character and sets a variable to its integer ASCII value.</p><p>To read from a file and write the contents to stdout, use the <code>open</code>, <code>get_char</code>, and <code>close</code> functions. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">processStream</span><span class="token punctuation">(</span>end_of_file<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token operator">!.</span> <span class="token comment">% a "cut" that stops execution</span><br><br><span class="token function">processStream</span><span class="token punctuation">(</span>Char<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">write</span><span class="token punctuation">(</span>Char<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">get_char</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> NextChar<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">processStream</span><span class="token punctuation">(</span>NextChar<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">readFile</span><span class="token punctuation">(</span>File<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">open</span><span class="token punctuation">(</span>File<span class="token punctuation">,</span> read<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">get_char</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> Char<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">processStream</span><span class="token punctuation">(</span>Char<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">close</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'demo.txt'</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>TODO: Is there an open source library that provides a similar function TODO: that places the file contents in a variable as a string?</p><h2 id="output" tabindex="-1">Output</h2><p>The <code>write</code> predicate writes to the current output stream, which defaults to stdout. The atom <code>nl</code> is a built-in that writes a newline character to the current output stream.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span><br><br><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% same as previous line</span></code></pre><p>The <a href="https://www.swi-prolog.org/pldoc/man?predicate=format/2?v=1.0.21" rel="noopener" target="_blank">format</a> predicate also writes to the current output stream. It takes a format string and a list of values to be substituted into the format string.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'~w likes ~w.'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>mark<span class="token punctuation">,</span> <span class="token string">'Prolog'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% Outputs "mark likes Prolog."</span></code></pre><p>Rules can write to the current output stream. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">greet</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Hello, ~w!'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">'Mark'</span><span class="token punctuation">)</span><br><span class="token comment">% Outputs "Hello, Mark!"</span></code></pre><p>The following special sequences can be used in format strings:</p><ul><li><code>~2f</code>: substitutes a float value and only outputs two decimal places</li><li><code>~n</code>: newline character</li><li><code>~s</code>: substitutes a literal string</li><li><code>~w</code>: substitutes a word derived from an atom name</li><li>TODO: Add more!</li></ul><p>The <code>put</code> function writes a single ASCII value to the current output stream. It is the counterpart to the <code>get</code> function.</p><p>To write to a file, use the <code>open</code>, <code>write</code>, and <code>close</code> functions. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">writeFile</span><span class="token punctuation">(</span>File<span class="token punctuation">,</span> Text<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">open</span><span class="token punctuation">(</span>File<span class="token punctuation">,</span> write<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">write</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> Text<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token punctuation">,</span><br>  <span class="token function">close</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">writeFile</span><span class="token punctuation">(</span><span class="token string">'demo.txt'</span><span class="token punctuation">,</span> <span class="token string">'first line\nsecond line'</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="special-characters" tabindex="-1">Special Characters</h2><table><thead><tr><th>Characters</th><th>Meaning</th></tr></thead><tbody><tr><td><code>:-</code></td><td>if; used to define rules</td></tr><tr><td><code>,</code></td><td>logical and</td></tr><tr><td><code>;</code></td><td>logical or</td></tr><tr><td><code>not</code></td><td>logical not</td></tr><tr><td><code>?-</code></td><td>begins a query</td></tr><tr><td><code>.</code></td><td>terminates all commands</td></tr><tr><td><code>%</code></td><td>begins single-line comment</td></tr><tr><td><code>/*</code> and <code>*/</code></td><td>delimits multi-line comment</td></tr></tbody></table><h2 id="naming-conventions" tabindex="-1">Naming Conventions</h2><p>Atoms are sequences of letters, numbers, and underscores that begin with a lowercase letter. They can also be any text enclosed in single quotes (allows spaces). There are also the following special atoms: <code>;</code>, <code>!</code>, <code>[]</code>, and <code>{}</code>.</p><p>Variables are also sequences of letters, numbers, and underscores, but they begin with an uppercase letter or an underscore. An underscore by itself represents an anonymous variable. These can be used as arguments to predicates when the value of an argument does not matter.</p><h2 id="operators" tabindex="-1">Operators</h2><p>Prolog supports the following relational operators:</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>=:=</code></td><td>equal</td></tr><tr><td><code>=\=</code></td><td>not equal</td></tr><tr><td><code>&lt;</code></td><td>less than</td></tr><tr><td><code>&gt;</code></td><td>greater than</td></tr><tr><td><code>=&lt;</code></td><td>less than or equal</td></tr><tr><td><code>&gt;=</code></td><td>greater than or equal</td></tr></tbody></table><p>The syntax for &quot;equal&quot; and &quot;not equal&quot; is quite odd!</p><p>The odd syntax for &quot;less than or equal&quot; was chosen so it doesn't look like an arrow.</p><p>Prolog supports the following math operators:</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>+</code></td><td>addition</td></tr><tr><td><code>-</code></td><td>subtraction</td></tr><tr><td><code>*</code></td><td>multiplication</td></tr><tr><td><code>/</code></td><td>floating point division</td></tr><tr><td><code>//</code></td><td>integer division</td></tr><tr><td><code>**</code></td><td>exponentiation</td></tr><tr><td><code>^</code></td><td>exponentiation</td></tr><tr><td><code>mod</code></td><td>modulo</td></tr></tbody></table><p>One way to evaluate a mathematical expression is to assign it to a variable. For example, we can compute the angle in degrees whose <code>sin</code> is <code>0.5</code> as follows:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% The asin function returns an angle in radians.</span><br><span class="token operator">?-</span> Angle <span class="token operator">is</span> <span class="token function">asin</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">180</span> <span class="token operator">/</span> pi<span class="token operator">.</span><br>Angle <span class="token operator">=</span> <span class="token number">29.999999999999996</span><span class="token operator">.</span></code></pre><p>After evaluating this, the variable <code>Angle</code> is no longer defined.</p><h2 id="strings" tabindex="-1">Strings</h2><p>Literal strings can be delimited with single or double quotes. Single quotes seem to be preferred. To escape a quote inside a literal string, precede it with a backslash.</p><p>A string is represented by a list of characters.</p><p>To get the length of a string, use the <code>atom_length</code> function. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">atom_length</span><span class="token punctuation">(</span><span class="token string">"Mark"</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token number">4.</span></code></pre><p>To create a list of ASCII values from a literal string, use the <code>name</code> function. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">'ABC'</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">]</span><span class="token operator">.</span></code></pre><p>To create a string from a list of ASCII values, also use the <code>name</code> function. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">name</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token string">'ABC'</span><span class="token operator">.</span></code></pre><p>To append two strings, convert them to lists of ASCII codes, append those lists, and convert the result back to a string. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">appendStrings</span><span class="token punctuation">(</span>S1<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> SR<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">name</span><span class="token punctuation">(</span>S1<span class="token punctuation">,</span> L1<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">name</span><span class="token punctuation">(</span>S2<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">append</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> LR<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">name</span><span class="token punctuation">(</span>SR<span class="token punctuation">,</span> LR<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">appendStrings</span><span class="token punctuation">(</span><span class="token string">'first '</span><span class="token punctuation">,</span> <span class="token string">'second'</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token string">'first second'</span></code></pre><p>To get a single character from a string, convert it to a list of ASCII codes, and use the <code>nth0</code> function. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"Mark"</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">nth0</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> L<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">put</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% 114 (ASCII code for 'r')</span></code></pre><h2 id="arithmetic-functions" tabindex="-1">Arithmetic Functions</h2><p>Prolog supports a large number of functions that return a number. See <a href="https://www.swi-prolog.org/pldoc/man?section=functions?v=1.0.21" rel="noopener" target="_blank">Arithmetic Functions</a>. These include</p><ul><li><code>abs</code>: absolute value</li><li>bitwise operations such as shift and <code>xor</code></li><li><code>ceiling</code>: smallest integer that is greater than or equal to a value</li><li><code>e</code>: value of e (2.71828...)</li><li><code>floor</code>: largest integer that is less than or equal to a value</li><li><code>exp</code>: e to a given power</li><li><code>gcd</code>: greatest common denominator</li><li><code>inf</code>: positive infinity</li><li><code>lcm</code>: least common multiple</li><li><code>log</code>: logarithm base e (natural logarithm)</li><li><code>log10</code>: logarithm base 10</li><li><code>max</code>: maximum of two values</li><li><code>min</code>: minimum of two values</li><li><code>nan</code>: not a number value</li><li><code>pi</code>: value of pi (3.14159...)</li><li><code>random</code>: random integer between zero and an upper bound</li><li><code>random_float</code>: random float between zero and one (exclusive on both ends)</li><li><code>succ</code>: successive value; <code>succ(2, X)</code> gives <code>3</code>; <code>succ(X, 3)</code> gives <code>2</code></li><li><code>truncate</code>: similar to <code>floor</code>, but rounds toward zero for negative numbers</li><li>trigonometry functions</li></ul><h2 id="conditional-logic" tabindex="-1">Conditional Logic</h2><p>TODO: Add this.</p><h2 id="iteration" tabindex="-1">Iteration</h2><p>Iteration in Prolog is done with recursion.</p><p>To get all the integers starting from one integer and ending at another, use the <code>between</code> function. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This sets V to 3, 4, 5, 6, and 7.</span><br><span class="token operator">?-</span> <span class="token function">between</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="lists-1" tabindex="-1">Lists</h2><p>Lists are sequential collections of values. They are created by including a comma-separated list of values in square brackets.</p><p>To create a new list that results from adding a value to the beginning of an existing list, use the pipe operator. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> L <span class="token operator">is</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">|</span> L<span class="token punctuation">]</span><span class="token operator">.</span><br></code></pre><p>The following rule computes the sum of numbers in a list:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This is an example of a recursive rule.</span><br><span class="token function">sum</span><span class="token punctuation">(</span>List<span class="token punctuation">,</span> Sum<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% If the list is empty then the sum is zero.</span><br>  List <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> Sum <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">;</span><br>  <span class="token comment">% Otherwise ...</span><br>  List <span class="token operator">=</span><br>    <span class="token comment">% Get the first number and a list of the remaining numbers.</span><br>    <span class="token punctuation">[</span>Head<span class="token operator">|</span>Tail<span class="token punctuation">]</span><span class="token punctuation">,</span><br>    <span class="token comment">% Compute the sum of the remaining numbers.</span><br>    <span class="token function">sum</span><span class="token punctuation">(</span>Tail<span class="token punctuation">,</span> TailSum<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token comment">% The result is the first number plus that sum.</span><br>    <span class="token comment">% Note the use of the "is" keyword to assign a value to the Sum argument.</span><br>    Sum <span class="token operator">is</span> TailSum <span class="token operator">+</span> Head<span class="token operator">.</span><br><br><span class="token operator">?-</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token number">6.</span></code></pre><p>To get the length of a list, use the <code>length</code> rule. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br>L <span class="token operator">=</span> <span class="token number">3.</span></code></pre><p>TODO: Show an example where a list is destructured in the argument list using <code>[H|T]</code></p><p>Anonymous variables (<code>_</code>) can be used to destructure value from a list. For example, the following gets the first and third values. The <code>| _</code> syntax at the end of the list on the left side indicates that we do not care about values in the tail of the list which includes all values after the third.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token punctuation">[</span>V1<span class="token punctuation">,</span> _<span class="token punctuation">,</span> V3 <span class="token operator">|</span> _<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">.</span><br>V1 <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span><br>V3 <span class="token operator">=</span> <span class="token number">7.</span></code></pre><p>To test whether a value is a member of a list, use the <code>member</code> function. For example:</p><pre class="language-prolog"><code class="language-prolog">TODO<span class="token operator">:</span> WHY DOESN'T THIS WORK<span class="token operator">?</span><br>TODO<span class="token operator">:</span> How can you set a variable and then use it in a subsequest predicate<span class="token operator">?</span><br>MyList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">member</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> MyList<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% true</span><br><span class="token function">member</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> MyList<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% false</span></code></pre><p>The <code>member</code> function can also be used to iterate over the values in a list. For example, <code>member(X, [3, 7, 9])</code> will set <code>X</code> to each value in the list one at a time.</p><p>The <code>reverse</code> function creates a new list containing all the values in a given list in reverse order. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% X = [3, 2, 1]</span></code></pre><p>The <code>append</code> function creates a new list by appending two existing lists. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% X = [1, 2, 3, 4, 5]</span></code></pre><p>Lists can be nested. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token punctuation">[</span>f<span class="token punctuation">,</span> g<span class="token punctuation">,</span> h<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>TODO: Can you append and insert values in list? TODO: Can you remove values from a list?</p><p>For implementations of map, filter, and reduce, see <a href="https://pbrown.me/blog/functional-prolog-map-filter-and-reduce/?v=1.0.21" rel="noopener" target="_blank">Functional Prolog</a>.</p><h2 id="help" tabindex="-1">Help</h2><p>To find information about built-ins related to a specific word in SWI-Prolog, enter <code>apropos(word).</code>. For example, <code>apropos(pair).</code> outputs the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% LIB pairs_keys/2                        Remove the values from a list of Key-Value pairs.</span><br><span class="token comment">% LIB pairs_values/2                      Remove the keys from a list of Key-Value pairs.</span><br><span class="token comment">% LIB pairs_keys_values/3                 True if Keys holds the keys of Pairs and Values the values.</span><br><span class="token comment">% SWI dict_pairs/3                        Bi-directional mapping between a dict and an ordered list of pairs (see secti ...</span><br><span class="token comment">%   C 'PL_is_pair'()                      Returns non-zero if term is a compound term using the list constructor.</span><br><span class="token comment">% SWI stream_pair/3                       This predicate can be used in mode (-,+,+) to create a stream-pair from an in ...</span><br><span class="token comment">% SEC 'summary-lib-pairs'                 library(pairs)</span><br><span class="token comment">% LIB protobuf_map_pairs/3                Convert between a list of protobuf map entries (in the form DictTag{key:Key,  ...</span><br><span class="token comment">% LIB transpose_pairs/2                   Swap Key-Value to Value-Key.</span><br><span class="token comment">% LIB json_dict_pairs/2                   This hook may be used to order the keys of an object.</span><br><span class="token comment">% LIB map_list_to_pairs/3                 Create a Key-Value list by mapping each element of List.</span><br><span class="token comment">% LIB group_pairs_by_key/2                Group values with equivalent (==/2) consecutive keys.</span><br><span class="token comment">% ISO keysort/2                           Sort a list of pairs.</span><br><span class="token comment">% LIB all_distinct/1                      True iff Vars are pairwise distinct.</span><br><span class="token comment">%   C 'PL_clear_hash_table'()             Delete all key-value pairs from the table.</span><br><span class="token comment">%   C 'PL_advance_hash_table_enum'()      Get the next key-value pair from a cursor.</span><br><span class="token comment">%   C 'PL_new_hash_table'()               Create a new table for size key-value pairs.</span><br><span class="token comment">% SEC pairs                               library(pairs): Operations on key-value lists</span><br><span class="token comment">% LIB assoc_to_list/2                     Translate Assoc to a list Pairs of Key-Value pairs.</span><br><span class="token comment">%   C 'PL_STRINGS_MARK'()                 These macros must be paired and create a C block ({...}).</span><br><span class="token comment">% Showing 20 of 52 matches</span><br><span class="token comment">%</span><br><span class="token comment">% Use ?- apropos(Type:Query) or multiple words in Query</span><br><span class="token comment">% to restrict your search.  For example:</span><br><span class="token comment">%</span><br><span class="token comment">%   ?- apropos(iso:open).</span><br><span class="token comment">%   ?- apropos('open file').</span></code></pre><h2 id="listing" tabindex="-1">Listing</h2><p>To list all the facts and rules known in the current session, enter <code>listing.</code>. The output will contain many clauses created by the system in addition to those you loaded.</p><p>To list only the facts and rules for a given predicate, enter <code>listing(predicate-name).</code></p><h2 id="debugging" tabindex="-1">Debugging</h2><p>To see all the steps used to evaluate a predicate, turn on trace mode by entering <code>trace.</code></p><p>Enter a query and press the return key after viewing the result of each step in the evaluation.</p><p>When finished debugging, enter <code>notrace.</code> to turn this mode off.</p><h2 id="structures" tabindex="-1">Structures</h2><p>TODO: Add this detail.</p><h2 id="calling-from-other-languages" tabindex="-1">Calling From Other Languages</h2><p>SWI-Prolog can be called from C. See <a href="https://www.swi-prolog.org/pldoc/man?section=calling-prolog-from-c?v=1.0.21" rel="noopener" target="_blank">Calling Prolog from C</a>.</p><p>TODO: Which other programming languages can call SWI-Prolog?</p><h2 id="efficiency" tabindex="-1">Efficiency</h2><p>For information about the performance of Prolog, see <a href="https://www.metalevel.at/prolog/efficiency?v=1.0.21" rel="noopener" target="_blank">Efficiency of Prolog</a>.</p><h2 id="constraint-logic-programming-over-finite-domains%3A-clp(fd)" tabindex="-1">Constraint Logic Programming over Finite Domains: CLP(FD)</h2><p>The library clpfd implmenents Constraint Logic Programming over Finite Domains. This supports two primary use cases:</p><ul><li>declarative integer arithmetic</li><li>combinatorial problems</li></ul><p>This library supports a different, powerful way to write Prolog rules.</p><p>For example, the following rule computes the area of various geometry shapes.</p><pre class="language-prolog"><code class="language-prolog"><br>## Unit Tests<br><br>SCI<span class="token operator">-</span>Prolog includes a unit testing framework called <span class="token string">"Test Box"</span><span class="token operator">.</span><br>See <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/plunit.html%27)?v=1.0.21"</span> rel<span class="token operator">=</span><span class="token string">"noopener"</span> target<span class="token operator">=</span><span class="token string">"_blank"</span><span class="token operator">></span>Prolog Unit Tests<span class="token operator">&lt;/</span>a<span class="token operator">>.</span><br><br>Code for unit tests can be placed in the same source file<br>as the rules they test<span class="token operator">.</span><br>Alternatively<span class="token punctuation">,</span> test code can be placed in a separate file<br>with an extension of `<span class="token operator">.</span>plt`<span class="token operator">.</span><br><br>The following code demonstrates implementing unit tests<br>for the built<span class="token operator">-</span>in `append` rule<span class="token operator">.</span><br><br>```prolog<br><span class="token comment">% This line is only needed to load predicates from another file.</span><br><span class="token comment">% :- consult({file-name}).</span><br><br><span class="token operator">:-</span> <span class="token function">begin_tests</span><span class="token punctuation">(</span>append<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>append_assertions<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>append_make_first<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">append</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">assertion</span><span class="token punctuation">(</span>X <span class="token operator">==</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token operator">!.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>append_make_second<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">assertion</span><span class="token punctuation">(</span>X <span class="token operator">==</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>append_make_third<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">assertion</span><span class="token punctuation">(</span>X <span class="token operator">==</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">end_tests</span><span class="token punctuation">(</span>append<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> run_tests<span class="token operator">.</span><br><span class="token operator">:-</span> halt<span class="token operator">.</span></code></pre><p>If the code above is in a file named <code>append.plt</code> then the tests can be run by entering <code>swipl append.plt</code>. If the last two lines in the code above are omitted, use the following instead: <code>swipl -g run_tests -t halt your/file.pl</code></p><p>The <code>test</code> rule takes a test name (atom or string) and an optional list of options. Supported options include:</p><ul><li><code>setup</code>: takes a goal to execute before the test is run</li><li><code>cleanup</code>: takes a goal to execute after the test is run</li><li><code>forall</code>: takes a generator and runs the test for each generated value</li><li><code>throws</code>: takes an error and verifies that the test throws the error</li><li><code>error</code>: takes an error and verifies that the test throws <code>error(Error, _Context)</code></li><li>several other options that seem less valuable</li></ul><p>The <code>assertion</code> rule prints assertions that fail. When this is not used, the output will only provide the name of the test that failed.</p><p>If a test ends with a choice point, a warning message will be output. To prevent this, end the test with the cut operator (<code>, !.</code>) or include the option <code>nondet</code>.</p><h2 id="language-server" tabindex="-1">Language Server</h2><p>TODO: How can you install a Prolog language server in Neovim? TODO: See <a href="https://github.com/jamesnvc/lsp_server">https://github.com/jamesnvc/lsp_server</a>.</p><p>TODO: Can you run Prolog code inside Neovim?</p><h2 id="libraries" tabindex="-1">Libraries</h2><p>TODO: Is there a popular collection of open source Prolog libraries?</p></article>