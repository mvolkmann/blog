<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Prolog</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#use-cases">Use Cases</a></li><li><a href="#learning-curve">Learning Curve</a></li><li><a href="#resources">Resources</a></li><li><a href="#implementations">Implementations</a><ol><li><a href="#scryer-prolog">Scryer Prolog</a><ol><li><a href="#scryer-help">Scryer Help</a></li><li><a href="#scryer-common-errors">Scryer Common Errors</a></li></ol></li><li><a href="#sicstus-prolog">SICStus Prolog</a></li><li><a href="#gnu-prolog">GNU Prolog</a></li><li><a href="#swi-prolog">SWI-Prolog</a><ol><li><a href="#swi-prolog-conformance">SWI-Prolog Conformance</a></li><li><a href="#swi-prolog-packs">SWI-Prolog Packs</a></li><li><a href="#swi-prolog-debugging">SWI-Prolog Debugging</a></li><li><a href="#swi-prolog-executables">SWI-Prolog Executables</a></li></ol></li><li><a href="#ciao-prolog">Ciao Prolog</a></li><li><a href="#other-implementations">Other Implementations</a></li></ol></li><li><a href="#online-top-level">Online Top Level</a></li><li><a href="#exiting">Exiting</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#syntax">Syntax</a><ol><li><a href="#facts">Facts</a></li><li><a href="#rules">Rules</a></li><li><a href="#queries">Queries</a></li><li><a href="#conjunctions">Conjunctions</a></li><li><a href="#disjunctions">Disjunctions</a></li></ol></li><li><a href="#typical-flow">Typical Flow</a></li><li><a href="#naming-conventions">Naming Conventions</a></li><li><a href="#common-errors">Common Errors</a></li><li><a href="#compiler-directives">Compiler Directives</a><ol><li><a href="#compiler-flags">Compiler Flags</a></li><li><a href="#including-source-files">Including Source Files</a></li><li><a href="#including-a-module%2Flibrary">Including a Module/Library</a></li><li><a href="#evaluating-goals-on-load">Evaluating Goals on Load</a></li><li><a href="#command-line-arguments">Command-line Arguments</a></li></ol></li><li><a href="#tree-representation">Tree Representation</a></li><li><a href="#primitive-types">Primitive Types</a><ol><li><a href="#booleans">Booleans</a></li><li><a href="#numbers">Numbers</a></li><li><a href="#strings">Strings</a></li></ol></li><li><a href="#data-structures">Data Structures</a><ol><li><a href="#structures">Structures</a></li><li><a href="#lists">Lists</a><ol><li><a href="#destructuring">Destructuring</a></li><li><a href="#append-predicate">append Predicate</a></li><li><a href="#copy_term-predicate">copy_term Predicate</a></li><li><a href="#length-predicate">length Predicate</a></li><li><a href="#list_min-and-list_max-predicates">list_min and list_max Predicates</a></li><li><a href="#maplist-predicate">maplist Predicate</a></li><li><a href="#member-predicate">member Predicate</a></li><li><a href="#nth0-and-nth1-predicates">nth0 and nth1 Predicates</a></li><li><a href="#permutation-predicate">permutation Predicate</a></li><li><a href="#reverse-predicate">reverse Predicate</a></li><li><a href="#same_length-predicate">same_length Predicate</a></li><li><a href="#select-predicate">select Predicate</a></li><li><a href="#sort-predicate">sort Predicate</a></li><li><a href="#sum_list-predicate">sum_list Predicate</a></li><li><a href="#miscellaneous-(move-these!)">Miscellaneous (MOVE THESE!)</a></li></ol></li><li><a href="#pairs">Pairs</a></li><li><a href="#key%2Fvalue-pairs">Key/Value Pairs</a><ol><li><a href="#assoc-library">assoc library</a></li><li><a href="#dict-type">dict type</a></li></ol></li><li><a href="#linked-lists">Linked Lists</a></li></ol></li><li><a href="#type-checking">Type Checking</a></li><li><a href="#higher-order-predicates">Higher-order Predicates</a></li><li><a href="#dynamic-predicates">Dynamic Predicates</a></li><li><a href="#input">Input</a></li><li><a href="#output">Output</a></li><li><a href="#special-characters">Special Characters</a></li><li><a href="#operators">Operators</a><ol><li><a href="#number-operators">Number Operators</a></li><li><a href="#atom-and-string-operators">Atom and String Operators</a></li><li><a href="#term-operators">Term Operators</a></li><li><a href="#arithmetic-operators">Arithmetic Operators</a></li><li><a href="#bitwise-operators">Bitwise Operators</a></li><li><a href="#constraint-logic-programming-(clp)">Constraint Logic Programming (CLP)</a></li><li><a href="#other-operators">Other Operators</a></li><li><a href="#custom-operators">Custom Operators</a></li></ol></li><li><a href="#arithmetic-functions">Arithmetic Functions</a></li><li><a href="#conditional-logic">Conditional Logic</a></li><li><a href="#iteration">Iteration</a></li><li><a href="#lists-of-solutions">Lists of Solutions</a></li><li><a href="#unfair-enumerations">Unfair Enumerations</a></li><li><a href="#partial-goals">Partial Goals</a></li><li><a href="#error-handling">Error Handling</a></li><li><a href="#pure-monotonic-core">Pure Monotonic Core</a></li><li><a href="#help">Help</a></li><li><a href="#debugging">Debugging</a><ol><li><a href="#trace-predicate">trace Predicate</a></li><li><a href="#debug-library">debug Library</a></li><li><a href="#time-predicate">time Predicate</a></li></ol></li><li><a href="#calling-from-other-languages">Calling From Other Languages</a></li><li><a href="#efficiency">Efficiency</a></li><li><a href="#unit-tests">Unit Tests</a></li><li><a href="#puzzles">Puzzles</a><ol><li><a href="#jug-problem">Jug Problem</a></li><li><a href="#sudoku">Sudoku</a></li><li><a href="#einstein's-riddle">Einstein's Riddle</a></li></ol></li><li><a href="#search-strategies">Search Strategies</a></li><li><a href="#reading-from-urls">Reading from URLs</a></li><li><a href="#definite-clause-grammars-(dcgs)">Definite Clause Grammars (DCGs)</a><ol><li><a href="#dcg-predicates">DCG Predicates</a></li><li><a href="#representing-trees">Representing Trees</a></li><li><a href="#dcg-rule-termination">DCG Rule Termination</a></li><li><a href="#lexical-analysis">Lexical Analysis</a></li><li><a href="#parsing-sentences">Parsing Sentences</a></li><li><a href="#generating-syntax-trees">Generating Syntax Trees</a></li></ol></li><li><a href="#meta-interprers">Meta-interprers</a></li><li><a href="#calling-from-javascript">Calling From JavaScript</a></li><li><a href="#creating-an-http-server">Creating an HTTP Server</a></li><li><a href="#language-server">Language Server</a></li><li><a href="#miscellaneous-topics">Miscellaneous Topics</a></li></ol></nav></aside><article><h2 id="overview" tabindex="-1">Overview</h2><p>Prolog is a logic-based programming language. The name is a contraction of &quot;programming in logic&quot;.</p><p>Prolog first appeared in 1972. It was designed by three computer scientists, Alain Colmerauer (France), Phillipe Roussel (France), and Robert Kowalski (USA/Britain).</p><p>Prolog uses a declarative syntax rather than a procedural one. Instead of writing code that describes &quot;what&quot; to do, the code describes relationships between data values.</p><p>Nearly all Prolog code has one of these four purposes:</p><ol><li><p>Describe a relationship that is always true (aka holds) ... a fact.</p><p>For example:</p></li></ol><pre class="language-prolog"><code class="language-prolog"><span class="token function">father</span><span class="token punctuation">(</span>richard<span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">father</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> amanda<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">father</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> jeremy<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><ol><li><p>Describe a relationship that is conditionally true ... a rule.</p><p>For example, the following rule states that <code>G</code> is a grandfather of <code>C</code> if <code>G</code> is the father of <code>P</code> AND <code>P</code> is either the father or mother of <code>C</code>:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">grandfather</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">:=</span><br>  <span class="token function">father</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> P<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token punctuation">(</span><span class="token function">father</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token operator">;</span> <span class="token function">mother</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre></li><li><p>Ask whether a specific relationship is true using a query with no variables.</p><p>For example, <code>?- grandfather(richard, amanda).</code> outputs <code>true</code>.</p></li><li><p>Ask for values for which a relationship is true using a query with variables.</p><p>For example, <code>?- grandfather(G, amanda).</code> sets <code>G</code> to <code>richard</code> Sometimes there are multiple values for which a query holds. For example, the query <code>?- grandfather(richard, G).</code> sets <code>G</code> to <code>amanda</code> and then <code>jeremy</code>. Note how a rule can be used to find values for any of its arguments, searching in multiple directions.</p></li></ol><p>Queries (aka questions) perform &quot;unification&quot; which basically means finding values for variables that cause a relationship to hold. This requires pattern matching search and backtracking. Unification relies on the properties of <a href="https://en.wikipedia.org/wiki/Horn_clause?v=1.0.21" rel="noopener" target="_blank">Horn clauses</a>. A related term is &quot;ground&quot; which refers to an expression that contains no uninstantiated variables.</p><p>The set of facts and rules supplied to the Prolog engine is called the knowledge base (or database). Prolog is highly optimized to handle searching large knowledge bases.</p><p>Prolog is a homoiconic language, which means its code can be treated as data. Everything in Prolog is some kind of &quot;term&quot;. A program is a list of clauses. A list and a clause can both be represented as terms.</p><p>Prolog has many uses including artificial intelligence, abstract problem solving, symbolic equation solving, and more.</p><p>&quot;IBM Watson is a question-answering computer system capable of answering questions posed in natural language.&quot; It is partially implemented in Prolog.</p><h2 id="use-cases" tabindex="-1">Use Cases</h2><p>Prolog is used in many kinds of applications including:</p><ul><li><p>explainable AI (as opposed to approaches like neural networks)</p></li><li><p>problem solving</p></li><li><p>parsing</p><p>This includes parsing programming language source code.</p></li><li><p>natural language processing (NLP)</p><p>This includes automatic translation from one human language to another. It also includes translating human language to direct a computer and possibly generating a human language response (ex. Alexa and Siri).</p></li><li><p>specification language</p><p>For example, the Java Virtual Machine (JVM) specification uses Prolog.</p></li><li><p>rule-based systems (ex. Eliza)</p></li><li><p>automation systems</p></li><li><p>robot planning</p></li><li><p>natural language understanding</p></li><li><p>intelligent database retrieval</p></li></ul><h2 id="learning-curve" tabindex="-1">Learning Curve</h2><p>The primary concepts in Prolog such as facts, rules, and queries are easy to understand after seeing a few examples.</p><p>However, writing programs that are entirely based on relationships rather than imperative code makes Prolog very different from other programming languages. This makes learning Prolog somewhat challenging initially. For example, to write a program that compiles some source code into its target representation, define the relationship that describes when source code is related to the target representation.</p><p>Prolog supports a large number of operators and built-in predicates. These take considerable time to learn and master.</p><h2 id="resources" tabindex="-1">Resources</h2><ul><li><p><a href="https://swi-prolog.discourse.group/?v=1.0.21" rel="noopener" target="_blank">SWI Prolog Discourse group</a></p></li><li><p><a href="https://mitpress.mit.edu/9780262691635/the-art-of-prolog/?v=1.0.21" rel="noopener" target="_blank">The Art of Prolog</a> Second Edition book by Sterling and Shapiro</p></li><li><p><a href="https://www.youtube.com/watch?v=dKn-BbS_zQQ?v=1.0.21" rel="noopener" target="_blank">A Brief Introduction to Prolog</a> YouTube video by Erik Schierboom</p></li><li><p><a href="https://link.springer.com/book/10.1007/978-3-642-58274-5?v=1.0.21" rel="noopener" target="_blank">Clause and Effect</a> book by Clocksin</p></li><li><p><a href="https://www.covingtoninnovations.com/mc/plcoding.pdf?v=1.0.21" rel="noopener" target="_blank">Coding guidelines for Prolog</a></p></li><li><p><a href="http://www.gprolog.org?v=1.0.21" rel="noopener" target="_blank">GNU Prolog</a></p></li><li><p><a href="https://www.iso.org/standard/21413.html?v=1.0.21" rel="noopener" target="_blank">ISO Standard for Prolog</a></p></li><li><p><a href="http://lpn.swi-prolog.org/lpnpage.php?pageid=online?v=1.0.21" rel="noopener" target="_blank">Learn Prolog Now!</a></p></li><li><p><a href="https://www.metalevel.at/prolog?v=1.0.21" rel="noopener" target="_blank">The Power of Prolog</a> free, online book with accompanying videos by <a href="https://www.metalevel.at?v=1.0.21" rel="noopener" target="_blank">Dr. Markus Triska</a> from the University of Technology in Austria</p></li><li><p><a href="https://link.springer.com/book/10.1007/978-3-642-55481-0?v=1.0.21" rel="noopener" target="_blank">Programming in Prolog</a> Fifth edition book by Clocksin and Mellish</p></li><li><p><a href="https://www.softwarepreservation.org/projects/prolog?v=1.0.21" rel="noopener" target="_blank">Prolog and Logic Programming Historical Sources Archive</a></p></li><li><p><a href="https://www.scryer.pl?v=1.0.21" rel="noopener" target="_blank">Scryer Prolog</a></p></li><li><p><a href="https://www.swi-prolog.org?v=1.0.21" rel="noopener" target="_blank">SWI-Prolog</a></p></li><li><p><a href="https://www.linuxlinks.com/excellent-free-books-learn-prolog/?v=1.0.21" rel="noopener" target="_blank">13 Excellent Free Books to Learn Prolog</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Prolog?v=1.0.21" rel="noopener" target="_blank">Wikipedia</a></p></li></ul><h2 id="implementations" tabindex="-1">Implementations</h2><p>There are many implementations of the Prolog programming language. The first Prolog implementation was Marseilles Prolog (also referred to as Prolog 0 to Prolog IV) developed at Marseilles University. The second Prolog implementation was DEC-10 Prolog developed at Edinburgh University, and commonly referred to as Edinburgh Prolog.</p><p>Many current Prolog implementations conform to the <a href="https://www.iso.org/standard/21413.html?v=1.0.21" rel="noopener" target="_blank">ISO Standard for Prolog</a>. This defines the minimum requirements for conforming implementations. Most implementations also add features beyond the ISO standard.</p><p>The ISO standard does not require implementations to provide a &quot;top level&quot; or REPL, but most do. A top level supports interactive entry and evaluation of Prolog queries. Some top level implementations also support tab completion, interactive debugging.</p><p>Several Prolog implementations compile source code to abstract machine code for the Warren Abstract Machine (WAM). Searches in WAM use an efficient hash-based approach.</p><p>The table at <a href="http://www.complang.tuwien.ac.at/ulrich/iso-prolog/conformity_testing?v=1.0.21" rel="noopener" target="_blank">Conforming Testing</a> describes the degree to which each implementation conforms to the ISO standard. One reason to select a conforming implementation is that it increases the likelihood that your code will run in other implementations. Switch may be necessary in order to gain performance or specific features.</p><p>The Prolog implementations that are currently popular are described below.</p><h3 id="scryer-prolog" tabindex="-1">Scryer Prolog</h3><p><img alt="Scryer Prolog logo" style="width: 20%" src="/blog/assets/scryer-prolog-logo.png?v=1.0.21" title="Scryer Prolog logo"></p><p><a href="https://www.scryer.pl?v=1.0.21" rel="noopener" target="_blank">Scryer Prolog</a> &quot;is a free software ISO Prolog system intended to be an industrial strength production environment and a testbed for bleeding edge research in logic and constraint programming.&quot;</p><p>Scryer Prolog is implemented in Rust (64%) and Prolog (36%).</p><p>A &quot;scryer&quot; is somehow who sees, hears or otherwise interprets spirit communications, usually on behalf of a magician who isn't so gifted.</p><p>From the Scryer website, it's main features include:</p><ul><li>ISO standard compliant</li><li>integrated Constraint Logic Programming (CLP) libraries</li><li>supports Definite Clause Grammars (DCGs)</li><li>coroutine support</li><li>tabling and SLG resolution</li><li>compact string representation</li><li>network libraries (TCP sockets, HTTP server, HTTP client, ...)</li><li>cryptography predicates</li><li>WAM-based engine</li><li>cross-platform</li><li>implemented in Rust</li></ul><p>To install, enter the following commands:</p><pre class="language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/mthom/scryer-prolog<br><span class="token builtin class-name">cd</span> scryer-prolog<br><span class="token function">curl</span> https://sh.rustup.rs <span class="token parameter variable">-sSf</span> <span class="token operator">|</span> <span class="token function">sh</span> <span class="token comment"># if cargo is not yet installed</span><br><span class="token function">cargo</span> build <span class="token parameter variable">--release</span></code></pre><p>This creates the executable file <code>target/release/scryer-prolog</code>. Define an alias like <code>scryerp</code> or just <code>scry</code> to make this easier to run.</p><p>To update your version of Scryer Prolog:</p><ol><li>cd to the directory containing the cloned GitHub repository.</li><li>Enter <code>git pull</code></li><li>Enter <code>cargo build --release</code></li></ol><p>To start a Scryer Prolog top level from a terminal, enter <code>scry</code>.</p><p>By default, Scryer Prolog only provides built-in predicates that are defined in the ISO standard. But it bundles many libraries that define non-ISO predicates that can easily be made available with <code>:- use_module(library(library-name)).</code></p><p>To specify configuration for all top level sessions, create the file <code>$HOME/.scryerrc</code>.</p><p>This file often imports commonly used libraries. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>There is currently an <a href="https://github.com/mthom/scryer-prolog/issues/1775?v=1.0.21" rel="noopener" target="_blank">issue</a> where operators defined in modules that are loaded in <code>.scryerrc</code> are not available in source files passed to the Scryer interpreter. A workaround is to explicitly load the module in the source file with <code>:- use_module(library(library-name)).</code></p><h4 id="scryer-help" tabindex="-1">Scryer Help</h4><p>After entering a query, press &quot;h&quot; to get the following help:</p><pre class="language-text"><code class="language-text">SPACE, "n" or ";": next solution, if any<br>RETURN or ".": stop enumeration<br>"a": enumerate all solutions<br>"f": enumerate the next 5 solutions<br>"h": display this help message<br>"w": write terms without depth limit<br>"p": print terms with depth limit</code></pre><h4 id="scryer-common-errors" tabindex="-1">Scryer Common Errors</h4><p>The following list describes some of the most commonly seen error messages that are output by Scryer Prolog.</p><ul><li><pre>Warning: <b>singleton variable</b> Name at line N of file-name.pl.</pre><p>This means that the variable <code>Name</code> either:</p><ul><li>is an argument of a rule, but is not used by any rule body goal</li><li>appears in a rule body goal, but is not an argument and is not set in a previous goal</li></ul></li><li><pre>error(<b>existence_error</b>(source_sink,"file-name.pl"),open/4).</pre><p>This error occurs when Scryer Prolog is started with a file path and the file is not found.</p></li><li><pre>error(syntax_error(inconsistent_entry),load/1).</pre><p>This error can occur when there is a typo in a compiler directive.</p></li><li><pre>error(permission_error(access,private_procedure,module_does_not_contain_claimed_export),load/1).</pre><p>This error means that a module is being defined and the list of exports contains a functor that is not defined in the file. Sadly, the error does not indicate which function is undefined.</p></li><li><pre>error(<b>permission_error</b>(modify,static_procedure,(',')/2),load/1).</pre><p>This error means that the source file contains a term with invalid syntax. Often the cause is a rule body that contains a goal which is not the last goal and is terminated by a period instead of a comma.</p></li><li><pre>error(<b>syntax_error</b>(incomplete_reduction),read_term/3:line-number).</pre><p>This error means that the source file contains a term with invalid syntax. Often the cause is a rule body whose last goal is terminated by a comma instead of a period or a rule body goal that is not the last one and is not followed by a comma.</p><p>This error can also occur when a goal uses a non-builtin operator that has not been loaded. For example, using the <code>#=</code> requires loading the <code>clpz</code> library.</p></li><li><pre>error(<b>type_error</b>(list,6),must_be/2).</pre><p>This error can occur when a predicate argument is expected to be a list, but is some other type. For example, this happens when the second argument to <code>format</code> is not a list.</p></li></ul><h3 id="sicstus-prolog" tabindex="-1">SICStus Prolog</h3><p><a href="https://sicstus.sics.se?v=1.0.21" rel="noopener" target="_blank">SICStus Prolog</a> is a commercial, high-performance implementation that began in 1986. A 30-day <a href="https://sicstus.sics.se/eval.html?v=1.0.21" rel="noopener" target="_blank">evaluation version</a> is free of charge.</p><p>SICS is an acronym for the Swedish Institute of Computer Science where SICStus was created. The &quot;tus&quot; suffix is a play on Quintus Prolog (released in 1985) which was a fifth generation Prolog implementation. Think of &quot;SICS&quot; as having an alternative meaning of &quot;sixth&quot;.</p><p>It is one of the most conforming and sophisticated Prolog systems. No other system is even remotely comparable in terms of robustness.</p><h3 id="gnu-prolog" tabindex="-1">GNU Prolog</h3><p><img alt="GNU Prolog logo" style="width: 20%" src="/blog/assets/gnu-prolog-logo.png?v=1.0.21" title="GNU Prolog logo"></p><p><a href="http://www.gprolog.org?v=1.0.21" rel="noopener" target="_blank">GNU Prolog</a>. is implemented in C (84%) and Prolog (15%).</p><p>To install the terminal command <code>gprolog</code> in macOS, enter <code>brew install gnu-prolog</code>.</p><p>To start a GNU Prolog top level from a terminal, enter <code>gprolog</code>.</p><h3 id="swi-prolog" tabindex="-1">SWI-Prolog</h3><p><img alt="SWI-Prolog logo" style="width: 20%" src="/blog/assets/swipl-logo.png?v=1.0.21" title="SWI-Prolog logo"></p><blockquote><p>SWI-Prolog offers a comprehensive free Prolog environment. Since its start in 1987, SWI-Prolog development has been driven by the needs of real world applications. SWI-Prolog is widely used in research and education as well as commercial applications.&quot;</p></blockquote><blockquote><p>Its main author is Jan Wielemaker. The name SWI is derived from Sociaal-Wetenschappelijke Informatica (&quot;Social Science Informatics&quot;), the former name of the group at the University of Amsterdam, where Wielemaker is employed.</p></blockquote><p><a href="https://www.swi-prolog.org?v=1.0.21" rel="noopener" target="_blank">SWI-Prolog</a> is implemented in C (48%) and Prolog (39%).</p><p>To install the terminal command <code>swipl</code> in macOS, enter <code>brew install swi-prolog</code></p><p>To start a SWI-Prolog top level from a terminal, enter <code>swipl</code>.</p><p>To specify configuration for all top level sessions, create the file <code>$HOME/.config/swi-prolog/init.pl</code>. For example, this file might set <a href="#prolog-flags">prolog flags</a>.</p><h4 id="swi-prolog-conformance" tabindex="-1">SWI-Prolog Conformance</h4><p>SWI-Prolog adds features beyond the ISO standard, some of which contradict the standard, making it non-conforming. One example is the addition of a string type. Many dedicated predicates are needed to operate on these strings rather than using list predicates. Another example is the addition of a custom dict type.</p><p>It is very easy to write code that runs in SWI-Prolog, but does not run in other Prolog implementations. In addition, some code that is valid according to the ISO standard does not run in SWI-Prolog.</p><p>For a detailed take on this issue, see <a href="https://www.youtube.com/watch?v=kGQNeeRp4sM?v=1.0.21" rel="noopener" target="_blank">Preparing Prolog</a>.</p><p>Also see <a href="https://www.complang.tuwien.ac.at/ulrich/iso-prolog/SWI7_and_ISO?v=1.0.21" rel="noopener" target="_blank">SWI7 and ISO Prolog</a>.</p><h4 id="swi-prolog-packs" tabindex="-1">SWI-Prolog Packs</h4><p>Packs are add-on libraries.</p><p>To see a list of known packages, browse <a href="https://www.swi-prolog.org/pack/list?v=1.0.21" rel="noopener" target="_blank">Packs (add-ons) for SWI-Prolog</a>. Alternatively, enter <code>pack_list(substring)</code> where substring is part of one or more pack names.</p><p>To install a pack, enter <code>pack_install(name)</code>. This will download the code and install it.</p><p>The &quot;reif&quot; pack (reified if) implements the <code>if_</code> predicate which is similar to the <code>-&gt;</code> operator, but has some advantages. See the section &quot;Higher-order Predicates&quot; for examples.</p><p>The <a href="https://www.swi-prolog.org/pack/list?p=gvterm?v=1.0.21" rel="noopener" target="_blank">gvterm</a> pack generates a graphviz file from a Prolog term. This is useful for visualizing the tree structure of a term.</p><h4 id="swi-prolog-debugging" tabindex="-1">SWI-Prolog Debugging</h4><p>For information on using the debugger in SWI-Prolog, see <a href="https://www.swi-prolog.org/pldoc/man?section=debugoverview?v=1.0.21" rel="noopener" target="_blank">Overview of the Debugger</a>.</p><p>The <code>trace</code> predicate enables tracing of the search to find a query solution.</p><p>The following code defines fact about my family and a rule about grandfathers.</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">female</span><span class="token punctuation">(</span>amanda<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">female</span><span class="token punctuation">(</span>judi<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">female</span><span class="token punctuation">(</span>tami<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">male</span><span class="token punctuation">(</span>jeremy<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">male</span><span class="token punctuation">(</span>mark<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">male</span><span class="token punctuation">(</span>richard<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">father</span><span class="token punctuation">(</span>richard<span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">father</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> amanda<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">father</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> jeremy<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">mother</span><span class="token punctuation">(</span>judi<span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">mother</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> amanda<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">mother</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> jeremy<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">grandfather_of</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">father</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> P<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token punctuation">(</span><span class="token function">father</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token operator">;</span> <span class="token function">mother</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To trace the execution of the query <code>grandfather_of(richard, X).</code>, enter <code>trace.</code> and then the query. The screenshot below shows the output. After each line in the trace, press the spacebar to advance to the next term to be evaluated. After a solution is found, press the semicolon key to begin searching for the next solution.</p><p><img alt="SWI-Prolog trace" style="width: 60%" src="/blog/assets/swi-prolog-trace.png?v=1.0.21" title="SWI-Prolog trace"></p><p>The <code>trace</code> predicate enables both the trace and debug modes. To disable these, enter <code>notrace.</code> and <code>nodebug.</code></p><h4 id="swi-prolog-executables" tabindex="-1">SWI-Prolog Executables</h4><p>To compile a Prolog source file to an executable, enter <code>swipl -o {exe-name} -c {source-name}.pl</code>. For example, <code>swipl -o sukuko -c suduko.pl</code>. Running this executable with <code>./suduko</code> starts a top level session and loads the compiled facts and rules.</p><h3 id="ciao-prolog" tabindex="-1">Ciao Prolog</h3><p><a href="https://ciao-lang.org?v=1.0.21" rel="noopener" target="_blank">Ciao</a> &quot;is a modern Prolog implementation that builds up from a logic-based simple kernel designed to be portable, extensible, and modular.&quot;</p><p>Ciao is implemented in Prolog (72%) and C (23%).</p><p>To install:</p><ol><li><p>Install emacs. In macOS, this can be done by entering <code>brew install emacs</code></p></li><li><p>Enter <code>curl https://ciao-lang.org/boot -sSfL | sh</code></p></li><li><p>Create an alias to the executable. For example:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">ciao</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/.ciaoroot/v1.22.0-m5/build/bin/ciao"</span></code></pre></li></ol><p>To start a Ciao top level from a terminal, enter <code>ciao</code>.</p><h3 id="other-implementations" tabindex="-1">Other Implementations</h3><ul><li><a href="http://tau-prolog.org?v=1.0.21" rel="noopener" target="_blank">Tau</a> is implemented in JavaScript (95%) and Prolog (5%).</li><li><a href="https://github.com/trealla-prolog/trealla?v=1.0.21" rel="noopener" target="_blank">Trealla</a> is implemented in C (82%) and Prolog (18%).</li></ul><h2 id="online-top-level" tabindex="-1">Online Top Level</h2><p>To enter and run Prolog code in a web browser, browse <a href="https://swish.swi-prolog.org?v=1.0.21" rel="noopener" target="_blank">SWISH</a>.</p><p>Enter facts and rules in the left pane. Enter a query in the lower-right pane. Press the &quot;Run!&quot; button or ctrl-return to execute the query.</p><h2 id="exiting" tabindex="-1">Exiting</h2><p>To exit from any Prolog interpreter, enter <code>halt.</code> or press ctrl-d.</p><h2 id="terminology" tabindex="-1">Terminology</h2><table><thead><tr><th>Term</th><th>Meaning</th></tr></thead><tbody><tr><td>term</td><td>the only datatype; has four subtypes listed below</td></tr><tr><td>- number</td><td>integer or floating point</td></tr><tr><td>- atom</td><td>identifier that represents a specific thing</td></tr><tr><td>- variable</td><td>represents a value to be determined</td></tr><tr><td>- compound term</td><td>specific combination of terms; more detail below</td></tr><tr><td>structure</td><td>another name for a compound term</td></tr><tr><td>fact</td><td>description of something that is true</td></tr><tr><td>rule</td><td>relationship involving one or more unknown things (variables)</td></tr><tr><td>clause</td><td>a single fact or rule</td></tr><tr><td>predicate</td><td>collection of clauses with the same principal functor</td></tr><tr><td>principal functor</td><td>name of a predicate</td></tr><tr><td>query</td><td>asks if a term is true or asks for satisfying variable values</td></tr><tr><td>knowledge base</td><td>collection of predicate clauses (aka database)</td></tr><tr><td>arity</td><td>number of predicate arguments</td></tr><tr><td>functor</td><td>predicate name and its arity; written with a slash between</td></tr><tr><td>goal</td><td>compound term in a rule body or query</td></tr><tr><td>list notation</td><td>comma-separated terms inside square brackets; ex. <code>[a, B, 7]</code></td></tr><tr><td>operator notation</td><td>terms separated by operators; ex. <code>Y = m*X + b</code></td></tr><tr><td>function notation</td><td>operators are written as function calls; ex. <code>*(3, +(1, 2))</code></td></tr><tr><td>unification</td><td>process of searching for variable values that satisfy a goal</td></tr><tr><td>choice point</td><td>represents a choice in the search for a solution</td></tr><tr><td>conjunction</td><td>and'ing terms with comma operator</td></tr><tr><td>disjunction</td><td>or'ing terms with semicolon operator</td></tr><tr><td>monotonic</td><td>described below</td></tr><tr><td>homoiconic</td><td>described below</td></tr></tbody></table><p>A string is treated as a list of atoms where each atom represents a character. This makes it a compound term.</p><p>Every compound term can be written as a functor name followed by an argument list. Each argument can be an atom, a variable, or another compound term. All compound terms, including nested ones, can be represented by a tree structure.</p><p>A rule can be thought of as a special kind of fact that depends on a set of other facts</p><p>Numbers can include underscores for readability. For example, <code>1_234_567</code> makes it more clear that this number is greater than one million.</p><p>The functor for <code>foo(bar, baz)</code> is written as <code>foo/2</code>.</p><p>The term &quot;monotonic&quot;, when used in the context of Prolog, is the property that:</p><ol><li>Adding constraints or conjunctions to a rule can only <strong>decrease</strong> the number of possible solutions.</li><li>Adding clauses or disjunctions can only <strong>increase</strong> the number of possible solutions.</li></ol><p>Prolog is a &quot;homoiconic&quot; language in that everything, including query results and complete Prolog programs, can be described by a term.</p><p>For more, see <a href="https://swi-prolog.org/pldoc/man?section=glossary" target="_blank">Glossary of Terms</a>.</p><h2 id="syntax" tabindex="-1">Syntax</h2><p>Prolog programs are composed of facts, rules, and queries. All of these are terminated by a period.</p><h3 id="facts" tabindex="-1">Facts</h3><p>A fact states that some relationship holds (always true). A fact cannot state relationships that do not hold.</p><p>A fact is written as a functor (atom) followed by an argument list that is surrounded by parentheses. The argument list contains only atoms, not variables.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">runner</span><span class="token punctuation">(</span>mark<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% says mark is a runner</span><br><span class="token comment">% We cannot use a rule to state that tami is not a runner.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> prolog<span class="token punctuation">)</span> <span class="token comment">% says mark likes prolog</span></code></pre><p>These are facts that say comet is a whippet and spots is a cheetah:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">whippet</span><span class="token punctuation">(</span>comet<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">cheetah</span><span class="token punctuation">(</span>spots<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Facts provide a convenient way to define constants that are used in several places within a program. For example, a &quot;size&quot; constant can be defined and used as follows:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">some_rule</span><span class="token punctuation">(</span>Arg1<span class="token punctuation">,</span> Arg2<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">size</span><span class="token punctuation">(</span>Size<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'The size is ~w.~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h3 id="rules" tabindex="-1">Rules</h3><p>Rules are written as a head and a body separated by the &quot;if&quot; operator <code>:-</code> and terminated by a period. They states that the head holds if all the goals in the body hold. Rules do not return a value like functions in other programming languages, but they can set the values of variables provided as arguments.</p><p>The head is a functor name followed by an argument list that is surrounded by parentheses. The head syntax is similar to that of a fact, but its argument list can contain variables.</p><p>The body is a comma (means &quot;and&quot;) or semicolon (means &quot;or&quot;) separated list of goals. Typically each goal is written on a separated line and indented, but this is not required.</p><p>The following rules state that something is fast if it is a cheetah or a whippet.</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">fast</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">cheetah</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">fast</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">whippet</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% The previous two lines can be replaced with the following</span><br><span class="token comment">% where the `;` operator or's its left and right values.</span><br><span class="token comment">% fast(X) :- cheetah(X); whippet(X).</span></code></pre><p>A fact is a degenerate case of a rule whose body only contains <code>true</code>. For example, the following are equivalent:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> ice<span class="token operator">-</span>cream<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> ice<span class="token operator">-</span>cream<span class="token punctuation">)</span> <span class="token operator">:-</span> true<span class="token operator">.</span></code></pre><p>The following rules define what it means for two people to be siblings or sisters.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dif<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This rule states that siblings must have the same father and the same mother.</span><br><span class="token comment">% It has four goals.</span><br><span class="token function">sibling</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">dif</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% can't be sibling of self</span><br>  <span class="token function">father</span><span class="token punctuation">(</span>F<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">father</span><span class="token punctuation">(</span>F<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">mother</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">mother</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">sister_of</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">dif</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% can't be sister of self</span><br>  <span class="token function">female</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">sibling</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Often functor names describe the arguments whose relationship is being described, separated by underscores. For example, the rule head <code>parent_child(P, C)</code> makes it clear that the first argument represents a parent and the second argument represents a child.</p><p>Good rules can be used in multiple directions, supporting multiple usage modes. For example, it should be possible to use the <code>parent_child</code> rule to find the children of a given parent, find the parents of a given child, and find all known combinations of parent and child. Using a name such as <code>parent_of</code> and <code>parent</code> makes this less clear.</p><p>Good functor names are general and describe a relationship rather than an action. Functor names containing words like &quot;count&quot;, &quot;drop&quot;, &quot;find&quot;, or &quot;sort&quot; imply that it performs an action rather than describing a relationship. For example, a rule that describes a relationship between a list and a sorted version of the list might be named &quot;list_sorted&quot; or &quot;list_ascending&quot;. These indicate that the rule has two arguments which are an unsorted list and a sorted list.</p><p>The <code>is</code> operator evaluates its right-hand side as an arithmetic expression and assign the result to its left-hand side. It should only be used when the right-hand side is an arithmetic expression. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">area</span><span class="token punctuation">(</span>circle<span class="token punctuation">,</span> Radius<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> X <span class="token operator">is</span> pi <span class="token operator">*</span> Radius<span class="token operator">^</span><span class="token number">2.</span><br><span class="token function">area</span><span class="token punctuation">(</span>square<span class="token punctuation">,</span> Side<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> X <span class="token operator">is</span> Side<span class="token operator">^</span><span class="token number">2.</span><br><span class="token function">area</span><span class="token punctuation">(</span>rectangle<span class="token punctuation">,</span> Width<span class="token punctuation">,</span> Height<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> X <span class="token operator">is</span> Width <span class="token operator">*</span> Height<span class="token operator">.</span><br><br><span class="token operator">?-</span> <span class="token function">area</span><span class="token punctuation">(</span>circle<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token number">12.566370614359172</span><span class="token operator">.</span></code></pre><p>TODO: See the version of the area rule that uses clpr in <a href="http://geometry.pl">geometry.pl</a>.</p><p>Rules only set the values variables that are arguments or used in body goals one time. Once set, they cannot be modified except through backtracking.</p><p>The last goal in a rule can be the built-in predicate <code>true</code> to always succeed. It can also be <code>false</code> or <code>fail</code> to always fail. None of these approaches are commonly used.</p><p>Rules can be recursive. The following rules compute the factorial of an integer:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token operator">!.</span><br><br><span class="token function">factorial</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> F<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  N1 <span class="token operator">is</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span><br>  <span class="token function">factorial</span><span class="token punctuation">(</span>N1<span class="token punctuation">,</span> F1<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  F <span class="token operator">is</span> N <span class="token operator">*</span> F1<span class="token operator">.</span><br><br><span class="token operator">?-</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> F<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is F = 120.</span></code></pre><p>Also see the <code>sum</code> example in the &quot;Lists&quot; section.</p><p>When a rule is not working as expected, it may be too general (true for invalid values) or too specific (false for valid values). A common way to fix a rule that is too general is to add more goals. A common way to fix a rule that is too specific is to add more versions of the rule.</p><h3 id="queries" tabindex="-1">Queries</h3><p>To ask a question in a top level, enter a query. after the <code>?-</code> operator. Top levels typical provide this operator as a prompt.</p><p>This is also referred to as &quot;posting&quot; a query.</p><p>The main point of Prolog is to find solutions to queries or determine that there are no solutions.</p><p>A query ask whether or how a goal can be satisfied, aka hold.</p><p>When a query has no uninstantiated variables, the result is <code>true</code> or <code>false</code>.</p><p>When uninstantiated variables are present, the result is a set of solutions. Each solution is expressed as a conjunction of variable values or constraints and the set of solutions is expressed as a disjunction. Conjunction (and'ed expressions) and disjunction (or'ed expressions) are described below. This makes the result a valid Prolog term.</p><p>The output from a query is a new, equivalent query that describes the possible known solutions. Solutions assign values to all variables in the query, which is referred to as making them &quot;ground&quot;. We say that only &quot;known&quot; solutions are found because it is possible that other solutions exist but cannot be found because they are not described by the provided facts and rules.</p><p>In summary, a query always has one of these four kinds of results:</p><ul><li><code>true</code> or <code>false</code></li><li>answer substitution expressed as sets of variable values for which the query holds</li><li>a conditional solution (aka residual goal) expressed as constraints on variable values</li><li>an exception describing why the query failed</li></ul><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This is a query that asks whether comet is fast.</span><br><span class="token operator">?-</span> <span class="token function">fast</span><span class="token punctuation">(</span>comet<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% true</span><br><br><span class="token comment">% This is a query that asks for something that is fast.</span><br><span class="token operator">?-</span> <span class="token function">fast</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% comet</span></code></pre><p>Suppose the following facts are loaded:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> tacos<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> books<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> running<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The query <code>likes(X, running)</code> will find &quot;mark&quot;.</p><p>The query <code>likes(mark, X)</code> will find &quot;tacos&quot;, &quot;books&quot;, and &quot;running&quot; that in that order. When a query has multiple matches, as in this example, the interpreter will wait for further input.</p><p>The query <code>likes(X, Y)</code> will find all known combinations of people and things that they like. When all arguments in a query are uninstantiated variables, it is referred to as a &quot;most general query&quot;. It is recommended to write nearly all rules in a way that supports the most general query.</p><p>To search for the next match, press the semicolon key. SWI-Prolog also supports pressing the n, r, space, or tab keys to do this. Scryer Prolog supports pressing a to output all remaining solutions.</p><p>To stop searching for matches before the last one is found, press the return key. SWI-Prolog also supports pressing the c or a keys to do this.</p><p>After the last match is found, a prompt for the next query will appear.</p><p>Variables can be used for any argument of a predicate. The unification process will find each set of variable values that cause the predicate to succeed, one set at a time.</p><p>The <code>once</code> predicate wraps another predicate and gives only the first solution. This is useful for predicates that never terminate or predicates where only the first solution is needed.</p><h3 id="conjunctions" tabindex="-1">Conjunctions</h3><p>The comma operator, read as &quot;and&quot;, is used in rules or queries where multiple goals must be met. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This rule says that mark likes females that like cycling.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token function">female</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">likes</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> cycling<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This query asks if mark loves tami AND tami loves mark.</span><br><span class="token operator">?-</span> <span class="token function">loves</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> tami<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">loves</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> mark<span class="token punctuation">)</span>`<br><br><span class="token comment">% This query searches for things that both mark and tami love.</span><br><span class="token comment">% X stands for the same value in both goals.</span><br><span class="token operator">?-</span> <span class="token function">loves</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">loves</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> X<span class="token punctuation">)</span></code></pre><p>Variables retain their values across query conjunctions, but their values are lost when a query ends. This is a feature of <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form?v=1.0.21" rel="noopener" target="_blank">static single-assignment</a> (SSA) that is used by Prolog. In SSA, &quot;each variable to be assigned exactly once and defined before it is used.&quot; and &quot;every definition (Prolog fact, rule, or query) gets its own version.&quot;</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog">X <span class="token operator">is</span> <span class="token number">6</span><span class="token punctuation">,</span> Y <span class="token operator">is</span> X <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> Z <span class="token operator">is</span> Y <span class="token operator">/</span> <span class="token number">3.</span><br><span class="token comment">% output is X = 6, Y = 12, Z = 4.</span><br><span class="token comment">% Subsequent queries cannot access these values.</span></code></pre><h3 id="disjunctions" tabindex="-1">Disjunctions</h3><p>The semicolon operator, read as &quot;or&quot;, is used in rules or queries where one of a set of goals must be met.</p><p>Earlier we saw a rule that stated something is fast if it is a cheetah or whippet. The following way of writing the rule uses disjunction:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% fast(X) :- cheetah(X); whippet(X).</span></code></pre><h2 id="typical-flow" tabindex="-1">Typical Flow</h2><p>To start a Prolog top level, enter an implementation-specific command such as <code>swipl</code> or <code>gprolog</code>.</p><p>To evaluate a query in the top level, enter the query terminated with a period.</p><p>If the query does not contain any variables then <code>true</code> or <code>false</code> will be output.</p><p>If the query does contain variables, a lazy search will be performed to find the first set of values that satisfy the query will be output. To see the next possible solution, press the semicolon key. A period will be output after the last set is found. To stop outputting solutions before the last one has been output, press the period key.</p><p>In some top level implementations such as SWI-Prolog, pressing <code>?</code> outputs help on supported key commands.</p><p>To evaluate arithmetic operators that result in a numeric value, assign the expression to a variable using the <code>is</code> operator. For example, entering <code>X is 1 + 2.</code> will output <code>X = 3.</code></p><p>The typical steps to run a Prolog program are:</p><ol><li>Add facts and rules to a Prolog source file that has an extension of <code>.pl</code></li><li>Load Prolog source files into the Prolog app.</li><li>Enter queries in the Prolog app.</li></ol><p>Unfortunately Prolog and Perl use the same file extension for their source files.</p><p>To load a <code>.pl</code> file in the top level, enter <code>[f].</code> or <code>consult(f).</code> where <code>f</code> is a file name without quotes or a file path in quotes. For example, to load the file <code>demo.pl</code> in the current directory, enter <code>[demo].</code></p><p>Alternatively, pass a source file to the top level when starting it. For example, <code>swipl demo.pl</code></p><p>In SWI-Prolog, after modifying source files that have already been loaded, enter <code>make.</code> to reload all of them.</p><p>To enter new facts and rules in a running session:</p><ul><li>Enter <code>[user].</code> to open stdin as a pseudo file.</li><li>Enter facts and rules.</li><li>Press ctrl-d to close and load the pseudo file.</li></ul><p>It seems this can replace existing facts rather than add to them.</p><h2 id="naming-conventions" tabindex="-1">Naming Conventions</h2><p>Atoms are sequences of letters, numbers, and underscores that begin with a lowercase letter. They can also be any text enclosed in single quotes (allows spaces). There are also the following special atoms: <code>;</code>, <code>!</code>, <code>[]</code>, and <code>{}</code>.</p><p>Variables are also sequences of letters, numbers, and underscores, but they begin with an uppercase letter or an underscore. An underscore by itself represents an anonymous variable. These can be used as arguments to predicates when the value of an argument does not matter.</p><p>Predicate names should describe a relationship rather than an imperative action. It is also recommended that they indicate the kinds of arguments they take and the order of the arguments. For example, using the name <code>sort</code> for a predicate that can generate a sorted list from an unsorted one is imperative and does not describe its arguments. A better name is <code>list_ascending</code> because:</p><ol><li>It indicates that there are two arguments.</li><li>It indicates the order of the arguments which is the unsorted list followed by the sorted list.</li><li>It does not favor a specific direction and can be used to generate a sorted list or determine whether a list is already sorted.</li></ol><p>The following built-in predicates are examples of good names: <code>atom_chars</code>, <code>atom_codes</code>, <code>atom_length</code>, <code>atom_prefix</code>, <code>number_chars</code>, and <code>number_codes</code>.</p><p>Only predicates with side effects such as producing output should have imperative names. The following built-in predicates are examples of this: <code>asserta</code>, <code>assertz</code>, <code>retract</code>, <code>retractall</code>, <code>write</code>, <code>write_canonical</code>, and <code>write_term</code>.</p><h2 id="common-errors" tabindex="-1">Common Errors</h2><p>When an attempt to run a Prolog program fails, it is often for one of these reasons.</p><ul><li>A token intended to be a variable starts with a lowercase letter instead of uppercase.</li><li>A rule has <code>:=</code> between its head and body instead of <code>:-</code>.</li><li>A goal in an intended conjunction ends with a period instead of a comma. Look for the error message &quot;Full stop in clause-body?&quot;.</li><li>The last argument to the <code>format</code> predicate is a single value instead of a list of values to be inserted in the format string.</li><li>An attempt assign an arithmetic expression to a variable uses the <code>=</code> operator instead of the <code>is</code> operator resulting in the expression not being evaluated.</li><li>The <code>-&gt;</code> operator is used in one goal of a multiple goal conjunction and so must be wrapped in parentheses.</li></ul><h2 id="compiler-directives" tabindex="-1">Compiler Directives</h2><p>Compiler directives in source files begin with <code>:-</code>. They have several purposed including:</p><ul><li>setting compiler flags</li><li>including other source files</li><li>including a module or library</li><li>evaluate goals when the source file is loaded</li></ul><h3 id="compiler-flags" tabindex="-1">Compiler Flags</h3><p>Prolog flags configure the operation of a Prolog compiler.</p><p>To get the value of a prolog flag, use the <code>current_prolog_flag</code> predicate. For example, <code>current_prolog_flag(double_quotes, F)</code> sets <code>F</code> to the current value.</p><p>To set the value of the prolog flag, use the directive <code>set_prolog_flag</code>. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">set_prolog_flag</span><span class="token punctuation">(</span>double_quotes<span class="token punctuation">,</span> chars<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>For details on the <code>double_quotes</code> flag, see the <a href="#strings">Strings</a> section.</p><p>Scryer prolog supports the following flags: <code>bounded</code>, <code>double_quotes</code>, <code>integer_rounding_function</code>, <code>max_arity</code>, <code>max_integer</code>, <code>min_integer</code>, <code>occurs_check</code>, and <code>unknown</code>. These are documented in the source file <code>src/lib/builtins.pl</code>. before the clauses for <code>current_prolog_flag</code>.`</p><p>SWI-Prolog supports many more flags. These are documented at <a href="https://www.swi-prolog.org/pldoc/man?section=flags" target="_blank">Environment Control (Prolog flags)</a>.</p><p>To suppress warnings about singleton variables, use the following directive:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">style_check</span><span class="token punctuation">(</span><span class="token operator">-</span>singleton<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h3 id="including-source-files" tabindex="-1">Including Source Files</h3><p>One Prolog source file can textually include another using the <code>include/1</code> directive. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">include</span><span class="token punctuation">(</span>util<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% includes the source file util.pl</span></code></pre><p>This is not currently supported in Scryer Prolog. A workaround is it to use the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token function">consult</span><span class="token punctuation">(</span>file<span class="token operator">-</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Another way to include another source file is to define it as a module and use the <code>use_module</code> compiler directive. For example, we could create the file <code>strings.pl</code> containing the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">module</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% This is intended to be run in Scryer Prolog which</span><br><span class="token comment">% defines the seq predicate in its dcgs library.</span><br><br><span class="token comment">% The first argument to the module predicate is the name of the module being defined.</span><br><span class="token comment">% The second argument is a list of functors being exported.</span><br><span class="token comment">% Note that DCG rules are passed two more arguments than appear.</span><br><span class="token operator">:-</span> <span class="token function">module</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">filename_extension/4</span><span class="token punctuation">,</span> <span class="token function">split/5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% To test this, enter phrase(split(",", P, S), "foo,bar").</span><br><span class="token function">split</span><span class="token punctuation">(</span>Delimiter<span class="token punctuation">,</span> Prefix<span class="token punctuation">,</span> Suffix<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">seq</span><span class="token punctuation">(</span>Prefix<span class="token punctuation">)</span><span class="token punctuation">,</span> Delimiter<span class="token punctuation">,</span> <span class="token function">seq</span><span class="token punctuation">(</span>Suffix<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% To test this, enter phrase(filename_extension(F, E), "foo.bar").</span><br><span class="token function">filename_extension</span><span class="token punctuation">(</span>Filename<span class="token punctuation">,</span> Extension<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> Filename<span class="token punctuation">,</span> Extension<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To use this module from another source file</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% The strings module defined in strings.pl is specific to Scryer Prolog.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span><br>  <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">filename_extension</span><span class="token punctuation">(</span>F<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"foo.bar"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"F = ~s, E = ~s~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>F<span class="token punctuation">,</span> E<span class="token punctuation">]</span><span class="token punctuation">)</span><br>  <span class="token comment">% outputs "F = foo, E = bar"</span><br><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h3 id="including-a-module%2Flibrary" tabindex="-1">Including a Module/Library</h3><p>To include a library (ex. clpfd), include a line like the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpfd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h3 id="evaluating-goals-on-load" tabindex="-1">Evaluating Goals on Load</h3><p>To evaluate goals when a source file is loaded, precede them with <code>:-</code>. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Hello, World!'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span></code></pre><p>A source file can contain any number of these.</p><p>Alternatively, to specify a conjunction of several goals to be evaluated, use <code>initialization</code>. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span>goal<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% or for multiple goals ...</span><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span>goal1<span class="token punctuation">,</span> goal2<span class="token punctuation">,</span> goal3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Another way to run a goal on load is to use the <code>-g</code> option. For example, <code>scry -g run,halt my_file.pl</code> loads a Prolog source file, executes its <code>run</code> goal, and executes <code>halt</code> to exit from top level. Omit the <code>halt</code> goal to remain in the top level so other goals can be interactively explored.</p><h3 id="command-line-arguments" tabindex="-1">Command-line Arguments</h3><p>To get command-line arguments in SWI-Prolog:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">current_prolog_flag</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> Argv<span class="token punctuation">)</span></code></pre><p>To get command-line arguments in Scryer Prolog:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">argv</span><span class="token punctuation">(</span>Args<span class="token punctuation">)</span></code></pre><h2 id="tree-representation" tabindex="-1">Tree Representation</h2><p>Every Prolog term can be represented as a tree where parent nodes are functors and arguments are children. For example, <code>a(b, c(d, e), f)</code> can be represented as the following tree:</p><ul><li>a/3<ul><li>b</li><li>c/2<ul><li>d</li><li>e</li></ul></li><li>f</li></ul></li></ul><h2 id="primitive-types" tabindex="-1">Primitive Types</h2><h3 id="booleans" tabindex="-1">Booleans</h3><p>Prolog represents Boolean values with the builtin predicates <code>true</code> (always succeeds) and <code>false</code> (same as <code>fail</code> and always fails).</p><p>Rather than writing a rule that sets an argument to <code>true</code> or <code>false</code>, it is preferable to write a rule that either succeeds or fails.</p><h3 id="numbers" tabindex="-1">Numbers</h3><p>The following rules determine whether a given number is even or odd:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">even</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">mod</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=:=</span> <span class="token number">0.</span><br><span class="token function">odd</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">mod</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=:=</span> <span class="token number">1.</span></code></pre><p>TODO: Add more detail here!</p><h3 id="strings" tabindex="-1">Strings</h3><p>Prolog can represent strings in three ways: a list of character atoms, a list of ASCII code integers, or an atom.</p><p>Literal strings can be delimited with double quotes or single quotes. SWI-Prolog adds the use of backticks which are non-standard.</p><p>To escape a quote inside a literal string, precede it with a backslash.</p><p>When single quotes are used, the value becomes an atom. A single quoted string containing no special characters such as spaces is equivalent to an atom with the same characters. For example, <code>'demo' == demo</code> is true.</p><p>In SWI-Prolog, when backticks are used, the value becomes a list of ASCII code integers.</p><p>When double quotes are used, the setting of the <code>double_quotes</code> flag determines what the value becomes.</p><table><thead><tr><th><code>double_quotes</code></th><th>`&quot;abc&quot;`` becomes</th></tr></thead><tbody><tr><td><code>atom</code></td><td>atom <code>abc</code></td></tr><tr><td><code>chars</code></td><td>list of character atoms <code>[a, b, c]</code></td></tr><tr><td><code>codes</code></td><td>list of ASCII code integers <code>[97, 98, 99]</code></td></tr></tbody></table><p>SWI-Prolog also supports the <code>double_quotes</code> value <code>string</code> which causes double-quoted strings to become a string type that is specific to SWI-Prolog.</p><p>The benefits of representing strings as lists of characters are that they can be output in a human-readable way, list predicates can be used to operate on them, and they can be partially instantiated with variable characters.</p><p>The default setting of <code>double_quotes</code> is <code>string</code> in SWI-Prolog and <code>chars</code> in Scryer Prolog. It is recommended to change this setting to <code>chars</code> in all implementations.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">set_prolog_flag</span><span class="token punctuation">(</span>double_quotes<span class="token punctuation">,</span> chars<span class="token punctuation">)</span><span class="token operator">.</span><br>L <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token operator">.</span>  <span class="token comment">% becomes a list of character atoms</span><br><span class="token comment">% L = [a, b, c].</span></code></pre><p>When the <code>double_quotes</code> flag is set to <code>chars</code>, the following are equivalent:</p><ul><li><code>&quot;&quot;</code> and <code>[]</code></li><li><code>&quot;a&quot;</code> and <code>[a]</code></li><li><code>&quot;abc&quot;</code> and <code>[a, b, c]</code></li></ul><p><a href="https://www.swi-prolog.org/pldoc/man?section=string?v=1.0.21" rel="noopener" target="_blank">The string type and its double quoted syntax</a> section 5.2.3 discusses the pros and cons of the string options.</p><p>Since a double-quoted string becomes a list of character atoms, its length can be obtained using the <code>length</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token string">"Mark"</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br>L <span class="token operator">=</span> <span class="token number">4.</span></code></pre><p>Since a single-quoted string becomes an atom, its length can be obtained using the <code>atom_length</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">atom_length</span><span class="token punctuation">(</span><span class="token string">'Mark'</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token number">4.</span></code></pre><p>To test whether a string contains a given substring, which could be a single character, use the <code>sub_string</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% 1st argument is the string to search.</span><br><span class="token comment">% 2nd argument is the number of characters before the substring.</span><br><span class="token comment">% 3rd argument is the number of characters in the substring.</span><br><span class="token comment">% 4th argument is the number of characters after the substring.</span><br><span class="token comment">% 5th argument is the substring to find.</span><br><span class="token comment">% It is not necessary to capture arguments 2-4.</span><br><span class="token function">once</span><span class="token punctuation">(</span><span class="token function">sub_string</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-></span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'found'</span><span class="token punctuation">)</span><span class="token operator">;</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'not found'</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To concatenate two strings, use the <code>string_concat</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">string_concat</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% sets S to "foobar"</span></code></pre><p>To create a list of ASCII values from a literal string, use the <code>name</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">'ABC'</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">]</span><span class="token operator">.</span></code></pre><p>To create a string from a list of ASCII values, also use the <code>name</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">name</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token string">'ABC'</span><span class="token operator">.</span></code></pre><p>To append two strings, convert them to lists of ASCII codes, append those lists, and convert the result back to a string. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">appendStrings</span><span class="token punctuation">(</span>S1<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> SR<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">name</span><span class="token punctuation">(</span>S1<span class="token punctuation">,</span> L1<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">name</span><span class="token punctuation">(</span>S2<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">append</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> LR<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">name</span><span class="token punctuation">(</span>SR<span class="token punctuation">,</span> LR<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">appendStrings</span><span class="token punctuation">(</span><span class="token string">'first '</span><span class="token punctuation">,</span> <span class="token string">'second'</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token string">'first second'</span></code></pre><p>To append multiple atomic values, including strings, use the <code>atomics_to_string</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">atomics_to_string</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is "foo3bar"</span></code></pre><p>The above approach will not work with double-quoted strings if the <code>double_quotes</code> flag is set to <code>chars</code> because in that case double-quotes strings will be treated as lists of atoms and lists are not atomic.</p><p>To join multiple atomic values with a delimiter between each, use the 3-argument version of <code>atomics_to_string</code>. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">atomics_to_string</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'|'</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is "foo|3|bar"</span></code></pre><p>To get a single character from a string, convert it to a list of ASCII codes, and use the <code>nth0</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">'Mark'</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">nth0</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> L<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">put</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% 114 (ASCII code for 'r')</span></code></pre><p>To get the tail of a string when the <code>double_quotes</code> flag is set to <code>chars</code>, use the <code>append</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token string">"foobarbaz"</span><span class="token punctuation">)</span><br><span class="token comment">% sets T to "barbaz"</span></code></pre><p>To split a string on a delimiter such as a space:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">split</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> Delimiter<span class="token punctuation">,</span> Prefix<span class="token punctuation">,</span> Suffix<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">once</span><span class="token punctuation">(</span><span class="token function">append</span><span class="token punctuation">(</span>Prefix<span class="token punctuation">,</span> <span class="token punctuation">[</span>Delimiter<span class="token operator">|</span>Suffix<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Example: filename_extension("foo.bar", F, E).</span><br><span class="token comment">% gives F = "foo", E = "bar"</span><br><span class="token function">filename_extension</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> Filename<span class="token punctuation">,</span> Extension<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">split</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> <span class="token operator">.</span><span class="token punctuation">,</span> Filename<span class="token punctuation">,</span> Extension<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% In SWI-Prolog the split_string predicate can be used.</span><br><span class="token function">split_string</span><span class="token punctuation">(</span><span class="token string">'foo,bar,baz'</span><span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% sets L to ["foo", "bar", "baz"]</span></code></pre><h2 id="data-structures" tabindex="-1">Data Structures</h2><p>ISO Prolog supports three data structures, structures, lists, and pairs. Some Prolog implementations, such as SWI-Prolog, also support dicts.</p><p>SWI-Prolog also supports dicts (a.k.a dictionaries). See <a href="https://eu.swi-prolog.org/pldoc/man?section=bidicts?v=1.0.21" rel="noopener" target="_blank">Dicts: structures with named arguments</a>.</p><h3 id="structures" tabindex="-1">Structures</h3><p>Structures (a.k.a. compound terms) are a bit like structs in some other programming languages. They group related values.</p><p>For example, <code>dog(whippet, comet)</code> is a structure that describes a dog whose breed is &quot;whippet&quot; and whose name is &quot;comet&quot;. In this example, one could think of <code>dog</code> as the type, and whippet and comet are the components of the structure. Developers determine the meaning and order of the components.</p><p>The syntax for a structure is the same as the syntax for a fact.</p><p>Structures can be used in facts and rules. Components of structures can be atoms or variables. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">owns</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> <span class="token function">pet</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> comet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">owns</span><span class="token punctuation">(</span>amanda<span class="token punctuation">,</span> <span class="token function">pet</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> maisey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">owns</span><span class="token punctuation">(</span>amanda<span class="token punctuation">,</span> <span class="token function">pet</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> oscar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">owns</span><span class="token punctuation">(</span>jeremy<span class="token punctuation">,</span> <span class="token function">pet</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> ramsay<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This takes a pet structure and destructures its kind and name.</span><br><span class="token function">print_pet</span><span class="token punctuation">(</span><span class="token function">pet</span><span class="token punctuation">(</span>Kind<span class="token punctuation">,</span> Name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'~w is a ~w.~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">,</span> Kind<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br>main <span class="token operator">:-</span><br>  <span class="token function">owns</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'pet = ~w~n'</span><span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% pet(dog,comet)</span><br><br>  <span class="token function">print_pet</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% comet is a dog.</span><br><br>  <span class="token function">owns</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> <span class="token function">pet</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'name = ~w~n'</span><span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% comet</span><br><br>  <span class="token function">owns</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> <span class="token function">pet</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'kind = ~w, name = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>C<span class="token punctuation">,</span> D<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% dog and comet</span><br><br><span class="token operator">:-</span> main<span class="token operator">.</span></code></pre><p>Structures can be nested. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">person</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token string">'123 Some Street'</span><span class="token punctuation">,</span> <span class="token string">'Somewhere'</span><span class="token punctuation">,</span> <span class="token string">'MO'</span><span class="token punctuation">,</span> <span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br>main <span class="token operator">:-</span><br>  <span class="token function">person</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> <span class="token function">address</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'street = ~w~n'</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% 123 Some Street</span><br><br><span class="token operator">:-</span> main<span class="token operator">.</span></code></pre><p>The parts of a structure can be obtained in multiple ways. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">report</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">functor</span><span class="token punctuation">(</span>Structure<span class="token punctuation">,</span> Name<span class="token punctuation">,</span> Arity<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Name = ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Arity = ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Arity<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">arg</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> Structure<span class="token punctuation">,</span> Arg<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"First Arg = ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Arg<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  Structure <span class="token operator">=..</span> List<span class="token punctuation">,</span> <span class="token comment">% uses the "univ" operator</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"List = ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>List<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">report</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% The output is</span><br><span class="token comment">% Name = a</span><br><span class="token comment">% Arity = 2</span><br><span class="token comment">% First Arg = b</span><br><span class="token comment">% List = [a,b,c]</span><br><span class="token comment">%   true.</span></code></pre><h3 id="lists" tabindex="-1">Lists</h3><p>Lists are commonly used to hold collections of elements when there can be any number of elements (even zero), their order matters, and all the elements have the same type (ex. all numbers).</p><p>A list can be written as a comma-separated set of terms surrounded by square brackets. For example, <code>[red, green, blue]</code> is a list of atoms and <code>[R, G, B]</code> is a list of variables that can be unified with any list containing exactly three elements.</p><p>An empty list is written as the atom <code>[]</code> which is called &quot;nil&quot;.</p><p>There are other ways to construct a list.</p><p>The dot functor (<code>./2</code>) is the list constructor. It is passed the head and the tail of the list to be constructed. For example, <code>.(H, T)</code> creates a list where <code>H</code> is a single element that is the head and <code>T</code> is a list of elements that is the tail. Often the names of variables that hold lists end in &quot;s&quot; (ex. <code>.(E, Es)</code>).</p><p>SWI-Prolog uses a different functor name for the list constructor. For example:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token string">'[|]'</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is L = [a, b, c].</span></code></pre><p>The head-tail separator <code>|</code> in <code>[H|T]</code> creates a list where H is a single element that is the head and <code>T</code> is a list of elements that is the tail. For example, <code>[a]</code> and <code>[a | []]</code> are both lists that only contain <code>a</code> and <code>[a | [b, c]]</code> is equivalent to <code>[a, b, c]</code>. Use of the <code>|</code> operator can be nested. For example, <code>[a | [b | [c]]]</code> is also equivalent to <code>[a, b, c]</code>.</p><p>The following are all equivalent ways to write the same list:</p><pre class="language-prolog"><code class="language-prolog"><span class="token punctuation">[</span>red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue<span class="token punctuation">]</span> <span class="token comment">% list notation</span><br><br><span class="token operator">.</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span> <span class="token operator">.</span><span class="token punctuation">(</span>green<span class="token punctuation">,</span> <span class="token operator">.</span><span class="token punctuation">(</span>blue<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">% function notation</span><br><span class="token comment">% In SWI-Prolog, the dots must be replaced by `'[|]'`.</span><br><br><span class="token punctuation">[</span>red <span class="token operator">|</span> <span class="token punctuation">[</span>green <span class="token operator">|</span> <span class="token punctuation">[</span>blue<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment">% head-tail separator notation</span><br><span class="token comment">% Specifying a tail of [] for [blue] is optional.</span></code></pre><p>Lists can be nested. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token punctuation">[</span>e<span class="token punctuation">,</span> <span class="token punctuation">[</span>f<span class="token punctuation">,</span> g<span class="token punctuation">,</span> h<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>A &quot;partial list&quot; is a term that could become a list. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token punctuation">[</span>a <span class="token operator">|</span> T<span class="token punctuation">]</span> <span class="token comment">% will be a list if T is a list</span><br><span class="token punctuation">[</span>a <span class="token operator">|</span> b<span class="token punctuation">]</span> <span class="token comment">% not a list because b is not a list</span><br><span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C <span class="token operator">|</span> T<span class="token punctuation">]</span> <span class="token comment">% will be a list of at least three elements if T is a list</span></code></pre><h4 id="destructuring" tabindex="-1">Destructuring</h4><p>The ISO <code>|</code> operator can be used to get the head and tail of a list. Anonymous variables (<code>_</code>) can be used as placeholders for elements whose values we don't care about.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">print_list_parts</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'head is ~w, tail is ~w'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>H<span class="token punctuation">,</span> T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">?-</span> <span class="token function">print_list_parts</span><span class="token punctuation">(</span><span class="token punctuation">[</span>red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is head is red, tail is [green,blue]</span></code></pre><p>The following code gets the first and third values from a list. The <code>| _</code> syntax at the end of the list on the left side indicates that we do not care about values in the tail of the list which includes all values after the third.</p><pre class="language-prolog"><code class="language-prolog"><span class="token punctuation">[</span>V1<span class="token punctuation">,</span> _<span class="token punctuation">,</span> V3 <span class="token operator">|</span> _<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token comment">% output is</span><br><span class="token comment">% V1 = 9,</span><br><span class="token comment">% V3 = 7.</span></code></pre><p>To create a new list that results from adding a value to the beginning of an existing list:</p><pre class="language-prolog"><code class="language-prolog">L1 <span class="token operator">=</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> L2 <span class="token operator">=</span> <span class="token punctuation">[</span>a <span class="token operator">|</span> L1<span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token comment">% output is L2 = [a, b, c, d].</span></code></pre><p>The follow recursive rule iterates over all the elements in a list. Note how destructuring a list into its head and tail can be done in the argument list.</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">print_elements</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% When the list is empty, do nothing.</span><br><br><span class="token function">print_elements</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:=</span><br>  <span class="token function">write</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token punctuation">,</span><br>  <span class="token function">print_elements</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">?-</span> <span class="token function">print_elements</span><span class="token punctuation">(</span><span class="token punctuation">[</span>red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is</span><br><span class="token comment">% red</span><br><span class="token comment">% green</span><br><span class="token comment">% blue</span></code></pre><h4 id="append-predicate" tabindex="-1">append Predicate</h4><p>The built-in, ISO predicate <code>append</code> relates two lists to a list that is the result of appending the first two lists.</p><p>If <code>append</code> were not built-in, it could be implemented as follows:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% Appending an empty list to any list gives the second list.</span><br><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Appending two lists is the same as appending</span><br><span class="token comment">% the head of the first list (H) to the result of appending</span><br><span class="token comment">% the tail of the first list (L1) to the second list (L2).</span><br><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>L1<span class="token punctuation">]</span><span class="token punctuation">,</span> L2<span class="token punctuation">,</span> <span class="token punctuation">[</span>H<span class="token operator">|</span>L3<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">append</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> L3<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Here are several examples of how <code>append</code> can be used:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% Is the result of appending two lists a given result list?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>true<span class="token operator">.</span><br><br><span class="token comment">% What is the result of appending two lists?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token comment">% What list must be appended to a given list to obtain a given result?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token comment">% What list must be prepended to a given list to obtain a given result?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><br><br><span class="token comment">% What lists can be appended to obtain a given result?</span><br><span class="token operator">?-</span> <span class="token function">append</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">;</span><br>false<span class="token operator">.</span></code></pre><p>To create a new list that is the result of appending multiple lists:</p><pre class="language-prolog"><code class="language-prolog">L1 <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> L2 <span class="token operator">=</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">]</span><span class="token punctuation">,</span> L3 <span class="token operator">=</span> <span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> L3<span class="token punctuation">]</span><span class="token punctuation">,</span> L4<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is L4 = [a, b, c, d, e, f].</span></code></pre><p>To create a new list that is the result of adding a value to the end of an existing list:</p><pre class="language-prolog"><code class="language-prolog">L1 <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">append</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> <span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is L2 = [a, b, c, d].</span></code></pre><h4 id="copy_term-predicate" tabindex="-1">copy_term Predicate</h4><p>The built-in, ISO <code>copy_term</code> predicate creates a copy of any term which can be a list or structure, possibly containing uninstantiated variables.</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">copy_term</span><span class="token punctuation">(</span>ListIn<span class="token punctuation">,</span> ListOut<span class="token punctuation">)</span></code></pre><h4 id="length-predicate" tabindex="-1">length Predicate</h4><p>The built-in, ISO <code>length</code> predicate relates a list to its length. For example:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">length</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Len<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% Len = 3</span></code></pre><h4 id="list_min-and-list_max-predicates" tabindex="-1">list_min and list_max Predicates</h4><p>The <code>list_min</code> and <code>list_max</code> predicates find the smallest and largest numbers in a list.</p><p>The <code>list_min</code> and <code>list_max</code> predicates are not defined in the ISO standard. They are present in the Scryer Prolog <code>lists</code> library. In SWI-Prolog, the <code>min_list</code> and <code>max_list</code> predicates provide the same functionality and are present in the <code>lists</code> library.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">list_min</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Min<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Min = 2.</span><br><br>L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">list_max</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Max<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Max = 9.</span></code></pre><h4 id="maplist-predicate" tabindex="-1">maplist Predicate</h4><p>The <code>maplist</code> predicate can be used to create a list that is derived by applying a given predicate to each element of another list. Predicates like this that take another predicate as an argument are called &quot;higher-order predicates&quot;.</p><p>The <code>maplist</code> predicate is not defined in the ISO standard. It is present in the Scryer Prolog <code>lists</code> library. It is also present in the SWI-Prolog <code>apply</code> library.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">double</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">var</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-></span> A <span class="token operator">is</span> B <span class="token operator">/</span> <span class="token number">2</span><span class="token operator">;</span> B <span class="token operator">is</span> A <span class="token operator">*</span> <span class="token number">2.</span><br><br><span class="token operator">:-</span> <span class="token function">maplist</span><span class="token punctuation">(</span>double<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">write</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span><br><span class="token comment">% output is [2, 4, 6]</span></code></pre><h4 id="member-predicate" tabindex="-1">member Predicate</h4><p>The <code>member</code> predicate can be used determine if a value is a member of a list.</p><p>The <code>member</code> predicate is not defined in the ISO standard. It is present in the Scryer Prolog and SWI-Prolog <code>lists</code> libraries.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">member</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% doesn't output true, but also doesn't fail</span><br><br>L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">member</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is false</span></code></pre><p>The <code>member</code> predicate can be used to iterate over the values in a list. For example, <code>member(X, [3, 7, 9])</code> will set <code>X</code> to each value in the list one at a time.</p><p>The <code>member</code> predicate can be used to implement the equivalent of the <code>list_max</code> predicate.</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">max_member</span><span class="token punctuation">(</span>List<span class="token punctuation">,</span> Max<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">member</span><span class="token punctuation">(</span>Max<span class="token punctuation">,</span> List<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% Max is a member of List.</span><br>  <span class="token comment">% It is not true that there is any member of List</span><br>  <span class="token comment">% whose value is greater than Max.</span><br>  <span class="token operator">\+</span> <span class="token punctuation">(</span><span class="token function">member</span><span class="token punctuation">(</span>E<span class="token punctuation">,</span> List<span class="token punctuation">)</span><span class="token punctuation">,</span> E <span class="token operator">></span> Max<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Compare the <code>max_member</code> rule to the following recursive rule which provides the same results.</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% The second argument to max_ is the maximum value found so far.</span><br><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> Max<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">max_</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> H<span class="token punctuation">,</span> Max<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">max_</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Max<span class="token punctuation">,</span> Max<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">max_</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> Max0<span class="token punctuation">,</span> Max<span class="token punctuation">)</span> <span class="token operator">:-</span> H <span class="token operator">></span> Max0<span class="token punctuation">,</span> <span class="token function">max_</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> H<span class="token punctuation">,</span> Max<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">max_</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> Max0<span class="token punctuation">,</span> Max<span class="token punctuation">)</span> <span class="token operator">:-</span> H <span class="token operator">=&lt;</span> Max0<span class="token punctuation">,</span> <span class="token function">max_</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> Max0<span class="token punctuation">,</span> Max<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h4 id="nth0-and-nth1-predicates" tabindex="-1">nth0 and nth1 Predicates</h4><p>The <code>nth0</code> and <code>nth1</code> predicates get a list element at a given index.</p><p>The <code>nth0</code> and <code>nth1</code> predicates are not defined in the ISO standard. They are present in the Scryer Prolog and SWI-Prolog <code>lists</code> libraries.</p><p>To get the list element at a given index:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">nth0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> L<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% zero-based index</span><br><span class="token comment">% output is E = b.</span><br><br>L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">nth1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> L<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% one-based index</span><br><span class="token comment">% output is E = b.</span></code></pre><p>To get the index of a given element in a list:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">nth0</span><span class="token punctuation">(</span>Index<span class="token punctuation">,</span> L<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% zero-based index</span><br><span class="token comment">% output is Index = 1.</span><br><br>L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">nth1</span><span class="token punctuation">(</span>Index<span class="token punctuation">,</span> L<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% one-based index</span><br><span class="token comment">% output is Index = 2.</span></code></pre><p>To create a new list that results from inserting a value at a given zero-based index in an existing list:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% Inserts x after 2nd element.</span><br>L1 <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">nth0</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> L2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> L1<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is L2 = [a, b, x, c].</span></code></pre><h4 id="permutation-predicate" tabindex="-1">permutation Predicate</h4><p>The <code>permutation</code> predicate gets all permutations of the elements in a given list.</p><p>The <code>permutation</code> predicate is not defined in the ISO standard. It is present in the Scryer Prolog and SWI-Prolog <code>lists</code> libraries.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">permutation</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Ps<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is</span><br><span class="token comment">% Ps = [1, 2, 3] ;</span><br><span class="token comment">% Ps = [1, 3, 2] ;</span><br><span class="token comment">% Ps = [2, 1, 3] ;</span><br><span class="token comment">% Ps = [2, 3, 1] ;</span><br><span class="token comment">% Ps = [3, 1, 2] ;</span><br><span class="token comment">% Ps = [3, 2, 1] ;</span><br>false<span class="token operator">.</span></code></pre><h4 id="reverse-predicate" tabindex="-1">reverse Predicate</h4><p>The <code>reverse</code> predicate relates a list to another list containing the same elements in reverse order.</p><p>The <code>reverse</code> predicate is not defined in the ISO standard. It is present in the Scryer Prolog and SWI-Prolog <code>lists</code> libraries.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is X = [3, 2, 1].</span></code></pre><h4 id="same_length-predicate" tabindex="-1">same_length Predicate</h4><p>The <code>same_length</code> predicate succeeds if two given lists have the same length.</p><p>The <code>same_length</code> predicate is not defined in the ISO standard. It is present in the Scryer Prolog and SWI-Prolog <code>lists</code> libraries.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog">L1 <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> L2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">same_length</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% doesn't output true, but also doesn't fail</span></code></pre><h4 id="select-predicate" tabindex="-1">select Predicate</h4><p>The <code>select</code> predicate relates a list to another list where the first instance of a given element is removed.</p><p>The <code>select</code> predicate is not defined in the ISO standard. It is present in the Scryer Prolog and SWI-Prolog <code>lists</code> libraries.</p><p>To create a new list that results from removing the first occurrence of a given value:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">select</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is L = [a, c, b].</span></code></pre><h4 id="sort-predicate" tabindex="-1">sort Predicate</h4><p>The built-in, ISO predicate <code>sort</code> relates a list to a sorted version of the list. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">[</span>banana<span class="token punctuation">,</span> cherry<span class="token punctuation">,</span> apple<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% S = [apple, banana, cherry]</span></code></pre><p>There is a defined sort order when the elements have different types. The order from lowest to highest is:</p><ul><li>variables sorted by their names</li><li>floating point numbers from lowest to highest</li><li>integers from lowest to highest</li><li>atoms sorted by their names</li><li>compound terms (structures) sorted by their arity and then by their functor name</li></ul><p>The following code demonstrates sorting a list containing all these kinds of elements.</p><pre class="language-prolog"><code class="language-prolog">L0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">b</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> a2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">a</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> a2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">a</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">,</span> foo<span class="token punctuation">,</span> bar<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> B<span class="token punctuation">,</span> A<span class="token punctuation">]</span><span class="token punctuation">,</span><br><span class="token function">sort</span><span class="token punctuation">(</span>L0<span class="token punctuation">,</span> L<span class="token punctuation">)</span><br><span class="token comment">% L = [_580800,_580802,1.1,2.2,1,2,bar,foo,a(a1),b(a1),a(a1,a2),b(a1,a2)]</span><br><span class="token comment">% The variables A and B were assigned the names _580800 and _580802.</span></code></pre><h4 id="sum_list-predicate" tabindex="-1">sum_list Predicate</h4><p>The <code>sum_list</code> predicate relates a list of numbers to its sum.</p><p>The <code>sum_list</code> predicate is not defined in the ISO standard. It is present in the Scryer Prolog and SWI-Prolog <code>lists</code> libraries.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">sum_list</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Sum<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Sum = 6.</span></code></pre><h4 id="miscellaneous-(move-these!)" tabindex="-1">Miscellaneous (MOVE THESE!)</h4><p>L = [c, a, d, b], max_member(Max, L). % output is Max = d.</p><p>To find the intersection of two lists:</p><pre class="language-prolog"><code class="language-prolog">L1 <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> L2 <span class="token operator">=</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> b<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">intersection</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> L3<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is L3 = [b, c].</span></code></pre><p>To find the union of two lists:</p><pre class="language-prolog"><code class="language-prolog">L1 <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> L2 <span class="token operator">=</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> b<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">union</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> L3<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is L3 = [a, c, b, d].</span></code></pre><p>To sort a list:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> b<span class="token punctuation">,</span> d<span class="token punctuation">,</span> a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">sort</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is [a, b, c, d].</span><br><br><span class="token function">age_compare</span><span class="token punctuation">(</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token function">person</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> A1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">person</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> A2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:-</span> A1 <span class="token operator">></span> A2<span class="token operator">.</span><br><span class="token function">age_compare</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">,</span> <span class="token function">person</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> A1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">person</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> A2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:-</span> A1 <span class="token operator">&lt;</span> A2<span class="token operator">.</span><br><span class="token function">age_compare</span><span class="token punctuation">(</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token function">person</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> A1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">person</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> A2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:-</span> A1 <span class="token operator">=</span> A2<span class="token operator">.</span><br><br><span class="token operator">?-</span> P1 <span class="token operator">=</span> <span class="token function">person</span><span class="token punctuation">(</span>ann<span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>   P2 <span class="token operator">=</span> <span class="token function">person</span><span class="token punctuation">(</span>bob<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>   P3 <span class="token operator">=</span> <span class="token function">person</span><span class="token punctuation">(</span>carl<span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>   People <span class="token operator">=</span> <span class="token punctuation">[</span>P1<span class="token punctuation">,</span> P2<span class="token punctuation">,</span> P3<span class="token punctuation">]</span><span class="token punctuation">,</span><br><br>   <span class="token function">predsort</span><span class="token punctuation">(</span>age_compare<span class="token punctuation">,</span> People<span class="token punctuation">,</span> Sorted<span class="token punctuation">)</span><span class="token punctuation">,</span><br>   <span class="token function">write</span><span class="token punctuation">(</span>Sorted<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span><br>   <span class="token comment">% output is [person(carl,19),person(ann,35),person(bob,50)]</span></code></pre><p>To determine if one list contains a subset of another:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">subset</span><span class="token punctuation">(</span><span class="token punctuation">[</span>b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% doesn't output true, but also doesn't fail</span><br><br>L <span class="token operator">=</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">subset</span><span class="token punctuation">(</span><span class="token punctuation">[</span>b<span class="token punctuation">,</span> e<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% outputs false</span></code></pre><p>There are no built-in predicates that determine if every or some element of a list satisfies a given predicate. Those can be implemented as follows:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This succeeds if every element in List satisfies Predicate</span><br><span class="token comment">% and fails otherwise.</span><br><span class="token function">every</span><span class="token punctuation">(</span>Predicate<span class="token punctuation">,</span> List<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">maplist</span><span class="token punctuation">(</span>Predicate<span class="token punctuation">,</span> List<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This succeeds if at least one element in List satisfies Predicate</span><br><span class="token comment">% and fails otherwise.</span><br><span class="token function">some</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span> fail<span class="token operator">.</span><br><span class="token function">some</span><span class="token punctuation">(</span>Predicate<span class="token punctuation">,</span> <span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">call</span><span class="token punctuation">(</span>Predicate<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">!;</span> <span class="token function">some</span><span class="token punctuation">(</span>Predicate<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The <code>every</code> and <code>some</code> predicates defined above can be used as follows:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">every</span><span class="token punctuation">(</span>clpfd<span class="token operator">:</span>even<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">% succeeds</span><br><span class="token function">every</span><span class="token punctuation">(</span>clpfd<span class="token operator">:</span>even<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">% fails</span><br><span class="token function">some</span><span class="token punctuation">(</span>clpfd<span class="token operator">:</span>even<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">% succeeds</span><br><span class="token function">some</span><span class="token punctuation">(</span>clpfd<span class="token operator">:</span>even<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">% fails</span></code></pre><p>For implementations of map, filter, and reduce, see <a href="https://pbrown.me/blog/functional-prolog-map-filter-and-reduce/?v=1.0.21" rel="noopener" target="_blank">Functional Prolog</a>.</p><p>To test whether all elements in a list are a given value:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">maplist</span><span class="token punctuation">(</span><span class="token operator">=</span><span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To test whether a list begins with a given sub-list:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">prefix</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% doesn't output true, but also doesn't fail</span></code></pre><p>To get the first element of a list:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>H<span class="token operator">|</span>_<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">.</span><br><span class="token comment">% output is H = a.</span></code></pre><p>To test whether a list ends with a given sub-list:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">last</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% doesn't output true, but also doesn't fail</span></code></pre><p>To get the last element of a list:</p><pre class="language-prolog"><code class="language-prolog">L <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">last</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is E = d.</span></code></pre><h3 id="pairs" tabindex="-1">Pairs</h3><p>A Prolog &quot;pair&quot; is a key and a value. There are two ways to write a pair, <code>k-v</code> or <code>-(k, v)</code>.</p><p>Searches for specific pairs in a list of pairs are sequential. For a more efficient key lookup see the &quot;Dicts&quot; section.</p><p>For details on predicates that operate on pairs, see <a href="https://eu.swi-prolog.org/pldoc/man?section=pairs?v=1.0.21" rel="noopener" target="_blank">library(pairs): Operations on key-value lists</a>.</p><p>To sort a list of pairs on their keys:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">keysort</span><span class="token punctuation">(</span><span class="token punctuation">[</span>c<span class="token operator">-</span>cow<span class="token punctuation">,</span> b<span class="token operator">-</span>bear<span class="token punctuation">,</span> a<span class="token operator">-</span>apple<span class="token punctuation">]</span><span class="token punctuation">,</span> Ps<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Ps = [a-apple, b-bear, c-cow].</span></code></pre><p>To get the keys from a list of pairs:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">pairs_keys</span><span class="token punctuation">(</span><span class="token punctuation">[</span>c<span class="token operator">-</span>cow<span class="token punctuation">,</span> b<span class="token operator">-</span>bear<span class="token punctuation">,</span> a<span class="token operator">-</span>apple<span class="token punctuation">]</span><span class="token punctuation">,</span> Ks<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Ks = [c, b, a].</span></code></pre><p>To get the values from a list of pairs:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">pairs_values</span><span class="token punctuation">(</span><span class="token punctuation">[</span>c<span class="token operator">-</span>cow<span class="token punctuation">,</span> b<span class="token operator">-</span>bear<span class="token punctuation">,</span> a<span class="token operator">-</span>apple<span class="token punctuation">]</span><span class="token punctuation">,</span> Vs<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Vs = [cow, bear, apple].</span></code></pre><p>To get both the keys and the values from a list of pairs:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">pairs_keys_values</span><span class="token punctuation">(</span><span class="token punctuation">[</span>c<span class="token operator">-</span>cow<span class="token punctuation">,</span> b<span class="token operator">-</span>bear<span class="token punctuation">,</span> a<span class="token operator">-</span>apple<span class="token punctuation">]</span><span class="token punctuation">,</span> Ks<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Ks = [c, b, a], Vs = [cow, bear, apple].</span></code></pre><p>When a list contains pairs with duplicate keys is sorted on those keys, we can get a new list where the keys are unique values and their values are lists of values. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">%- group_pairs_by_key([a-apple, a-apricot, b-banana, b-blueberry, c-cherry], G).</span><br><span class="token comment">% output is G = [a-[apple, apricot], b-[banana, blueberry], c-[cherry]].</span></code></pre><p>To swap keys and values in a list of pairs AND sort the pairs on their key:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">transpose_pairs</span><span class="token punctuation">(</span><span class="token punctuation">[</span>c<span class="token operator">-</span>cow<span class="token punctuation">,</span> b<span class="token operator">-</span>bear<span class="token punctuation">,</span> a<span class="token operator">-</span>apple<span class="token punctuation">]</span><span class="token punctuation">,</span> Ts<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Ts = [apple-a, bear-b, cow-c].</span></code></pre><p>The <code>map_list_to_pairs</code> predicate takes a predicate and a list of list. It creates a list of pairs where the key of each pair is the result of passing one of the sub-lists to a predicate and the associated value is the sub-list. For example, the following uses the <code>length</code> predicate.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">map_list_to_pairs</span><span class="token punctuation">(</span><br>     length<span class="token punctuation">,</span><br>     <span class="token punctuation">[</span><span class="token punctuation">[</span>apple<span class="token punctuation">,</span> apricot<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>banana<span class="token punctuation">,</span> blueberry<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>cherry<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>     Ps<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is Ps = [2-[apple, apricot], 2-[banana, blueberry], 1-[cherry]].</span></code></pre><p>The following code implements rules to determine if a queen on a chess board can attach another piece. Note that:</p><ul><li>Each board position is represented by a row-column pair.</li><li>The arguments destructure the keys and values of pairs that are passed in.</li><li>Anonymous variables (underscore) are used for values that do not matter.</li><li>The cut operator <code>!</code> stops searching after the first solution is found.</li></ul><pre class="language-prolog"><code class="language-prolog"><span class="token function">queen_can_attack</span><span class="token punctuation">(</span>R<span class="token operator">-</span>_<span class="token punctuation">,</span> R<span class="token operator">-</span>_<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token operator">!.</span> <span class="token comment">% same row</span><br><span class="token function">queen_can_attack</span><span class="token punctuation">(</span>_<span class="token operator">-</span>C<span class="token punctuation">,</span> _<span class="token operator">-</span>C<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token operator">!.</span> <span class="token comment">% same column</span><br><span class="token function">queen_can_attack</span><span class="token punctuation">(</span>R1<span class="token operator">-</span>C1<span class="token punctuation">,</span> R2<span class="token operator">-</span>C2<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token comment">% same diagonal</span><br>  <span class="token function">abs</span><span class="token punctuation">(</span>R1 <span class="token operator">-</span> R2<span class="token punctuation">)</span> <span class="token operator">=:=</span> <span class="token function">abs</span><span class="token punctuation">(</span>C1 <span class="token operator">-</span> C2<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h3 id="key%2Fvalue-pairs" tabindex="-1">Key/Value Pairs</h3><h4 id="assoc-library" tabindex="-1">assoc library</h4><p>Several Prolog implementations including Scryer Prolog, SICStus Prolog, and SWI-Prolog support collections of key/value pairs using the <a href="https://www.scryer.pl/assoc.html?v=1.0.21" rel="noopener" target="_blank">assoc library</a>.</p><p>The following code demonstrates the most commonly used predicates from this library, but there are more.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>assoc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br>demo <span class="token operator">:-</span><br>  <span class="token comment">% Create an empty assoc.</span><br>  <span class="token function">empty_assoc</span><span class="token punctuation">(</span>A0<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Add a key/value pair, resulting in a new assoc.</span><br>  <span class="token function">put_assoc</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> A0<span class="token punctuation">,</span> <span class="token string">'Mark'</span><span class="token punctuation">,</span> A1<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Retrieve the value corresponding to a given key.</span><br>  <span class="token function">get_assoc</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> A1<span class="token punctuation">,</span> Name<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Name = ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Delete the key/value pair for a given key.</span><br>  <span class="token comment">% The third argument can be a non-anonymous variable</span><br>  <span class="token comment">% that will be set to the value that was deleted.</span><br>  <span class="token function">del_assoc</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> A1<span class="token punctuation">,</span> _<span class="token punctuation">,</span> A2<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h4 id="dict-type" tabindex="-1">dict type</h4><p>SWI-Prolog supports another way to represent collections of key/value pairs using its custom dict type. Like the custom string type added in SWI-Prolog, the dict implementation violates the ISO standard in ways that allow writing code for SWI-Prolog that does not run in other implementations.</p><p>A dictionary, or dict for short, is a hash map. To create a dict, specify a tag followed by an open curly brace, key/value pairs where there is a colon between each key and value, and the pairs are separated by commas, and a closing curly brace. The tag can optionally begin with a module name and a colon. Then it must specify an atom or variable, which can be <code>_</code>.</p><p>Keys must be atoms or integers that are no larger than <code>max_tagged_integer</code>.</p><p>Values in dicts can be other dicts.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">report</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Hello, ~w ~w!~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>P<span class="token operator">.</span>first<span class="token punctuation">,</span> P<span class="token operator">.</span>last<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'I see you are ~w years old~n.'</span><span class="token punctuation">,</span> P<span class="token operator">.</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Your zip is ~w.~n'</span><span class="token punctuation">,</span> P<span class="token operator">.</span>address<span class="token operator">.</span>zip<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">?-</span> P <span class="token operator">=</span> person<span class="token punctuation">{</span><br>  first<span class="token operator">:</span> <span class="token string">'Mark'</span><span class="token punctuation">,</span><br>  last<span class="token operator">:</span> <span class="token string">'Volkmann'</span><span class="token punctuation">,</span><br>  age<span class="token operator">:</span> <span class="token number">62</span><span class="token punctuation">,</span><br>  address<span class="token operator">:</span> _<span class="token punctuation">{</span><br>    street<span class="token operator">:</span> <span class="token string">'123 Some Street'</span><span class="token punctuation">,</span><br>    city<span class="token operator">:</span> <span class="token string">'Somewhere'</span><span class="token punctuation">,</span><br>    state<span class="token operator">:</span> <span class="token string">'MO'</span><span class="token punctuation">,</span><br>    zip<span class="token operator">:</span> <span class="token number">12345</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span><br><span class="token function">report</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% The output is:</span><br><span class="token comment">% Hello, Mark Volkmann!</span><br><span class="token comment">% I see you are 62 years old.</span><br><span class="token comment">% Your zip is 12345.</span></code></pre><p>To get the value of a key in dict:</p><pre class="language-prolog"><code class="language-prolog">Value <span class="token operator">=</span> MyDict<span class="token operator">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">% returns false if key is missing?</span><br>Value <span class="token operator">=</span> MyDict<span class="token operator">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> defaultValue<span class="token punctuation">)</span> <span class="token comment">% uses default value if key is missing</span></code></pre><p>To use a default value when a keys is missing:</p><pre class="language-prolog"><code class="language-prolog">MyDict <span class="token operator">=</span> demo<span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>Key <span class="token operator">=</span> b<span class="token punctuation">,</span><br>Value <span class="token operator">=</span> MyDict<span class="token operator">.</span><span class="token function">get</span><span class="token punctuation">(</span>Key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'key ~w = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To test whether a key exists in a dict:</p><pre class="language-prolog"><code class="language-prolog">MyDict <span class="token operator">=</span> demo<span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>Key <span class="token operator">=</span> b<span class="token punctuation">,</span><br><span class="token punctuation">(</span>Value <span class="token operator">=</span> MyDict<span class="token operator">.</span><span class="token function">get</span><span class="token punctuation">(</span>Key<span class="token punctuation">)</span> <span class="token operator">-></span><br>    <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'key ~w = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">;</span><br>    <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'key ~w not found'</span><span class="token punctuation">,</span> Key<span class="token punctuation">)</span><br><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To create a new dict where a key/value part has been added or modified:</p><pre class="language-prolog"><code class="language-prolog">MyDict <span class="token operator">=</span> demo<span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>NewDict <span class="token operator">=</span> MyDict<span class="token operator">.</span><span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>TODO: Add more detail on working with dicts.</p><h3 id="linked-lists" tabindex="-1">Linked Lists</h3><p>Dictionary (<code>dict</code>) instances can have properties that refer to other instances. This can be used to implement a linked list. The following code demonstrates how to iterate over such instances:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This prints all the values found in a linked list.</span><br><span class="token function">print_list</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token operator">!.</span><br><span class="token function">print_list</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">write</span><span class="token punctuation">(</span>Node<span class="token operator">.</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token punctuation">,</span><br>  <span class="token function">print_list</span><span class="token punctuation">(</span>Node<span class="token operator">.</span>next<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This relates a node in a linked list to</span><br><span class="token comment">% a list of values found in all reachable nodes.</span><br><span class="token function">linked_list</span><span class="token punctuation">(</span>nil<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">linked_list</span><span class="token punctuation">(</span>Node<span class="token punctuation">,</span> L<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">linked_list</span><span class="token punctuation">(</span>Node<span class="token operator">.</span>next<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token comment">% This appends in the order encounter.</span><br>  <span class="token comment">% append([Node.value], L2, L).</span><br>  <span class="token comment">% This appends in reverse order.</span><br>  <span class="token function">append</span><span class="token punctuation">(</span>L2<span class="token punctuation">,</span> <span class="token punctuation">[</span>Node<span class="token operator">.</span>value<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span><br>  N1 <span class="token operator">=</span> node<span class="token punctuation">{</span>value<span class="token operator">:</span> <span class="token string">'alpha'</span><span class="token punctuation">,</span> next<span class="token operator">:</span> nil<span class="token punctuation">}</span><span class="token punctuation">,</span><br>  N2 <span class="token operator">=</span> node<span class="token punctuation">{</span>value<span class="token operator">:</span> <span class="token string">'beta'</span><span class="token punctuation">,</span> next<span class="token operator">:</span> N1<span class="token punctuation">}</span><span class="token punctuation">,</span><br>  N3 <span class="token operator">=</span> node<span class="token punctuation">{</span>value<span class="token operator">:</span> <span class="token string">'gamma'</span><span class="token punctuation">,</span> next<span class="token operator">:</span> N2<span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>  <span class="token function">print_list</span><span class="token punctuation">(</span>N3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% prints gamma then beta then alpha</span><br><br>  <span class="token function">linked_list</span><span class="token punctuation">(</span>N3<span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% [alpha, beta, gamma]</span><br><br>  <span class="token comment">% This creates a string containing joined values from a list.</span><br>  <span class="token function">atomics_to_string</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token function">write</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token punctuation">,</span> <span class="token comment">% alpha,beta,gamma</span><br>  halt<br><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="type-checking" tabindex="-1">Type Checking</h2><p>ISO Prolog provides many built-in predicates that can be used to assert the type of arguments. These are not supported in Scryer Prolog. Instead see the &quot;sufficiently instantiated&quot; (si) family of predicates in <a href="https://www.scryer.pl/si.html?v=1.0.21" rel="noopener" target="_blank">Module si</a>.</p><table><thead><tr><th>Predicate</th><th>Meaning</th></tr></thead><tbody><tr><td><code>var(V)</code></td><td>V is a variable</td></tr><tr><td><code>nonvar(V)</code></td><td>V is not a variable</td></tr><tr><td><code>number(V)</code></td><td>V is any kind of number</td></tr><tr><td><code>integer(V)</code></td><td>V is an integer</td></tr><tr><td><code>float(V)</code></td><td>V is a floating point number</td></tr><tr><td><code>rational(V)</code></td><td>V is a rational number (ex. 2r3)</td></tr><tr><td><code>rational(V, Numerator, Denominator)</code></td><td>V is a rational number with given a numerator and denominator</td></tr><tr><td><code>atom(V)</code></td><td>V is an atom</td></tr><tr><td><code>blob(V)</code></td><td>V is a blob</td></tr><tr><td><code>string(V)</code></td><td>V is a string</td></tr><tr><td><code>atomic(V)</code></td><td>V is not a variable or compound term</td></tr><tr><td><code>compound(V)</code></td><td>V is a compound term</td></tr><tr><td><code>functor(Term, Name, Arity)</code></td><td>gets the name and arity of any term</td></tr><tr><td><code>current_predicate(functor)</code></td><td>tests whether functor (ex. <code>op/3</code>) is a known predicate</td></tr><tr><td><code>callable(V)</code></td><td>V is an atom or a compound term</td></tr><tr><td><code>ground(V)</code></td><td>V is not a variable or a compound term that holds variables</td></tr><tr><td><code>cyclic_term(V)</code></td><td>V contains cycles (circular references)</td></tr><tr><td><code>acyclic_term(V)</code></td><td>V does not contain cycles (circular references)</td></tr></tbody></table><p>The following rule uses many of the predicates described above to output the type of a given value:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">writeln</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">write</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span> <span class="token comment">% predefined in SWI-Prolog</span><br><br><span class="token function">write_type</span><span class="token punctuation">(</span>Thing<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">atom</span><span class="token punctuation">(</span>Thing<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"atom"</span><span class="token punctuation">)</span><span class="token operator">;</span> <span class="token comment">% ex. a</span><br>  <span class="token function">is_list</span><span class="token punctuation">(</span>Thing<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"list"</span><span class="token punctuation">)</span><span class="token operator">;</span> <span class="token comment">% ex. [a]</span><br>  <span class="token function">compound</span><span class="token punctuation">(</span>Thing<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"compound"</span><span class="token punctuation">)</span><span class="token operator">;</span> <span class="token comment">% ex. a(b)</span><br>  <span class="token function">float</span><span class="token punctuation">(</span>Thing<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"float"</span><span class="token punctuation">)</span><span class="token operator">;</span> <span class="token comment">% ex. 3.1</span><br>  <span class="token function">integer</span><span class="token punctuation">(</span>Thing<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"integer"</span><span class="token punctuation">)</span><span class="token operator">;</span> <span class="token comment">% ex. 3</span><br>  <span class="token function">string</span><span class="token punctuation">(</span>Thing<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token operator">;</span> <span class="token comment">% ex. "a"</span><br>  <span class="token function">var</span><span class="token punctuation">(</span>Thing<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"variable"</span><span class="token punctuation">)</span><span class="token operator">;</span> <span class="token comment">% ex. A</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"unknown"</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Entering <code>functor(2 + 3, F, A).</code> sets <code>F</code> to <code>(+)</code> and <code>A</code> to <code>2</code>.</p><h2 id="higher-order-predicates" tabindex="-1">Higher-order Predicates</h2><p>Higher-order predicates, aka meta-predicates, are predicates that take another predicate as an argument and call it. Examples from the <code>lists</code> library include <code>call</code>, <code>findall</code>, <code>foldl</code>, and <code>maplist</code>. Examples from the <code>reif</code> library include <code>if_</code>, <code>tfilter</code>, and <code>tpartition</code>. Also, the custom predicates <code>every</code> and <code>some</code> defined in the &quot;Lists&quot; section above also do this.</p><p>The following code demonstrates using the <code>foldl</code> predicate in the <code>lists</code> library.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for #=</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for format</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for foldl</span><br><br><span class="token function">add</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">:-</span> C #<span class="token operator">=</span> A <span class="token operator">+</span> B<span class="token operator">.</span><br><br>run <span class="token operator">:-</span><br>  Numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token function">foldl</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> Numbers<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Sum<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Sum = ~d~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Sum<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The following code demonstrates using the <code>reif</code> library <code>if_</code>, <code>tfilter</code>, and <code>tpartition</code> predicates.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>reif<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">dog</span><span class="token punctuation">(</span>comet<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">dog</span><span class="token punctuation">(</span>maisey<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">dog</span><span class="token punctuation">(</span>oscar<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">dog</span><span class="token punctuation">(</span>ramsay<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">is_dog</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">dog</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">-></span> B <span class="token operator">=</span> true<span class="token operator">;</span> B <span class="token operator">=</span> false<span class="token operator">.</span><br><br><span class="token function">report_reif</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% The first argument must be a predicate that accepts</span><br>  <span class="token comment">% an extra variable argument to receive true or false.</span><br>  <span class="token function">if_</span><span class="token punctuation">(</span><br>    <span class="token function">is_dog</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">writeln</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'not a dog'</span><span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">writeln</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">write</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span><br><br>run <span class="token operator">:-</span><br>  <span class="token function">report_reif</span><span class="token punctuation">(</span>comet<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% dog</span><br>  <span class="token function">report_reif</span><span class="token punctuation">(</span>mark<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% not a dog</span><br><br>  Beings <span class="token operator">=</span> <span class="token punctuation">[</span>mark<span class="token punctuation">,</span> comet<span class="token punctuation">,</span> tami<span class="token punctuation">,</span> maisey<span class="token punctuation">,</span> ramsay<span class="token punctuation">,</span> oscar<span class="token punctuation">]</span><span class="token punctuation">,</span><br><br>  <span class="token function">tfilter</span><span class="token punctuation">(</span>is_dog<span class="token punctuation">,</span> Beings<span class="token punctuation">,</span> JustDogs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"JustDogs = ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>JustDogs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% [comet,maisey,ramsay,oscar]</span><br><br>  <span class="token function">tpartition</span><span class="token punctuation">(</span>is_dog<span class="token punctuation">,</span> Beings<span class="token punctuation">,</span> Dogs<span class="token punctuation">,</span> NonDogs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"dogs include ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Dogs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% [comet,maisey,ramsay,oscar]</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"non-dogs include ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NonDogs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% [mark,tami]</span></code></pre><h2 id="dynamic-predicates" tabindex="-1">Dynamic Predicates</h2><p>By default clauses cannot be added to or deleted from the knowledge base. To enable this, run a <code>dynamic</code> query on a specific functor. For example, to enable adding and removing &quot;likes&quot; predicates that take two arguments:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">dynamic</span><span class="token punctuation">(</span><span class="token function">likes/2</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Once this is done, a clause matching that head (<code>likes/2</code>) can be added to the beginning with <code>asserta</code> or added to the end with <code>assertz</code>.</p><p>In addition, clauses matching that head can be removed with the following predicates:</p><ul><li><p><code>retract</code> removes a specific clause identified by a term (head and body). Other clauses that match the head can still be used.</p></li><li><p><code>retractall</code> removes all clauses that match a given head. The predicate is still known to the runtime, but attempts to use the predicate after this will fail.</p></li><li><p><code>abolish</code> also removes all clauses that match a given head, but attempts to use the predicate after this result in a predicate existence error.</p></li></ul><p>For example, suppose we have the file <code>likes.pl</code> containing the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> books<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> running<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">likes</span><span class="token punctuation">(</span>tami<span class="token punctuation">,</span> bikes<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>A session can do the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token punctuation">[</span>likes<span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">dynamic</span><span class="token punctuation">(</span><span class="token function">likes/2</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">assertz</span><span class="token punctuation">(</span><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> reeces<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% adds after existing predicates</span><br><span class="token function">retract</span><span class="token punctuation">(</span><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> books<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% removes</span><br><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% outputs running and reeces</span><br><br><span class="token function">retractall</span><span class="token punctuation">(</span><span class="token function">likes</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% removes everything that mark likes</span><br><span class="token function">likes</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% outputs X = tami, Y = bikes.</span><br><span class="token function">retractall</span><span class="token punctuation">(</span><span class="token function">likes</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% removes everything that anybody likes</span><br><span class="token function">likes</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% outputs false.</span></code></pre><h2 id="input" tabindex="-1">Input</h2><p>Input can be read from a stream. There are two stream aliases, <code>user_input</code> (defaults to stdin) and <code>current_input</code> (defaults to stdin). The stream associated with <code>user_input</code> can be changed by the <code>set_prolog_IO</code> predicate. The stream associated with <code>current_input</code> can be changed by the <code>set_input</code> and <code>see</code> predicates.</p><p>Additional streams can be opened with the <code>open</code> predicate and closed with the <code>close</code> predicate.</p><p>The following predicates read from the <code>current_output</code> stream or a specified stream: <code>read</code>, <code>get_byte</code>, <code>get_char</code>, and <code>get_code</code>. For example:</p><pre class="language-prolog"><code class="language-prolog">greet <span class="token operator">:-</span><br>  <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Enter your name: '</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">read</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Hello, ~w!'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Enter a name in single or double quotes followed by a period. This is an odd requirement for users! Entering 'Mark'. results in the following output: <code>Hello, Mark!</code>.</p><p>To remove the requirement for the user to surround the value being entered in quotes and end with a period, SWI-Prolog provides the <code>read_line_to_string</code> predicate. This allows the user to enter any text and press the return key. Note that this predicate name violates Prolog naming convention for I/O that &quot;read&quot; is reserved for predicates that read entire Prolog terms. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">read_line_to_string</span><span class="token punctuation">(</span>user_input<span class="token punctuation">,</span> Name<span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Hello, ~w!~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The Scryer Prolog <code>charsio</code> library provides a similar predicate <code>get_line_to_chars/3</code>. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% :- use_module(library(charsio)).</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% The get_line_to_chars predicate in charsio includes the newline character.</span><br><span class="token comment">% The following reimplements it to avoid that.</span><br><span class="token function">get_line_to_chars</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> Cs0<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">get_line_to_chars_</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> Cs0<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">get_line_to_chars_</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> Cs0<span class="token punctuation">,</span> Cs<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token string">'$get_n_chars'</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Char<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token punctuation">(</span> Char <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span><br>    Cs0 <span class="token operator">=</span> Cs<br>  <span class="token operator">;</span> Char <span class="token operator">=</span> <span class="token punctuation">[</span>C<span class="token punctuation">]</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span> C <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token operator">-></span><br>      Rest <span class="token operator">=</span> Cs<br>    <span class="token operator">;</span> Cs0 <span class="token operator">=</span> <span class="token punctuation">[</span>C<span class="token operator">|</span>Rest<span class="token punctuation">]</span><span class="token punctuation">,</span><br>      <span class="token function">get_line_to_chars_</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> Rest<span class="token punctuation">,</span> Cs<span class="token punctuation">)</span><br>    <span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token operator">.</span><br><br>demo <span class="token operator">:-</span><br>  repeat<span class="token punctuation">,</span><br>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Enter name: '</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token comment">% read_line_to_string(user_input, Name), % user must press return key</span><br>    <span class="token function">get_line_to_chars</span><span class="token punctuation">(</span>user_input<span class="token punctuation">,</span> Name<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>    <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Hello, ~s!~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token operator">!.</span></code></pre><p>The <code>get</code> predicate reads a single character and sets a variable to its integer ASCII value.</p><p>To read from a file and write the contents to stdout, use the <code>open</code>, <code>get_char</code>, <code>get_code</code>, and <code>close</code> predicates. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">processStream</span><span class="token punctuation">(</span>end_of_file<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token operator">!.</span> <span class="token comment">% a "cut" that stops execution</span><br><br><span class="token function">processStream</span><span class="token punctuation">(</span>Char<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">write</span><span class="token punctuation">(</span>Char<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">get_char</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> NextChar<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">processStream</span><span class="token punctuation">(</span>NextChar<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">readFile</span><span class="token punctuation">(</span>File<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">open</span><span class="token punctuation">(</span>File<span class="token punctuation">,</span> read<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">get_char</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> Char<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">processStream</span><span class="token punctuation">(</span>Char<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">close</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'demo.txt'</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To read from a text file in Scryer Prolog:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for seq</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>pio<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for phrase_from_file and phrase_to_stream</span><br><span class="token function">phrase_from_file</span><span class="token punctuation">(</span><span class="token function">seq</span><span class="token punctuation">(</span>Cs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"input.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token function">phrase_to_stream</span><span class="token punctuation">(</span>Cs<span class="token punctuation">,</span> user_output<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% writes to stdout</span></code></pre><h2 id="output" tabindex="-1">Output</h2><p>There are three output stream aliases, <code>user_output</code> (defaults to stdout), <code>user_error</code> (defaults to stderr), and <code>current_output</code> (defaults to stdout). The streams associated with <code>user_output</code> and <code>user_error</code> can be changed by the <code>set_prolog_IO</code> predicate. The stream associated with <code>current_output</code> can be changed by the <code>set_output</code> and <code>tell</code> predicates.</p><p>Additional streams can be opened with the <code>open</code> predicate and closed with the <code>close</code> predicate.</p><p>The following predicates write to the <code>current_output</code> stream or a specified stream: <code>write</code>, <code>format</code>, <code>put_byte</code>, <code>put_char</code>, <code>put_code</code>, and <code>nl</code> (writes a newline character).</p><p>The first argument to the <code>write</code> predicate should be an atom, which can be produced by a single-quoted string.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">writeln</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">write</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span> <span class="token comment">% predefined in SWI-Prolog</span><br><br><span class="token comment">% The following four lines all produce the same output.</span><br><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span><br><span class="token function">write</span><span class="token punctuation">(</span>current_output<span class="token punctuation">,</span> <span class="token string">'Hello World!\n'</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% SWI-Prolog only</span><br><span class="token function">writeln</span><span class="token punctuation">(</span>current_output<span class="token punctuation">,</span> <span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% SWI-Prolog only</span></code></pre><p>The <a href="https://www.swi-prolog.org/pldoc/man?predicate=format/2?v=1.0.21" rel="noopener" target="_blank">format</a> predicate can also write to the current output stream. Often it is better to use the <code>format_</code> DCG non-terminal (described later) instead so the result can be captured and tested.</p><p>The <code>format</code> predicate takes a format string and a list of values to be substituted into the format string. The format string should be a list of character atoms, which can be produced by a double-quoted string when the <code>double_quotes</code> compiler flag is set to <code>chars</code>.</p><p>In Scryer Prolog, include the <code>format</code> library which defines the <code>format</code> predicate and the <code>format_</code> DCG non-terminal.</p><p>The format string can contain the following control sequences that all begin with a tilde:</p><ul><li><code>~d</code>: decimal</li><li><code>~D</code>: decimal with commas every three digits</li><li><code>~e</code>: floating point in exponential notation</li><li><code>~E</code>: same as <code>~e</code> but with a capital E</li><li><code>~f</code>: floating point without exponential notation</li><li><code>~i</code>: ignores corresponding value; no output</li><li><code>~Nf</code>: float value with only N decimal places</li><li><code>~n</code>: single newline character</li><li><code>~Nn</code>: N newline characters</li><li><code>~Nr</code>: integer converted to radix N For example, <code>~2r</code> outputs a number in binary, <code>~16r</code> outputs a number in lowercase hexadecimal, and <code>~16R</code> outputs an integer in uppercase hexadecimal.</li><li><code>~s</code>: literal string</li><li><code>~t</code>: inserts multiple spaces up to the next tab stop; used to left, center, or right align what follows</li><li><code>~w</code>: writes value of a variable or atom</li><li><code>~N|</code>: sets a tab stop at column N</li><li><code>~N+</code>: sets a tab stop at N columns past last tab stop (A tab stop is assumed at column zero.)</li></ul><p>For more control sequences, see the &quot;format&quot; link above.</p><p>A list of character atoms (which can be produced by a double-quoted string) should be passed as the first argument to the <code>format</code> predicate.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This is the equivalent of JavaScript console.log.</span><br><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"MyVariable = ~w~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>MyVariable<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"~w likes ~s."</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>mark<span class="token punctuation">,</span> <span class="token string">"Prolog"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% outputs "mark likes Prolog."</span></code></pre><p>Rules can write to the current output stream. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">greet</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Hello, ~w!"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">"Mark"</span><span class="token punctuation">)</span><br><span class="token comment">% outputs "Hello, Mark!"</span><br>```<br><br>Tab stops can be used to output aligned columns<span class="token operator">.</span><br>For example<span class="token operator">:</span><br><br>```prolog<br><span class="token function">print_row</span><span class="token punctuation">(</span>Row<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% The 1st list element is left-aligned.</span><br>  <span class="token comment">% The 2nd list element is center-aligned.</span><br>  <span class="token comment">% The 3rd list element is right-aligned.</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'~w~t~10+~t~w~t~10+~t~w~10+~n'</span><span class="token punctuation">,</span> Row<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> Rows <span class="token operator">=</span> <span class="token punctuation">[</span><br>     <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"baz"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>     <span class="token punctuation">[</span><span class="token string">"foolish"</span><span class="token punctuation">,</span> <span class="token string">"barking"</span><span class="token punctuation">,</span> <span class="token string">"bazooka"</span><span class="token punctuation">]</span><br>   <span class="token punctuation">]</span><span class="token punctuation">,</span><br>   <span class="token function">maplist</span><span class="token punctuation">(</span>print_row<span class="token punctuation">,</span> Rows<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The output is:</p><pre class="language-text"><code class="language-text">foo          bar           baz<br>foolish     barking     bazooka</code></pre><p>The 3-argument version of <code>format</code> can write to any stream, including a string. For example, the following code sets <code>S</code> to a formatted string.</p><pre class="language-prolog"><code class="language-prolog">Language <span class="token operator">=</span> <span class="token string">'Prolog'</span><span class="token punctuation">,</span><br>Assessment <span class="token operator">=</span> fun<span class="token punctuation">,</span><br><span class="token function">format</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"~w is ~w.~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Language<span class="token punctuation">,</span> Assessment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The <code>format_</code> DCG non-terminal is similar to <code>format</code>. Rather than writing to a stream it can be used with <code>phrase</code> to capture the output as a list of character atoms. This is typically preferred over using <code>format</code> so the result can be tested.</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog">S <span class="token operator">=</span> <span class="token string">'World'</span><span class="token punctuation">,</span><br><span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">format_</span><span class="token punctuation">(</span><span class="token string">"Hello, ~w!~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>S<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Result<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br><span class="token comment">% Result is a list of character atoms.</span><br><span class="token comment">% This writes each one to stdout.</span><br><span class="token function">maplist</span><span class="token punctuation">(</span>write<span class="token punctuation">,</span> Result<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The <code>format_</code> DCG non-terminal can also be used with the <code>phrase_to_stream</code> predicate to write the result to a given stream.</p><p>The <code>put</code> predicate writes a single ASCII value to the current output stream. It is the counterpart to the <code>get</code> predicate.</p><p>To write to a file, use the <code>open</code>, <code>write</code>, and <code>close</code> predicates. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">writeFile</span><span class="token punctuation">(</span>File<span class="token punctuation">,</span> Text<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">open</span><span class="token punctuation">(</span>File<span class="token punctuation">,</span> write<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">write</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> Text<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token punctuation">,</span><br>  <span class="token function">close</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">writeFile</span><span class="token punctuation">(</span><span class="token string">"demo.txt"</span><span class="token punctuation">,</span> <span class="token string">"first line\nsecond line"</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To write to a text file in Scryer Prolog:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>pio<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for phrase_to_file</span><br><span class="token function">phrase_to_file</span><span class="token punctuation">(</span><span class="token string">"This is\na test."</span><span class="token punctuation">,</span> <span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To write to a stream in Scryer Prolog (in this case stdout):</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>pio<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for phrase_to_stream</span><br><span class="token function">phrase_to_stream</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">,</span> user_output<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% writes to stdout</span></code></pre><p>To create a stream associated with a file, use the <code>open</code> predicate, passing it a file path string, a mode (<code>read</code>, <code>write</code>, <code>append</code>, or <code>update</code>), and a variable to capture the stream. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'demo.txt'</span><span class="token punctuation">,</span> write<span class="token punctuation">,</span> Stream<span class="token punctuation">)</span></code></pre><p>It is also possible to capture everything a goal writes to stdout in a string. For example:</p><pre class="language-prolog"><code class="language-prolog">my_goal <span class="token operator">:-</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'line #1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'line #2'</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span><br>  <span class="token function">with_output_to</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">,</span> my_goal<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">write</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><br><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>Another way to write to a string is to use a <a href="https://www.swi-prolog.org/pldoc/man?section=memory-files?v=1.0.21" rel="noopener" target="_blank">memory file</a> which may be specific to SWI-Prolog. This has the advantage that rules can be written to accept any stream, allowing them to write to a file or a string. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% Create a handle for a memory file.</span><br><span class="token function">new_memory_file</span><span class="token punctuation">(</span>Handle<span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token comment">% Open a stream to a memory file.</span><br><span class="token function">open_memory_file</span><span class="token punctuation">(</span>Handle<span class="token punctuation">,</span> write<span class="token punctuation">,</span> Stream<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">free_on_close</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token comment">% Write to the stream.</span><br><span class="token function">writeln</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> <span class="token string">'line #1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token function">writeln</span><span class="token punctuation">(</span>Stream<span class="token punctuation">,</span> <span class="token string">'line #2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token function">close</span><span class="token punctuation">(</span>Stream<span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token comment">% Copy the contents of the stream into a string.</span><br><span class="token function">memory_file_to_string</span><span class="token punctuation">(</span>Handle<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token function">write</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="special-characters" tabindex="-1">Special Characters</h2><table><thead><tr><th>Characters</th><th>Meaning</th></tr></thead><tbody><tr><td><code>:-</code></td><td>if; used to define rules</td></tr><tr><td><code>,</code></td><td>logical and</td></tr><tr><td><code>;</code></td><td>logical or</td></tr><tr><td><code>not</code></td><td>logical not</td></tr><tr><td><code>?-</code></td><td>begins a query</td></tr><tr><td><code>.</code></td><td>terminates all commands</td></tr><tr><td><code>%</code></td><td>begins single-line comment</td></tr><tr><td><code>/*</code> and <code>*/</code></td><td>delimits multi-line comment</td></tr></tbody></table><h2 id="operators" tabindex="-1">Operators</h2><p>Prolog operators can be prefix, infix, or postfix. Of the built-in operators, most are infix, a few are prefix, and none are postfix. Prefix operators are noted below.</p><p>Each operator has left, right, or no associativity.</p><p>Operators can be used in function form. For example, infix operators like <code>+</code> whose usage s typically written like <code>a + b</code> can instead be written as <code>+(a, b)</code>. As another example, <code>X is 3 * (1 + 2).</code> gives the same result (<code>9</code>) as <code>X is *(3, +(1, 2)).</code></p><p>The <code>write_canonical</code> predicate takes any term and outputs it in its equivalent function notation. For example, entering <code>write_canonical(3 * 1 + 2).</code> outputs <code>*(3,+(1,2))</code>.</p><h3 id="number-operators" tabindex="-1">Number Operators</h3><p>Prolog supports the following relational operators for numbers and arithmetic expressions. When the left and/or right side is an expression (ex. <code>X * 2</code>) it is evaluated before the comparison is performed.</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>=:=</code></td><td>equal value</td></tr><tr><td><code>=\=</code></td><td>not equal value</td></tr><tr><td><code>&lt;</code></td><td>less than</td></tr><tr><td><code>&gt;</code></td><td>greater than</td></tr><tr><td><code>=&lt;</code></td><td>less than or equal</td></tr><tr><td><code>&gt;=</code></td><td>greater than or equal</td></tr></tbody></table><h3 id="atom-and-string-operators" tabindex="-1">Atom and String Operators</h3><p>Prolog supports the following relational operators for atoms and strings (also works with numbers):</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>@&lt;</code></td><td>alphabetically less than</td></tr><tr><td><code>@=&lt;</code></td><td>alphabetically less than or equal</td></tr><tr><td><code>@&gt;</code></td><td>alphabetically greater than</td></tr><tr><td><code>@&gt;=</code></td><td>alphabetically greater than or equal</td></tr></tbody></table><h3 id="term-operators" tabindex="-1">Term Operators</h3><p>Prolog supports the following relational operators for single and compound terms:</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>==</code></td><td>identical terms</td></tr><tr><td><code>\==</code></td><td>not identical terms</td></tr><tr><td><code>=@=</code></td><td>structurally equivalent terms</td></tr><tr><td><code>\=@=</code></td><td>not structurally equivalent terms</td></tr></tbody></table><p>The <code>dif/2</code> predicate is an alternative to the <code>\==</code> operator. For example, <code>dif(A, B)</code> is similar to <code>A \== B</code>, but the difference is somewhat complicated. The <code>dif/2</code> predicate expresses that its arguments can never become identical and handles cases where this is not immediately known. For more detail, see <a href="https://github.com/dtonhofer/prolog_notes/tree/master/swipl_notes/about_dif?v=1.0.21" rel="noopener" target="_blank">About dif/2</a>.</p><p>The odd syntax for &quot;equal&quot; and &quot;not equal&quot; was chosen because <code>=</code> is used for unification.</p><p>The odd syntax for &quot;less than or equal&quot; was chosen so it doesn't look like an arrow.</p><p>The following tests demonstrate many of the relational operators:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">test</span><span class="token punctuation">(</span>equal<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  X <span class="token operator">is</span> <span class="token number">1</span><span class="token punctuation">,</span><br>  Y <span class="token operator">is</span> <span class="token number">1</span><span class="token punctuation">,</span><br>  X <span class="token operator">=:=</span> Y<span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>not_equal<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  X <span class="token operator">is</span> <span class="token number">1</span><span class="token punctuation">,</span><br>  Y <span class="token operator">is</span> <span class="token number">2</span><span class="token punctuation">,</span><br>  X <span class="token operator">=\=</span> Y<span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>alphabetically<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token string">'dog'</span> <span class="token operator">@&lt;</span> <span class="token string">'fox'</span><span class="token punctuation">,</span><br>  <span class="token string">'fox'</span> <span class="token operator">@></span> <span class="token string">'dog'</span><span class="token punctuation">,</span><br>  <span class="token string">'dog'</span> <span class="token operator">==</span> <span class="token string">'dog'</span><span class="token punctuation">,</span><br>  <span class="token string">'dog'</span> <span class="token operator">@=&lt;</span> <span class="token string">'dog'</span><span class="token punctuation">,</span><br>  <span class="token string">'dog'</span> <span class="token operator">@>=</span> <span class="token string">'dog'</span><span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>identical<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">x</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">x</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% same functor name and argument variables</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>not_identical<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">x</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">\==</span> <span class="token function">x</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% different argument variables</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>structurally_equivalent<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">]</span> <span class="token operator">=@=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token function">x</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">=@=</span> <span class="token function">x</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>not_structurally_equivalent<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">x</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">\=@=</span> <span class="token function">x</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> D<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% different arity</span><br>  <span class="token function">x</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">\=@=</span> <span class="token function">y</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% different functor name</span></code></pre><h3 id="arithmetic-operators" tabindex="-1">Arithmetic Operators</h3><p>Prolog supports the following arithmetic operators:</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>+</code></td><td>addition (infix and prefix)</td></tr><tr><td><code>-</code></td><td>subtraction (infix and prefix)</td></tr><tr><td><code>*</code></td><td>multiplication</td></tr><tr><td><code>/</code></td><td>floating point division</td></tr><tr><td><code>//</code></td><td>integer division</td></tr><tr><td><code>div</code></td><td>integer division</td></tr><tr><td><code>rem</code></td><td>remainder of integer division</td></tr><tr><td><code>rdiv</code></td><td>rational number division</td></tr><tr><td><code>mod</code></td><td>modulo</td></tr><tr><td><code>**</code></td><td>exponentiation</td></tr><tr><td><code>^</code></td><td>exponentiation</td></tr></tbody></table><h3 id="bitwise-operators" tabindex="-1">Bitwise Operators</h3><p>Prolog supports the following bitwise operators:</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>/\</code></td><td>bitwise and</td></tr><tr><td><code>\/</code></td><td>bitwise or</td></tr><tr><td><code>xor</code></td><td>bitwise exclusive or</td></tr><tr><td><code>\</code></td><td>bitwise not (prefix)</td></tr><tr><td><code>&lt;&lt;</code></td><td>bitwise shift left</td></tr><tr><td><code>&gt;&gt;</code></td><td>bitwise shift right</td></tr></tbody></table><h3 id="constraint-logic-programming-(clp)" tabindex="-1">Constraint Logic Programming (CLP)</h3><p>The CLP libraries implements Constraint Logic Programming through a series of new operators. These supports two primary use cases:</p><ul><li>declarative integer arithmetic</li><li>combinatorial problems</li></ul><p><a href="https://www.swi-prolog.org/pldoc/man?section=clp" target="_blank">CLP<a> provides a different way of expression Prolog constraints for values in specific domains. There are four supported domains:</a></a></p><ul><li><a href="https://www.swi-prolog.org/pldoc/man?section=clpfd" target="_blank">CLP(FD)<a> for integers</a></a></li><li><a href="https://www.swi-prolog.org/pldoc/man?section=clpb" target="_blank">CLP(B)<a> for Booleans</a></a></li><li><a href="https://www.swi-prolog.org/pldoc/man?section=clpqr" target="_blank">CLP(Q)<a> for rational numbers</a></a></li><li><a href="https://www.swi-prolog.org/pldoc/man?section=clpqr" target="_blank">CLP(R)<a> for floating point numbers</a></a></li></ul><p>When using Scryer or SICStus Prolog, consider using <a href="https://github.com/triska/clpz?v=1.0.21" rel="noopener" target="_blank">CLP(Z)</a> as an alternative to CLP(FD).</p><p>The atoms <code>inf</code> and <code>sup</code> represent extreme values in a given domain. For example, when the <code>clpfd</code> (or <code>clpz</code>) library is loaded, they represent extreme values of integers. They can only be used as range bounds specified with the <code>..</code> operator.</p><p>In the case of the integer domain:</p><ul><li><code>inf</code> represents the greatest value that is less than or equal to all integers. This can be thought of as negative infinity.</li><li><code>sup</code> represents the least value that is greater than or equal to all integers. This can be thought of as positive infinity.</li></ul><p>Each of these libraries define new operators. Highlights include the following:</p><ul><li><p>arithmetic constraints:</p><ul><li><code>#=</code> equal</li><li><code>#\=</code> not equal</li><li><code>#&gt;</code> greater</li><li><code>#&gt;=</code> greater or equal</li><li><code>#&lt;</code> less</li><li><code>#=&lt;</code> less or equal</li></ul></li><li><p>combinatorial constraints:</p><ul><li><p><code>all_distinct</code> holds when all elements in a list have distinct values</p><p>For example, this does not hold: <code>Values = [2, 5, 2], all_distinct(Values).</code></p></li><li><p><code>global_cardinality</code> checks number of occurrences of each value in a list</p><p>The first argument is a list of values to check. The second argument is a list of pairs where the key in each pair is a vale from the first list and the value in each pair is the number of times it occurs in the first list.</p><p>For example, this holds: <code>Vs = [2, 4, 2, 3, 2, 4], global_cardinality(Vs, [2-3, 3-1, 4-2]).</code></p></li></ul></li><li><p>integer range: <code>..</code></p><p>For example, <code>2..7</code> is the range of integers from 2 to 7 inclusive on both ends and <code>100..sup</code> is the range of integers from 100 to positive infinity.</p></li><li><p>membership constraints:</p><ul><li><p><code>in</code>: single value is in an inclusive range</p><p>For example, this holds: <code>Value = 3, Range = 2..7, Value in Range.</code></p></li><li><p><code>ins</code>: list of values all all in a range</p><p>For example, the following holds: <code>Values = [3, 4, 7], Range = 2..7, Values ins Range.</code></p><p>The rule <code>demo</code> defined below code relates three integers &gt;= 0 whose sum is 3.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for ins, #=, and label</span><br><br><span class="token function">demo</span><span class="token punctuation">(</span>A <span class="token operator">+</span> B <span class="token operator">+</span> C <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% Relate three integers >= 0 whose sum is 3.</span><br>  Vs <span class="token operator">=</span> <span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">]</span><span class="token punctuation">,</span><br>  Vs ins <span class="token number">0.</span><span class="token operator">.</span>sup<span class="token punctuation">,</span><br>  A <span class="token operator">+</span> B <span class="token operator">+</span> C #<span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span><br>  <span class="token function">label</span><span class="token punctuation">(</span>Vs<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To test this, enter queries like the following:</p><ul><li><p><code>demo(1 + 0 + 2 = 3).</code> - result is <code>true</code>.</p></li><li><p><code>demo(1 + 2 + 3 = 3).</code> - result is <code>false</code>.</p></li><li><p><code>demo(1 + 0 + X = 3).</code> - result is <code>X = 2.</code></p></li><li><p><code>demo(T).</code> - result is the following:</p><pre class="language-prolog"><code class="language-prolog">  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">+</span><span class="token number">3</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">+</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><br><span class="token operator">;</span>  T <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre></li></ul></li></ul></li><li><p>enumeration:</p><ul><li><p><code>indomain</code> ?</p></li><li><p><code>labeling</code> finds specific solutions to constraints. It takes a list of options and a list of constrained variables to which specific values should be assigned.</p></li><li><p><code>label</code> is a shorthand for <code>labeling</code> that uses an empty option list</p><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">findall</span><span class="token punctuation">(</span><br>  <span class="token punctuation">[</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token punctuation">(</span>X in <span class="token number">5.</span><span class="token operator">.</span><span class="token number">10</span><span class="token punctuation">,</span> Y in <span class="token number">7.</span><span class="token operator">.</span><span class="token number">14</span><span class="token punctuation">,</span> X #<span class="token operator">></span> Y<span class="token punctuation">,</span> <span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">[</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  Results<br><span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token function">writeln</span><span class="token punctuation">(</span>Results<span class="token punctuation">)</span><br><span class="token comment">% output is [[8,7],[9,7],[9,8],[10,7],[10,8],[10,9]]</span></code></pre></li></ul></li></ul><p>For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpfd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Find sub-ranges of the given ranges for X and Y</span><br><span class="token comment">% where the X value is larger than the Y value.</span><br>X in <span class="token number">5.</span><span class="token operator">.</span><span class="token number">10</span><span class="token punctuation">,</span> Y in <span class="token number">7.</span><span class="token operator">.</span><span class="token number">14</span><span class="token punctuation">,</span> X #<span class="token operator">></span> Y<span class="token punctuation">,</span> <span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">[</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is:</span><br><span class="token comment">% X in 8..10, % determined that X cannot be less than 8</span><br><span class="token comment">% Y#=&lt;X+ -1, % means Y is less than or equal to X - 1</span><br><span class="token comment">% Y in 7..9. % determined that Y cannot be greater than 9</span><br><br><span class="token comment">% Find values for X and Y in their respective ranges</span><br><span class="token comment">% where the X value is larger than the Y value.</span><br><span class="token comment">% The label predicate finds specific values for which this holds.</span><br>X in <span class="token number">5.</span><span class="token operator">.</span><span class="token number">10</span><span class="token punctuation">,</span> Y in <span class="token number">7.</span><span class="token operator">.</span><span class="token number">14</span><span class="token punctuation">,</span> X #<span class="token operator">></span> Y<span class="token punctuation">,</span> <span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">[</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is:</span><br><span class="token comment">% X = 8, Y = 7 ;</span><br><span class="token comment">% X = 9, Y = 7 ;</span><br><span class="token comment">% X = 9, Y = 8 ;</span><br><span class="token comment">% X = 10, Y = 7 ;</span><br><span class="token comment">% X = 10, Y = 8 ;</span><br><span class="token comment">% X = 10, Y = 9.</span></code></pre><p>The following operators are provided by the <code>clpfd</code> library:</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>#=</code></td><td>evaluates arithmetic expression on right and assigns to variable on left</td></tr><tr><td><code>#\=</code></td><td></td></tr><tr><td><code>#&lt;</code></td><td></td></tr><tr><td><code>#=&lt;</code></td><td></td></tr><tr><td><code>#&gt;=</code></td><td></td></tr><tr><td><code>#&gt;</code></td><td></td></tr><tr><td><code>in</code></td><td></td></tr><tr><td><code>ins</code></td><td></td></tr><tr><td><code>indomain</code></td><td></td></tr><tr><td><code>label</code></td><td></td></tr><tr><td><code>labelling</code></td><td></td></tr><tr><td><code>all_distinct</code></td><td></td></tr><tr><td><code>global_cardinality</code></td><td></td></tr><tr><td><code>#&lt;===&gt;</code></td><td></td></tr><tr><td><code>fd_dom</code></td><td></td></tr></tbody></table><p>When using CLP, compare values with <code>#=</code> instead of <code>=:=</code>.</p><p>The following rules describe the relationship between a geometry shape and its area using operators defined by the &quot;clpr&quot; library:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">area</span><span class="token punctuation">(</span>circle<span class="token punctuation">,</span> Radius<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> Pi <span class="token operator">is</span> pi<span class="token punctuation">,</span> <span class="token punctuation">{</span>X <span class="token operator">=</span> Pi <span class="token operator">*</span> Radius<span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token operator">.</span><br><span class="token function">area</span><span class="token punctuation">(</span>square<span class="token punctuation">,</span> Side<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token punctuation">{</span>X <span class="token operator">=</span> Side<span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token operator">.</span><br><span class="token function">area</span><span class="token punctuation">(</span>rectangle<span class="token punctuation">,</span> Width<span class="token punctuation">,</span> Height<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token punctuation">{</span>X <span class="token operator">=</span> Width <span class="token operator">*</span> Height<span class="token punctuation">}</span><span class="token operator">.</span></code></pre><p>The following is another way to describe the relationship between a circle and its area without using CLP:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">radius_area</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">:-</span><br>    <span class="token function">ground</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% tests whether R is not a free variable</span><br>    A <span class="token operator">is</span> pi <span class="token operator">*</span> R<span class="token operator">^</span><span class="token number">2.</span><br><br><span class="token function">radius_area</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">:-</span><br>    <span class="token function">ground</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% tests whether A is not a free variable</span><br>    R <span class="token operator">is</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>A <span class="token operator">/</span> pi<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h3 id="other-operators" tabindex="-1">Other Operators</h3><p>Prolog supports the following additional operators:</p><p>TODO: Finish documenting the meaning of some of these operators.</p><table><thead><tr><th>Operator</th><th>Meaning</th></tr></thead><tbody><tr><td><code>:-</code></td><td>prefix; appears before a compiler directive</td></tr><tr><td><code>:-</code></td><td>infix; appears between the head and body of every rule; read as &quot;if&quot;</td></tr><tr><td><code>?-</code></td><td>prefix operator that appears before every query</td></tr><tr><td><code>|</code></td><td>separates the head and tail of a list in <code>[H| T]</code></td></tr><tr><td><code>,</code></td><td>separates terms to be and'ed</td></tr><tr><td><code>;</code></td><td>separates terms to be or'ed</td></tr><tr><td><code>-&gt;</code></td><td>similar to ternary operator <code>?:</code> in other languages; called &quot;if-then&quot;</td></tr><tr><td><code>--&gt;</code></td><td>used in DCG grammar rules for implementing parsers</td></tr><tr><td><code>\+</code></td><td>prefix operator that succeeds when the goal that follows does not hold</td></tr><tr><td><code>=</code></td><td>attempts to unify by finding satisfying variable values on LHS and RHS</td></tr><tr><td><code>\=</code></td><td>tests whether two terms cannot be unified</td></tr><tr><td><code>=..</code></td><td>creates a goal from a list containing a functor name and arguments; called &quot;univ&quot;</td></tr><tr><td><code>is</code></td><td>attempts to unify LHS with RHS arithmetic expression result</td></tr><tr><td><code>&gt;:&lt;</code></td><td>partial unification between to dictionaries</td></tr><tr><td><code>!</code></td><td>cut; prevents further backtracking</td></tr><tr><td><code>$</code></td><td>similar to <code>!</code> TODO How does it differ?</td></tr><tr><td><code>*-&gt;</code></td><td>soft cut; rarely used</td></tr><tr><td><code>:=</code></td><td>evaluates RHS as JavaScript (odd!)</td></tr><tr><td><code>:&lt;</code></td><td>succeeds when LHS is a sub-dict of RHS dict</td></tr><tr><td><code>?</code></td><td>TODO: Does this compose two predicates?</td></tr><tr><td><code>:</code></td><td></td></tr><tr><td><code>\_</code></td><td></td></tr><tr><td><code>/</code></td><td></td></tr><tr><td><code>.</code></td><td></td></tr><tr><td><code>as</code></td><td></td></tr><tr><td><code>=&gt;</code></td><td></td></tr></tbody></table><p>Directives provide information to the Prolog compiler. They are preceded by the <code>:-</code> prefix operator. Highlights include:</p><ul><li><code>dynamic(functors)</code>: allows adding and removing clauses for given functors</li><li><code>if</code>, <code>elif</code>, <code>else</code>, and <code>endif</code>: support conditional compilation</li><li><code>include(file)</code>: includes a given source file</li><li><code>initialization(goal)</code>: executes a given goal at startup; multiple initializations are executed in the order they appear</li><li><code>module</code>: declares a module definition</li><li><code>multifile(functors)</code>: allows clauses for given functors to reside in multiple source files</li><li><code>op(priority, kind, name)</code>: defines a custom operator</li><li><code>public(functors)</code>: allows inspecting clauses of given functors</li><li><code>set_prolog_flag(flag, value)</code>: sets a flag to change compiler operation</li><li><code>use_module(library)</code>: declares usage of a module; for example, <code>:- use_module(library(clpfd)).</code></li></ul><p>Some Prolog implementations allow placing <code>:-</code> before any goals to execute it when the file is loaded. But the ISO standard requires using the <code>initialization</code> directive. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'Goodbye'</span><span class="token punctuation">)</span><br><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The <code>?-</code> operator precedes queries. The top level of most Prolog implementations displays that operator as a prompt. I have not found a reason to actually used the <code>?-</code> operator in code.</p><p>There are two primary differences between <code>=</code> and <code>is</code>. The first is that the RHS of <code>is</code> must be an arithmetic expression. The second is that <code>is</code> evaluates the RHS whereas <code>=</code> does not.</p><p>One way to evaluate a mathematical expression is to assign it to a variable. For example, we can compute the angle in degrees whose <code>sin</code> is <code>0.5</code> as follows:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% The asin function returns an angle in radians.</span><br><span class="token operator">?-</span> Angle <span class="token operator">is</span> <span class="token function">asin</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">180</span> <span class="token operator">/</span> pi<span class="token operator">.</span><br>Angle <span class="token operator">=</span> <span class="token number">29.999999999999996</span><span class="token operator">.</span></code></pre><p>After evaluating this, the variable <code>Angle</code> is no longer defined.</p><p>The <code>-&gt;</code> operator provides the equivalent of an &quot;if&quot; statement or ternary operator in other programming languages. The expression on the left can be a goal or conditional expression. There can be two parts on the right separated by a semicolon. The first part is used if the left side holds and the second part is used if it does not. Note that Prolog does not support the concept of Booleans, so this is not decided based on whether the left side evaluates to &quot;true&quot;.</p><p>See the &quot;Conditional Logic&quot; section for details on the <code>-&gt;</code> operator.</p><p>The <code>=..</code> operator is typically used in conjunction with the <code>call</code> predicate to dynamically create a goal and execute it. For example:</p><pre class="language-prolog"><code class="language-prolog">Format <span class="token operator">=</span> <span class="token string">'X=~w and Y=~w~n'</span><span class="token punctuation">,</span><br>Args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>Goal <span class="token operator">=..</span> <span class="token punctuation">[</span>format<span class="token punctuation">,</span> Format<span class="token punctuation">,</span> Args<span class="token punctuation">]</span><span class="token punctuation">,</span><br><span class="token function">call</span><span class="token punctuation">(</span>Goal<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% outputs "X=1 and Y=2"</span><br><span class="token comment">% This is equivalent to the non-dynamic</span><br><span class="token comment">% format('X=~w and Y=~w~n', [1, 2])</span></code></pre><h3 id="custom-operators" tabindex="-1">Custom Operators</h3><p>Custom operators can be defined. There are two required parts, declaration and implementation. The <code>op</code> predicate declares the precedence, type, and name of an operator.</p><p>The precedence is a number between 0 and 1200 where 0 removes the declaration and 1 is the highest precedence. This is used to determine the order in which operators are evaluated in expressions that include multiple operators.</p><p>The type defines whether the operator is:</p><ul><li>prefix: <code>fx</code> or <code>fy</code></li><li>infix: <code>xfx</code>, <code>xfy</code>, or <code>yfx</code></li><li>postfix: <code>xf</code> or <code>yf</code></li></ul><p>The name can be any symbol.</p><p>The following code defines an operator named <code>dbl</code> that doubles a number:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">arithmetic_function</span><span class="token punctuation">(</span><span class="token function">dbl/1</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">op</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token builtin">fx</span><span class="token punctuation">,</span> dbl<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">dbl</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span> <span class="token operator">:-</span> Y <span class="token operator">is</span> X <span class="token operator">*</span> <span class="token number">2.</span><br><br><span class="token operator">?-</span> X <span class="token operator">is</span> dbl <span class="token number">5.</span> <span class="token comment">% gives 10</span></code></pre><p>The expression <code>dbl 5</code> generates the arithmetic expression <code>5 * 2</code> and the <code>is</code> operator evaluates that to get <code>10</code>.</p><p>Existing operators, except the comma operator, can be redefined. The <code>|</code> operator can only be redefined as an infix operator whose precedence is at least 1001.</p><p>The <code>current_op</code> predicate asks queries operators. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% Get the priority and type of the "is" operator.</span><br><span class="token function">current_op</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token string">'is'</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is P = 700, T = xfx.</span><br><br><span class="token comment">% Get all prefix operators.</span><br><span class="token function">current_op</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> <span class="token builtin">fx</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is P = 1, N = ($); and many more</span><br><span class="token comment">% All the names are output inside parentheses. Why?</span><br><br><span class="token comment">% Get all operators.</span><br><span class="token function">current_op</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> F<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="arithmetic-functions" tabindex="-1">Arithmetic Functions</h2><p>Prolog supports a large number of functions that return a number. See <a href="https://www.swi-prolog.org/pldoc/man?section=functions?v=1.0.21" rel="noopener" target="_blank">Arithmetic Functions</a>. These include</p><ul><li><code>abs</code>: absolute value</li><li>bitwise operations such as shift and <code>xor</code></li><li><code>ceiling</code>: smallest integer that is greater than or equal to a value</li><li><code>e</code>: value of e (2.71828...)</li><li><code>floor</code>: largest integer that is less than or equal to a value</li><li><code>exp</code>: e to a given power</li><li><code>gcd</code>: greatest common denominator</li><li><code>inf</code>: positive infinity</li><li><code>lcm</code>: least common multiple</li><li><code>log</code>: logarithm base e (natural logarithm)</li><li><code>log10</code>: logarithm base 10</li><li><code>max</code>: maximum of two values</li><li><code>min</code>: minimum of two values</li><li><code>nan</code>: not a number value</li><li><code>pi</code>: value of pi (3.14159...)</li><li><code>random</code>: random integer between zero and an upper bound</li><li><code>random_float</code>: random float between zero and one (exclusive on both ends)</li><li><code>succ</code>: successive value; <code>succ(2, X)</code> gives <code>3</code>; <code>succ(X, 3)</code> gives <code>2</code></li><li><code>truncate</code>: similar to <code>floor</code>, but rounds toward zero for negative numbers</li><li>trigonometry functions</li></ul><h2 id="conditional-logic" tabindex="-1">Conditional Logic</h2><p>Prolog does not have the equivalent of an <code>if</code> or <code>select</code> statement found in many other programming languages. But it does have the <code>-&gt;</code> operator which is somewhat like the ternary operator in other programming languages. An &quot;else&quot; part is often chained onto this using the <code>;</code> operator. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">sign_word</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> Word<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token punctuation">(</span>N <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-></span> Word <span class="token operator">=</span> <span class="token string">'zero'</span><span class="token operator">;</span><br>  <span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">-></span> Word <span class="token operator">=</span> <span class="token string">'positive'</span><span class="token operator">;</span><br>  Word <span class="token operator">=</span> <span class="token string">'negative'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>When expressions using the <code>-&gt;</code> operator appear in a conjunction (comma-separated list of goals), it must be wrapped in parentheses in order to be treated as a single goal in the conjunction.</p><p>When the <code>;</code> operator is not used, it is treated as if it were specified with the <code>fail</code> predicate. This means that <code>condition -&gt; true-part</code> is the same as <code>condition -&gt; true-part; fail</code>. For example:</p><pre class="language-prolog"><code class="language-prolog">N <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><br><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'before'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% will print</span><br><span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'positive'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% will not print due to failing</span><br><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'after'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% will not print due to failing</span></code></pre><p>To fix the scenario above, replace the arrow line with the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'positive'</span><span class="token punctuation">)</span><span class="token operator">;</span> true<span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>Replacing the arrow operator with the comma operator produces a very similar result. The only difference is that without the arrow operator, if the &quot;true goal&quot; backtracks then the &quot;false goal&quot; will execute.</p><p>For example, the <code>sign_word</code> predicate above could be written as follows. Since no backtracking occurs in this example, the behavior is identical.</p><pre class="language-prolog"><code class="language-prolog"><span class="token function">sign_word</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> Word<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token punctuation">(</span>N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> Word <span class="token operator">=</span> <span class="token string">'zero'</span><span class="token operator">;</span><br>  <span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> Word <span class="token operator">=</span> <span class="token string">'positive'</span><span class="token operator">;</span><br>  Word <span class="token operator">=</span> <span class="token string">'negative'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The <code>if_</code> predicate ... TODO: Finish this.</p><h2 id="iteration" tabindex="-1">Iteration</h2><p>Iteration in Prolog is done with recursion or the <code>repeat</code> predicate.</p><p>The following code demonstrates several approaches to sum the numbers in a list.</p><pre class="language-prolog"><code class="language-prolog">TODO<span class="token operator">:</span> Finish this<span class="token operator">!</span>  See sum<span class="token operator">.</span>pl<span class="token operator">.</span></code></pre><p>The following code demonstrates using the <code>repeat</code> predicate:</p><pre class="language-prolog"><code class="language-prolog">repeat<span class="token punctuation">,</span><br>  <span class="token function">read</span><span class="token punctuation">(</span>Term<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% include a period at end of each entry</span><br>  <span class="token punctuation">(</span> Term <span class="token operator">=</span> stop<span class="token punctuation">,</span> <span class="token operator">!</span> <span class="token comment">% stops backtracking</span><br>  <span class="token operator">;</span> <span class="token function">write</span><span class="token punctuation">(</span>Term<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    fail <span class="token comment">% triggers backtracking</span><br>  <span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To get all the integers starting from one integer and ending at another, use the <code>between</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This sets V to 3, 4, 5, 6, and 7.</span><br><span class="token operator">?-</span> <span class="token function">between</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The <code>between</code> predicate can also be used to test whether a value is between two numbers inclusively. For example, the following are equivalent:</p><pre class="language-prolog"><code class="language-prolog">Row <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">,</span> Row <span class="token operator">=&lt;</span> <span class="token number">7.</span><br><span class="token function">between</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> Row<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="lists-of-solutions" tabindex="-1">Lists of Solutions</h2><p>The combination of the <code>findall</code> and <code>label</code> predicates are useful for creating a list of solutions that satisfy given constraints when there is a finite set of solutions. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpfd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">add</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">:-</span> C #<span class="token operator">=</span> A <span class="token operator">+</span> B<span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span><br>    <span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">% transform each solution into the list [A, B]</span><br>    <span class="token comment">% Find all pairs of integers that satisfy these constraints.</span><br>    <span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> A in <span class="token number">1.</span><span class="token operator">.</span><span class="token number">5</span><span class="token punctuation">,</span> A #<span class="token operator">></span> B<span class="token punctuation">,</span> <span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    Results <span class="token comment">% set this</span><br>  <span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Results = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Results<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% [[3,2],[4,1],[5,0]]</span><br>  halt<br><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The <code>bagof</code> predicate is similar to the <code>findall</code> predicate, but <code>bagof</code> fails when their a no solutions whereas <code>findall</code> unifies with the empty list.</p><p>The <code>setof</code> predicate is similar to the <code>bagof</code> predicate, but it sorts the solutions and removes duplicates.</p><h2 id="unfair-enumerations" tabindex="-1">Unfair Enumerations</h2><p>When a query has an infinite number of solutions, there are situations where some solutions will never be generated. This is referred to as an &quot;unfair enumeration&quot;.</p><p>For example, the following code defines DCG rules that describe:</p><ul><li>a sequence of one or more &quot;a&quot; atoms named <code>as</code></li><li>a sequence of one or more &quot;b&quot; atoms named <code>bs</code></li><li>a sequence that combines these named <code>as_and_bs</code></li></ul><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% needed in Scryer Prolog</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% needed in Scryer Prolog</span><br><br>as <span class="token operator">--></span> <span class="token string">"a"</span><span class="token punctuation">,</span> as_<span class="token operator">.</span><br>as_ <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> as<span class="token operator">.</span><br><br>bs <span class="token operator">--></span> <span class="token string">"b"</span><span class="token punctuation">,</span> bs_<span class="token operator">.</span><br>bs_ <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> bs<span class="token operator">.</span><br><br>as_and_bs <span class="token operator">--></span> as<span class="token punctuation">,</span> bs<span class="token operator">.</span></code></pre><p>If we ask for all possible solutions for <code>as_and_bs</code>, we get the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">phrase</span><span class="token punctuation">(</span>as_and_bs<span class="token punctuation">,</span> Cs<span class="token punctuation">)</span><span class="token operator">.</span><br>   Cs <span class="token operator">=</span> <span class="token string">"ab"</span><br><span class="token operator">;</span>  Cs <span class="token operator">=</span> <span class="token string">"abb"</span><br><span class="token operator">;</span>  Cs <span class="token operator">=</span> <span class="token string">"abbb"</span><br><span class="token comment">% and more!</span></code></pre><p>This will continue forever, giving solutions that contain more of the letter &quot;b&quot;. But we will never see a solution with more than one &quot;a&quot;.</p><p>This can be changed using &quot;iterative deepening&quot; which will iteratively increase the length of the solutions that are output. It will begin with the shortest solution which is &quot;ab&quot;. Then it will generate all solutions of length 3 which only include &quot;abb&quot; and &quot;aab&quot;. Then it will generate all solutions of length 4, and so on.</p><p>To add iterative deepening, we must add the <code>length</code> predicate with an unspecified length before the <code>phrase</code> predicate as follows:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">length</span><span class="token punctuation">(</span>Cs<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span>as_and_bs<span class="token punctuation">,</span> Cs<span class="token punctuation">)</span><span class="token operator">.</span><br>   Cs <span class="token operator">=</span> <span class="token string">"ab"</span><br><span class="token operator">;</span>  Cs <span class="token operator">=</span> <span class="token string">"abb"</span><br><span class="token operator">;</span>  Cs <span class="token operator">=</span> <span class="token string">"aab"</span><br><span class="token operator">;</span>  Cs <span class="token operator">=</span> <span class="token string">"abbb"</span><br><span class="token operator">;</span>  Cs <span class="token operator">=</span> <span class="token string">"aabb"</span><br><span class="token operator">;</span>  Cs <span class="token operator">=</span> <span class="token string">"aaab"</span><br><span class="token operator">;</span>  Cs <span class="token operator">=</span> <span class="token string">"abbbb"</span><br><span class="token operator">;</span> <span class="token operator">...</span> <span class="token operator">.</span></code></pre><h2 id="partial-goals" tabindex="-1">Partial Goals</h2><p>Prolog supports adding arguments to goals before they are called. This creates a &quot;partial goal&quot; and is similar to function currying in other programming languages. The resulting predicate can be passed to the <code>call</code> predicate in order to evaluate it. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpfd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">sum2</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> Z<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  Z #<span class="token operator">=</span> X <span class="token operator">+</span> Y<span class="token operator">.</span><br><br><span class="token function">sum3</span><span class="token punctuation">(</span>A1<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> A3<span class="token punctuation">,</span> A4<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  A4 #<span class="token operator">=</span> A1 <span class="token operator">+</span> A2 <span class="token operator">+</span> A3<span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span><br>  <span class="token function">sum3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> R1<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% 6</span><br><br>  <span class="token function">sum3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> R2<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% 2</span><br><br>  <span class="token comment">% Currying one argument.</span><br>  <span class="token function">call</span><span class="token punctuation">(</span><span class="token function">sum3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> R3<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span>R3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% 60</span><br><br>  <span class="token comment">% Currying two arguments.</span><br>  <span class="token function">call</span><span class="token punctuation">(</span><span class="token function">sum3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> R4<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span>R4<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% 60</span><br><br>  <span class="token comment">% Currying goal passed to maplist.</span><br>  Numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span><span class="token function">sum2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Numbers<span class="token punctuation">,</span> R5<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span>R5<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% [11,12,13]</span><br><br>  P <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token punctuation">,</span> <span class="token comment">% could be set to a different relational operator</span><br>  Term <span class="token operator">=..</span> <span class="token punctuation">[</span>P<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">% builds term from list containing functor and arguments</span><br>  <span class="token comment">% call(Term), % evaluates term</span><br>  <span class="token punctuation">(</span><span class="token function">call</span><span class="token punctuation">(</span>Term<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'yes'</span><span class="token punctuation">)</span><span class="token operator">;</span> <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">'no'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% yes</span><br><br>  halt<br><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>A predicate can be placed in a variable at runtime and later used to create a term with the <code>:..</code> operator which is evaluated using the <code>call</code> predicate. For example:</p><pre class="language-prolog"><code class="language-prolog">P <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token punctuation">,</span> <span class="token comment">% could be set to a different relational operator</span><br>Term <span class="token operator">=..</span> <span class="token punctuation">[</span>P<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">% builds term from list containing functor and arguments</span><br><span class="token function">call</span><span class="token punctuation">(</span>Term<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% evaluates term</span></code></pre><h2 id="error-handling" tabindex="-1">Error Handling</h2><p>Prolog provides <code>throw</code> and <code>catch</code> predicates for error handling.</p><p>The following builtin error types are provided (copied from <a href="https://sicstus.sics.se/sicstus/docs/3.12.11/html/sicstus/Exception.html?v=1.0.21" rel="noopener" target="_blank">SICStus Error and Exception Handling</a>):</p><ul><li><p><code>instantiation_error</code> or <code>instantiation_error(Goal, ArgNo)</code></p><p>This indicates that a goal was called with insufficiently instantiated variables.</p></li><li><p><code>type_error(TypeName,Culprit)</code> or <code>type_error(Goal,ArgNo,TypeName,Culprit)</code></p><p>This indicates that a goal was called with the wrong type of arguments. <code>TypeName</code> is the expected type and <code>Culprit</code> what was actually found.</p></li><li><p><code>domain_error(Domain,Culprit)</code> and <code>domain_error(Goal,ArgNo,Domain,Culprit)</code></p><p>This indicates that a goal was called with arguments of the right type, but with illegal values. <code>Domain</code> is the expected domain and <code>Culprit</code> what was actually found.</p></li><li><p><code>existence_error(ObjectType,Culprit)</code> or <code>existence_error(Goal,ArgNo,ObjectType,Culprit,Reserved)</code></p><p>This indicates that something does not exist. If the <code>unknown</code> compiler flag is set to <code>error</code>, this error is raised with ArgNo set to 0 when an undefined predicate is called.</p></li><li><p><code>consistency_error(Culprit1,Culprit2,Message)</code> or <code>consistency_error(Goal,Culprit1,Culprit2,Message)</code></p><p>This indicates that a consistency error occurs when two otherwise valid values or operations have been specified that are inconsistent with each other.</p></li><li><p><code>context_error(ContextType,CommandType)</code> or <code>context_error(Goal,ContextType,CommandType)</code></p><p>This indicates that the <code>CommandType</code> is not permitted in <code>ContextType</code>.</p></li><li><p><code>evaluation_error(ErrorType,Culprit)</code> or <code>evaluation_error(Goal,ArgNo,ErrorType,Culprit)</code></p><p>This indicates that an incorrect arithmetic expression was evaluated. This only occurs in <code>iso</code> execution mode.</p></li><li><p><code>permission_error(Operation,ObjectType,Culprit)</code> or <code>permission_error(Goal,Operation,ObjectType,Culprit,Reserved)</code></p><p>This indicates that the <code>Operation</code> is not permitted on <code>Culprit</code> of the type <code>ObjectType</code>.</p></li><li><p><code>representation_error(ErrorType)</code> or <code>representation_error(Goal,ArgNo,ErrorType)</code></p><p>This indicates that a representation error occurs when the program tries to compute some well-defined value that cannot be represented, such as a compound term with arity &gt; 255.</p></li><li><p><code>resource_error(ResourceType)</code> or <code>resource_error(Goal,ResourceType)</code></p><p>This indicates that a resource error occurs when there are insufficient resources (ex. memory) to complete execution.</p></li><li><p><code>syntax_error(Message)</code> or <code>syntax_error(Goal,Position,Message,Tokens,AfterError)</code></p><p>This indicates that a syntax error was found when reading a term with <code>read/[1,2]</code> or assembling a number from its characters with <code>number_chars/2</code>. In the former case this error is raised only if the <code>syntax_errors</code> compiler flag is set to <code>error</code>.</p></li><li><p><code>system_error</code> or <code>system_error(Message)</code></p><p>This indicates that an error occurred while dealing with the operating system.</p></li></ul><p>The following code demonstrates writing a rule that can throw and writing another rule uses the first rule and catches errors from it.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This throws if N is less than zero.</span><br><span class="token function">double</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> D<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token punctuation">(</span> N #<span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">-></span><br>    D #<span class="token operator">=</span> N <span class="token operator">*</span> <span class="token number">2</span><br>  <span class="token operator">;</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token function">error</span><span class="token punctuation">(</span><br>      <span class="token function">domain_error</span><span class="token punctuation">(</span>non_negative_integer<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">,</span><br>      <span class="token function">double/2</span><br>    <span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token operator">.</span><br><br>demo <span class="token operator">:-</span><br>  <span class="token function">catch</span><span class="token punctuation">(</span><br>    <span class="token comment">% The first argument specifies the goal to try.</span><br>    <span class="token comment">% Change -3 to 3 to see what happens when no error is thrown.</span><br>    <span class="token function">double</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>    <span class="token comment">% The second argument specifies the kinds of errors to handle.</span><br>    <span class="token function">error</span><span class="token punctuation">(</span><span class="token function">domain_error</span><span class="token punctuation">(</span>Domain<span class="token punctuation">,</span> Value<span class="token punctuation">)</span><span class="token punctuation">,</span> Context<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>    <span class="token comment">% The second argument can also be a variable to catch any kind of error.</span><br>    <span class="token comment">% Error,</span><br><br>    <span class="token comment">% The third argument specifies what to do after an error is caught.</span><br>    <span class="token punctuation">(</span><br>      <span class="token function">format</span><span class="token punctuation">(</span><br>        <span class="token string">"~w was passed ~w which is not in the domain ~w.~n"</span><span class="token punctuation">,</span><br>        <span class="token punctuation">[</span>Context<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> Domain<span class="token punctuation">]</span><br>      <span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>      <span class="token comment">% Use this instead of the previous line</span><br>      <span class="token comment">% when the second argument is a variable.</span><br>      <span class="token comment">% format("Error = ~w~n", [Error]),</span><br><br>      <span class="token comment">% optionally fail this rule when an error is caught.</span><br>      <span class="token comment">% fail</span><br><br>      <span class="token comment">% This provides a value for D when an error is caught.</span><br>      D <span class="token operator">=</span> <span class="token number">0</span><br>    <span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"D = ~d~n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>D<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="pure-monotonic-core" tabindex="-1">Pure Monotonic Core</h2><p>The following is from Dr. Markus Triska:</p><blockquote><p>To benefit most from Prolog, you must keep to its <strong>pure monotonic core</strong>. Side-effects and extra-logical predicates are well outside this core. Try to think in terms of relations and state what you want to describe, using only the predicates from the pure core. A small number of predicates suffices to express a great number of programs in this way.</p><p>As a guidance, the enumeration of libraries at <a href="https://github.com/mthom/scryer-prolog/#modules" target="_blank">Scryer Prolog Modules</a> is ordered roughly in proportion of their expected need when keeping to the pure monotonic core, with <code>lists</code>, <code>dcgs</code>, <code>dif</code>, <code>reif</code> and <code>clpz</code> at the start. These 5 libraries broadly suffice for a good 1-year course about Prolog.</p><p>The library <code>format</code> is down further in this list, and the documentation makes it clear that <code>format_//2</code> should be used to declaratively describe the output instead of only emitting it via side-effects. The predicates from the <code>iso_ext</code> library such as <code>bb_get/2</code>, etc. are even further down in this list and may be interesting for internal use by authors of constraint solvers.</p></blockquote><p>In the context of Prolog, &quot;pure&quot; means that the relations described in a program have certain properties such as not mutating data and not causing side effects (like producing output).</p><p>In the context of Prolog, &quot;monotonic&quot; means that adding a clause for a predicate or removing a goal from a clause only makes the predicate more general. This allows more solutions rather than removing any.</p><h2 id="help" tabindex="-1">Help</h2><p>Documentation of predicates uses <strong>argument mode indicators</strong> that are described at <a href="https://www.swi-prolog.org/pldoc/man?section=preddesc" target="_blank">Notation of Predicate Descriptions</a>. These include <code>++</code> (ground), <code>+</code> (instantiated), <code>-</code> (output), <code>--</code> (unbound), <code>?</code> (partially bound), <code>:</code> (meta-argument such as a goal), <code>@</code> (will not be instantiated), and <code>!</code> (mutable).</p><p>SWI-Prolog provides predicates that output information about predicates. These include <code>apropos</code>, <code>help</code>, and <code>listing</code>.</p><p>To find information about built-ins related to a specific word in SWI-Prolog, enter <code>apropos(word).</code>. For example, <code>apropos(pair).</code> outputs the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% LIB pairs_keys/2                        Remove the values from a list of Key-Value pairs.</span><br><span class="token comment">% LIB pairs_values/2                      Remove the keys from a list of Key-Value pairs.</span><br><span class="token comment">% LIB pairs_keys_values/3                 True if Keys holds the keys of Pairs and Values the values.</span><br><span class="token comment">% SWI dict_pairs/3                        Bi-directional mapping between a dict and an ordered list of pairs (see secti ...</span><br><span class="token comment">%   C 'PL_is_pair'()                      Returns non-zero if term is a compound term using the list constructor.</span><br><span class="token comment">% SWI stream_pair/3                       This predicate can be used in mode (-,+,+) to create a stream-pair from an in ...</span><br><span class="token comment">% SEC 'summary-lib-pairs'                 library(pairs)</span><br><span class="token comment">% LIB protobuf_map_pairs/3                Convert between a list of protobuf map entries (in the form DictTag{key:Key,  ...</span><br><span class="token comment">% LIB transpose_pairs/2                   Swap Key-Value to Value-Key.</span><br><span class="token comment">% LIB json_dict_pairs/2                   This hook may be used to order the keys of an object.</span><br><span class="token comment">% LIB map_list_to_pairs/3                 Create a Key-Value list by mapping each element of List.</span><br><span class="token comment">% LIB group_pairs_by_key/2                Group values with equivalent (==/2) consecutive keys.</span><br><span class="token comment">% ISO keysort/2                           Sort a list of pairs.</span><br><span class="token comment">% LIB all_distinct/1                      True iff Vars are pairwise distinct.</span><br><span class="token comment">%   C 'PL_clear_hash_table'()             Delete all key-value pairs from the table.</span><br><span class="token comment">%   C 'PL_advance_hash_table_enum'()      Get the next key-value pair from a cursor.</span><br><span class="token comment">%   C 'PL_new_hash_table'()               Create a new table for size key-value pairs.</span><br><span class="token comment">% SEC pairs                               library(pairs): Operations on key-value lists</span><br><span class="token comment">% LIB assoc_to_list/2                     Translate Assoc to a list Pairs of Key-Value pairs.</span><br><span class="token comment">%   C 'PL_STRINGS_MARK'()                 These macros must be paired and create a C block ({...}).</span><br><span class="token comment">% Showing 20 of 52 matches</span><br><span class="token comment">%</span><br><span class="token comment">% Use ?- apropos(Type:Query) or multiple words in Query</span><br><span class="token comment">% to restrict your search.  For example:</span><br><span class="token comment">%</span><br><span class="token comment">%   ?- apropos(iso:open).</span><br><span class="token comment">%   ?- apropos('open file').</span></code></pre><p>For more detailed help on a specific predicate, enter <code>help(functor/arity).</code> For example, <code>help(between/3).</code></p><p>To list all the clauses (facts and rules) known in the current session, enter <code>listing.</code>. The output will contain many built-in clauses in addition to those you loaded.</p><p>To list only the clauses for a given functor name, enter <code>listing(functor-name).</code> This will list all matching clauses regardless of arity.</p><p>For example, <code>listing(append).</code> shows the implementation of this functor name.</p><h2 id="debugging" tabindex="-1">Debugging</h2><h3 id="trace-predicate" tabindex="-1">trace Predicate</h3><p>To see all the steps used to evaluate a predicate, turn on trace mode by entering <code>trace.</code></p><p>Enter a query and press the return key after viewing the result of each step in the evaluation.</p><p>When finished debugging, enter <code>notrace.</code> to turn this mode off.</p><h3 id="debug-library" tabindex="-1">debug Library</h3><p>The <code>debug</code> library defines three prefix operators that can be useful for debugging.</p><p>The <code>*</code> operator generalizes away a goal, which essentially acts as though the goal is not present. This can be placed before any goal, even the last one which is followed by a period. This is an advantage over commenting out a goal.</p><p>The <code>$</code> operator adds tracing output to a goal. It will write <code>call:{namespace}:{goal-name}.</code> to stdout before evaluating the goal and write <code>exit:{namespace}:{goal-name}.</code> to stdout after evaluating it. For user defined goals, the namespace is <code>user</code>.</p><p>The <code>$-</code> operator will catch and portray any errors thrown when the goal is evaluated. If no errors are thrown, it has no effect. The output will be <code>exception:{normal-error-message}:{namespace}:{goal-name}({arguments}).</code> The main benefit of using this is that it outputs the name of the goal that triggered the error and the arguments that were provided.</p><p>The following code demonstrates using each of the <code>debug</code> library operators:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>debug<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">writeln</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">write</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> nl<span class="token operator">.</span><br><br><span class="token function">anger</span><span class="token punctuation">(</span>Level<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token punctuation">(</span> Level <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">-></span><br>    <span class="token function">writeln</span><span class="token punctuation">(</span>red<span class="token punctuation">)</span><br>  <span class="token operator">;</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token function">error</span><span class="token punctuation">(</span><br>      <span class="token function">domain_error</span><span class="token punctuation">(</span>too_angry<span class="token punctuation">,</span> Level<span class="token punctuation">)</span><span class="token punctuation">,</span><br>      <span class="token function">anger/1</span><br>    <span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token operator">.</span><br><br>envy <span class="token operator">:-</span> <span class="token function">writeln</span><span class="token punctuation">(</span>green<span class="token punctuation">)</span><span class="token operator">.</span><br><br>demo <span class="token operator">:-</span><br>  <span class="token operator">$-</span> <span class="token function">anger</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token operator">$</span> envy<span class="token punctuation">,</span><br>  <span class="token operator">*</span> <span class="token function">writeln</span><span class="token punctuation">(</span>blue<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The output of the <code>demo</code> rule is:</p><pre class="language-text"><code class="language-text">red<br>call:user:envy.<br>green<br>exit:user:envy.<br>   true.</code></pre><h3 id="time-predicate" tabindex="-1">time Predicate</h3><p>To determine how long it takes to evaluate a query, use the <code>time</code> predicate from the <code>time</code> library. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">?-</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="calling-from-other-languages" tabindex="-1">Calling From Other Languages</h2><p>SWI-Prolog can be called from C. See <a href="https://www.swi-prolog.org/pldoc/man?section=calling-prolog-from-c?v=1.0.21" rel="noopener" target="_blank">Calling Prolog from C</a>.</p><p>TODO: Which other programming languages can call SWI-Prolog?</p><h2 id="efficiency" tabindex="-1">Efficiency</h2><p>For information about the performance of Prolog, see <a href="https://www.metalevel.at/prolog/efficiency?v=1.0.21" rel="noopener" target="_blank">Efficiency of Prolog</a>.</p><h2 id="unit-tests" tabindex="-1">Unit Tests</h2><p>SCI-Prolog includes a unit testing framework called &quot;Test Box&quot;. See <a href="https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/plunit.html%27)" target="_blank">Prolog Unit Tests</a>.</p><p>Code for unit tests can be placed in the same source file as the rules they test. Alternatively, test code can be placed in a separate file with an extension of <code>.plt</code>.</p><p>The following code demonstrates implementing unit tests for the built-in <code>append</code> rule.</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This line is only needed to load predicates from another file.</span><br><span class="token comment">% :- consult({file-name}).</span><br><br><span class="token operator">:-</span> <span class="token function">begin_tests</span><span class="token punctuation">(</span>append<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>append_assertions<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>append_make_first<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">append</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">assertion</span><span class="token punctuation">(</span>X <span class="token operator">==</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token operator">!.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>append_make_second<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">assertion</span><span class="token punctuation">(</span>X <span class="token operator">==</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">test</span><span class="token punctuation">(</span>append_make_third<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">assertion</span><span class="token punctuation">(</span>X <span class="token operator">==</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">end_tests</span><span class="token punctuation">(</span>append<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> run_tests<span class="token operator">.</span><br><span class="token operator">:-</span> halt<span class="token operator">.</span></code></pre><p>If the code above is in a file named <code>append.plt</code> then the tests can be run by entering <code>swipl append.plt</code>. If the last two lines in the code above are omitted, use the following instead: <code>swipl -g run_tests -t halt your/file.pl</code></p><p>The <code>test</code> rule takes a test name (atom or string) and an optional list of options. Supported options include:</p><ul><li><code>setup</code>: takes a goal to execute before the test is run</li><li><code>cleanup</code>: takes a goal to execute after the test is run</li><li><code>forall</code>: takes a generator and runs the test for each generated value</li><li><code>throws</code>: takes an error and verifies that the test throws the error</li><li><code>error</code>: takes an error and verifies that the test throws <code>error(Error, _Context)</code></li><li>several other options that seem less valuable</li></ul><p>The <code>assertion</code> rule prints assertions that fail. When this is not used, the output will only provide the name of the test that failed.</p><p>If a test ends with a choice point, a warning message will be output. To prevent this, end the test with the cut operator (<code>, !.</code>) or include the option <code>nondet</code>.</p><h2 id="puzzles" tabindex="-1">Puzzles</h2><h3 id="jug-problem" tabindex="-1">Jug Problem</h3><p>TODO: Add this!</p><h3 id="sudoku" tabindex="-1">Sudoku</h3><p>Prolog can be used to solve puzzles such as <a href="https://en.wikipedia.org/wiki/Sudoku?v=1.0.21" rel="noopener" target="_blank">Sudoku</a>.</p><p>The following code is based on code from Markus Triska in the SWI-Prolog manual.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>clpfd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">sudoku</span><span class="token punctuation">(</span>Rows<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% Verify that Rows is a list with 9 elements.</span><br>  <span class="token function">length</span><span class="token punctuation">(</span>Rows<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Verify that all elements are lists</span><br>  <span class="token comment">% with the same length as Rows which is 9.</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span><span class="token function">same_length</span><span class="token punctuation">(</span>Rows<span class="token punctuation">)</span><span class="token punctuation">,</span> Rows<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Create a flattened list of all the values (Vs), and verify</span><br>  <span class="token comment">% that all elements in Vs are a number in the range 1 to 9.</span><br>  <span class="token function">append</span><span class="token punctuation">(</span>Rows<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span><span class="token punctuation">,</span> Vs ins <span class="token number">1.</span><span class="token operator">.</span><span class="token number">9</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Verify that all element values in all rows</span><br>  <span class="token comment">% are unique within their row.</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>all_distinct<span class="token punctuation">,</span> Rows<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Create a list of lists that represent the columns.</span><br>  <span class="token function">transpose</span><span class="token punctuation">(</span>Rows<span class="token punctuation">,</span> Columns<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Verify that all element values in all columns</span><br>  <span class="token comment">% are unique within their column.</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>all_distinct<span class="token punctuation">,</span> Columns<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Assign a variable name to each of the 9 rows.</span><br>  <span class="token punctuation">[</span>R1<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> R3<span class="token punctuation">,</span> R4<span class="token punctuation">,</span> R5<span class="token punctuation">,</span> R6<span class="token punctuation">,</span> R7<span class="token punctuation">,</span> R8<span class="token punctuation">,</span> R9<span class="token punctuation">]</span> <span class="token operator">=</span> Rows<span class="token punctuation">,</span><br><br>  <span class="token comment">% Verify that the element values in every 3x3 block</span><br>  <span class="token comment">% are unique within their block.</span><br>  <span class="token function">blocks</span><span class="token punctuation">(</span>R1<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> R3<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">blocks</span><span class="token punctuation">(</span>R4<span class="token punctuation">,</span> R5<span class="token punctuation">,</span> R6<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">blocks</span><span class="token punctuation">(</span>R7<span class="token punctuation">,</span> R8<span class="token punctuation">,</span> R9<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% When a block is empty, its element values (which are none)</span><br><span class="token comment">% can be considered unique.</span><br><span class="token function">blocks</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% When a block is not empty, get its 9 values</span><br><span class="token comment">% and verify that they are unique.</span><br><span class="token function">blocks</span><span class="token punctuation">(</span><span class="token punctuation">[</span>R1C1<span class="token punctuation">,</span>R1C2<span class="token punctuation">,</span>R1C3<span class="token operator">|</span>T1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>R2C1<span class="token punctuation">,</span>R2C2<span class="token punctuation">,</span>R2C3<span class="token operator">|</span>T2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>R3C1<span class="token punctuation">,</span>R3C2<span class="token punctuation">,</span>R3C3<span class="token operator">|</span>T3<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">all_distinct</span><span class="token punctuation">(</span><span class="token punctuation">[</span>R1C1<span class="token punctuation">,</span> R1C2<span class="token punctuation">,</span> R1C3<span class="token punctuation">,</span> R2C1<span class="token punctuation">,</span> R2C2<span class="token punctuation">,</span> R2C3<span class="token punctuation">,</span> R3C1<span class="token punctuation">,</span> R3C2<span class="token punctuation">,</span> R3C3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">blocks</span><span class="token punctuation">(</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> T3<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% When there a no more rows, stop printing.</span><br><span class="token function">print_rows</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% When there are more rows, print the first row.</span><br><span class="token function">print_rows</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">print_row</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">print_rows</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% When the last element of a row has been printed, print a newline.</span><br><span class="token function">print_row</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span> nl<span class="token operator">.</span><br><br><span class="token comment">% When there are more row elements,</span><br><span class="token comment">% print the first one followed by a space.</span><br><span class="token function">print_row</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'~w '</span><span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">print_row</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Each puzzle must contain at least 17 clues.</span><br><br><span class="token function">problem</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">% can solve</span><br>  <span class="token punctuation">[</span><span class="token punctuation">[</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span><br>   <span class="token punctuation">[</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>   <span class="token punctuation">[</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span><br><br>   <span class="token punctuation">[</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span><br>   <span class="token punctuation">[</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span><br>   <span class="token punctuation">[</span>_<span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span><br><br>   <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>   <span class="token punctuation">[</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span><br>   <span class="token punctuation">[</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span>_<span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">problem</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> Rows<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sudoku</span><span class="token punctuation">(</span>Rows<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">print_rows</span><span class="token punctuation">(</span>Rows<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>This outputs the following solution:</p><pre class="language-text"><code class="language-text">9 8 7 6 5 4 3 2 1<br>2 4 6 1 7 3 9 8 5<br>3 5 1 9 2 8 7 4 6<br>1 2 8 5 3 7 6 9 4<br>6 3 4 8 9 2 1 5 7<br>7 9 5 4 6 1 8 3 2<br>5 1 9 2 8 6 4 7 3<br>4 7 2 3 1 9 5 6 8<br>8 6 3 7 4 5 2 1 9</code></pre><h3 id="einstein's-riddle" tabindex="-1">Einstein's Riddle</h3><p>Einstein's riddle, aka <a href="https://en.wikipedia.org/wiki/Zebra_Puzzle?v=1.0.21" rel="noopener" target="_blank">Zebra Puzzle</a>, describes a set of known facts and relationships and asks you to find some set of unknown values.</p><p>There are several examples of this type of puzzle.</p><p>One begins with &quot;Three kids went to a superheroes dress birthday party.&quot; The following code solves this puzzle.</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% The names of the three kids are Ethan, Ali and Anya.</span><br><span class="token function">kid</span><span class="token punctuation">(</span>ethan<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">kid</span><span class="token punctuation">(</span>ali<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">kid</span><span class="token punctuation">(</span>anya<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% They dressed up as Spiderman, Captain America and Iron Man.</span><br><span class="token function">hero</span><span class="token punctuation">(</span>spiderman<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">hero</span><span class="token punctuation">(</span>captain_america<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">hero</span><span class="token punctuation">(</span>iron_man<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% The kids are 6, 8 and 10 years old.</span><br><span class="token function">age</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">age</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">age</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Anya was dressed up as Spiderman.</span><br><span class="token function">kid_hero_age</span><span class="token punctuation">(</span>anya<span class="token punctuation">,</span> spiderman<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">age</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Ethan was not dressed up as Captain America.</span><br><span class="token function">kid_hero_age</span><span class="token punctuation">(</span>ethan<span class="token punctuation">,</span> H<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">hero</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> H<span class="token operator">\=</span>captain_america<span class="token operator">.</span><br><br><span class="token comment">% The youngest kid dressed up as Spiderman.</span><br><span class="token function">kid_hero_age</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> spiderman<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">:-</span> <span class="token function">kid</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% The kid who is 8 years old dressed up as Captain America.</span><br><span class="token function">kid_hero_age</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> captain_america<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">kid</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Three values are distinct if this holds.</span><br><span class="token function">different</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  A <span class="token operator">\=</span> B<span class="token punctuation">,</span> A <span class="token operator">\=</span> C<span class="token punctuation">,</span> B <span class="token operator">\=</span> C<span class="token operator">.</span> <span class="token comment">% use distinct list?</span><br><br><span class="token comment">% Determine the missing information.</span><br><span class="token function">solve</span><span class="token punctuation">(</span>K1<span class="token punctuation">,</span> H1<span class="token punctuation">,</span> A1<span class="token punctuation">,</span> K2<span class="token punctuation">,</span> H2<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> K3<span class="token punctuation">,</span> H3<span class="token punctuation">,</span> A3<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">kid_hero_age</span><span class="token punctuation">(</span>K1<span class="token punctuation">,</span> H1<span class="token punctuation">,</span> A1<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">kid_hero_age</span><span class="token punctuation">(</span>K2<span class="token punctuation">,</span> H2<span class="token punctuation">,</span> A2<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">kid_hero_age</span><span class="token punctuation">(</span>K3<span class="token punctuation">,</span> H3<span class="token punctuation">,</span> A3<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">different</span><span class="token punctuation">(</span>K1<span class="token punctuation">,</span> K2<span class="token punctuation">,</span> K3<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">different</span><span class="token punctuation">(</span>H1<span class="token punctuation">,</span> H2<span class="token punctuation">,</span> H3<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">different</span><span class="token punctuation">(</span>A1<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> A3<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token operator">!.</span><br><br><span class="token operator">:-</span> <span class="token function">solve</span><span class="token punctuation">(</span>K1<span class="token punctuation">,</span> H1<span class="token punctuation">,</span> A1<span class="token punctuation">,</span> K2<span class="token punctuation">,</span> H2<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> K3<span class="token punctuation">,</span> H3<span class="token punctuation">,</span> A3<span class="token punctuation">)</span><span class="token punctuation">,</span><br>   S <span class="token operator">=</span> <span class="token string">'~w is ~w and dressed as ~w.~n'</span><span class="token punctuation">,</span><br>   <span class="token function">format</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> <span class="token punctuation">[</span>K1<span class="token punctuation">,</span> A1<span class="token punctuation">,</span> H1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>   <span class="token function">format</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> <span class="token punctuation">[</span>K2<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> H2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>   <span class="token function">format</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> <span class="token punctuation">[</span>K3<span class="token punctuation">,</span> A3<span class="token punctuation">,</span> H3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>   halt<span class="token operator">.</span></code></pre><p>The output is:</p><pre><code>anya is 6 and dressed as spiderman.
ethan is 10 and dressed as iron_man.
ali is 8 and dressed as captain_america.
</code></pre><p>The classic Zebra puzzle is a bit more difficult. It asks you to determine who owns a zebra.</p><p>There are five nationalities: englishman, japanese, norwegian, spaniard, and ukrainian.</p><p>There are five houses colors: blue, green, ivory, red, and yellow.</p><p>There are five drinks: coffee, milk, orange_juice, tea, and water.</p><p>There are five smokes: chesterfields, kools, lucky_strike, old_gold, and parliaments.</p><p>There are five pets: dog, fox, horse, snails, and zebra.</p><p>The following code solves this puzzle.</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% The relation arguments are Nationality, Color, Drinks, Smokes, and Pet.</span><br><br><span class="token comment">% List element A is on the left of list element B</span><br><span class="token comment">% if appending $ something onto a list</span><br><span class="token comment">% beginning with A,B results in a given list.</span><br><span class="token function">on_left</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> Ls<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">append</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">[</span>A<span class="token punctuation">,</span>B<span class="token operator">|</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span> Ls<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% List element A is on the right of list element B</span><br><span class="token comment">% if B is on the left of A.</span><br><span class="token function">on_right</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> Ls<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">on_left</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> A<span class="token punctuation">,</span> Ls<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% List elements A and B are adjacent</span><br><span class="token comment">% if A is on the left or right side of B.</span><br><span class="token function">adjacent</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> Ls<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">on_left</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> Ls<span class="token punctuation">)</span><span class="token operator">;</span> <span class="token function">on_right</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> Ls<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This gets a list of all the houses contain all their details.</span><br><span class="token function">houses</span><span class="token punctuation">(</span>Hs<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% There are five houses.</span><br>  <span class="token function">length</span><span class="token punctuation">(</span>Hs<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The Englishman lives in the red house.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>englishman<span class="token punctuation">,</span> red<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The Spaniard owns the dog.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>spaniard<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> dog<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Coffee is drunk in the green house.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> green<span class="token punctuation">,</span> coffee<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The Ukrainian drinks tea.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>ukrainian<span class="token punctuation">,</span> _<span class="token punctuation">,</span> tea<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The green house is immediately to the right of the ivory house.</span><br>  <span class="token function">on_left</span><span class="token punctuation">(</span><br>    <span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> ivory<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> green<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The Old Gold smoker owns snails.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> old_gold<span class="token punctuation">,</span> snails<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Kools are smoked in the yellow house.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> yellow<span class="token punctuation">,</span> _<span class="token punctuation">,</span> kools<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Milk is drunk in the middle house.</span><br>  Hs <span class="token operator">=</span> <span class="token punctuation">[</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> <span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> milk<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">]</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The Norwegian lives in the first house.</span><br>  Hs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">relation</span><span class="token punctuation">(</span>norwegian<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">|</span> _<span class="token punctuation">]</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The man who smokes Chesterfields lives in</span><br>  <span class="token comment">% the house next to the man with the fox.</span><br>  <span class="token function">adjacent</span><span class="token punctuation">(</span><br>    <span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> chesterfields<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> fox<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Kools are smoked in the house next to the house where the horse is kept.</span><br>  <span class="token function">adjacent</span><span class="token punctuation">(</span><br>    <span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> kools<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> horse<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The Lucky Strike smoker drinks orange juice.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> orange_juice<span class="token punctuation">,</span> lucky_strike<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The Japanese smokes Parliaments.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>japanese<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> parliaments<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% The Norwegian lives next to the blue house.</span><br>  <span class="token function">adjacent</span><span class="token punctuation">(</span><br>    <span class="token function">relation</span><span class="token punctuation">(</span>norwegian<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Someone drinks water.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> water<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  <span class="token comment">% Someone owns a zebra.</span><br>  <span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> zebra<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">zebra_owner</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">:-</span><br>	<span class="token function">houses</span><span class="token punctuation">(</span>Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>	<span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> zebra<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>	<span class="token operator">!.</span><br><br><span class="token function">water_drinker</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">:-</span><br>	<span class="token function">houses</span><span class="token punctuation">(</span>Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>	<span class="token function">member</span><span class="token punctuation">(</span><span class="token function">relation</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> _<span class="token punctuation">,</span> water<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> Hs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>	<span class="token operator">!.</span><br><br><span class="token function">print_houses</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">print_houses</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">relation</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">,</span> S<span class="token punctuation">,</span> P<span class="token punctuation">)</span> <span class="token operator">=</span> H<span class="token punctuation">,</span><br>  <span class="token comment">%S = 'The ~w lives in the ~w house, drinks ~w, smokes ~w, and owns a ~w.~n',</span><br>  <span class="token comment">%format(S, [N, C, D, S, P]),</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><br>    <span class="token string">'The ~w lives in the ~w house, drinks ~w, smokes ~w, and owns a ~w.~n'</span><span class="token punctuation">,</span><br>    <span class="token punctuation">[</span>N<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">,</span> S<span class="token punctuation">,</span> P<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">print_houses</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">houses</span><span class="token punctuation">(</span>Hs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">print_houses</span><span class="token punctuation">(</span>Hs<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The output is:</p><pre><code>The norwegian lives in the yellow house, drinks water, smokes kools, and owns a fox.
The ukrainian lives in the blue house, drinks tea, smokes chesterfields, and owns a horse.
The englishman lives in the red house, drinks milk, smokes old_gold, and owns a snails.
The spaniard lives in the ivory house, drinks orange_juice, smokes lucky_strike, and owns a dog.
The japanese lives in the green house, drinks coffee, smokes parliaments, and owns a zebra.
</code></pre><h2 id="search-strategies" tabindex="-1">Search Strategies</h2><p>Prolog implementations can employ many search strategies.</p><p>A forward chaining search strategy starts from a starting state and derives new states that can follow using rules describing valid changes until a goal state is reached.</p><p>A backward chaining search strategy starts from a goal state and derives new states that can precede it using rules describing valid changes until the starting state is reached.</p><p>TODO: Add information about other search strategies TODO: that Prolog implementations typically use.</p><h2 id="reading-from-urls" tabindex="-1">Reading from URLs</h2><p>The following code prints all the tag names found in an HTML document. They are indented to represent their position in the DOM hierarchy. This was only tested in SWI-Prolog.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>http<span class="token operator">/</span>http_open<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for http_open</span><br><br><span class="token function">indent_write</span><span class="token punctuation">(</span>Indent<span class="token punctuation">,</span> V<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'~*|~t~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Indent<span class="token punctuation">,</span> V<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This is used if 2nd argument is an element structure.</span><br><span class="token comment">% element structure components are Tag, Attributes, and Children.</span><br><span class="token function">print_tag</span><span class="token punctuation">(</span>Level<span class="token punctuation">,</span> <span class="token function">element</span><span class="token punctuation">(</span>Tag<span class="token punctuation">,</span> _<span class="token punctuation">,</span> Children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:-</span><br>  Indent <span class="token operator">is</span> Level <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span><br>  <span class="token function">indent_write</span><span class="token punctuation">(</span>Indent<span class="token punctuation">,</span> Tag<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  NextLevel <span class="token operator">is</span> Level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span><span class="token function">print_tag</span><span class="token punctuation">(</span>NextLevel<span class="token punctuation">)</span><span class="token punctuation">,</span> Children<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This is used if 2nd argument is not an element structure.</span><br><span class="token function">print_tag</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% ignore</span><br><br><span class="token comment">% This provides a starting level of 0.</span><br><span class="token function">print_tag</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">print_tag</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">process</span><span class="token punctuation">(</span>In<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% copy_stream_data(In, user_output). % for debugging</span><br>  <span class="token function">load_html</span><span class="token punctuation">(</span>In<span class="token punctuation">,</span> DOM<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>print_tag<span class="token punctuation">,</span> DOM<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This ensures that close is called regardless of whether</span><br><span class="token comment">% the first argument goal succeeds, fails, or raises an exception.</span><br><span class="token operator">:-</span> <span class="token function">setup_call_cleanup</span><span class="token punctuation">(</span><br>     <span class="token comment">% Must use single, not double quotes around URL!</span><br>     <span class="token function">http_open</span><span class="token punctuation">(</span><span class="token string">'https://mvolkmann.github.io'</span><span class="token punctuation">,</span> In<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>     <span class="token function">process</span><span class="token punctuation">(</span>In<span class="token punctuation">)</span><span class="token punctuation">,</span><br>     <span class="token function">close</span><span class="token punctuation">(</span>In<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="definite-clause-grammars-(dcgs)" tabindex="-1">Definite Clause Grammars (DCGs)</h2><p>A DCG defines a set of grammar rules (GR) that are used for testing, completing, generating, and parsing text. Each grammar rule has the syntax <code>GRHead --&gt; GRBody</code> and describes sequences of characters or tokens (often represented as atoms). Be careful to include two dashes in the arrow and not just one.</p><p>DCGs are not yet part of the ISO Prolog standard, but they are being considered. Most Prolog implementations already support DCGs.</p><p>DCGs are enabled by default in SWI-Prolog, but not in all Prolog implementations. To enable DCGs, it may be necessary to include the <code>dcgs</code> library with <code>:- use_module(library(dcgs)).</code> This can be added to the configuration file for a Prolog implementation so the <code>dcg</code> library is always available.</p><p>The name at the beginning of <code>GRHead</code> is used to refer to the rule. Grammar rule names typically describe the kinds of sequences they allow rather than describe their arguments as is common in Prolog predicates.</p><p>Each GRBody consists of terminals, non-terminals, and grammar goals. Terminals are fixed, allowed values contained lists. There are multiple ways to construct such lists including strings in double quotes and atoms in square brackets. A non-terminal refers to another DCG rule and typical includes a variable argument to capture matching text.</p><p>A grammar goal is a single Prolog goal or conjunction of them, written inside curly braces. Typically the purpose of a grammar goal is to set the values of variables that appear in the GRHead argument or a GRBody non-terminal. Grammar goals that set variables used in GRBody non-terminals should appear <strong>before</strong> all such non-terminals.</p><p>The following basic example demonstrates using a DCG to describe a string that can contain a name. It uses the <code>seq</code> DCG predicate to capture text.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% To use this, enter something like the following:</span><br><span class="token comment">% phrase(hello(Name), "Hello, World!").</span><br><span class="token comment">% The cut at the end allows the rule to terminate after matching once.</span><br><span class="token function">hello</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token string">"Hello, "</span><span class="token punctuation">,</span> <span class="token function">seq</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">,</span> <span class="token operator">!.</span></code></pre><p>To test whether a specific string matches this grammar rule for a specific name, enter something like <code>phrase(hello(&quot;World&quot;), &quot;Hello, World!&quot;).</code> which outputs <code>true</code>.</p><p>To extract a name from a matching string, enter something like <code>phrase(hello(Name), &quot;Hello, World!&quot;).</code> which outputs <code>Name = &quot;World&quot;</code>.</p><p>To generate the matching string for a given name, enter something like <code>phrase(hello(&quot;World&quot;), X).</code> which outputs <code>X = &quot;Hello, World!&quot;</code>.</p><p>To generate all possible matching strings, enter something like <code>phrase(hello(Name), S).</code> which outputs many possible solutions such as:</p><pre class="language-prolog"><code class="language-prolog">   Name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> S <span class="token operator">=</span> <span class="token string">"Hello, !"</span><br><span class="token operator">;</span>  Name <span class="token operator">=</span> <span class="token punctuation">[</span>_A<span class="token punctuation">]</span><span class="token punctuation">,</span> S <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'H'</span><span class="token punctuation">,</span>e<span class="token punctuation">,</span>l<span class="token punctuation">,</span>l<span class="token punctuation">,</span>o<span class="token punctuation">,</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span>_A<span class="token operator">|</span><span class="token string">"!"</span><span class="token punctuation">]</span><br><span class="token operator">;</span>  Name <span class="token operator">=</span> <span class="token punctuation">[</span>_A<span class="token punctuation">,</span>_B<span class="token punctuation">]</span><span class="token punctuation">,</span> S <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'H'</span><span class="token punctuation">,</span>e<span class="token punctuation">,</span>l<span class="token punctuation">,</span>l<span class="token punctuation">,</span>o<span class="token punctuation">,</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span>_A<span class="token punctuation">,</span>_B<span class="token operator">|</span><span class="token string">"!"</span><span class="token punctuation">]</span><br><span class="token operator">;</span> <span class="token operator">...</span> <span class="token operator">.</span></code></pre><p>The notation <code>F//N</code> refers to the DCG non-terminal <code>F</code> with <code>N</code> arguments. Using two slashes instead of one distinguishes it from a normal Prolog predicate.</p><p>Predefined non-terminals include:</p><ul><li><code>(,)//2</code>: concatenation; read as &quot;and then&quot; or &quot;followed by&quot;</li><li><code>(|)//2</code>: alternatives; read as &quot;or&quot;</li></ul><p>The predicate <code>phrase(GRBody, L)</code> holds if <code>L</code> is a list of character atoms that match <code>GRBody</code>. This can be used to test, complete, and generate solutions for a DCG rule. Since grammar rules can be used in all of these usage modes, it is preferable to say that a grammar rule &quot;describes&quot; conforming sequences rather than using words like &quot;generates&quot; and &quot;consumes&quot;.</p><p>When using SWI-Prolog, within DCG rules double-quoted strings are treated as lists of ASCII code integers regardless of the <code>double_quotes</code> compiler flag setting.</p><p>For example, the following grammar rules describe sequences that contain any number of <code>x</code> characters.</p><p>The SWI-Prolog libraries <code>dcg/basics</code> and <code>dcg/higher_order</code> provide additional predicates that are useful in writing DCG rules. These must be included to use them.</p><p>All DCG rules can be translated to a standard Prolog rules which typically require longer code. Most DCG implementations do this behind the scenes and then consider those rules at runtime instead of the DCG rules.</p><h3 id="dcg-predicates" tabindex="-1">DCG Predicates</h3><p>The predicate <code>seq(L)</code> describes a sequence of values. For example, the following finds all combinations of <code>Xs</code> and <code>Ys</code> values that can be concatenated to form <code>&quot;abc&quot;</code>:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">?-</span> <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">seq</span><span class="token punctuation">(</span>Xs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">seq</span><span class="token punctuation">(</span>Ys<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> `abc`<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% output is:</span><br><span class="token comment">% Xs = [], Ys = "abc"</span><br><span class="token comment">% ;  Xs = "a", Ys = "bc"</span><br><span class="token comment">% ;  Xs = "ab", Ys = "c"</span><br><span class="token comment">% ;  Xs = "abc", Ys = []</span></code></pre><p>The following code implements predicates that are often useful when using DCGs:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% seq represents a sequence of elements.</span><br><span class="token comment">% Scryer Prolog provides this in its dcgs library.</span><br><span class="token function">seq</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">seq</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>H<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">seq</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Alternate way to implement append using DCGs.</span><br><span class="token function">append</span><span class="token punctuation">(</span>Xs<span class="token punctuation">,</span> Ys<span class="token punctuation">,</span> Zs<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">seq</span><span class="token punctuation">(</span>Xs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">seq</span><span class="token punctuation">(</span>Ys<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Zs<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% append('abc', "xyz", L), writeln(L). % output is [a,b,c,x,y,z]</span><br><br><span class="token comment">% seqq represents a sequence of sequences.</span><br><span class="token comment">% Scryer Prolog provides this in its dcgs library.</span><br><span class="token function">seqq</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">seqq</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">seq</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">seqq</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% phrase(seqq(["ab", "cd", "ef"]), L), writeln(L). % output is [a,b,c,d,e,f].</span><br><br><span class="token comment">% qes is the reverse of seq.</span><br><span class="token function">qes</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">qes</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">qes</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>H<span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token function">palindrome</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">:-</span> <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">qes</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token comment">% palindrome('mother'). % false</span><br><span class="token comment">% palindrome('mom'). % true</span><br><br><span class="token comment">% ... represents any sequence without capturing it.</span><br><span class="token comment">% Scryer Prolog provides this in its dcgs library.</span><br><span class="token operator">...</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token operator">.</span><br><br><span class="token comment">% ... can be used to get the last element in a list.</span><br><span class="token comment">% phrase((..., [Last]), "xyz"). % output is Last = z</span><br><br><span class="token comment">% ... can be used to determine if a given sublist</span><br><span class="token comment">% occurs anywhere in a list.</span><br><span class="token comment">% phrase((..., "y", ...), "xyz"). % output is true</span><br><span class="token comment">% phrase((..., "ar", ...), "Mark"). % output is true</span><br><br><span class="token comment">% ... can be used to determine if</span><br><span class="token comment">% any element occurs twice in succession in a list.</span><br><span class="token comment">% phrase((..., [X, X], ...), "Mississippi"). % finds s, s, and p</span></code></pre><h3 id="representing-trees" tabindex="-1">Representing Trees</h3><p>A DCG can be used to describe a tree structure and capture it as a nested structure. DCG rule heads can contain an optional structure for capturing parsed data. The functor names of these structures identify the kind of data captured.</p><p>For example, the following grammar rules describe a binary tree:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">nodes</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">nodes</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>Node<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>Node<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">nodes</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">nodes</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span><br>  <span class="token function">phrase</span><span class="token punctuation">(</span><br>    <span class="token function">nodes</span><span class="token punctuation">(</span><br>      <span class="token function">node</span><span class="token punctuation">(</span><br>        a<span class="token punctuation">,</span><br>        nil<span class="token punctuation">,</span><br>        <span class="token function">node</span><span class="token punctuation">(</span><br>          b<span class="token punctuation">,</span><br>          <span class="token function">node</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nil<span class="token punctuation">,</span> nil<span class="token punctuation">)</span><span class="token punctuation">,</span><br>          nil<br>        <span class="token punctuation">)</span><br>      <span class="token punctuation">)</span><br>    <span class="token punctuation">)</span><span class="token punctuation">,</span><br>    L<br>  <span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">write</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  nl<br>  <span class="token comment">% output is list of leaf node values [a,b,c].</span><br><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>DCGs can be used for parsing text by describing a relationship between lists of characters and syntax trees. This makes them ideal for parsing programming language syntax and producing an abstract syntax tree (AST).</p><h3 id="dcg-rule-termination" tabindex="-1">DCG Rule Termination</h3><p>Some grammar rules do not naturally terminate. One way to cause them to terminate is to use a different execution strategy such as &quot;SLG resolution&quot;. To enable this, execute the following:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>tabling<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> table expr<span class="token operator">//</span><span class="token number">0.</span></code></pre><p>The following DCG that describes sequences like <code>1+1+1</code> doesn't naturally terminate due to its use of left recursion. However, it does terminate when SLG resolution is enabled.</p><pre class="language-prolog"><code class="language-prolog">expr <span class="token operator">--></span> <span class="token string">"1"</span><span class="token operator">.</span><br>expr <span class="token operator">--></span> expr<span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">,</span> expr<span class="token operator">.</span> <span class="token comment">% uses left recursion</span></code></pre><p>This can be rewritten as follows so it terminates without SLG resolution.</p><pre class="language-prolog"><code class="language-prolog">expr <span class="token operator">--></span> <span class="token string">"1"</span><span class="token punctuation">,</span> expr_rest<span class="token operator">.</span><br>expr_rest <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br>expr_rest <span class="token operator">--></span> <span class="token string">"+"</span><span class="token punctuation">,</span> expr<span class="token operator">.</span></code></pre><p>Using SLG resolution with DCGs is called &quot;Packrat Parsing&quot;.</p><h3 id="lexical-analysis" tabindex="-1">Lexical Analysis</h3><p>Lexical analysis defines relationships between strings and sequences of tokens. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This was only tested in Scryer Prolog.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>charsio<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for char_type</span><br><br><span class="token function">assignment</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> I<span class="token punctuation">)</span> <span class="token operator">--></span> ws<span class="token punctuation">,</span> <span class="token function">word</span><span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token string">":="</span><span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token function">integer</span><span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">,</span> ws<span class="token operator">.</span><br><span class="token comment">% once(phrase(assignment(V, I), "  gretzky := 99 ")).</span><br><span class="token comment">% V = "gretzky", I = 99.</span><br><br><span class="token comment">% This matches any single digit.</span><br><span class="token comment">% The char_type predicate is defined in the charsio library.</span><br><span class="token function">digit</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>D<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">char_type</span><span class="token punctuation">(</span>D<span class="token punctuation">,</span> decimal_digit<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">.</span><br><br><span class="token comment">% This matches any non-empty list of digits.</span><br><span class="token function">digits</span><span class="token punctuation">(</span><span class="token punctuation">[</span>D<span class="token operator">|</span>Ds<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">digit</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">digits_</span><span class="token punctuation">(</span>Ds<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This is an "auxiliary rule" that is not intended to be used directly.</span><br><span class="token comment">% Typically the names of such rules match that of the rule that uses it</span><br><span class="token comment">% with an underscore added at the end.</span><br><span class="token comment">% This matches any list of digits including an empty list.</span><br><span class="token function">digits_</span><span class="token punctuation">(</span><span class="token punctuation">[</span>D<span class="token operator">|</span>Ds<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">digit</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">digits_</span><span class="token punctuation">(</span>Ds<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">digits_</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token comment">% This matches any non-empty list of digits and converts it to an integer.</span><br><span class="token comment">% For example, once(phrase(integer(I), "123")) gives the integer 123.</span><br><span class="token comment">% For example, once(phrase((ws, integer(I), ws), "  1961 ")).</span><br><span class="token comment">% I = 1961.</span><br><span class="token function">integer</span><span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">digits</span><span class="token punctuation">(</span>Ds<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">number_chars</span><span class="token punctuation">(</span>I<span class="token punctuation">,</span> Ds<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">.</span><br><br><span class="token comment">% See https://github.com/mthom/scryer-prolog/discussions/1921</span><br><span class="token comment">% There may be a bug related to ascii_punctuation.</span><br><span class="token function">punctuation</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">char_type</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> ascii_punctuation<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">.</span><br><br><span class="token comment">% This is an "eager consumer rule" which</span><br><span class="token comment">% causes tokens to extend to their maximum length.</span><br><span class="token comment">% Eager consumer rules check for the nil case ([]) last.</span><br><span class="token function">word</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>H<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">char_type</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> alphabetic<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">word</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">word</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token comment">% For example, once(phrase(words(Ws), "This is a test")).</span><br><span class="token comment">% gives ["This","is","a","test"].</span><br><span class="token comment">% This will not terminate if it encounters</span><br><span class="token comment">% an unexpected character such as punctuation.</span><br><span class="token comment">% TODO: Try to fix this with the punctuation grammar rule above.</span><br><span class="token function">words</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">words</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> ws<span class="token punctuation">,</span> <span class="token function">word</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token function">words</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% ws matches one or more whitespace characters which include</span><br><span class="token comment">% space, tab (\t), newline (\n), formfeed (\f), carriage return (\r),</span><br><span class="token comment">% and many higher Unicode characters that are considered whitespace.</span><br><span class="token comment">% To see a full list, enter</span><br><span class="token comment">% length(_, N), char_code(C, N), char_type(C, whitespace).</span><br><span class="token comment">% length(_, N) is a tricky way to generate decimal numbers from 0 to infinity.</span><br><span class="token comment">% char_code(C, N) then gets the character code</span><br><span class="token comment">% that corresponds to each decimal number.</span><br><span class="token comment">% char_type(C, whitespace) then filters the output</span><br><span class="token comment">% to only the character codes that are whitespace characters.</span><br><span class="token comment">% After the last character is output, the following error message will appear,</span><br><span class="token comment">% because there are no Unicode code points above some integer.</span><br><span class="token comment">% error(representation_error(character_code),char_code/2).</span><br>ws <span class="token operator">--></span> <span class="token punctuation">[</span>W<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">char_type</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> whitespace<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> ws<span class="token operator">.</span><br>ws <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span></code></pre><p>For simple text matching and extraction, using a regular expression in other programming languages is an easier alternative. However, DCGs can be used for this purpose.</p><p>The following code provides two examples that are specific to Scryer Prolog:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for -->, seq, and phrase</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>charsio<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for char_type</span><br><br><span class="token comment">% To use this, enter something like the following:</span><br><span class="token comment">% phrase(hello(Name), "Hello, World!").</span><br><span class="token function">hello</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span> <span class="token operator">--></span><br>  <span class="token string">"Hello, "</span><span class="token punctuation">,</span> <span class="token function">seq</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">,</span> <span class="token operator">!.</span><br><br><span class="token comment">% To use this, enter something like the following:</span><br><span class="token comment">% phrase(player(Name, Number), "Player Gretzky wears number 99.").</span><br><span class="token function">player</span><span class="token punctuation">(</span>Name<span class="token punctuation">,</span> Number<span class="token punctuation">)</span> <span class="token operator">--></span><br>  <span class="token string">"Player "</span><span class="token punctuation">,</span><br>  <span class="token function">seq</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token string">" wears number "</span><span class="token punctuation">,</span><br>  <span class="token comment">% seq(Number),</span><br>  <span class="token function">integer</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token string">"."</span><span class="token operator">.</span><br><br><span class="token comment">% This matches any single digit.</span><br><span class="token comment">% The char_type predicate is defined in the charsio library.</span><br><span class="token function">digit</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>D<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">char_type</span><span class="token punctuation">(</span>D<span class="token punctuation">,</span> decimal_digit<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">.</span><br><br><span class="token comment">% This matches any non-empty list of digits.</span><br><span class="token function">digits</span><span class="token punctuation">(</span><span class="token punctuation">[</span>D<span class="token operator">|</span>Ds<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">digit</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">digits_</span><span class="token punctuation">(</span>Ds<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This matches any list of digits including an empty list.</span><br><span class="token function">digits_</span><span class="token punctuation">(</span><span class="token punctuation">[</span>D<span class="token operator">|</span>Ds<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">digit</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">digits_</span><span class="token punctuation">(</span>Ds<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">digits_</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token comment">% This matches any non-empty list of digits and converts it to an integer.</span><br><span class="token function">integer</span><span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">digits</span><span class="token punctuation">(</span>Ds<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">number_chars</span><span class="token punctuation">(</span>I<span class="token punctuation">,</span> Ds<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">.</span></code></pre><p>The following code provides two examples that are specific to SWI-Prolog:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcg<span class="token operator">/</span>basics<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% for string_without and digits</span><br><br><span class="token comment">% To test this, enter something like</span><br><span class="token comment">% phrase(hello(Name), "Hello, World!").</span><br><span class="token function">hello</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span> <span class="token operator">--></span><br>  <span class="token string">"Hello, "</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">,</span> <span class="token operator">!</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span> <span class="token function">string_codes</span><span class="token punctuation">(</span>Name<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">.</span><br><br><span class="token comment">% To test this, enter something like</span><br><span class="token comment">% phrase(player(Name, Number), "Player Gretzky wears number 99.").</span><br><span class="token function">player</span><span class="token punctuation">(</span>Name<span class="token punctuation">,</span> Number<span class="token punctuation">)</span> <span class="token operator">--></span><br>  <span class="token string">"Player "</span><span class="token punctuation">,</span><br>  <span class="token function">string_without</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> Cs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token string">" wears number "</span><span class="token punctuation">,</span><br>  <span class="token function">digits</span><span class="token punctuation">(</span>Ds<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token string">"."</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token function">string_codes</span><span class="token punctuation">(</span>Name<span class="token punctuation">,</span> Cs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">number_codes</span><span class="token punctuation">(</span>Number<span class="token punctuation">,</span> Ds<span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><span class="token operator">.</span></code></pre><h3 id="parsing-sentences" tabindex="-1">Parsing Sentences</h3><p>The following code provides a basic example of using a DCG to perform Natural Language Processing (NLP). It is based on code in the video &quot;Build Syntax Trees in Prolog with DCGs&quot; at <a href="https://youtu.be/QGXypIkV-GU">https://youtu.be/QGXypIkV-GU</a>.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">include</span><span class="token punctuation">(</span>sentences<span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% This file is shown below.</span><br><br><span class="token comment">% From Wikipedia, "English determiners are words such as</span><br><span class="token comment">% the, a, each, some, which, this, and six</span><br><span class="token comment">% that are most commonly used with nouns to specify their referents."</span><br>determiner <span class="token operator">--></span> <span class="token punctuation">[</span>the<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">.</span><br><br>noun <span class="token operator">--></span> <span class="token punctuation">[</span>cat<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>dog<span class="token punctuation">]</span><span class="token operator">.</span><br>noun_phrase <span class="token operator">--></span> determiner<span class="token punctuation">,</span> noun<span class="token operator">.</span><br>verb <span class="token operator">--></span> <span class="token punctuation">[</span>chased<span class="token punctuation">]</span><span class="token operator">.</span><br>verb_phrase <span class="token operator">--></span> verb<span class="token punctuation">,</span> noun_phrase<span class="token operator">.</span><br>sentence <span class="token operator">--></span> noun_phrase<span class="token punctuation">,</span> verb_phrase<span class="token operator">.</span><br><br><span class="token comment">% Enter `test.`</span><br>test <span class="token operator">:-</span><br>  <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>a<span class="token punctuation">,</span>dog<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% matches</span><br>  <span class="token operator">\+</span> <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>a<span class="token punctuation">,</span>mouse<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% does not match</span><br>  <span class="token operator">!.</span><br><br><span class="token comment">% Enter `complete1.`</span><br>complete1 <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>X<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>the<span class="token punctuation">,</span>dog<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Solutions = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Solutions<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Enter `complete2.`</span><br>complete2 <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>Rest<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased <span class="token operator">|</span> Rest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Solutions = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Solutions<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Enter `generate.`</span><br>generate <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>atoms_sentence<span class="token punctuation">,</span> Solutions<span class="token punctuation">,</span> Sentences<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>writeln<span class="token punctuation">,</span> Sentences<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">/*<br>This is a basic example of using a DCG to perform<br>Natural Language Processing (NLP) in Prolog.<br>It is based on code in the video "Build Syntax Trees in Prolog with DCGs"<br>at https://youtu.be/QGXypIkV-GU.<br>*/</span><br><br><span class="token operator">:-</span> <span class="token function">include</span><span class="token punctuation">(</span>sentences<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% From Wikipedia, "English determiners are words such as</span><br><span class="token comment">% the, a, each, some, which, this, and six</span><br><span class="token comment">% that are most commonly used with nouns to specify their referents."</span><br>determiner <span class="token operator">--></span> <span class="token punctuation">[</span>the<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">.</span><br><br>noun <span class="token operator">--></span> <span class="token punctuation">[</span>cat<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>dog<span class="token punctuation">]</span><span class="token operator">.</span><br>noun_phrase <span class="token operator">--></span> determiner<span class="token punctuation">,</span> noun<span class="token operator">.</span><br>verb <span class="token operator">--></span> <span class="token punctuation">[</span>chased<span class="token punctuation">]</span><span class="token operator">.</span><br>verb_phrase <span class="token operator">--></span> verb<span class="token punctuation">,</span> noun_phrase<span class="token operator">.</span><br>sentence <span class="token operator">--></span> noun_phrase<span class="token punctuation">,</span> verb_phrase<span class="token operator">.</span><br><br><span class="token comment">% Enter `test.`</span><br>test <span class="token operator">:-</span><br>  <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>a<span class="token punctuation">,</span>dog<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% matches</span><br>  <span class="token operator">\+</span> <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>a<span class="token punctuation">,</span>mouse<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% does not match</span><br>  <span class="token operator">!.</span><br><br><span class="token comment">% Enter `complete1.`</span><br>complete1 <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>X<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>the<span class="token punctuation">,</span>dog<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Solutions = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Solutions<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Enter `complete2.`</span><br>complete2 <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>Rest<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased <span class="token operator">|</span> Rest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Solutions = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Solutions<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Enter `generate.`</span><br>generate <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>atoms_sentence<span class="token punctuation">,</span> Solutions<span class="token punctuation">,</span> Sentences<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>writeln<span class="token punctuation">,</span> Sentences<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>The following code is from the file <code>sentences.pl</code> which is included in the code above:</p><pre class="language-prolog"><code class="language-prolog"><span class="token comment">% This relates a string to the same string,</span><br><span class="token comment">% but with the first letter capitalized.</span><br><span class="token function">capitalize</span><span class="token punctuation">(</span>S0<span class="token punctuation">,</span> S1<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">string_chars</span><span class="token punctuation">(</span>S0<span class="token punctuation">,</span> <span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">string_upper</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> U<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">atomics_to_string</span><span class="token punctuation">(</span><span class="token punctuation">[</span>U<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> S1<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This relates a list of atoms to a sentence.</span><br><span class="token function">atoms_sentence</span><span class="token punctuation">(</span>Atoms<span class="token punctuation">,</span> Sentence<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% Convert the list atoms into a list of strings.</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>atom_string<span class="token punctuation">,</span> Atoms<span class="token punctuation">,</span> Strings<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token comment">% Get the first word and a list of the remaining words.</span><br>  <span class="token punctuation">[</span>W <span class="token operator">|</span> Ws<span class="token punctuation">]</span> <span class="token operator">=</span> Strings<span class="token punctuation">,</span><br>  <span class="token comment">% Capitalize the first word.</span><br>  <span class="token function">capitalize</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token comment">% Join the words back into a single string</span><br>  <span class="token comment">% with a space between each word.</span><br>  <span class="token function">atomics_to_string</span><span class="token punctuation">(</span><span class="token punctuation">[</span>C <span class="token operator">|</span> Ws<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token comment">% Add period at end.</span><br>  <span class="token function">string_concat</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> Sentence<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% This converts a list of atoms to a sentence</span><br><span class="token comment">% and writes it to the current output stream.</span><br><span class="token function">write_sentence</span><span class="token punctuation">(</span>Atoms<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">atoms_sentence</span><span class="token punctuation">(</span>Atoms<span class="token punctuation">,</span> Sentence<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">writeln</span><span class="token punctuation">(</span>Sentence<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h3 id="generating-syntax-trees" tabindex="-1">Generating Syntax Trees</h3><p>The following code is an alternate version of the code in the previous section. It uses grammar goal arguments to capture nested structures that describe a syntax tree for a parsed sentence.</p><p>To capture the atoms that match each grammar rule, we specify a structure as the argument of each rule. These structures can contain arguments that are fixed atoms or variables that are set in the grammar rule body. The grammar rule arguments are &quot;accumulators&quot; in that they accumulate the result of parsing in a syntax tree.</p><p>This enables each grammar rule to generate a tree of structures that describe what was matched.</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">include</span><span class="token punctuation">(</span>sentences<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">determiner</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">determiner</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span>the<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>the<span class="token punctuation">]</span><span class="token operator">.</span><br><br><span class="token function">noun</span><span class="token punctuation">(</span><span class="token function">n</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>cat<span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">noun</span><span class="token punctuation">(</span><span class="token function">n</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>dog<span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">noun_phrase</span><span class="token punctuation">(</span><span class="token function">np</span><span class="token punctuation">(</span>D<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">determiner</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">noun</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">verb</span><span class="token punctuation">(</span><span class="token function">v</span><span class="token punctuation">(</span>chased<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span>chased<span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">verb_phrase</span><span class="token punctuation">(</span><span class="token function">vp</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> Np<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">verb</span><span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">noun_phrase</span><span class="token punctuation">(</span>Np<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">sentence</span><span class="token punctuation">(</span><span class="token function">s</span><span class="token punctuation">(</span>Np<span class="token punctuation">,</span> Vp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">noun_phrase</span><span class="token punctuation">(</span>Np<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">verb_phrase</span><span class="token punctuation">(</span>Vp<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% To see a sample tree, enter</span><br><span class="token comment">% `phrase(sentence(Tree), [a,cat,chased,the,dog]).`</span><br><br><span class="token comment">% Enter `test.`</span><br>test <span class="token operator">:-</span><br>  <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">sentence</span><span class="token punctuation">(</span>Tree<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>a<span class="token punctuation">,</span>dog<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% matches</span><br>  <span class="token comment">% Tree = s(np(d(the), n(cat)), vp(v(chased), np(d(a), n(dog)))).</span><br>  <span class="token operator">\+</span> <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">sentence</span><span class="token punctuation">(</span>Tree<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>a<span class="token punctuation">,</span>mouse<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">% does not match</span><br>  <span class="token operator">!.</span><br><br><span class="token comment">% Enter `complete1.`</span><br>complete1 <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">sentence</span><span class="token punctuation">(</span>Tree<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>X<span class="token punctuation">,</span>chased<span class="token punctuation">,</span>the<span class="token punctuation">,</span>dog<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Solutions = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Solutions<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Enter `complete2.`</span><br>complete2 <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>Rest<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">sentence</span><span class="token punctuation">(</span>Tree<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>the<span class="token punctuation">,</span>cat<span class="token punctuation">,</span>chased <span class="token operator">|</span> Rest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">'Solutions = ~w~n'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Solutions<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% Enter `generate.`</span><br>generate <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">sentence</span><span class="token punctuation">(</span>Tree<span class="token punctuation">)</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">,</span> Solutions<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>atoms_sentence<span class="token punctuation">,</span> Solutions<span class="token punctuation">,</span> Sentences<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>writeln<span class="token punctuation">,</span> Sentences<span class="token punctuation">)</span><span class="token operator">.</span></code></pre><h2 id="meta-interprers" tabindex="-1">Meta-interprers</h2><p>The topic of meta-interpreters is covered well at <a href="https://www.metalevel.at/acomip/?v=1.0.21" rel="noopener" target="_blank">A Couple of Meta-interpreters in Prolog</a>. Some key quotes from this post are:</p><ul><li>&quot;An interpreter is a program that evaluates programs.&quot;</li><li>&quot;Many programs are interpreters for domain-specific languages. For example, a program reading settings from a configuration file.&quot;</li><li>&quot;An interpreter for a language similar or identical to its own implementation language is called meta-interpreter (MI).&quot;</li><li>&quot;Prolog is exceptionally well-suited for writing MIs.&quot;</li></ul><h2 id="calling-from-javascript" tabindex="-1">Calling From JavaScript</h2><p>The npm package <a href="https://github.com/rla/node-swipl#readme?v=1.0.21" rel="noopener" target="_blank">swipl</a> makes it easy to run Prolog queries from a Node.js application which can be an Express server. This requires installing Node.js and SWI-Prolog.</p><p>To create a Node.js application that does this:</p><ol><li>Create a directory for the application and cd to it.</li><li>Enter <code>npm init</code> to create a <code>package.json</code> file.</li><li>Enter <code>npm install swipl</code> to install the package.</li><li>Edit <code>package.json</code> and add the script <code>&quot;start&quot;: &quot;node index.js&quot;</code>.</li><li>Create the file <code>index.js</code> containing code similar to the following:</li></ol><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> swipl <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'swipl'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">function</span> <span class="token function">loadFile</span><span class="token punctuation">(</span><span class="token parameter">directory<span class="token punctuation">,</span> fileName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">swipl</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">working_directory(_, '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>directory<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">')</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">swipl</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">consult(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>fileName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">function</span> <span class="token function">printSolution</span><span class="token punctuation">(</span><span class="token parameter">goal<span class="token punctuation">,</span> solution</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Solution for'</span><span class="token punctuation">,</span> goal<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>solution<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> solution<span class="token punctuation">.</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'No solution returned'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">function</span> <span class="token function">printSolutions</span><span class="token punctuation">(</span><span class="token parameter">goal<span class="token punctuation">,</span> query</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Solutions for'</span><span class="token punctuation">,</span> goal<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">while</span> <span class="token punctuation">(</span>query <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>solution <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> solution<span class="token punctuation">.</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// Only one query can be open at a time.</span><br>  query<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// This only gets the first solution.</span><br><span class="token keyword">let</span> goal <span class="token operator">=</span> <span class="token string">'member(X, [1,2,3,4])'</span><span class="token punctuation">;</span><br><span class="token function">printSolution</span><span class="token punctuation">(</span>goal<span class="token punctuation">,</span> <span class="token function">swipl</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'member(X, [1,2,3,4])'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// This gets all solutions.</span><br><span class="token keyword">let</span> query <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">swipl<span class="token punctuation">.</span>Query</span><span class="token punctuation">(</span>goal<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">printSolutions</span><span class="token punctuation">(</span>goal<span class="token punctuation">,</span> query<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// This loads a Prolog source file and runs a query against it.</span><br><span class="token function">loadFile</span><span class="token punctuation">(</span><span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'exercise1_3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>goal <span class="token operator">=</span> <span class="token string">'grandfather_of(richard, X)'</span><span class="token punctuation">;</span><br>query <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">swipl<span class="token punctuation">.</span>Query</span><span class="token punctuation">(</span>goal<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">printSolutions</span><span class="token punctuation">(</span>goal<span class="token punctuation">,</span> query<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The Prolog code is not prevented from performing &quot;unsafe&quot; operations. For example if it invokes the <code>halt</code> predicate then no further queries will be processed. I</p><h2 id="creating-an-http-server" tabindex="-1">Creating an HTTP Server</h2><p>Scryer Prolog supports creating an HTTP server that that can run Prolog queries and serves HTML pages containing the results. For example:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>dcgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>http<span class="token operator">/</span>http_server<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token function">consult</span><span class="token punctuation">(</span>family<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token comment">% All the code from here to END could be moved to a module for reuse.</span><br><span class="token function">tag1</span><span class="token punctuation">(</span>Name<span class="token punctuation">,</span> Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token string">"&lt;"</span><span class="token punctuation">,</span> Name<span class="token punctuation">,</span> <span class="token string">">"</span><span class="token punctuation">,</span> Content<span class="token punctuation">,</span> <span class="token string">"&lt;/"</span><span class="token punctuation">,</span> Name<span class="token punctuation">,</span> <span class="token string">">"</span><span class="token operator">.</span><br><span class="token function">tag2</span><span class="token punctuation">(</span>Name<span class="token punctuation">,</span> Children<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token string">"&lt;"</span><span class="token punctuation">,</span> Name<span class="token punctuation">,</span> <span class="token string">">"</span><span class="token punctuation">,</span> <span class="token function">children</span><span class="token punctuation">(</span>Children<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"&lt;/"</span><span class="token punctuation">,</span> Name<span class="token punctuation">,</span> <span class="token string">">"</span><span class="token operator">.</span><br><br><span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">.</span><br><span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--></span> H<span class="token punctuation">,</span> <span class="token function">children</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">a</span><span class="token punctuation">(</span>URL<span class="token punctuation">,</span> Text<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token string">"&lt;a href=\""</span><span class="token punctuation">,</span> URL<span class="token punctuation">,</span> <span class="token string">"\">"</span><span class="token punctuation">,</span> Text<span class="token punctuation">,</span> <span class="token string">"&lt;/a>"</span><span class="token operator">.</span><br><span class="token function">body</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">tag2</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">div</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token string">"&lt;h1>"</span><span class="token punctuation">,</span> Content<span class="token punctuation">,</span> <span class="token string">"&lt;/h1>"</span><span class="token operator">.</span><br><span class="token function">h1</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">tag1</span><span class="token punctuation">(</span><span class="token string">"h1"</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">h2</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">tag1</span><span class="token punctuation">(</span><span class="token string">"h2"</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">head</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">tag2</span><span class="token punctuation">(</span><span class="token string">"head"</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">html</span><span class="token punctuation">(</span>Head<span class="token punctuation">,</span> Body<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token string">"&lt;html>"</span><span class="token punctuation">,</span> Head<span class="token punctuation">,</span> Body<span class="token punctuation">,</span> <span class="token string">"&lt;/html>"</span><span class="token operator">.</span><br><span class="token function">li</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">tag1</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">style</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">tag2</span><span class="token punctuation">(</span><span class="token string">"style"</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">title</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">tag1</span><span class="token punctuation">(</span><span class="token string">"title"</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token operator">.</span><br><span class="token function">ul</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span> <span class="token operator">--></span> <span class="token function">tag2</span><span class="token punctuation">(</span><span class="token string">"ul"</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">not_found_handler</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> Response<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">http_status_code</span><span class="token punctuation">(</span>Response<span class="token punctuation">,</span> <span class="token number">404</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% not providing an icon</span><br><span class="token comment">% END</span><br><br><span class="token function">home_handler</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> Response<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% http_status_code(Response, 200), % default status</span><br>  <span class="token comment">% http_body(Response, text("Welcome to Scryer Prolog!")).</span><br>  <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">html</span><span class="token punctuation">(</span><br>    <span class="token function">head</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">body</span><span class="token punctuation">(</span><span class="token punctuation">[</span><br>      <span class="token function">h1</span><span class="token punctuation">(</span><span class="token string">"Welcome to Scryer Prolog!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>      <span class="token function">a</span><span class="token punctuation">(</span><span class="token string">"/grandchildren"</span><span class="token punctuation">,</span> <span class="token string">"Grandchildren"</span><span class="token punctuation">)</span><br>    <span class="token punctuation">]</span><span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">http_body</span><span class="token punctuation">(</span>Response<span class="token punctuation">,</span> <span class="token function">text</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">person_li</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> Li<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">atom_chars</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> Cs<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  Li <span class="token operator">=</span> <span class="token function">li</span><span class="token punctuation">(</span>Cs<span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">grandchildren_handler</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> Response<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> <span class="token function">grandfather</span><span class="token punctuation">(</span>richard<span class="token punctuation">,</span> P<span class="token punctuation">)</span><span class="token punctuation">,</span> Ps<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">maplist</span><span class="token punctuation">(</span>person_li<span class="token punctuation">,</span> Ps<span class="token punctuation">,</span> Lis<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  Title <span class="token operator">=</span> <span class="token string">"Grandchildren of Richard"</span><span class="token punctuation">,</span><br>  <span class="token function">phrase</span><span class="token punctuation">(</span><span class="token function">html</span><span class="token punctuation">(</span><br>    <span class="token function">head</span><span class="token punctuation">(</span><span class="token punctuation">[</span><br>      <span class="token function">title</span><span class="token punctuation">(</span>Title<span class="token punctuation">)</span><span class="token punctuation">,</span><br>      <span class="token function">style</span><span class="token punctuation">(</span><span class="token punctuation">[</span><br>        <span class="token string">"body { background-color: linen; }"</span><span class="token punctuation">,</span><br>        <span class="token string">"h1 { color: red; }"</span><span class="token punctuation">,</span><br>        <span class="token string">"h2 { color: blue; }"</span><span class="token punctuation">,</span><br>        <span class="token string">"li { color: purple; }"</span><br>      <span class="token punctuation">]</span><span class="token punctuation">)</span><br>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">body</span><span class="token punctuation">(</span><span class="token punctuation">[</span><br>      <span class="token function">h1</span><span class="token punctuation">(</span>Title<span class="token punctuation">)</span><span class="token punctuation">,</span><br>      <span class="token function">ul</span><span class="token punctuation">(</span>Lis<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>      <span class="token function">h2</span><span class="token punctuation">(</span><span class="token string">"Colors"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>      <span class="token function">ul</span><span class="token punctuation">(</span><span class="token punctuation">[</span><br>        <span class="token function">li</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token function">li</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token function">li</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">)</span><br>      <span class="token punctuation">]</span><span class="token punctuation">)</span><br>    <span class="token punctuation">]</span><span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><span class="token punctuation">,</span> Content<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">http_body</span><span class="token punctuation">(</span>Response<span class="token punctuation">,</span> <span class="token function">text</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span> <span class="token comment">% not providing an icon</span><br><br>listen <span class="token operator">:-</span><br>  <span class="token comment">% This cannot be stopped with ctrl-c.</span><br>  <span class="token comment">% See https://github.com/mthom/scryer-prolog/issues/485.</span><br>  <span class="token comment">% As a workaround, run the command `killall scryer-prolog`.</span><br>  <span class="token function">http_listen</span><span class="token punctuation">(</span><span class="token number">8081</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><br>    <span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> home_handler<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'favicon.ico'</span><span class="token punctuation">,</span> not_found_handler<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token function">get</span><span class="token punctuation">(</span>grandchildren<span class="token punctuation">,</span> grandchildren_handler<span class="token punctuation">)</span><br>  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>After loading this file into Scryer Prolog, enter <code>listen.</code> to start the server. Then browse &quot;<a href="http://localhost:8081">http://localhost:8081</a>&quot;.</p><p>The following code implements similar functionality in SWI-Prolog:</p><pre class="language-prolog"><code class="language-prolog"><span class="token operator">:-</span> <span class="token function">use_module</span><span class="token punctuation">(</span><span class="token function">library</span><span class="token punctuation">(</span>http<span class="token operator">/</span>http_server<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">initialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span><br>  <span class="token function">consult</span><span class="token punctuation">(</span>family<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">http_server</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">port</span><span class="token punctuation">(</span><span class="token number">8081</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><br><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">http_handler</span><span class="token punctuation">(</span><br>  <span class="token function">root</span><span class="token punctuation">(</span><span class="token operator">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token function">http_redirect</span><span class="token punctuation">(</span>moved<span class="token punctuation">,</span> <span class="token function">location_by_id</span><span class="token punctuation">(</span>home_page<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token operator">:-</span> <span class="token function">http_handler</span><span class="token punctuation">(</span><br>  <span class="token function">root</span><span class="token punctuation">(</span>home<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  home_page<span class="token punctuation">,</span><br>  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><br><br><span class="token function">home_page</span><span class="token punctuation">(</span>_Request<span class="token punctuation">)</span> <span class="token operator">:-</span><br>  <span class="token comment">% findall gathers all the solutions from the 2nd argument query,</span><br>  <span class="token comment">% transforms them with the first argument,</span><br>  <span class="token comment">% and places the resulting list in the 3rd argument.</span><br>  <span class="token function">findall</span><span class="token punctuation">(</span><span class="token function">h2</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">grandfather_of</span><span class="token punctuation">(</span>richard<span class="token punctuation">,</span> P<span class="token punctuation">)</span><span class="token punctuation">,</span> L<span class="token punctuation">)</span><span class="token punctuation">,</span><br><br>  Title <span class="token operator">=</span> <span class="token string">'Grandchildren of Richard'</span><span class="token punctuation">,</span><br>  <span class="token function">reply_html_page</span><span class="token punctuation">(</span><br>    <span class="token function">title</span><span class="token punctuation">(</span>Title<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">[</span><span class="token function">h1</span><span class="token punctuation">(</span>Title<span class="token punctuation">)</span> <span class="token operator">|</span> L<span class="token punctuation">]</span> <span class="token comment">% page body</span><br>  <span class="token punctuation">)</span><span class="token operator">.</span></code></pre><p>To start the server, enter <code>swipl {filename}.pl</code>. Then browse localhost:{port-number}.</p><p>Another way to run Prolog code in an HTTP server is to use <a href="https://pengines.swi-prolog.org/docs/index.htm?v=1.0.21" rel="noopener" target="_blank">Pengines</a>. However, the getting started page says &quot;We cannot at this time guarantee the safety of the Pengines platform. We think it is safe, but only if you know what you are doing. You run it at your own risk!&quot; This coupled with the fact that the code has not been modified since November, 2020 leads me to think this may not be a good option.</p><h2 id="language-server" tabindex="-1">Language Server</h2><p>TODO: How can you install a Prolog language server in Neovim? TODO: See <a href="https://github.com/jamesnvc/lsp_server">https://github.com/jamesnvc/lsp_server</a>.</p><p>TODO: Can you run Prolog code inside Neovim?</p><h2 id="miscellaneous-topics" tabindex="-1">Miscellaneous Topics</h2><p>For multithreading, see the <a href="http://packs.ndrix.com/spawn/index.html?v=1.0.21" rel="noopener" target="_blank">spawn</a> library.</p><p>TODO: Can you create an HTTP server that returns results of a Prolog program?</p></article>