<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Docker</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#installing">Installing</a></li><li><a href="#verifying-installation">Verifying Installation</a></li><li><a href="#docker-images">Docker Images</a><ol><li><a href="#official-base-images">Official Base Images</a></li></ol></li><li><a href="#examples">Examples</a><ol><li><a href="#bash-example">Bash Example</a></li><li><a href="#node-example">Node Example</a></li><li><a href="#volume-example">Volume Example</a></li><li><a href="#express-example">Express Example</a></li></ol></li><li><a href="#amazon-ec2">Amazon EC2</a></li><li><a href="#docker-machine">Docker Machine</a></li><li><a href="#dockerfile-contents">Dockerfile Contents</a></li><li><a href="#dockerfile-instructions">Dockerfile Instructions</a></li></ol></nav></aside><article><style>img {
    border: 1px solid gray;
  }</style><figure style="width: 30%"><img alt="Docker logo" style="border: 0" src="/blog/assets/docker.png?v=1.1.1"></figure><h2 id="overview" tabindex="-1">Overview</h2><p><a href="https://www.docker.com?v=1.1.1" rel="noopener" target="_blank">Docker</a> &quot;helps developers build, share, run, and verify applications anywhere â€” without tedious environment configuration or management.&quot;</p><p>The primary appeal of using Docker is that &quot;Dockerized&quot; apps can run anywhere. This includes Windows, Mac, and Linux. Each platform must install Docker. Applications run in a virtual Linux environment. Many Linux variants are supported.</p><p>The most common use of Docker is to run server software. For example, it can be used to run a web server or API server.</p><p>At a high level, the steps involved in using Docker include:</p><ul><li>Create a file named <code>DockerFile</code> that describes an &quot;image&quot;.</li><li>Build the image.</li><li>Run the image in a &quot;container&quot;.</li></ul><h2 id="installing" tabindex="-1">Installing</h2><p>The steps to install Docker in Windows are:</p><ul><li>Browse <a href="https://docs.docker.com/docker-for-windows/" target="_blank">https://docs.docker.com/docker-for-windows/</a>.</li><li>Scroll to and click &quot;Get Docker for Windows (stable)&quot; to download a <code>.msi</code> file.</li><li>Double-click the downloaded .msi file and follow the instructions.</li></ul><p>The steps to install Docker in macOS are:</p><ul><li>Browse <a href="https://docs.docker.com/docker-for-mac/" target="_blank">https://docs.docker.com/docker-for-mac/</a>.</li><li>Scroll to and click &quot;Get Docker for Mac (stable)&quot; to download a .dmg file.</li><li>Double-click the download <code>.dmg</code> file.</li><li>In the install dialog, drag Docker.app to the Applications folder.</li></ul><p>It is also possible to install Docker in macOS using Homebrew, but it requires more steps. See <a href="https://nickcharlton.net/posts/docker-via-homebrew.html" target="_blank">https://nickcharlton.net/posts/docker-via-homebrew.html</a>.</p><p>The steps to install Docker in Linux vary based on the Linux distribution being used. See <a href="https://docs.docker.com/engine/installation/linux/" target="_blank">https://docs.docker.com/engine/installation/linux/</a>.</p><h2 id="verifying-installation" tabindex="-1">Verifying Installation</h2><p>The easiest way to verify that the installation was successful is to download and run the &quot;hello-world&quot; image. To do this enter: <code>docker run hello-world</code>. This will download the image, and output information related to the download, the line &quot;<code>Hello from Docker!</code>&quot;, and information to help you get started using Docker. It also results in creation of an image and a container.</p><p>To see the new image enter: <code>docker images</code></p><p>To see the new container enter: <code>docker ps -a</code></p><p>To run the container again enter: <code>docker start -a {container-id-prefix}</code></p><p>To get help on a docker command enter: <code>docker help {command}</code>. For example, <code>docker help start</code> briefly describes the -a option. It is used to attach to an existing container.</p><h2 id="docker-images" tabindex="-1">Docker Images</h2><p>A Docker image is a filesystem and a set of parameters to use at runtime. It doesn't have state and never changes. Images can run a set of commands and exit, but more commonly they continue running until stopped. Examples include web servers, REST servers, and database daemons. An image runs inside a container.</p><p>Images are described by and built from files that, by convention, are named &quot;<code>Dockerfile</code>&quot;. When building an image, the <code>-f</code> option of the <code>docker build</code> commmand can be specified to use a file with a different name.</p><h3 id="official-base-images" tabindex="-1">Official Base Images</h3><p>Some images are labelled as &quot;official&quot;. For details on what this means, see <a href="https://github.com/docker-library/official-images" target="_blank">https://github.com/docker-library/official-images</a>. For a list of the official images, sorted on the number of times they have been &quot;pulled&quot;, see <a href="https://hub.docker.com/explore/" target="_blank">https://hub.docker.com/explore/</a>.</p><p>Official programming language images include clojure, elixir, erlang, haskell, ibmjava, julia, gcc, golang, java, jruby, node, openjdk, perl, php, python, ruby, and swift.</p><p>Official web server images include glassfish, httpd (Apache), jetty, nginx, and tomcat.</p><p>Official database images include cassandra, couchbase, couchdb, mariadb, mongo, mongoexpress, mysql, neo4j, oraclelinux, postgres, redis, and rethinkdb.</p><p>Official Linux images include debian, centos, fedora, opensuse, and ubuntu.</p><p>Other official images of note include bash, drupal, hello-world, jenkins, maven, rails, redmine, and wordpress.</p><h2 id="examples" tabindex="-1">Examples</h2><p>Before diving into details about Docker, let's walk through some simple examples.</p><p>We should only have one image now. That is the one created while verifying the installation. Verify this by running <code>docker images</code>.</p><h3 id="bash-example" tabindex="-1">Bash Example</h3><p>Let's create a very simple image that just outputs &quot;Hello, World!&quot; using bash. Here is the Dockerfile that describes the image.</p><pre class="language-docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> bash</span><br><span class="token instruction"><span class="token keyword">CMD</span> echo Hello, World!&lt;/pre></span></code></pre><p>To build this image enter: <code>docker build -t my-demo .</code><br>Because we didn't already have the <code>bash</code> base image, that was downloaded and built.</p><p>To see all the current images enter: <code>docker images</code><br>We should have three images now. They are <code>hello-world</code>, <code>bash,</code> and <code>my-demo</code>.</p><p>To run the <code>my-demo</code> image enter: <code>docker run my-demo</code><br>This runs the image in a newly created container. The container still exists.</p><p>To see this enter: <code>docker ps -a</code></p><p>To run this container again enter: <code>docker run -a {container-id}</code></p><p>To delete this container enter: <code>docker rm {container-id-prefix}</code></p><p>To delete the <code>my-demo</code> image enter: <code>docker rmi my-demo</code><br>Note that the <code>bash</code> image on which it depended was not deleted, but it can be deleted with <code>docker rmi bash</code>. It is common to create multiple images that use the same base image and retain these rather than delete them.</p><h3 id="node-example" tabindex="-1">Node Example</h3><p>Now let's create an image that outputs &quot;<code>Hello, World!</code>&quot; using Node.js. It uses the &quot;chalk&quot; npm package to output colored text. We are doing this to illustrate using npm packages from a Docker image.</p><p>Here is the <code>package.json</code> file that describes dependencies. It can also specify a &quot;script&quot; for running the application.</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"chalk-demo"</span><span class="token punctuation">,</span><br>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span><br>  <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"a Hello World app that uses the chalk npm package"</span><span class="token punctuation">,</span><br>  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span><br>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"node index.js"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token property">"license"</span><span class="token operator">:</span> <span class="token string">"MIT"</span><span class="token punctuation">,</span><br>  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"chalk"</span><span class="token operator">:</span> <span class="token string">"^1.1.3"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here is the JavaScript code from the file <code>index.js</code>.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> chalk <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'chalk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// process.argv holds command-line arguments.</span><br><span class="token comment">// The first value is the path to the node executable.</span><br><span class="token comment">// The second value is the path to the file being executed.</span><br><span class="token comment">// The third value (at index 2) is the first command-line argument.</span><br><span class="token keyword">const</span> name <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>name <span class="token operator">||</span> <span class="token string">'World'</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello, '</span> <span class="token operator">+</span> chalk<span class="token punctuation">.</span>red<span class="token punctuation">.</span><span class="token function">bold</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>To run this Node application outside of Docker with no excess output from npm, enter: <code>npm -s start</code> Note how &quot;World&quot; is output in red.</p><p>Here is the Dockerfile that describes the image to be built. It specifies a specific version of Node, 7.4. An alternative it to request the latest long-term support (LTS) version by replacing the version number with the code name &quot;boron&quot;.</p><pre class="language-docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> node:7.4-onbuild</span><br><span class="token instruction"><span class="token keyword">ENV</span> name <span class="token string">""</span></span><br><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"npm"</span>, <span class="token string">"--silent"</span>, <span class="token string">"start"</span>]</span></code></pre><p>Base images with an &quot;<code>onbuild&quot;</code> tag use <code>ONBUILD</code> instructions to specify instructions to be executed when the using image is executed. These instructions are executed as if were inserted immediately after the FROM instruction. In the case of node onbuild images, the following happens automatically when the image is executed:</p><ul><li>Assume the current directory contains a <code>package.json</code> file.</li><li>Run <code>npm install</code> which installs the dependencies described in <code>package.json</code>.</li><li>Assume <code>package.json</code> defines a <code>start</code> script.</li><li>Run <code>npm start</code>.</li></ul><p>The CMD instruction in the Dockerfile above overrides the one provided by the <code>node onbuild</code> image to use the <code>--silent</code> option. This suppresses informational messages from npm.</p><p>To build the Docker image enter: <code>docker build -t node-demo .</code><br>This will take several minutes because it needs to download and build the <code>node</code> base image. Once the base image has been built, rebuilding this image, or other images that use the same base image, will build much faster.</p><p>To run this image, but not retain the container in which it runs, enter: <code>docker run -t --rm node-demo</code><br>The <code>-t</code> option tells Docker to run the image in a pseudo-TTY which is able to process the ANSI escape codes output by the <code>chalk</code> package to produce colored text. The <code>--rm</code> option tells Docker not to retain the container it creates after the image exits. Note that it is preceded by two dashes, not one.</p><p>To override the value of the <code>name</code> environment variable specified in <code>Dockerfile</code> and <code>index.js</code>, add &quot;<code>-e name={value}</code>&quot; to the <code>docker run</code> command. For example, <code>docker run -t --rm -e name=Mark node-demo</code></p><h3 id="volume-example" tabindex="-1">Volume Example</h3><p>Now let's create an image that writes and reads files on the host.</p><p>Here is the <code>package.json</code> file. This example has no dependencies.</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"volume-demo"</span><span class="token punctuation">,</span><br>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span><br>  <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"demonstrates reading and writing text files"</span><span class="token punctuation">,</span><br>  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span><br>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"node index.js"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token property">"license"</span><span class="token operator">:</span> <span class="token string">"MIT"</span><br><span class="token punctuation">}</span></code></pre><p>Here is the JavaScript code from the file <code>index.js</code>.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> filePath <span class="token operator">=</span> <span class="token string">'/data/test.txt'</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">'Hello, World!'</span><span class="token punctuation">;</span><br>fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token parameter">err</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span><br><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'write was successful'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> buf</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'read got:'</span><span class="token punctuation">,</span> buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here is the Dockerfile that describes the image to be built.</p><pre class="language-docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> node:7.4-onbuild</span><br><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"npm"</span>, <span class="token string">"start"</span>]</span></code></pre><p>To build the Docker image enter: <code>docker build -t volume-demo .</code><br></p><p>To run this image, enter: <code>docker run --rm -v $HOME/data:/data volume-demo</code><br>The <code>-v</code> option tells Docker to map the container directory <code>/data</code> to the host directory <code>data</code> under your home directory.</p><p>After running this, a file named <code>test.txt</code> will exist in <code>$HOME/data</code> directory and it will contain &quot;<code>Hello, World!</code>&quot;.</p><h3 id="express-example" tabindex="-1">Express Example</h3><p>Now let's create an image that runs an Express HTTP server using Node.js.</p><p>Here is the <code>package.json</code> file that describes dependencies. It also specifies a <code>script</code> for running the application.</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"express-demo"</span><span class="token punctuation">,</span><br>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span><br>  <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"a Hello World Express app"</span><span class="token punctuation">,</span><br>  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span><br>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"node index.js"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token property">"license"</span><span class="token operator">:</span> <span class="token string">"MIT"</span><span class="token punctuation">,</span><br>  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"express"</span><span class="token operator">:</span> <span class="token string">"^4.14.0"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here is the JavaScript code from the file <code>index.js</code>.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/hello'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> name <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>name <span class="token operator">||</span> <span class="token string">'World'</span><span class="token punctuation">;</span><br>  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span><br>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'listening on port'</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>To run this Node application outside of Docker enter: <code>npm start</code><br>and browse <code>localhost:3000/hello?name={your-first-name}</code>.</p><p>Here is the <code>Dockerfile</code> that describes the image to be built.</p><pre class="language-docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> node:7.4-onbuild</span><br><span class="token instruction"><span class="token keyword">EXPOSE</span> 3000</span></code></pre><p>To build this image enter: <code>docker build -t express-demo .</code></p><p>When a container exposes ports using the EXPOSE instruction, these ports are only available to processes running in the container. To use them outside of the container (in the host), they must be mapped to a host port. This is specified with the <code>--publish</code> or <code>-p</code> option. For example, <code>-p 3001:3000</code> specifies that port 3000 inside the container is mapped to the host port 3001. The same port number can be used for both if the container port isn't already in use on the host.</p><p>To run this image in a container enter: <code>docker run -d -p 3000:3000 express-demo</code><br>The <code>-d</code> option causes the container to run in the background (detached mode). Do not include the <code>--rm</code> option when using this.</p><p>To output log messages from container enter: <code>docker logs {container-id-prefix}</code><br>This is a great way to diagnose issues.</p><p>When a container is not running in detached mode, it cannot be stopped by pressing ctrl-c in the terminal where it is running. To stop a running container enter: <code>docker stop {container-id-prefix}</code></p><p>The docker info command outputs an overview of the current Docker environment including the operating system (ex. Ubuntu), provider (ex. amazonec2), number of images, number of containers, and how many are running and stopped.</p><h2 id="amazon-ec2" tabindex="-1">Amazon EC2</h2><p>From the Amazon EC2 website, &quot;Amazon Elastic Compute Cloud (Amazon EC2) is a web service that provides resizable compute capacity in the cloud. It is designed to make web-scale cloud computing easier for developers.&quot;</p><p>In the next section we will walk through the steps to run a Docker image in a container within an EC2 instance. To prepare for that, this section provides the steps to create a free EC2 account. Skip the rest of this section if you already have an EC2 account.</p><ul><li>Browse <a href="https://amazon.com/ec2" target="_blank">https://amazon.com/ec2</a></li><li>Click the &quot;Create an AWS Account&quot; button.</li><li>Enter your email address.</li><li>Select the &quot;I am a new user&quot; radio button.</li><li>Press the &quot;Sign in using our secure server&quot; button.</li><li>Enter the requested information.</li><li>Press the &quot;Create account&quot; button.</li><li>Enter contact information and check the &quot;AWS Customer Agreement&quot; checkbox.</li><li>Press the &quot;Create Account and Continue&quot; button.</li><li>Enter credit card information. You will only be charged if your usage exceeds certain limits after the trial period ends.</li><li>Press the &quot;Continue&quot; button.</li><li>Enter your telephone number.</li><li>Press the &quot;Call Me Now&quot; button.</li><li>You will receive a phone call. On your phone, enter the PIN number that is displayed in the browser.</li><li>Press the &quot;Continue to select your Support Plan&quot; button.</li><li>Select the &quot;Basic&quot; radio button.</li><li>Press the &quot;Continue&quot; button.</li></ul><p>The next step is to get access and secret keys.</p><ul><li>From the &quot;My Account&quot; menu in the upper-right, select &quot;Security Credentials&quot;.</li><li>Sign in using your new account.</li><li>Press the &quot;Continue to Security Credentials&quot; button.</li><li>Click &quot;Access Keys (Access Key ID and Secret Access Key)&quot;.</li><li>Press the &quot;Create New Access Key&quot; button.</li><li>Press the &quot;Download New Key&quot; button.</li><li>This downloads a file named &quot;rootkey.csv&quot; in the Downloads directory. It contains your access key and secret key. Move this file to a place you'll remember to look for it later, like in a directory named &quot;Amazon-AWS&quot;.</li></ul><h2 id="docker-machine" tabindex="-1">Docker Machine</h2><p>Docker Machine makes it easy to use Docker in cloud provider instances. We'll walk through the steps to create an instance on Amazon EC2. This section assumes you already have an AWS account.</p><ul><li><p>Install Docker Machine by following the instructions at <a href="https://docs.docker.com/machine/install-machine" target="_blank">https://docs.docker.com/machine/install-machine</a>.</p></li><li><p>Create a Docker-aware Amazon EC2 instance by entering the following commands. We will use the instance name &quot;aws-sandbox&quot;. That should be substituted in place of all occurrences of {instance-name} below.</p><pre class="language-bash"><code class="language-bash">docker-machine create <span class="token parameter variable">--driver</span> amazonec2 <span class="token punctuation">\</span><span class="token operator">&lt;</span>br<span class="token operator">></span><br>  --amazonec2-access-key<span class="token operator">=</span><span class="token punctuation">{</span>access-key<span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token operator">&lt;</span>br<span class="token operator">></span><br>  --amazonec2-secret-key<span class="token operator">=</span><span class="token punctuation">{</span>secret-key<span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token operator">&lt;</span>br<span class="token operator">></span><br>  --amazonec2-region<span class="token operator">=</span><span class="token punctuation">{</span>region<span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token operator">&lt;</span>br<span class="token operator">></span><br>  <span class="token punctuation">{</span>instance-name<span class="token punctuation">}</span></code></pre><p>The values for <code>access-key</code> and <code>secret-key</code> can be obtained from the <code>rootkey.csv</code> file that was downloaded in the previous section. The value for region will be similar to &quot;us-west-2&quot;.</p></li>This command populates the <code>~/.docker/machine/machines/{instance-name}</code> directory with several <code>.pem</code> files and more. It will take several minutes to complete.<p></p><li><p>Enter: <code>eval $(docker-machine env {instance-name})</code><br>This sets four Docker-related environment variables that cause subsequent &quot;<code>docker</code>&quot; commands to run on the AWS instance instead of locally. The environment variables are <code>DOCKER_CERT_PATH</code>, <code>DOCKER_HOST</code>, <code>DOCKER_MACHINE_NAME</code>, and <code>DOCKER_TLS_VERIFY</code>. Unset these environment variables later to return to using Docker locally.</p></li><p></p></ul><p>To list the current Docker Machine instances enter: <code>docker-machine ls</code></p><p>To get the IP address of an instance enter: <code>docker-machine ip {instance-name}</code></p><p>Use the normal docker commands to build images and run them in containers within the AWS instance. For example, to build and run our <code>express-demo</code>, cd to its directory and enter these commands:<br><code>docker build -t express-demo .</code><br><code>docker run -d -p 3000:3000 express-demo</code><br></p><p>To test this app running in the AWS instance, browse <code>http://{instance-ip-address}:3000/hello</code>. TODO: Why doesn't the server respond? You should also be able to test this by running<br><code>docker run -d -p 8000:80 --name webserver kitematic/hello-world-nginx</code><br>and browsing {ip-address}:8000, but that doesn't work either!</p><p>To stop a running instance enter <code>docker-machine stop {instance-name}</code></p><p>To restart a running instance enter <code>docker-machine restart {instance-name}</code></p><p>To remove a stopped instance enter <code>docker-machine remove {instance-name}</code></p><p>To ssh into an instance enter: <code>docker-machine ssh {instance-name}</code></p><p>TODO: Is there a good reason to create an IAM user and install the aws CLI?</p><h2 id="dockerfile-contents" tabindex="-1">Dockerfile Contents</h2><p>Dockerfiles contain instructions that describe an image to be built. Each instruction is on a separate line. They start with an instruction name followed by its arguments. Instruction names are not case sensitive, but the convention is for them to be all uppercase. To spread arguments over several lines, end all but the last line with a backslash like in Bash. Comments are lines that begin with <code>#</code>. Comments cannot appear at the ends of instructions.</p><h2 id="dockerfile-instructions" tabindex="-1">Dockerfile Instructions</h2><p>Each instruction runs independently in a new image created just for it, or ones from previous builds that are in the &quot;build cache&quot;. Previous commands do not affect subsequent ones. For example, &quot;RUN cd /usr/local&quot; will not change the working directory used by the next instruction.</p><pre><code>&lt;h4&gt;FROM&lt;/h4&gt;
&lt;p&gt;
  This specifies the base image.
  It is required and MUST be the first instruction.
&lt;/p&gt;

&lt;h4&gt;ENV&lt;/h4&gt;
&lt;p&gt;
  This instruction sets the value of an environment variable
  that is used inside the Dockerfile.
  It cannot be used to change the value
  of a previously set environment variable.
  For example, to set ANIMAL to GIRAFFE,
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
</code></pre><p>ENV animal giraffe</p><p>To refer to this enviroment variable in another instruction, use <code>${ANIMAL}</code> or <code>$ANIMAL</code>.</p><p>Instructions that support references to environment variables include: <code>ADD</code>, <code>COPY</code>, <code>ENV</code>, <code>EXPOSE</code>, <code>LABEL</code>, <code>ONBUILD</code>, <code>STOPSIGNAL</code>, <code>USER</code>, <code>VOLUME</code>, and <code>WORKDIR</code>.</p><pre><code>&lt;h4&gt;MAINTAINER&lt;/h4&gt;

&lt;h4&gt;WORKDIR&lt;/h4&gt;
&lt;p&gt;
  This sets the default working directory from which commands will execute.
  It defaults to &quot;/&quot;.
&lt;/p&gt;

&lt;h4&gt;RUN&lt;/h4&gt;

&lt;h4&gt;CMD&lt;/h4&gt;

&lt;h4&gt;PATH&lt;/h4&gt;
&lt;p&gt;
  This specifies a local filesystem path that will be in the context of the image.
  This should expose only the files needed by the image.
  For example, do not use /.
  A .dockerignore file can be added to any directory
  to specify files that should not be exposed to the image.
&lt;/p&gt;

&lt;h4&gt;URL&lt;/h4&gt;
&lt;p&gt;
  This specifies a Github repository whose files will be in the context of the image.
&lt;/p&gt;

&lt;h4&gt;COPY&lt;/h4&gt;

&lt;h4&gt;WORKPATH&lt;/h4&gt;

&lt;h3&gt;Base images&lt;/h3&gt;
&lt;p&gt;
  TODO:
&lt;/p&gt;

&lt;h4&gt;Creating images&lt;/h4&gt;
&lt;p&gt;
  To build an image from a Dockerfile:
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker build [-t {tag}] {Dockerfile-path}&lt;/pre&gt;
&lt;p&gt;
  While the -t option can be omitted, it is preferable include it.
  Otherwise the image can only be identified by
  the id that is automatically assigned.
  A tag consists of a name and an an optional version separated from the name by a colon.
  For example, &lt;code&gt;my-project:1.2&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;
  Typically the &quot;docker build&quot; command is run
  from the directory that contains Dockerfile.
  When that is the case, the value for Dockerfile-path
  can be a period representing the current directory.
&lt;/p&gt;
&lt;p&gt;
  If the base image identified in Dockerfile does not already
  exist locally, its Dockerfile is downloaded from
  &lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker Hub&lt;/a&gt;.
  Docker Hub is a repository of shared Docker images.
  Next, the base image built.
  The time required to do this depends on the base image,
  but it is typically several minutes.
  Subsequent builds of your images that use these base images
  are much faster because locally installed base images are reused.
&lt;/p&gt;
&lt;p&gt;
  Examples of commonly used base images include
  bash and node.  ADD MORE!
&lt;/p&gt;

&lt;h4&gt;Listing existing images&lt;/h4&gt;
&lt;p&gt;
  To get a list of all exising images:
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker images&lt;/pre&gt;

&lt;h4&gt;Tagging images&lt;/h4&gt;
&lt;p&gt;
  Images have unique ids which are SHA values.
  These are long and difficult to type.
  Tags are human readable aliases for image ids.
  Any number of tags can be added to the same image.
  To add a tag to an image:
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker tag {id-or-existing-name} {new-name}&lt;/pre&gt;

&lt;h4&gt;Deleting images&lt;/h4&gt;
&lt;p&gt;
  To delete an image:
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker rmi [-f] {image-id-prefix-or-tag}&lt;/pre&gt;
&lt;p&gt;
  If an image has a tag other than &quot;latest&quot;,
  deleting it requires specifying both the name and tag like this:
&lt;/p&gt;
&lt;p&gt;
  If the image is used by an existing container,
  an error message explaining this will be output.
  The image can be deleted anyway if the -f option is used.
  Containers whose images have been deleted can still be rerun
  because all images it requires were copied into it.
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker rmi [-f] {name}:{tag}&lt;/pre&gt;
&lt;p&gt;
  There are multiple versions of an image, eash with a different tag,
  deleting one by its id, requires using the -f option.
&lt;/p&gt;
&lt;p&gt;
  Deleting a tag only deletes the corresponding image
  if it is the only tag for that image. ???
&lt;/p&gt;
&lt;p&gt;
  Here is a bash script that deletes all images.
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
</code></pre><p>#!/bin/bash</p><h1 id="removes-all-images." tabindex="-1">Removes all images.</h1><p>docker rmi -f $(docker images -q)</p><pre><code>&lt;h4&gt;Dangling images&lt;/h4&gt;
&lt;p&gt;
  During iterative development it is common
  to rebuild an image multiple times.
  When an image with the same name as an existing one is built,
  the previous version remains but is stripped of its name and tag.
  These are referred to as &quot;dangling images&quot;.
  The following command deletes all of them:
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker rmi $(docker images -qa -f &quot;dangling=true&quot;)&lt;/pre&gt;
&lt;p&gt;
  This uses two docker commands.
  First, &quot;docker images&quot; is used to get a list of the ids
  of all the dangling images.
  Second, &quot;docker rmi&quot; is used to delete those images.
  Why isn't there a build option to do this automatically?
&lt;/p&gt;

&lt;h3&gt;Docker Containers&lt;/h3&gt;
&lt;p&gt;
  A container is a running instance of an image.
&lt;/p&gt;

&lt;h4&gt;Creating/Running containers&lt;/h4&gt;

&lt;h4&gt;Listing containers&lt;/h4&gt;
&lt;p&gt;
  To list the current running containers,
  enter: &lt;code&gt;docker ps&lt;/code&gt;.
  To list all containers including those that are stopped,
  enter: &lt;code&gt;docker ps -a&lt;/code&gt;.
&lt;/p&gt;

&lt;h4&gt;Getting container details&lt;/h4&gt;
&lt;p&gt;
  To see details about an existing container,
  enter: &lt;code&gt;docker inspect {container-id}&lt;/code&gt;.
&lt;/p&gt;

&lt;h4&gt;Restarting containers&lt;/h4&gt;
&lt;p&gt;
  To restart a container whose image is currently running,
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker restart {container-id}&lt;/pre&gt;

&lt;h4&gt;Rerunning containers&lt;/h4&gt;
&lt;p&gt;
  To rerun a container whose image has exited,
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker start -a {container-id}&lt;/pre&gt;
&lt;p&gt;
  This works even if the images used by the container have been deleted
  because the images have already been copied into the container.
&lt;/p&gt;

&lt;h4&gt;Deleting containers&lt;/h4&gt;
&lt;p&gt;
  To delete specific containers enter: &lt;code&gt;docker rm {container-ids}&lt;/code&gt;&lt;br&gt;
  A space-separated list of container id prefixes can be specified.
  Each id prefix must uniquely match a single container.
&lt;/p&gt;
&lt;p&gt;
  To delete all containers enter: &lt;code&gt;docker rm $(docker ps -qa)&lt;/code&gt;
&lt;/p&gt;

&lt;h4&gt;Opening a shell inside a running container&lt;/h4&gt;
&lt;p&gt;
  To interact with a running container,
  open a shell inside it where commands can be entered.
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker exec -it {container-id} /bin/sh&lt;/pre&gt;
&lt;p&gt;
  Here is a bash script that deletes all containers.
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
</code></pre><p>#!/bin/bash</p><h1 id="removes-all-containers%2C-including-running-ones." tabindex="-1">Removes all containers, including running ones.</h1><p>docker rm -f $(docker ps -qa)</p><pre><code>&lt;h3&gt;Volumes&lt;/h3&gt;
&lt;p&gt;
  Containers can also provide read-write access to the read-only image filesystem
  a &quot;Union File System&quot;.
  Changes to files happens in the container, but are not saved in the image.
  &quot;Volumes&quot; allow these changes to be persisted to the local filesystem.
&lt;/p&gt;
&lt;p&gt;
  To specify a volume to be used by a container,
  use the -v option of the docker run command as follows:
&lt;/p&gt;
&lt;pre class=&quot;brush: plain&quot;&gt;
  docker run {image-name} -v $(pwd):{directory}&lt;/pre&gt;
brush
&lt;p&gt;
  It should be possible to edit files under a volume directory
  and have the image in the container utilize the changes
  without restarted it.  TRY THIS!
  See https://dzone.com/articles/docker-for-devs-creating-a-developer-image?edition=264895&amp;utm_source=Spotlight&amp;utm_medium=email&amp;utm_campaign=cloud%202017-01-24
&lt;/p&gt;

&lt;h3&gt;Sharing Image&lt;/h3&gt;
&lt;p&gt;
  The easiest way to share a Docker image
  is to share its Dockerfile.
  The recipient can build this image from that.
&lt;/p&gt;
&lt;p&gt;
  Another alternative is to register for a
  &lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker Hub&lt;/a&gt;
  account and upload your image there.
  From here you can browse for shared, downloadable images.
  For example, docker/whalesay.
&lt;/p&gt;
</code></pre><ul><li>Docker Engine: supports sharing Docker images</li><li>docker run docker/whalesay cowsay Hello from the whale!</li></ul><p>To start Docker on Mac OS X</p><ul><li>if there is no whale icon in the status bar at the top of the screen<ul><li>open Launchpad or Finder/Applications</li><li>click Docker icon (whale)</li><li>should see Docker icon in status bar at top</li></ul></li><li>if there is a whale icon<ul><li>click it a verify that the dropdown says &quot;Docker is running&quot;</li></ul></li></ul><p>To set Docker preferences</p><ul><li>click the whale icon in the status bar</li><li>select &quot;Preferences&quot;</li><li>General options include:<ul><li>&quot;Automatically start Docker when you log in&quot; (on by default)</li><li>&quot;Automatically check for updates&quot; (on by default)</li><li>&quot;Exclude VM from Time Machine backups&quot; (off by default)</li><li>number of CPUs</li><li>amount of memory allocated</li></ul></li><li>can configure proxies</li><li>can configure file sharing with the host machine</li><li>can initiate uninstall</li></ul><p>Kitematic</p><ul><li>a graphical UI for Docker</li><li>can be installed from the Docker whale menu</li></ul><p>To determine if Docker is running and see other info</p><ul><li>docker info</li></ul><p>Images</p><ul><li>to define<ul><li>create a new directory and cd to it</li><li>create a file name &quot;Dockerfile&quot;</li><li>comments in this file begin with #</li><li>first instruction must be &quot;FROM {image-name}[:tag]&quot; to specify the base image - tag defaults to &quot;latest&quot;, but can specify a different version - the smallest, simplest base image is &quot;scratch&quot;, but that doesn't seem to be able to do anything - another good option is &quot;bash&quot; - official Node base images are described at <a href="https://hub.docker.com/_/node/">https://hub.docker.com/_/node/</a> _ specify npm packages to be installed in package.json _ run a command to install PostgreSQL? IMPORTANT! * SEE <a href="https://hub.docker.com/r/spittet/node-postgresql/">https://hub.docker.com/r/spittet/node-postgresql/</a> - official PostgreSQL base images are described at <a href="https://hub.docker.com/_/postgres/">https://hub.docker.com/_/postgres/</a> - there doesn't seem to be an offical base image that includes Express</li><li>RUN command<ul><li>executes command(s) in a new layer and creates a new image</li><li>often used to install software packages</li><li>to install software in the image, add lines like this: RUN apt-get -y update &amp;&amp; apt-get install -y {software-name}</li></ul></li><li>CMD command<ul><li>sets the default command and/or parameters</li><li>can be overwritten from command line when running</li><li>only the last CMD command is used, so there is no point in having more than one</li><li>typically used to start a server</li><li>to run a command, add the line &quot;CMD {command}&quot;</li></ul></li><li>ENTRYPOINT command<ul><li>configures a container that will run as an executable</li></ul></li><li>RUN, CMD, and ENTRYPOINT can be used in &quot;shell&quot; or &quot;exec&quot; form<ul><li>in shell form the command is executed with &quot;/bin/sh -c {command}&quot;<ul><li>ex. CMD echo &quot;Hello, World!&quot;</li></ul></li><li>in exec form an executable is executed directly with no shell processing<ul><li>ex. CMD [&quot;/bin/echo&quot;, &quot;Hello, World!&quot;]</li><li>exec form is preferred for the CMD and ENTRYPOINT commands</li></ul></li></ul></li><li>save the file</li></ul></li><li>to SSH into a Docker container<ul><li>run <code>docker ps</code> to get the container id</li><li>run `docker exec -it {container-id} /bin/bash</li></ul></li><li>to build an image</li></ul><ul><li>docker build [-t {name[:tag]}] {Dockerfile-path}<ul><li>if -t option is omitted, the image will have no name (a.k.a. repository) or tag, just an id</li><li>Dockerfile-path can be . for the current directory</li><li>also downloads and builds image for the base image if it doesn't already exist<ul><li>ex. bash and node</li><li>can take a long time, but subsequent builds are much faster because the base image is already downloaded and built</li></ul></li><li>if you build an image with the same name as an existing image, it will not be replaced, but it will lose its name so the name can be assigned to the new image<ul><li>referred to as a &quot;dangling image&quot;</li><li>can delete it by its id or with this command: docker rmi $(docker images -qa -f &quot;dangling=true&quot;)</li><li>why isn't there a build option to do this automatically?</li></ul></li></ul></li></ul><ul><li>to list existing images<ul><li>docker images</li></ul></li><li>to remove an image<ul><li>docker rmi {image-name-or-id}<ul><li>can use shortest length of image id that is unique</li></ul></li><li>not allowed if image is currently running in a container</li></ul></li></ul><p>Containers</p><ul><li><p>to list</p><ul><li>only running: docker ps</li><li>all: docker ps -a</li><li>only latest created: docker ps -l</li></ul></li><li><p>to create, but not start: docker create</p></li><li><p>to create and start: docker run {image-name}</p><ul><li>docker run {image-name}<ul><li>options -i : is for interactive (can read from stdin) -t : allocates a pseudo TTY --rm : removes container after image exits --name {container-name} : gives name to container</li></ul></li><li>if the image isn't found locally, this attempts to download it from &quot;Docker Hub&quot;<ul><li>download images are saved locally for future use</li><li>can remove when no longer needed</li></ul></li><li>every time this is run, a new container is created</li><li>after this completes, the new container remains unless the --rm option is used<ul><li>I think you want this for non-server images</li></ul></li></ul></li><li><p>to stop and restart a running container: docker restart {container-id}</p></li><li><p>to rename: docker rename {container-id} {new-name}</p></li><li><p>to delete: docker rm {container-id}</p><ul><li>can use shortest length of container id that is unique</li></ul></li><li><p>containers are process-centric</p><ul><li>once the image inside it exits, the container is done</li><li>so why does it still exist?<ul><li>may to allow view its logs</li></ul></li></ul></li><li><p>to stop a running container</p><ul><li>docker stop {container-id}</li></ul></li><li><p>to output logs from a running container</p><ul><li>docker logs {container-name}</li></ul></li><li><p>to show processes running inside a running container</p><ul><li>docker top {container-name}</li></ul></li><li><p>to run a command inside a running container</p><ul><li>docker exec {container-name} {command}</li><li>one use is to inspect the contents of a database</li></ul></li><li><p>to copy a file into a running container</p></li><li><p>docker cp {file-path} {container-name}:/{new-file-name}</p></li><li><p>to open a bash shell running inside a running container</p><ul><li>docker exec -it {container-name} /bin/bash</li><li>useful to poke around at the state</li></ul></li><li><p>to get information about an image or container</p><ul><li>docker inspect {name-or-id}<ul><li>Monsanto container-name is &quot;capacity-api&quot;</li></ul></li></ul></li></ul><p>Docker Compose</p><ul><li>a tool for defining multi-container applications</li><li>Does Monsanto use this?</li><li>to start an image<ul><li>How is this different than loading into a container?</li><li>cd to a directory containing docker-compose.yml</li><li>docker-compose up -d<ul><li>-d (daemon) avoids taking over the current process</li></ul></li></ul></li><li>to stop an image<ul><li>cd to a directory containing docker-compose.yml</li><li>docker-compose down</li></ul></li></ul><p>Command Summary Action Containers Images</p><pre><code>
</code></pre></article>